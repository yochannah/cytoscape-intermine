(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],3:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":4}],4:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],5:[function(require,module,exports){
(function (process,__dirname){
/*!
 * This file is part of Cytoscape.js 2.4.4.
 * 
 * Cytoscape.js is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 * 
 * Cytoscape.js is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License along with
 * Cytoscape.js. If not, see <http://www.gnu.org/licenses/>.
 */
 

// this is put as a global var in the browser
// or it's just a global to this module if commonjs

var cytoscape;

(function(window){ 'use strict';

  // the object iteself is a function that init's an instance of cytoscape

  var $$ = cytoscape = function(){ // jshint ignore:line
    return cytoscape.init.apply(cytoscape, arguments);
  };

  $$.version = '2.4.4';
  
  // allow functional access to cytoscape.js
  // e.g. var cyto = $.cytoscape({ selector: "#foo", ... });
  //      var nodes = cyto.nodes();
  $$.init = function( options ){
    
    // if no options specified, use default
    if( options === undefined ){
      options = {};
    }

    // create instance
    if( $$.is.plainObject( options ) ){
      return new $$.Core( options );
    } 
    
    // allow for registration of extensions
    // e.g. $.cytoscape('renderer', 'svg', SvgRenderer);
    // e.g. $.cytoscape('renderer', 'svg', 'nodeshape', 'ellipse', SvgEllipseNodeShape);
    // e.g. $.cytoscape('core', 'doSomething', function(){ /* doSomething code */ });
    // e.g. $.cytoscape('collection', 'doSomething', function(){ /* doSomething code */ });
    else if( $$.is.string( options ) ) {
      return $$.extension.apply($$.extension, arguments);
    }
  };

  // define the function namespace here, since it has members in many places
  $$.fn = {};

  if( typeof module !== 'undefined' && module.exports ){ // expose as a commonjs module
    module.exports = cytoscape;
  }

  if( typeof define !== 'undefined' && define.amd ){ // expose as an amd/requirejs module
    define('cytoscape', function(){
      return cytoscape;
    });
  }

  // make sure we always register in the window just in case (e.g. w/ derbyjs)
  if( window ){
    window.cytoscape = cytoscape;
  }
  
})( typeof window === 'undefined' ? null : window );

// extra set to `this` is necessary for meteor
this.cytoscape = cytoscape;

// internal, minimal Promise impl s.t. apis can return promises in old envs
// based on thenable (http://github.com/rse/thenable)

// NB: you must use `new $$.Promise`, because you may have native promises that don't autonew for you

;(function($$){ 'use strict';
  
  /*  promise states [Promises/A+ 2.1]  */
  var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
  var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
  var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */

  /*  promise object constructor  */
  var api = function (executor) {
    /*  optionally support non-constructor/plain-function call  */
    if (!(this instanceof api))
      return new api(executor);

    /*  initialize object  */
    this.id           = "Thenable/1.0.7";
    this.state        = STATE_PENDING; /*  initial state  */
    this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
    this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
    this.onFulfilled  = [];            /*  initial handlers  */
    this.onRejected   = [];            /*  initial handlers  */

    /*  provide optional information-hiding proxy  */
    this.proxy = {
      then: this.then.bind(this)
    };

    /*  support optional executor function  */
    if (typeof executor === "function")
      executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
  };

  /*  promise API methods  */
  api.prototype = {
    /*  promise resolving methods  */
    fulfill: function (value) { return deliver(this, STATE_FULFILLED, "fulfillValue", value); },
    reject:  function (value) { return deliver(this, STATE_REJECTED,  "rejectReason", value); },

    /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
    then: function (onFulfilled, onRejected) {
      var curr = this;
      var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
      curr.onFulfilled.push(
        resolver(onFulfilled, next, "fulfill"));             /*  [Promises/A+ 2.2.2/2.2.6]  */
      curr.onRejected.push(
        resolver(onRejected,  next, "reject" ));             /*  [Promises/A+ 2.2.3/2.2.6]  */
      execute(curr);
      return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
    }
  };

  /*  deliver an action  */
  var deliver = function (curr, state, name, value) {
    if (curr.state === STATE_PENDING) {
      curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
      curr[name] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
      execute(curr);
    }
    return curr;
  };

  /*  execute all handlers  */
  var execute = function (curr) {
    if (curr.state === STATE_FULFILLED)
      execute_handlers(curr, "onFulfilled", curr.fulfillValue);
    else if (curr.state === STATE_REJECTED)
      execute_handlers(curr, "onRejected",  curr.rejectReason);
  };

  /*  execute particular set of handlers  */
  var execute_handlers = function (curr, name, value) {
    /* global process: true */
    /* global setImmediate: true */
    /* global setTimeout: true */

    /*  short-circuit processing  */
    if (curr[name].length === 0)
      return;

    /*  iterate over all handlers, exactly once  */
    var handlers = curr[name];
    curr[name] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
    var func = function () {
      for (var i = 0; i < handlers.length; i++)
        handlers[i](value);                                  /*  [Promises/A+ 2.2.5]  */
    };

    /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
    if (typeof process === "object" && typeof process.nextTick === "function")
      process.nextTick(func);
    else if (typeof setImmediate === "function")
      setImmediate(func);
    else
      setTimeout(func, 0);
  };

  /*  generate a resolver function  */
  var resolver = function (cb, next, method) {
    return function (value) {
      if (typeof cb !== "function")                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
        next[method].call(next, value);                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
      else {
        var result;
        try { result = cb(value); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
        catch (e) {
          next.reject(e);                                  /*  [Promises/A+ 2.2.7.2]  */
          return;
        }
        resolve(next, result);                               /*  [Promises/A+ 2.2.7.1]  */
      }
    };
  };

  /*  "Promise Resolution Procedure"  */                           /*  [Promises/A+ 2.3]  */
  var resolve = function (promise, x) {
    /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
    if (promise === x || promise.proxy === x) {
      promise.reject(new TypeError("cannot resolve promise with itself"));
      return;
    }

    /*  surgically check for a "then" method
      (mainly to just call the "getter" of "then" only once)  */
    var then;
    if ((typeof x === "object" && x !== null) || typeof x === "function") {
      try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
      catch (e) {
        promise.reject(e);                                   /*  [Promises/A+ 2.3.3.2]  */
        return;
      }
    }

    /*  handle own Thenables    [Promises/A+ 2.3.2]
      and similar "thenables" [Promises/A+ 2.3.3]  */
    if (typeof then === "function") {
      var resolved = false;
      try {
        /*  call retrieved "then" method */                  /*  [Promises/A+ 2.3.3.3]  */
        then.call(x,
          /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
          function (y) {
            if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
            if (y === x)                                 /*  [Promises/A+ 3.6]  */
              promise.reject(new TypeError("circular thenable chain"));
            else
              resolve(promise, y);
          },

          /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
          function (r) {
            if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
            promise.reject(r);
          }
        );
      }
      catch (e) {
        if (!resolved)                                       /*  [Promises/A+ 2.3.3.3.3]  */
          promise.reject(e);                               /*  [Promises/A+ 2.3.3.3.4]  */
      }
      return;
    }

    /*  handle other values  */
    promise.fulfill(x);                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
  };

  // use native promises where possible
  $$.Promise = typeof Promise === 'undefined' ? api : Promise;

  // so we always have Promise.all()
  $$.Promise.all = $$.Promise.all || function( ps ){
    return new $$.Promise(function( resolveAll, rejectAll ){
      var vals = new Array( ps.length );
      var doneCount = 0;

      var fulfill = function( i, val ){
        vals[i] = val;
        doneCount++;

        if( doneCount === ps.length ){
          resolveAll( vals );
        }
      };

      for( var i = 0; i < ps.length; i++ ){
        (function( i ){
          var p = ps[i];
          var isPromise = p.then != null;

          if( isPromise ){
            p.then(function( val ){
              fulfill( i, val );
            }, function( err ){
              rejectAll( err );
            });
          } else {
            var val = p;
            fulfill( i, val );
          }
        })( i );
      }

    });
  };

})( cytoscape );
// type testing utility functions

;(function($$, window){ 'use strict';

  var typeofstr = typeof '';
  var typeofobj = typeof {};
  var typeoffn = typeof function(){};

  $$.is = {
    defined: function(obj){
      return obj != null; // not undefined or null
    },

    string: function(obj){
      return obj != null && typeof obj == typeofstr;
    },
    
    fn: function(obj){
      return obj != null && typeof obj === typeoffn;
    },
    
    array: function(obj){
      return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
    },
    
    plainObject: function(obj){
      return obj != null && typeof obj === typeofobj && !$$.is.array(obj) && obj.constructor === Object;
    },

    object: function(obj){
      return obj != null && typeof obj === typeofobj;
    },
    
    number: function(obj){
      return obj != null && typeof obj === typeof 1 && !isNaN(obj);
    },

    integer: function( obj ){
      return $$.is.number(obj) && Math.floor(obj) === obj;
    },
    
    color: function(obj){
      return obj != null && typeof obj === typeof '' && $.Color(obj).toString() !== '';
    },
    
    bool: function(obj){
      return obj != null && typeof obj === typeof true;
    },
    
    elementOrCollection: function(obj){
      return $$.is.element(obj) || $$.is.collection(obj);
    },
    
    element: function(obj){
      return obj instanceof $$.Element && obj._private.single;
    },
    
    collection: function(obj){
      return obj instanceof $$.Collection && !obj._private.single;
    },
    
    core: function(obj){
      return obj instanceof $$.Core;
    },

    style: function(obj){
      return obj instanceof $$.Style;
    },

    stylesheet: function(obj){
      return obj instanceof $$.Stylesheet;
    },

    event: function(obj){
      return obj instanceof $$.Event;
    },

    thread: function(obj){
      return obj instanceof $$.Thread;
    },

    fabric: function(obj){
      return obj instanceof $$.Fabric;
    },

    emptyString: function(obj){
      if( !obj ){ // null is empty
        return true; 
      } else if( $$.is.string(obj) ){
        if( obj === '' || obj.match(/^\s+$/) ){
          return true; // empty string is empty
        }
      }
      
      return false; // otherwise, we don't know what we've got
    },
    
    nonemptyString: function(obj){
      if( obj && $$.is.string(obj) && obj !== '' && !obj.match(/^\s+$/) ){
        return true;
      }

      return false;
    },

    domElement: function(obj){
      if( typeof HTMLElement === 'undefined' ){
        return false; // we're not in a browser so it doesn't matter
      } else {
        return obj instanceof HTMLElement;
      }
    },

    boundingBox: function(obj){
      return $$.is.plainObject(obj) && 
        $$.is.number(obj.x1) && $$.is.number(obj.x2) &&
        $$.is.number(obj.y1) && $$.is.number(obj.y2)
      ;
    },

    promise: function(obj){
      return $$.is.object(obj) && $$.is.fn(obj.then);
    },

    touch: function(){
      return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );
    },

    gecko: function(){
      return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);
    },

    webkit: function(){
      return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);
    },

    chromium: function(){
      return typeof chrome !== 'undefined';
    },

    khtml: function(){
      return navigator.vendor.match(/kde/i); // TODO probably a better way to detect this...
    },

    khtmlEtc: function(){
      return $$.is.khtml() || $$.is.webkit() || $$.is.chromium();
    },

    trident: function(){
       return typeof ActiveXObject !== 'undefined' || /*@cc_on!@*/false;
    },

    windows: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Win/i);
    },

    mac: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Mac/i);
    },

    linux: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Linux/i);
    },

    unix: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/X11/i);
    }
  };  
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';
  
  // utility functions only for internal use

  $$.util = {

    // the jquery extend() function
    // NB: modified to use $$.is etc since we can't use jquery functions
    extend: function() {
      var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

      // Handle a deep copy situation
      if ( typeof target === 'boolean' ) {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
      }

      // Handle case when target is a string or something (possible in deep copy)
      if ( typeof target !== 'object' && !$$.is.fn(target) ) {
        target = {};
      }

      // extend jQuery itself if only one argument is passed
      if ( length === i ) {
        target = this;
        --i;
      }

      for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
          // Extend the base object
          for ( name in options ) {
            src = target[ name ];
            copy = options[ name ];

            // Prevent never-ending loop
            if ( target === copy ) {
              continue;
            }

            // Recurse if we're merging plain objects or arrays
            if ( deep && copy && ( $$.is.plainObject(copy) || (copyIsArray = $$.is.array(copy)) ) ) {
              if ( copyIsArray ) {
                copyIsArray = false;
                clone = src && $$.is.array(src) ? src : [];

              } else {
                clone = src && $$.is.plainObject(src) ? src : {};
              }

              // Never move original objects, clone them
              target[ name ] = $$.util.extend( deep, clone, copy );

            // Don't bring in undefined values
            } else if ( copy !== undefined ) {
              target[ name ] = copy;
            }
          }
        }
      }

      // Return the modified object
      return target;
    },

    // require that pulls in module from commonjs, amd, or window (falling back until found)
    require: function( name, callback, options ){
      var ret;
      options = $$.util.extend({
        msgIfNotFound: true
      }, options);

      var done = false;
      var fulfil = function( ret ){
        done = true;
        callback( ret );
      };

      var checkWindow = function( next ){
        if( window ){ // detected browser/window env
          ret = window[ name ];
        }

        if( ret !== undefined ){ fulfil(ret); }
        if( next ){ next(); }
      };
      var onCheckWindowDone = function(){
        if( !done ){
          checkCommonJs( onCheckCommonJsDone );
        }
      };

      var checkCommonJs = function( next ){
        if( typeof module !== 'undefined' && module.exports && require ){ // detected commonjs env
          ret = require( name ); // regular require
        }

        if( ret !== undefined ){ fulfil(ret); }
        if( next ){ next(); }
      };
      var onCheckCommonJsDone = function(){
        if( !done ){
          checkAmd( onCheckAmdDone );
        }
      };

      var checkAmd = function( next ){
        if( typeof define !== 'undefined' && define.amd && require ){ // detected amd env w/ defined module
          require([ name ], function( nameImpl ){
            ret = nameImpl;
            
            if( ret !== undefined ){ fulfil(ret); }
            if( next ){ next(); }
          });
        }
      };
      var onCheckAmdDone = function(){
        if( !done && options.msgIfNotFound ){
          $$.util.error('Cytoscape.js tried to pull in dependency `' + name + '` but no module (i.e. CommonJS, AMD, or window) was found');
        }
      };

      // kick off 1st check: window
      checkWindow( onCheckWindowDone );

    },

    // multiple requires in one callback
    requires: function( names, callback ){
      var impls = [];
      var gotImpl = [];

      var checkDone = function(){
        for( var i = 0; i < names.length; i++ ){ // check have all impls
          if( !gotImpl[i] ){ return; }
        }

        // otherwise, all got all impls => done
        callback.apply( callback, impls ); 
      };

      for( var i = 0; i < names.length; i++ ){ (function(){ // w/scope
        var name = names[i];
        var index = i;

        $$.util.require(name, function(impl){
          impls[index] = impl;
          gotImpl[index] = true;

          checkDone();
        });
      })(); }
    },

    // ported lodash throttle function
    throttle: function(func, wait, options) {
      var leading = true,
          trailing = true;

      if (options === false) {
        leading = false;
      } else if ($$.is.plainObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      options = options || {};
      options.leading = leading;
      options.maxWait = wait;
      options.trailing = trailing;

      return $$.util.debounce(func, wait, options);
    },

    now: function(){
      return +new Date();
    },

    // ported lodash debounce function
    debounce: function(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!$$.is.fn(func)) {
        return;
      }
      wait = Math.max(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if ($$.is.plainObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (Math.max(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - ($$.util.now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = $$.util.now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = $$.util.now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = $$.util.now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    },

    error: function( msg ){
      if( console ){
        if( console.error ){
          console.error.apply( console, arguments );
        } else if( console.log ){
          console.log.apply( console, arguments );
        } else {
          throw msg;
        }
      } else {
        throw msg;
      }
    },    

    clone: function( obj ){
      var target = {};
      for (var i in obj) {
        if ( obj.hasOwnProperty(i) ) { // TODO is this hasOwnProperty() call necessary for our use?
          target[i] = obj[i];
        }
      }
      return target;
    },

    // gets a shallow copy of the argument
    copy: function( obj ){
      if( obj == null ){
        return obj;
      } if( $$.is.array(obj) ){
        return obj.slice();
      } else if( $$.is.plainObject(obj) ){
        return $$.util.clone( obj );
      } else {
        return obj;
      }
    },
    
    // makes a full bb (x1, y1, x2, y2, w, h) from implicit params
    makeBoundingBox: function( bb ){
      if( bb.x1 != null && bb.y1 != null ){
        if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x2,
            y2: bb.y2,
            w: bb.x2 - bb.x1,
            h: bb.y2 - bb.y1
          };
        } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x1 + bb.w,
            y2: bb.y1 + bb.h,
            w: bb.w,
            h: bb.h
          };
        }
      } 
    },

    // has anything been set in the map
    mapEmpty: function( map ){
      var empty = true;

      if( map != null ){
        for(var i in map){ // jshint ignore:line
          empty = false;
          break;
        }
      }

      return empty;
    },

    // pushes to the array at the end of a map (map may not be built)
    pushMap: function( options ){
      var array = $$.util.getMap(options);

      if( array == null ){ // if empty, put initial array
        $$.util.setMap( $.extend({}, options, {
          value: [ options.value ]
        }) );
      } else {
        array.push( options.value );
      }
    },

    // sets the value in a map (map may not be built)
    setMap: function( options ){
      var obj = options.map;
      var key;
      var keys = options.keys;
      var l = keys.length;

      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to set map with object key');
        }

        if( i < keys.length - 1 ){
          
          // extend the map if necessary
          if( obj[key] == null ){
            obj[key] = {};
          }
          
          obj = obj[key];
        } else {
          // set the value
          obj[key] = options.value;
        }
      }
    },
    
    // gets the value in a map even if it's not built in places
    getMap: function( options ){
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
      
      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to get map with object key');
        }

        obj = obj[key];
        
        if( obj == null ){
          return obj;
        }
      }
      
      return obj;
    },

    // deletes the entry in the map
    deleteMap: function( options ){
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
      var keepChildren = options.keepChildren;
      
      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to delete map with object key');
        }

        var lastKey = i === options.keys.length - 1;
        if( lastKey ){
          
          if( keepChildren ){ // then only delete child fields not in keepChildren
            for( var child in obj ){
              if( !keepChildren[child] ){
                obj[child] = undefined;
              }
            }
          } else {
            obj[key] = undefined;
          }

        } else {
          obj = obj[key];
        }
      }
    },
    
    capitalize: function(str){
      if( $$.is.emptyString(str) ){
        return str;
      }
      
      return str.charAt(0).toUpperCase() + str.substring(1);
    },

    camel2dash: function( str ){
      var ret = [];

      for( var i = 0; i < str.length; i++ ){
        var ch = str[i];
        var chLowerCase = ch.toLowerCase();
        var isUpperCase = ch !== chLowerCase;

        if( isUpperCase ){
          ret.push( '-' );
          ret.push( chLowerCase );
        } else {
          ret.push( ch );
        }
      }

      var noUpperCases = ret.length === str.length;
      if( noUpperCases ){ return str; } // cheaper than .join()

      return ret.join('');
    },

    dash2camel: function( str ){
      var ret = [];
      var nextIsUpper = false;

      for( var i = 0; i < str.length; i++ ){
        var ch = str[i];
        var isDash = ch === '-';

        if( isDash ){
          nextIsUpper = true;
        } else {
          if( nextIsUpper ){
            ret.push( ch.toUpperCase() );
          } else {
            ret.push( ch );
          }

          nextIsUpper = false;
        }
      }

      return ret.join('');
    },

    // strip spaces from beginning of string and end of string
    trim: function( str ){
      var first, last;

      // find first non-space char
      for( first = 0; first < str.length && str[first] === ' '; first++ ){}

      // find last non-space char
      for( last = str.length - 1; last > first && str[last] === ' '; last-- ){}

      return str.substring(first, last + 1);
    },

    // get [r, g, b] from #abc or #aabbcc
    hex2tuple: function( hex ){
      if( !(hex.length === 4 || hex.length === 7) || hex[0] !== "#" ){ return; }

      var shortHex = hex.length === 4;
      var r, g, b;
      var base = 16;

      if( shortHex ){
        r = parseInt( hex[1] + hex[1], base );
        g = parseInt( hex[2] + hex[2], base );
        b = parseInt( hex[3] + hex[3], base );
      } else {
        r = parseInt( hex[1] + hex[2], base );
        g = parseInt( hex[3] + hex[4], base );
        b = parseInt( hex[5] + hex[6], base );
      }

      return [r, g, b];
    },

    // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
    hsl2tuple: function( hsl ){
      var ret;
      var h, s, l, a, r, g, b;
      function hue2rgb(p, q, t){
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      }

      var m = new RegExp("^" + $$.util.regex.hsla + "$").exec(hsl);
      if( m ){

        // get hue
        h = parseInt( m[1] ); 
        if( h < 0 ){
          h = ( 360 - (-1*h % 360) ) % 360;
        } else if( h > 360 ){
          h = h % 360;
        }
        h /= 360; // normalise on [0, 1]

        s = parseFloat( m[2] );
        if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]
        s = s/100; // normalise on [0, 1]

        l = parseFloat( m[3] );
        if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]
        l = l/100; // normalise on [0, 1]

        a = m[4];
        if( a !== undefined ){
          a = parseFloat( a );

          if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]
        }

        // now, convert to rgb
        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
        if( s === 0 ){
          r = g = b = Math.round(l * 255); // achromatic
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = Math.round( 255 * hue2rgb(p, q, h + 1/3) );
          g = Math.round( 255 * hue2rgb(p, q, h) );
          b = Math.round( 255 * hue2rgb(p, q, h - 1/3) );
        }

        ret = [r, g, b, a];
      }

      return ret;
    },

    // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
    rgb2tuple: function( rgb ){
      var ret;

      var m = new RegExp("^" + $$.util.regex.rgba + "$").exec(rgb);
      if( m ){
        ret = [];

        var isPct = [];
        for( var i = 1; i <= 3; i++ ){
          var channel = m[i];

          if( channel[ channel.length - 1 ] === "%" ){
            isPct[i] = true;
          }
          channel = parseFloat( channel );

          if( isPct[i] ){
            channel = channel/100 * 255; // normalise to [0, 255]
          }

          if( channel < 0 || channel > 255 ){ return; } // invalid channel value

          ret.push( Math.floor(channel) );
        }

        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
        var allArePct = isPct[1] && isPct[2] && isPct[3];
        if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is

        var alpha = m[4];
        if( alpha !== undefined ){
          alpha = parseFloat( alpha );

          if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value

          ret.push( alpha );
        }
      }

      return ret;
    },

    colorname2tuple: function( color ){
      return $$.util.colors[ color.toLowerCase() ];
    },

    color2tuple: function( color ){
      return ( $$.is.array(color) ? color : null ) 
        || $$.util.colorname2tuple(color)
        || $$.util.hex2tuple(color)
        || $$.util.rgb2tuple(color)
        || $$.util.hsl2tuple(color);
    },

    tuple2hex: function( tuple ){
      var r = tuple[0];
      var g = tuple[1];
      var b = tuple[2];

      function ch2hex( ch ){
        var hex = ch.toString(16);

        if( hex.length === 1 ){
          hex = '0' + hex;
        }

        return hex;
      }

      return '#' + ch2hex(r) + ch2hex(g) + ch2hex(b);
    },

    colors: {
      // special colour names
      transparent:      [0,0,0,0], // NB alpha === 0

      // regular colours
      aliceblue:        [240,248,255],
      antiquewhite:      [250,235,215],
      aqua:          [0,255,255],
      aquamarine:        [127,255,212],
      azure:          [240,255,255],
      beige:          [245,245,220],
      bisque:          [255,228,196],
      black:          [0,0,0],
      blanchedalmond:      [255,235,205],
      blue:          [0,0,255],
      blueviolet:        [138,43,226],
      brown:          [165,42,42],
      burlywood:        [222,184,135],
      cadetblue:        [95,158,160],
      chartreuse:        [127,255,0],
      chocolate:        [210,105,30],
      coral:          [255,127,80],
      cornflowerblue:      [100,149,237],
      cornsilk:        [255,248,220],
      crimson:        [220,20,60],
      cyan:          [0,255,255],
      darkblue:        [0,0,139],
      darkcyan:        [0,139,139],
      darkgoldenrod:      [184,134,11],
      darkgray:        [169,169,169],
      darkgreen:        [0,100,0],
      darkgrey:        [169,169,169],
      darkkhaki:        [189,183,107],
      darkmagenta:      [139,0,139],
      darkolivegreen:      [85,107,47],
      darkorange:        [255,140,0],
      darkorchid:        [153,50,204],
      darkred:        [139,0,0],
      darksalmon:        [233,150,122],
      darkseagreen:      [143,188,143],
      darkslateblue:      [72,61,139],
      darkslategray:      [47,79,79],
      darkslategrey:      [47,79,79],
      darkturquoise:      [0,206,209],
      darkviolet:        [148,0,211],
      deeppink:        [255,20,147],
      deepskyblue:      [0,191,255],
      dimgray:        [105,105,105],
      dimgrey:        [105,105,105],
      dodgerblue:        [30,144,255],
      firebrick:        [178,34,34],
      floralwhite:      [255,250,240],
      forestgreen:      [34,139,34],
      fuchsia:        [255,0,255],
      gainsboro:        [220,220,220],
      ghostwhite:        [248,248,255],
      gold:          [255,215,0],
      goldenrod:        [218,165,32],
      gray:          [128,128,128],
      grey:          [128,128,128],
      green:          [0,128,0],
      greenyellow:      [173,255,47],
      honeydew:        [240,255,240],
      hotpink:        [255,105,180],
      indianred:        [205,92,92],
      indigo:          [75,0,130],
      ivory:          [255,255,240],
      khaki:          [240,230,140],
      lavender:        [230,230,250],
      lavenderblush:      [255,240,245],
      lawngreen:        [124,252,0],
      lemonchiffon:      [255,250,205],
      lightblue:        [173,216,230],
      lightcoral:        [240,128,128],
      lightcyan:        [224,255,255],
      lightgoldenrodyellow:  [250,250,210],
      lightgray:        [211,211,211],
      lightgreen:        [144,238,144],
      lightgrey:        [211,211,211],
      lightpink:        [255,182,193],
      lightsalmon:      [255,160,122],
      lightseagreen:      [32,178,170],
      lightskyblue:      [135,206,250],
      lightslategray:      [119,136,153],
      lightslategrey:      [119,136,153],
      lightsteelblue:      [176,196,222],
      lightyellow:      [255,255,224],
      lime:          [0,255,0],
      limegreen:        [50,205,50],
      linen:          [250,240,230],
      magenta:        [255,0,255],
      maroon:          [128,0,0],
      mediumaquamarine:    [102,205,170],
      mediumblue:        [0,0,205],
      mediumorchid:      [186,85,211],
      mediumpurple:      [147,112,219],
      mediumseagreen:      [60,179,113],
      mediumslateblue:    [123,104,238],
      mediumspringgreen:    [0,250,154],
      mediumturquoise:    [72,209,204],
      mediumvioletred:    [199,21,133],
      midnightblue:      [25,25,112],
      mintcream:        [245,255,250],
      mistyrose:        [255,228,225],
      moccasin:        [255,228,181],
      navajowhite:      [255,222,173],
      navy:          [0,0,128],
      oldlace:        [253,245,230],
      olive:          [128,128,0],
      olivedrab:        [107,142,35],
      orange:          [255,165,0],
      orangered:        [255,69,0],
      orchid:          [218,112,214],
      palegoldenrod:      [238,232,170],
      palegreen:        [152,251,152],
      paleturquoise:      [175,238,238],
      palevioletred:      [219,112,147],
      papayawhip:        [255,239,213],
      peachpuff:        [255,218,185],
      peru:          [205,133,63],
      pink:          [255,192,203],
      plum:          [221,160,221],
      powderblue:        [176,224,230],
      purple:          [128,0,128],
      red:          [255,0,0],
      rosybrown:        [188,143,143],
      royalblue:        [65,105,225],
      saddlebrown:      [139,69,19],
      salmon:          [250,128,114],
      sandybrown:        [244,164,96],
      seagreen:        [46,139,87],
      seashell:        [255,245,238],
      sienna:          [160,82,45],
      silver:          [192,192,192],
      skyblue:        [135,206,235],
      slateblue:        [106,90,205],
      slategray:        [112,128,144],
      slategrey:        [112,128,144],
      snow:          [255,250,250],
      springgreen:      [0,255,127],
      steelblue:        [70,130,180],
      tan:          [210,180,140],
      teal:          [0,128,128],
      thistle:        [216,191,216],
      tomato:          [255,99,71],
      turquoise:        [64,224,208],
      violet:          [238,130,238],
      wheat:          [245,222,179],
      white:          [255,255,255],
      whitesmoke:        [245,245,245],
      yellow:          [255,255,0],
      yellowgreen:      [154,205,50]
    }
      
  };

  $$.util.regex = {};
  
  $$.util.regex.number = "(?:[-]?\\d*\\.\\d+|[-]?\\d+|[-]?\\d*\\.\\d+[eE]\\d+)";
  
  $$.util.regex.rgba = "rgb[a]?\\(("+ $$.util.regex.number +"[%]?)\\s*,\\s*("+ $$.util.regex.number +"[%]?)\\s*,\\s*("+ $$.util.regex.number +"[%]?)(?:\\s*,\\s*("+ $$.util.regex.number +"))?\\)";
  $$.util.regex.rgbaNoBackRefs = "rgb[a]?\\((?:"+ $$.util.regex.number +"[%]?)\\s*,\\s*(?:"+ $$.util.regex.number +"[%]?)\\s*,\\s*(?:"+ $$.util.regex.number +"[%]?)(?:\\s*,\\s*(?:"+ $$.util.regex.number +"))?\\)";
  
  $$.util.regex.hsla = "hsl[a]?\\(("+ $$.util.regex.number +")\\s*,\\s*("+ $$.util.regex.number +"[%])\\s*,\\s*("+ $$.util.regex.number +"[%])(?:\\s*,\\s*("+ $$.util.regex.number +"))?\\)";
  $$.util.regex.hslaNoBackRefs = "hsl[a]?\\((?:"+ $$.util.regex.number +")\\s*,\\s*(?:"+ $$.util.regex.number +"[%])\\s*,\\s*(?:"+ $$.util.regex.number +"[%])(?:\\s*,\\s*(?:"+ $$.util.regex.number +"))?\\)";
  
  $$.util.regex.hex3 = "\\#[0-9a-fA-F]{3}";
  $$.util.regex.hex6 = "\\#[0-9a-fA-F]{6}";

  var raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||  
        window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );

  raf = raf || function(fn){ if(fn){ setTimeout(fn, 1000/60); } };

  $$.util.requestAnimationFrame = function(fn){
    raf( fn );
  };

})( cytoscape, typeof window === 'undefined' ? null : window  );

;(function($$){ 'use strict';
  
  $$.math = {};
  
  $$.math.signum = function(x){
    if( x > 0 ){
      return 1;
    } else if( x < 0 ){
      return -1;
    } else {
      return 0;
    }
  };

  $$.math.distance = function( p1, p2 ){
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt( dx*dx + dy*dy );
  };

  // from http://en.wikipedia.org/wiki/Bzier_curve#Quadratic_curves
  $$.math.qbezierAt = function(p0, p1, p2, t){
    return (1 - t)*(1 - t)*p0 + 2*(1 - t)*t*p1 + t*t*p2;
  };

  $$.math.qbezierPtAt = function(p0, p1, p2, t){
    return {
      x: $$.math.qbezierAt( p0.x, p1.x, p2.x, t ),
      y: $$.math.qbezierAt( p0.y, p1.y, p2.y, t )
    };
  };

  $$.math.boundingBoxesIntersect = function( bb1, bb2 ){
    // case: one bb to right of other
    if( bb1.x1 > bb2.x2 ){ return false; }
    if( bb2.x1 > bb1.x2 ){ return false; }

    // case: one bb to left of other
    if( bb1.x2 < bb2.x1 ){ return false; }
    if( bb2.x2 < bb1.x1 ){ return false; }

    // case: one bb above other
    if( bb1.y2 < bb2.y1 ){ return false; }
    if( bb2.y2 < bb1.y1 ){ return false; }

    // case: one bb below other
    if( bb1.y1 > bb2.y2 ){ return false; }
    if( bb2.y1 > bb1.y2 ){ return false; }

    // otherwise, must have some overlap
    return true;
  };

  $$.math.inBoundingBox = function( bb, x, y ){
    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
  };

  $$.math.pointInBoundingBox = function( bb, pt ){
    return this.inBoundingBox( bb, pt.x, pt.y );
  };

  $$.math.roundRectangleIntersectLine = function(
    x, y, nodeX, nodeY, width, height, padding) {
    
    var cornerRadius = this.getRoundRectangleRadius(width, height);
    
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    
    // Check intersections with straight line segments
    var straightLineIntersections;
    
    // Top segment, left to right
    {
      var topStartX = nodeX - halfWidth + cornerRadius - padding;
      var topStartY = nodeY - halfHeight - padding;
      var topEndX = nodeX + halfWidth - cornerRadius + padding;
      var topEndY = topStartY;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Right segment, top to bottom
    {
      var rightStartX = nodeX + halfWidth + padding;
      var rightStartY = nodeY - halfHeight + cornerRadius - padding;
      var rightEndX = rightStartX;
      var rightEndY = nodeY + halfHeight - cornerRadius + padding;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Bottom segment, left to right
    {
      var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
      var bottomStartY = nodeY + halfHeight + padding;
      var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
      var bottomEndY = bottomStartY;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Left segment, top to bottom
    {
      var leftStartX = nodeX - halfWidth - padding;
      var leftStartY = nodeY - halfHeight + cornerRadius - padding;
      var leftEndX = leftStartX;
      var leftEndY = nodeY + halfHeight - cornerRadius + padding;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Check intersections with arc segments
    var arcIntersections;
    
    // Top Left
    {
      var topLeftCenterX = nodeX - halfWidth + cornerRadius;
      var topLeftCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        topLeftCenterX, topLeftCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] <= topLeftCenterX
        && arcIntersections[1] <= topLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Top Right
    {
      var topRightCenterX = nodeX + halfWidth - cornerRadius;
      var topRightCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        topRightCenterX, topRightCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] >= topRightCenterX
        && arcIntersections[1] <= topRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Bottom Right
    {
      var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
      var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] >= bottomRightCenterX
        && arcIntersections[1] >= bottomRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Bottom Left
    {
      var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
      var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] <= bottomLeftCenterX
        && arcIntersections[1] >= bottomLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }

    return []; // if nothing
  };
  
  $$.math.roundRectangleIntersectBox = function(
    boxX1, boxY1, boxX2, boxY2, width, height, centerX, centerY, padding) {
    
    // We have the following shpae
    
    //    _____
    //  _|     |_
    // |         |
    // |_       _|
    //   |_____|
    //
    // With a quarter circle at each corner.
    
    var cornerRadius = this.getRoundRectangleRadius(width, height);
    
    var hBoxTopLeftX = centerX - width / 2 - padding;
    var hBoxTopLeftY = centerY - height / 2 + cornerRadius - padding;
    var hBoxBottomRightX = centerX + width / 2 + padding;
    var hBoxBottomRightY = centerY + height / 2 - cornerRadius + padding;
    
    var vBoxTopLeftX = centerX - width / 2 + cornerRadius - padding;
    var vBoxTopLeftY = centerY - height / 2 - padding;
    var vBoxBottomRightX = centerX + width / 2 - cornerRadius + padding;
    var vBoxBottomRightY = centerY + height / 2 + padding;
    
    // Check if the box is out of bounds
    var boxMinX = Math.min(boxX1, boxX2);
    var boxMaxX = Math.max(boxX1, boxX2);
    var boxMinY = Math.min(boxY1, boxY2);
    var boxMaxY = Math.max(boxY1, boxY2);
    
    if (boxMaxX < hBoxTopLeftX) {
      return false;
    } else if (boxMinX > hBoxBottomRightX) {
      return false;
    }
    
    if (boxMaxY < vBoxTopLeftY) {
      return false;
    } else if (boxMinY > vBoxBottomRightY) {
      return false;
    }
    
    // Check if an hBox point is in given box
    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX
        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX
        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX
        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX
        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    // Check if a given point box is in the hBox
    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX
      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX
      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX
      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX
      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {
      return true;
    }
    
    // Check if an vBox point is in given box
    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX
        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX
        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX
        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX
        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    // Check if a given point box is in the vBox
    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX
      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX
      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX
      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX
      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {
      return true;
    }
    
    // Lastly, check if one of the ellipses coincide with the box
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxTopLeftY + padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxBottomRightY - padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxBottomRightY - padding)) {
      return true;
    }
    
    return false;
  };
  
  // @O Approximate collision functions
  $$.math.checkInBoundingCircle = function(
    x, y, farthestPointSqDistance, padding, width, height, centerX, centerY) {
    
    x = (x - centerX) / (width + padding);
    y = (y - centerY) / (height + padding);
    
    return (x * x + y * y) <= farthestPointSqDistance;
  };
  
  $$.math.boxInBezierVicinity = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {
    
    // Return values:
    // 0 - curve is not in box
    // 1 - curve may be in box; needs precise check
    // 2 - curve is in box
    
    // midpoint
    var midX = 0.25 * x1 + 0.5 * x2 + 0.25 * x3;
    var midY = 0.25 * y1 + 0.5 * y2 + 0.25 * y3;

    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) { // (x1, y1) in box
      return 1;
    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) { // (x3, y3) in box
      return 1;
    } else if (midX >= boxMinX && midX <= boxMaxX && midY >= boxMinY && midY <= boxMaxY) { // (midX, midY) in box
      return 1;
    } else if (x2 >= boxMinX && x2 <= boxMaxX && y2 >= boxMinY && y2 <= boxMaxY) { // ctrl pt in box
      return 1;
    }
    
    var curveMinX = Math.min(x1, midX, x3);
    var curveMinY = Math.min(y1, midY, y3);
    var curveMaxX = Math.max(x1, midX, x3);
    var curveMaxY = Math.max(y1, midY, y3);
    
    /*
    console.log(curveMinX + ", " + curveMinY + ", " + curveMaxX 
      + ", " + curveMaxY);
    if (curveMinX == undefined) {
      console.log("undefined curveMinX: " + x1 + ", " + x2 + ", " + x3);
    }
    */
    
    if (curveMinX > boxMaxX
      || curveMaxX < boxMinX
      || curveMinY > boxMaxY
      || curveMaxY < boxMinY) {
      
      return 0;  
    }
    
    return 1;
  };

  $$.math.checkBezierInBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {

    function sampleInBox(t){
      var x = $$.math.qbezierAt(x1, x2, x3, t);
      var y = $$.math.qbezierAt(y1, y2, y3, t);

      return x1box <= x && x <= x2box
        && y1box <= y && y <= y2box
      ;
    }

    for( var t = 0; t <= 1; t += 0.25 ){
      if( !sampleInBox(t) ){
        return false;
      }
    }

    return true;
  };
  
  $$.math.checkStraightEdgeInBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {

    return x1box <= x1 && x1 <= x2box
      && x1box <= x2 && x2 <= x2box
      && y1box <= y1 && y1 <= y2box
      && y1box <= y2 && y2 <= y2box
    ;
  };

  $$.math.checkStraightEdgeCrossesBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {
    
   //console.log(arguments);
    
    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    // Check left + right bounds
    var aX = x2 - x1;
    var bX = x1;
    var yValue;
    
    // Top and bottom
    var aY = y2 - y1;
    var bY = y1;
    var xValue;
    
    if (Math.abs(aX) < 0.0001) {
      return (x1 >= boxMinX && x1 <= boxMaxX
        && Math.min(y1, y2) <= boxMinY
        && Math.max(y1, y2) >= boxMaxY);  
    }
    
    var tLeft = (boxMinX - bX) / aX;
    if (tLeft > 0 && tLeft <= 1) {
      yValue = aY * tLeft + bY;
      if (yValue >= boxMinY && yValue <= boxMaxY) {
        return true;
      } 
    }
    
    var tRight = (boxMaxX - bX) / aX;
    if (tRight > 0 && tRight <= 1) {
      yValue = aY * tRight + bY;
      if (yValue >= boxMinY && yValue <= boxMaxY) {
        return true;
      } 
    }
    
    var tTop = (boxMinY - bY) / aY;
    if (tTop > 0 && tTop <= 1) {
      xValue = aX * tTop + bX;
      if (xValue >= boxMinX && xValue <= boxMaxX) {
        return true;
      } 
    }
    
    var tBottom = (boxMaxY - bY) / aY;
    if (tBottom > 0 && tBottom <= 1) {
      xValue = aX * tBottom + bX;
      if (xValue >= boxMinX && xValue <= boxMaxX) {
        return true;
      } 
    }
    
    return false;
  };
  
  $$.math.checkBezierCrossesBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {
    
    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) {
      return true;
    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) {
      return true;
    }
    
    var aX = x1 - 2 * x2 + x3;
    var bX = -2 * x1 + 2 * x2;
    var cX = x1;

    var xIntervals = [];
    
    if (Math.abs(aX) < 0.0001) {
      var leftParam = (boxMinX - x1) / bX;
      var rightParam = (boxMaxX - x1) / bX;
      
      xIntervals.push(leftParam, rightParam);
    } else {
      // Find when x coordinate of the curve crosses the left side of the box
      var discriminantX1 = bX * bX - 4 * aX * (cX - boxMinX);
      var tX1, tX2;
      if (discriminantX1 > 0) {
        var sqrt = Math.sqrt(discriminantX1);
        tX1 = (-bX + sqrt) / (2 * aX);
        tX2 = (-bX - sqrt) / (2 * aX);
        
        xIntervals.push(tX1, tX2);
      }
      
      var discriminantX2 = bX * bX - 4 * aX * (cX - boxMaxX);
      var tX3, tX4;
      if (discriminantX2 > 0) {
        var sqrt = Math.sqrt(discriminantX2);
        tX3 = (-bX + sqrt) / (2 * aX);
        tX4 = (-bX - sqrt) / (2 * aX);
        
        xIntervals.push(tX3, tX4);
      }
    }
    
    xIntervals.sort(function(a, b) { return a - b; });
    
    var aY = y1 - 2 * y2 + y3;
    var bY = -2 * y1 + 2 * y2;
    var cY = y1;
    
    var yIntervals = [];
    
    if (Math.abs(aY) < 0.0001) {
      var topParam = (boxMinY - y1) / bY;
      var bottomParam = (boxMaxY - y1) / bY;
      
      yIntervals.push(topParam, bottomParam);
    } else {
      var discriminantY1 = bY * bY - 4 * aY * (cY - boxMinY);
      
      var tY1, tY2;
      if (discriminantY1 > 0) {
        var sqrt = Math.sqrt(discriminantY1);
        tY1 = (-bY + sqrt) / (2 * aY);
        tY2 = (-bY - sqrt) / (2 * aY);
        
        yIntervals.push(tY1, tY2);
      }
  
      var discriminantY2 = bY * bY - 4 * aY * (cY - boxMaxY);
      
      var tY3, tY4;
      if (discriminantY2 > 0) {
        var sqrt = Math.sqrt(discriminantY2);
        tY3 = (-bY + sqrt) / (2 * aY);
        tY4 = (-bY - sqrt) / (2 * aY);
        
        yIntervals.push(tY3, tY4);
      }
    }
        
    yIntervals.sort(function(a, b) { return a - b; });

    for (var index = 0; index < xIntervals.length; index += 2) {
      for (var yIndex = 1; yIndex < yIntervals.length; yIndex += 2) {
        
        // Check if there exists values for the Bezier curve
        // parameter between 0 and 1 where both the curve's
        // x and y coordinates are within the bounds specified by the box
        if (xIntervals[index] < yIntervals[yIndex]
          && yIntervals[yIndex] >= 0.0
          && xIntervals[index] <= 1.0
          && xIntervals[index + 1] > yIntervals[yIndex - 1]
          && yIntervals[yIndex - 1] <= 1.0
          && xIntervals[index + 1] >= 0.0) {
          
          return true;
        }
      }
    }
    
    return false;
  };
  
  $$.math.inLineVicinity = function(x, y, lx1, ly1, lx2, ly2, tolerance){
    var t = tolerance;

    var x1 = Math.min(lx1, lx2);
    var x2 = Math.max(lx1, lx2);
    var y1 = Math.min(ly1, ly2);
    var y2 = Math.max(ly1, ly2);

    return x1 - t <= x && x <= x2 + t
      && y1 - t <= y && y <= y2 + t;
  };

  $$.math.inBezierVicinity = function(
    x, y, x1, y1, x2, y2, x3, y3, toleranceSquared) {

    var bb = {
      x1: Math.min( x1, x3, x2 ),
      x2: Math.max( x1, x3, x2 ),
      y1: Math.min( y1, y3, y2 ),
      y2: Math.max( y1, y3, y2 )
    };

    // if outside the rough bounding box for the bezier, then it can't be a hit
    if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){
      // console.log('bezier out of rough bb')
      return false;
    } else {
      // console.log('do more expensive check');
      return true;
    }

  };
  
  $$.math.solveCubic = function(a, b, c, d, result) {
    
    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
    // r is the real component, i is the imaginary component

    // An implementation of the Cardano method from the year 1545
    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

    b /= a;
    c /= a;
    d /= a;
    
    var discriminant, q, r, dum1, s, t, term1, r13;

    q = (3.0 * c - (b * b)) / 9.0;
    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
    r /= 54.0;
    
    discriminant = q * q * q + r * r;
    result[1] = 0;
    term1 = (b / 3.0);
    
    if (discriminant > 0) {
      s = r + Math.sqrt(discriminant);
      s = ((s < 0) ? -Math.pow(-s, (1.0 / 3.0)) : Math.pow(s, (1.0 / 3.0)));
      t = r - Math.sqrt(discriminant);
      t = ((t < 0) ? -Math.pow(-t, (1.0 / 3.0)) : Math.pow(t, (1.0 / 3.0)));
      result[0] = -term1 + s + t;
      term1 += (s + t) / 2.0;
      result[4] = result[2] = -term1;
      term1 = Math.sqrt(3.0) * (-t + s) / 2;
      result[3] = term1;
      result[5] = -term1;
      return;
    }
    
    result[5] = result[3] = 0;
    
    if (discriminant === 0) {
      r13 = ((r < 0) ? -Math.pow(-r, (1.0 / 3.0)) : Math.pow(r, (1.0 / 3.0)));
      result[0] = -term1 + 2.0 * r13;
      result[4] = result[2] = -(r13 + term1);
      return;
    }
    
    q = -q;
    dum1 = q * q * q;
    dum1 = Math.acos(r / Math.sqrt(dum1));
    r13 = 2.0 * Math.sqrt(q);
    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
    
    return;
  };

  $$.math.sqDistanceToQuadraticBezier = function(
    x, y, x1, y1, x2, y2, x3, y3) {
    
    // Find minimum distance by using the minimum of the distance 
    // function between the given point and the curve
    
    // This gives the coefficients of the resulting cubic equation
    // whose roots tell us where a possible minimum is
    // (Coefficients are divided by 4)
    
    var a = 1.0 * x1*x1 - 4*x1*x2 + 2*x1*x3 + 4*x2*x2 - 4*x2*x3 + x3*x3
      + y1*y1 - 4*y1*y2 + 2*y1*y3 + 4*y2*y2 - 4*y2*y3 + y3*y3;
    
    var b = 1.0 * 9*x1*x2 - 3*x1*x1 - 3*x1*x3 - 6*x2*x2 + 3*x2*x3
      + 9*y1*y2 - 3*y1*y1 - 3*y1*y3 - 6*y2*y2 + 3*y2*y3;
    
    var c = 1.0 * 3*x1*x1 - 6*x1*x2 + x1*x3 - x1*x + 2*x2*x2 + 2*x2*x - x3*x
      + 3*y1*y1 - 6*y1*y2 + y1*y3 - y1*y + 2*y2*y2 + 2*y2*y - y3*y;
      
    var d = 1.0 * x1*x2 - x1*x1 + x1*x - x2*x
      + y1*y2 - y1*y1 + y1*y - y2*y;
    
    // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);
    
    var roots = [];
    
    // Use the cubic solving algorithm
    this.solveCubic(a, b, c, d, roots);
    
    var zeroThreshold = 0.0000001;
    
    var params = [];
    
    for (var index = 0; index < 6; index += 2) {
      if (Math.abs(roots[index + 1]) < zeroThreshold
          && roots[index] >= 0
          && roots[index] <= 1.0) {
        params.push(roots[index]);
      }
    }
    
    params.push(1.0);
    params.push(0.0);
    
    var minDistanceSquared = -1;
    var closestParam;
    
    var curX, curY, distSquared;
    for (var i = 0; i < params.length; i++) {
      curX = Math.pow(1.0 - params[i], 2.0) * x1
        + 2.0 * (1 - params[i]) * params[i] * x2
        + params[i] * params[i] * x3;
        
      curY = Math.pow(1 - params[i], 2.0) * y1
        + 2 * (1.0 - params[i]) * params[i] * y2
        + params[i] * params[i] * y3;
        
      distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
      // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
      if (minDistanceSquared >= 0) {
        if (distSquared < minDistanceSquared) {
          minDistanceSquared = distSquared;
          closestParam = params[i];
        }
      } else {
        minDistanceSquared = distSquared;
        closestParam = params[i];
      }
    }
    
    /*
    debugStats.clickX = x;
    debugStats.clickY = y;
    
    debugStats.closestX = Math.pow(1.0 - closestParam, 2.0) * x1
        + 2.0 * (1.0 - closestParam) * closestParam * x2
        + closestParam * closestParam * x3;
        
    debugStats.closestY = Math.pow(1.0 - closestParam, 2.0) * y1
        + 2.0 * (1.0 - closestParam) * closestParam * y2
        + closestParam * closestParam * y3;
    */
    
    // debug("given: " 
    //   + "( " + x + ", " + y + "), " 
    //   + "( " + x1 + ", " + y1 + "), " 
    //   + "( " + x2 + ", " + y2 + "), "
    //   + "( " + x3 + ", " + y3 + ")");
    
    
    // debug("roots: " + roots);
    // debug("params: " + params);
    // debug("closest param: " + closestParam);
    return minDistanceSquared;
  };
  
  $$.math.sqDistanceToFiniteLine = function(x, y, x1, y1, x2, y2) {
    var offset = [x - x1, y - y1];
    var line = [x2 - x1, y2 - y1];
    
    var lineSq = line[0] * line[0] + line[1] * line[1];
    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
    
    var dotProduct = offset[0] * line[0] + offset[1] * line[1];
    var adjSq = dotProduct * dotProduct / lineSq;
    
    if (dotProduct < 0) {
      return hypSq;
    }
    
    if (adjSq > lineSq) {
      return (x - x2) * (x - x2) + (y - y2) * (y - y2);
    }
    
    return hypSq - adjSq;
  };

  $$.math.pointInsidePolygon = function(
    x, y, basePoints, centerX, centerY, width, height, direction, padding) {

    //var direction = arguments[6];
    var transformedPoints = new Array(basePoints.length);

    // Gives negative angle
    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] 
      + direction[1] * direction[1])));
    
    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
        
    var cos = Math.cos(-angle);
    var sin = Math.sin(-angle);
    
//    console.log("base: " + basePoints);
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = 
        width / 2 * (basePoints[i * 2] * cos
          - basePoints[i * 2 + 1] * sin);
      
      transformedPoints[i * 2 + 1] = 
        height / 2 * (basePoints[i * 2 + 1] * cos 
          + basePoints[i * 2] * sin);

      transformedPoints[i * 2] += centerX;
      transformedPoints[i * 2 + 1] += centerY;
    }
    
    var points;
    
    if (padding > 0) {
      var expandedLineSet = this.expandPolygon(
        transformedPoints,
        -padding);
      
      points = this.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    
    var x1, y1, x2, y2;
    var y3;
    
    // Intersect with vertical line through (x, y)
    var up = 0;
    var down = 0;
    for (var i = 0; i < points.length / 2; i++) {
      
      x1 = points[i * 2];
      y1 = points[i * 2 + 1];
      
      if (i + 1 < points.length / 2) {
        x2 = points[(i + 1) * 2];
        y2 = points[(i + 1) * 2 + 1];
      } else {
        x2 = points[(i + 1 - points.length / 2) * 2];
        y2 = points[(i + 1 - points.length / 2) * 2 + 1];
      }
      
//*      console.log("line from (" + x1 + ", " + y1 + ") to (" + x2 + ", " + y2 + ")");

//&      console.log(x1, x, x2);

      if (x1 == x && x2 == x) {
        
      } else if ((x1 >= x && x >= x2)
        || (x1 <= x && x <= x2)) {
        
        y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;
        
        if (y3 > y) {
          up++;
        }
        
        if (y3 < y) {
          down++;
        }
        
//*        console.log(y3, y);
        
      } else {
//*        console.log('22');
        continue;
      }
      
    }
    
//*    console.log("up: " + up + ", down: " + down);
    
    if (up % 2 === 0) {
      return false;
    } else {
      return true;
    }
  };

  $$.math.joinLines = function(lineSet) {
    
    var vertices = new Array(lineSet.length / 2);
    
    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;
    
    for (var i = 0; i < lineSet.length / 4; i++) {
      currentLineStartX = lineSet[i * 4];
      currentLineStartY = lineSet[i * 4 + 1];
      currentLineEndX = lineSet[i * 4 + 2];
      currentLineEndY = lineSet[i * 4 + 3];
      
      if (i < lineSet.length / 4 - 1) {
        nextLineStartX = lineSet[(i + 1) * 4];
        nextLineStartY = lineSet[(i + 1) * 4 + 1];
        nextLineEndX = lineSet[(i + 1) * 4 + 2];
        nextLineEndY = lineSet[(i + 1) * 4 + 3];
      } else {
        nextLineStartX = lineSet[0];
        nextLineStartY = lineSet[1];
        nextLineEndX = lineSet[2];
        nextLineEndY = lineSet[3];
      }
      
      var intersection = this.finiteLinesIntersect(
        currentLineStartX, currentLineStartY,
        currentLineEndX, currentLineEndY,
        nextLineStartX, nextLineStartY,
        nextLineEndX, nextLineEndY,
        true);
      
      vertices[i * 2] = intersection[0];
      vertices[i * 2 + 1] = intersection[1];
    }
    
    return vertices;
  };

  $$.math.expandPolygon = function(points, pad) {
    
    var expandedLineSet = new Array(points.length * 2);
    
    var currentPointX, currentPointY, nextPointX, nextPointY;
    
    for (var i = 0; i < points.length / 2; i++) {
      currentPointX = points[i * 2];
      currentPointY = points[i * 2 + 1];
      
      if (i < points.length / 2 - 1) {
        nextPointX = points[(i + 1) * 2];
        nextPointY = points[(i + 1) * 2 + 1];
      } else {
        nextPointX = points[0];
        nextPointY = points[1];
      }
      
      // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
      
      // Assume CCW polygon winding
      
      var offsetX = (nextPointY - currentPointY);
      var offsetY = -(nextPointX - currentPointX);
      
      // Normalize
      var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
      var normalizedOffsetX = offsetX / offsetLength;
      var normalizedOffsetY = offsetY / offsetLength;
      
      expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
      expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
      expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
      expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
    }
    
    return expandedLineSet;
  };

  $$.math.intersectLineEllipse = function(
    x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
    
    var dispX = centerX - x;
    var dispY = centerY - y;
    
    dispX /= ellipseWradius;
    dispY /= ellipseHradius;
    
    var len = Math.sqrt(dispX * dispX + dispY * dispY);
    
    var newLength = len - 1;
    
    if (newLength < 0) {
      return [];
    }
    
    var lenProportion = newLength / len;
    
    return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
  };
  
  $$.math.dotProduct = function(
    vec1, vec2) {
    
    if (vec1.length != 2 || vec2.length != 2) {
      throw 'dot product: arguments are not vectors';
    }
    
    return (vec1[0] * vec2[0] + vec1[1] * vec2[1]);
  };
  
  // Returns intersections of increasing distance from line's start point
  $$.math.intersectLineCircle = function(
    x1, y1, x2, y2, centerX, centerY, radius) {
    
    // Calculate d, direction vector of line
    var d = [x2 - x1, y2 - y1]; // Direction vector of line
    var c = [centerX, centerY]; // Center of circle
    var f = [x1 - centerX, y1 - centerY];
    
    var a = d[0] * d[0] + d[1] * d[1];
    var b = 2 * (f[0] * d[0] + f[1] * d[1]);
    var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;
    
    var discriminant = b*b-4*a*c;
    
    if (discriminant < 0) {
      return [];
    }
    
    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
    
    var tMin = Math.min(t1, t2);
    var tMax = Math.max(t1, t2);
    var inRangeParams = [];
    
    if (tMin >= 0 && tMin <= 1) {
      inRangeParams.push(tMin);
    }
    
    if (tMax >= 0 && tMax <= 1) {
      inRangeParams.push(tMax);
    }
    
    if (inRangeParams.length === 0) {
      return [];
    }
    
    var nearIntersectionX = inRangeParams[0] * d[0] + x1;
    var nearIntersectionY = inRangeParams[0] * d[1] + y1;
    
    if (inRangeParams.length > 1) {
    
      if (inRangeParams[0] == inRangeParams[1]) {
        return [nearIntersectionX, nearIntersectionY];
      } else {
        
        var farIntersectionX = inRangeParams[1] * d[0] + x1;
        var farIntersectionY = inRangeParams[1] * d[1] + y1;
      
        return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
      }
      
    } else {
      return [nearIntersectionX, nearIntersectionY];
    }
    
  };
  
  $$.math.findCircleNearPoint = function(centerX, centerY, 
    radius, farX, farY) {
    
    var displacementX = farX - centerX;
    var displacementY = farY - centerY;
    var distance = Math.sqrt(displacementX * displacementX 
      + displacementY * displacementY);
    
    var unitDisplacementX = displacementX / distance;
    var unitDisplacementY = displacementY / distance;
    
    return [centerX + unitDisplacementX * radius, 
      centerY + unitDisplacementY * radius];
  };
  
  $$.math.findMaxSqDistanceToOrigin = function(points) {
    var maxSqDistance = 0.000001;
    var sqDistance;
    
    for (var i = 0; i < points.length / 2; i++) {
      
      sqDistance = points[i * 2] * points[i * 2] 
        + points[i * 2 + 1] * points[i * 2 + 1];
      
      if (sqDistance > maxSqDistance) {
        maxSqDistance = sqDistance;
      }
    }
    
    return maxSqDistance;
  };
  
  $$.math.finiteLinesIntersect = function(
    x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
    
    var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

    if (u_b !== 0) {
      var ua = ua_t / u_b;
      var ub = ub_t / u_b;
      
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {  
        return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
        
      } else {
        if (!infiniteLines) {
          return [];
        } else {
          return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
        }
      }
    } else {
      if (ua_t === 0 || ub_t === 0) {

        // Parallel, coincident lines. Check if overlap

        // Check endpoint of second line
        if ([x1, x2, x4].sort()[1] === x4) {
          return [x4, y4];
        }
        
        // Check start point of second line
        if ([x1, x2, x3].sort()[1] === x3) {
          return [x3, y3];
        }
        
        // Endpoint of first line
        if ([x3, x4, x2].sort()[1] === x2) {
          return [x2, y2];
        }
        
        return [];
      } else {
      
        // Parallel, non-coincident
        return [];
      }
    }
  };
  
  // (boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
  //      cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {
  
  $$.math.boxIntersectEllipse = function(
    x1, y1, x2, y2, padding, width, height, centerX, centerY) {
    
    if (x2 < x1) {
      var oldX1 = x1;
      x1 = x2;
      x2 = oldX1;
    }
    
    if (y2 < y1) {
      var oldY1 = y1;
      y1 = y2;
      y2 = oldY1;
    }
    
    // 4 ortho extreme points
    var west = [centerX - width / 2 - padding, centerY];
    var east = [centerX + width / 2 + padding, centerY];
    var north = [centerX, centerY - height / 2 - padding];
    var south = [centerX, centerY + height / 2 + padding];
    
    // out of bounds: return false
    if (x2 < west[0]) {
      return false;
    }
    
    if (x1 > east[0]) {
      return false;
    }
    
    if (y1 > south[1]) {
      return false;
    }
    
    if (y2 < north[1]) {
      return false;
    }
    
    // 1 of 4 ortho extreme points in box: return true
    if (x1 <= east[0] && east[0] <= x2
        && y1 <= east[1] && east[1] <= y2) {
      return true;
    }
    
    if (x1 <= west[0] && west[0] <= x2
        && y1 <= west[1] && west[1] <= y2) {
      return true;
    }
    
    if (x1 <= north[0] && north[0] <= x2
        && y1 <= north[1] && north[1] <= y2) {
      return true;
    }
    
    if (x1 <= south[0] && south[0] <= x2
        && y1 <= south[1] && south[1] <= y2) {
      return true;
    }
    
    // box corner in ellipse: return true    
    x1 = (x1 - centerX) / (width / 2 + padding);
    x2 = (x2 - centerX) / (width / 2 + padding);
    
    y1 = (y1 - centerY) / (height / 2 + padding);
    y2 = (y2 - centerY) / (height / 2 + padding);
    
    if (x1 * x1 + y1 * y1 <= 1) {
      return true;
    }
    
    if (x2 * x2 + y1 * y1 <= 1) {
      return true;
    }
    
    if (x2 * x2 + y2 * y2 <= 1) {
      return true;
    }
    
    if (x1 * x1 + y2 * y2 <= 1) {
      return true;
    }
    
    return false;
  };
  
  $$.math.boxIntersectPolygon = function(
    x1, y1, x2, y2, basePoints, width, height, centerX, centerY, direction, padding) {
    
//    console.log(arguments);
    
    if (x2 < x1) {
      var oldX1 = x1;
      x1 = x2;
      x2 = oldX1;
    }
    
    if (y2 < y1) {
      var oldY1 = y1;
      y1 = y2;
      y2 = oldY1;
    }
    
    var transformedPoints = new Array(basePoints.length);
    
    // Gives negative of angle
    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] 
      + direction[1] * direction[1])));
    
    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
    
    var cos = Math.cos(-angle);
    var sin = Math.sin(-angle);
    
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = 
        width / 2 * (basePoints[i * 2] * cos
          - basePoints[i * 2 + 1] * sin);
      
      transformedPoints[i * 2 + 1] = 
        height / 2 * (basePoints[i * 2 + 1] * cos 
          + basePoints[i * 2] * sin);
      
      transformedPoints[i * 2] += centerX;
      transformedPoints[i * 2 + 1] += centerY;
    }
    
    // Assume transformedPoints.length > 0, and check if intersection is possible
    var minTransformedX = transformedPoints[0];
    var maxTransformedX = transformedPoints[0];
    var minTransformedY = transformedPoints[1];
    var maxTransformedY = transformedPoints[1];
    
    for (var i = 1; i < transformedPoints.length / 2; i++) {
      if (transformedPoints[i * 2] > maxTransformedX) {
        maxTransformedX = transformedPoints[i * 2];
      }
      
      if (transformedPoints[i * 2] < minTransformedX) {
        minTransformedX = transformedPoints[i * 2];
      }
      
      if (transformedPoints[i * 2 + 1] > maxTransformedY) {
        maxTransformedY = transformedPoints[i * 2 + 1];
      }
      
      if (transformedPoints[i * 2 + 1] < minTransformedY) {
        minTransformedY = transformedPoints[i * 2 + 1];
      }
    }
    
    if (x2 < minTransformedX - padding) {
      return false;
    }
    
    if (x1 > maxTransformedX + padding) {
      return false;
    }
    
    if (y2 < minTransformedY - padding) {
      return false;
    }
    
    if (y1 > maxTransformedY + padding) {
      return false;
    }
    
    // Continue checking with padding-corrected points
    var points;
    
    if (padding > 0) {
      var expandedLineSet = $$.math.expandPolygon(
        transformedPoints,
        -padding);
      
      points = $$.math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    
    // Check if a point is in box
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      if (x1 <= transformedPoints[i * 2]
          && transformedPoints[i * 2] <= x2) {
        
        if (y1 <= transformedPoints[i * 2 + 1]
            && transformedPoints[i * 2 + 1] <= y2) {
          
          return true;
        }
      }
    }
    
    
    // Check for intersections with the selection box
    for (var i = 0; i < points.length / 2; i++) {
      
      var currentX = points[i * 2];
      var currentY = points[i * 2 + 1];
      var nextX;
      var nextY;
      
      if (i < points.length / 2 - 1) {
        nextX = points[(i + 1) * 2];
        nextY = points[(i + 1) * 2 + 1];
      } else {
        nextX = points[0];
        nextY = points[1];
      }
      
      // Intersection with top of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x2, y1, false).length > 0) {
        return true;
      }
      
      // Intersection with bottom of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y2, x2, y2, false).length > 0) {
        return true;
      }
      
      // Intersection with left side of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x1, y2, false).length > 0) {
        return true;
      }
      
      // Intersection with right side of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x2, y1, x2, y2, false).length > 0) {
        return true;
      }
    }

    /*
    // Check if box corner in the polygon
    if ($$.math.pointInsidePolygon(
      x1, y1, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    } else if ($$.math.pointInsidePolygon(
      x1, y2, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    } else if ($$.math.pointInsidePolygon(
      x2, y2, points, 0, 0, 1, 1, 0, direction)) {
       
      return true; 
    } else if ($$.math.pointInsidePolygon(
      x2, y1, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    }
    */
    return false;
  };
  
  $$.math.polygonIntersectLine = function(
    x, y, basePoints, centerX, centerY, width, height, padding) {
    
    var intersections = [];
    var intersection;
    
    var transformedPoints = new Array(basePoints.length);
    
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
    }
    
    var points;
    
    if (padding > 0) {
      var expandedLineSet = $$.math.expandPolygon(
        transformedPoints,
        -padding);
      
      points = $$.math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    // var points = transformedPoints;
    
    var currentX, currentY, nextX, nextY;
    
    for (var i = 0; i < points.length / 2; i++) {
    
      currentX = points[i * 2];
      currentY = points[i * 2 + 1];

      if (i < points.length / 2 - 1) {
        nextX = points[(i + 1) * 2]; 
        nextY = points[(i + 1) * 2 + 1];
      } else {
        nextX = points[0]; 
        nextY = points[1];
      }
      
      intersection = this.finiteLinesIntersect(
        x, y, centerX, centerY,
        currentX, currentY,
        nextX, nextY);
      
      if (intersection.length !== 0) {
        intersections.push(intersection[0], intersection[1]);
      }
    }
    
    return intersections;
  };
  
  $$.math.shortenIntersection = function(
    intersection, offset, amount) {
    
    var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
    
    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
    
    var lenRatio = (length - amount) / length;
    
    if (lenRatio < 0) {
      lenRatio = 0.00001;
    }

    return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
  };

  $$.math.generateUnitNgonPointsFitToSquare = function(sides, rotationRadians) {
    var points = $$.math.generateUnitNgonPoints(sides, rotationRadians);
    points = $$.math.fitPolygonToSquare(points);

    return points;
  };

  $$.math.fitPolygonToSquare = function(points){
    var x, y;
    var sides = points.length/2;
    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    for (var i = 0; i < sides; i++) {
      x = points[2 * i];
      y = points[2 * i + 1];

      minX = Math.min( minX, x );
      maxX = Math.max( maxX, x );
      minY = Math.min( minY, y );
      maxY = Math.max( maxY, y );
    }
    
    // stretch factors
    var sx = 2 / (maxX - minX);
    var sy = 2 / (maxY - minY);

    for (var i = 0; i < sides; i++){
      x = points[2 * i] = points[2 * i] * sx;
      y = points[2 * i + 1] = points[2 * i + 1] * sy;

      minX = Math.min( minX, x );
      maxX = Math.max( maxX, x );
      minY = Math.min( minY, y );
      maxY = Math.max( maxY, y );
    }

    if( minY < -1 ){
      for (var i = 0; i < sides; i++){
        y = points[2 * i + 1] = points[2 * i + 1] + (-1 -minY);
      }
    }
    
    return points;
  };

  $$.math.generateUnitNgonPoints = function(sides, rotationRadians) {
    
    var increment = 1.0 / sides * 2 * Math.PI;
    var startAngle = sides % 2 === 0 ? 
      Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
//    console.log(nodeShapes['square']);
    startAngle += rotationRadians;
    
    var points = new Array(sides * 2);

    var currentAngle, x, y;
    for (var i = 0; i < sides; i++) {
      currentAngle = i * increment + startAngle;
      
      x = points[2 * i] = Math.cos(currentAngle);// * (1 + i/2);
      y = points[2 * i + 1] = Math.sin(-currentAngle);//  * (1 + i/2);
    }
    
    return points;
  };

  $$.math.getRoundRectangleRadius = function(width, height) {
    
    // Set the default radius, unless half of width or height is smaller than default
    return Math.min(width / 4, height / 4, 8);
  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  // registered extensions to cytoscape, indexed by name
  var extensions = {};
  $$.extensions = extensions;
  
  // registered modules for extensions, indexed by name
  var modules = {};
  $$.modules = modules;
  
  function setExtension(type, name, registrant){
    var impl = {};
    impl[name] = registrant;
    
    switch( type ){
    case 'core':
    case 'collection':
      $$.fn[type]( impl );
    }
    
    // fill in missing layout functions in the prototype
    if( type === 'layout' ){
      var layoutProto = registrant.prototype;
      var optLayoutFns = [];

      for( var i = 0; i < optLayoutFns.length; i++ ){
        var fnName = optLayoutFns[i];

        layoutProto[fnName] = layoutProto[fnName] || function(){ return this; };
      }

      // either .start() or .run() is defined, so autogen the other
      if( layoutProto.start && !layoutProto.run ){
        layoutProto.run = function(){ this.start(); return this; };
      } else if( !layoutProto.start && layoutProto.run ){
        layoutProto.start = function(){ this.run(); return this; };
      }
      
      if( !layoutProto.stop ){
        layoutProto.stop = function(){
          var opts = this.options;
          
          if( opts && opts.animate ){
            opts.eles.stop();
          }
          
          return this;
        };
      }

      layoutProto.on = $$.define.on({ layout: true });
      layoutProto.one = $$.define.on({ layout: true, unbindSelfOnTrigger: true });
      layoutProto.once = $$.define.on({ layout: true, unbindAllBindersOnTrigger: true });
      layoutProto.off = $$.define.off({ layout: true });
      layoutProto.trigger = $$.define.trigger({ layout: true });

      $$.define.eventAliasesOn( layoutProto );
    }

    return $$.util.setMap({
      map: extensions,
      keys: [ type, name ],
      value: registrant
    });
  }
  
  function getExtension(type, name){
    return $$.util.getMap({
      map: extensions,
      keys: [ type, name ]
    });
  }
  
  function setModule(type, name, moduleType, moduleName, registrant){
    return $$.util.setMap({
      map: modules,
      keys: [ type, name, moduleType, moduleName ],
      value: registrant
    });
  }
  
  function getModule(type, name, moduleType, moduleName){
    return $$.util.getMap({
      map: modules,
      keys: [ type, name, moduleType, moduleName ]
    });
  }
  
  $$.extension = function(){
    // e.g. $$.extension('renderer', 'svg')
    if( arguments.length == 2 ){
      return getExtension.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', { ... })
    else if( arguments.length == 3 ){
      return setExtension.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse')
    else if( arguments.length == 4 ){
      return getModule.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
    else if( arguments.length == 5 ){
      return setModule.apply(this, arguments);
    }
    
    else {
      $$.util.error('Invalid extension access syntax');
    }
  
  };
  
})( cytoscape );

;(function($, $$){ 'use strict';
  
  if( !$ ){ return; } // no jquery => don't need this

  var cyReg = function( $ele ){
    var d = $ele[0]._cyreg = $ele[0]._cyreg || {};

    return d;
  };

  // allow calls on a jQuery selector by proxying calls to $.cytoscape
  // e.g. $("#foo").cytoscape(options) => $.cytoscape(options) on #foo
  $.fn.cytoscape = function(opts){
    var $this = $(this);

    // get object
    if( opts === 'get' ){
      return cyReg( $this ).cy;
    }
    
    // bind to ready
    else if( $$.is.fn(opts) ){

      var ready = opts;
      var cy = cyReg( $this ).cy;
      
      if( cy && cy.isReady() ){ // already ready so just trigger now
        cy.trigger('ready', [], ready);

      } else { // not yet ready, so add to readies list
        var data = cyReg( $this );
        var readies = data.readies = data.readies || [];

        readies.push( ready );
      } 
      
    }
    
    // proxy to create instance
    else if( $$.is.plainObject(opts) ){
      return $this.each(function(){
        var options = $.extend({}, opts, {
          container: $(this)[0]
        });
      
        cytoscape(options);
      });
    }
  };
  
  // allow access to the global cytoscape object under jquery for legacy reasons
  $.cytoscape = cytoscape;
  
  // use short alias (cy) if not already defined
  if( $.fn.cy == null && $.cy == null ){
    $.fn.cy = $.fn.cytoscape;
    $.cy = $.cytoscape;
  }
  
})(typeof jQuery !== 'undefined' ? jQuery : null , cytoscape);

;(function($$){ 'use strict';
  
  // shamelessly taken from jQuery
  // https://github.com/jquery/jquery/blob/master/src/event.js

  $$.Event = function( src, props ) {
    // Allow instantiation without the 'new' keyword
    if ( !(this instanceof $$.Event) ) {
      return new $$.Event( src, props );
    }

    // Event object
    if ( src && src.type ) {
      this.originalEvent = src;
      this.type = src.type;

      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;

    // Event type
    } else {
      this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if ( props ) {
      // $$.util.extend( this, props );

      // more efficient to manually copy fields we use
      this.type = props.type !== undefined ? props.type : this.type;
      this.cy = props.cy;
      this.cyTarget = props.cyTarget;
      this.cyPosition = props.cyPosition;
      this.cyRenderedPosition = props.cyRenderedPosition;
      this.namespace = props.namespace;
      this.layout = props.layout;
      this.data = props.data;
      this.message = props.message;
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || +new Date();
  };

  function returnFalse() {
    return false;
  }
  function returnTrue() {
    return true;
  }

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  $$.Event.prototype = {
    preventDefault: function() {
      this.isDefaultPrevented = returnTrue;

      var e = this.originalEvent;
      if ( !e ) {
        return;
      }

      // if preventDefault exists run it on the original event
      if ( e.preventDefault ) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      this.isPropagationStopped = returnTrue;

      var e = this.originalEvent;
      if ( !e ) {
        return;
      }
      // if stopPropagation exists run it on the original event
      if ( e.stopPropagation ) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    },
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse
  };
  
  
})( cytoscape );

;(function($$){ 'use strict';

  // use this module to cherry pick functions into your prototype
  // (useful for functions shared between the core and collections, for example)

  // e.g.
  // $$.fn.collection({
  //   foo: $$.define.foo({ /* params... */ })
  // });

  $$.define = {

    // access data field
    data: function( params ){
      var defaults = { 
        field: 'data',
        bindingEvent: 'data',
        allowBinding: false,
        allowSetting: false,
        allowGetting: false,
        settingEvent: 'data',
        settingTriggersEvent: false,
        triggerFnName: 'trigger',
        immutableKeys: {}, // key => true if immutable
        updateStyle: false,
        onSet: function( self ){},
        canSet: function( self ){ return true; }
      };
      params = $$.util.extend({}, defaults, params);

      return function dataImpl( name, value ){
        var p = params;
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var single = selfIsArrayLike ? self[0] : self;

        // .data('foo', ...)
        if( $$.is.string(name) ){ // set or get property

          // .data('foo')
          if( p.allowGetting && value === undefined ){ // get

            var ret;
            if( single ){
              ret = single._private[ p.field ][ name ];
            }
            return ret;
          
          // .data('foo', 'bar')
          } else if( p.allowSetting && value !== undefined ) { // set
            var valid = !p.immutableKeys[name];
            if( valid ){
              for( var i = 0, l = all.length; i < l; i++ ){
                if( p.canSet( all[i] ) ){
                  all[i]._private[ p.field ][ name ] = value;
                }
              }

              // update mappers if asked
              if( p.updateStyle ){ self.updateStyle(); }

              // call onSet callback
              p.onSet( self );

              if( p.settingTriggersEvent ){
                self[ p.triggerFnName ]( p.settingEvent );
              }
            }
          }

        // .data({ 'foo': 'bar' })
        } else if( p.allowSetting && $$.is.plainObject(name) ){ // extend
          var obj = name;
          var k, v;

          for( k in obj ){
            v = obj[ k ];

            var valid = !p.immutableKeys[k];
            if( valid ){
              for( var i = 0, l = all.length; i < l; i++ ){
                if( p.canSet( all[i] ) ){
                  all[i]._private[ p.field ][ k ] = v;
                }
              }
            }
          }
          
          // update mappers if asked
          if( p.updateStyle ){ self.updateStyle(); }

          // call onSet callback
          p.onSet( self );

          if( p.settingTriggersEvent ){
            self[ p.triggerFnName ]( p.settingEvent );
          }
        
        // .data(function(){ ... })
        } else if( p.allowBinding && $$.is.fn(name) ){ // bind to event
          var fn = name;
          self.bind( p.bindingEvent, fn );
        
        // .data()
        } else if( p.allowGetting && name === undefined ){ // get whole object
          var ret;
          if( single ){
            ret = single._private[ p.field ];
          }
          return ret;
        }

        return self; // maintain chainability
      }; // function
    }, // data

    // remove data field
    removeData: function( params ){
      var defaults = { 
        field: 'data',
        event: 'data',
        triggerFnName: 'trigger',
        triggerEvent: false,
        immutableKeys: {} // key => true if immutable
      };
      params = $$.util.extend({}, defaults, params);

      return function removeDataImpl( names ){
        var p = params;
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        
        // .removeData('foo bar')
        if( $$.is.string(names) ){ // then get the list of keys, and delete them
          var keys = names.split(/\s+/);
          var l = keys.length;

          for( var i = 0; i < l; i++ ){ // delete each non-empty key
            var key = keys[i];
            if( $$.is.emptyString(key) ){ continue; }

            var valid = !p.immutableKeys[ key ]; // not valid if immutable
            if( valid ){
              for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
                all[ i_a ]._private[ p.field ][ key ] = undefined;
              }
            }
          }

          if( p.triggerEvent ){
            self[ p.triggerFnName ]( p.event );
          }

        // .removeData()
        } else if( names === undefined ){ // then delete all keys

          for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
            var _privateFields = all[ i_a ]._private[ p.field ];
            
            for( var key in _privateFields ){
              var validKeyToDelete = !p.immutableKeys[ key ];

              if( validKeyToDelete ){
                _privateFields[ key ] = undefined;
              }
            }
          }

          if( p.triggerEvent ){
            self[ p.triggerFnName ]( p.event );
          }
        }

        return self; // maintain chaining
      }; // function
    }, // removeData

    // event function reusable stuff
    event: {
      regex: /(\w+)(\.\w+)?/, // regex for matching event strings (e.g. "click.namespace")
      optionalTypeRegex: /(\w+)?(\.\w+)?/,
      falseCallback: function(){ return false; }
    },

    // event binding
    on: function( params ){
      var defaults = {
        unbindSelfOnTrigger: false,
        unbindAllBindersOnTrigger: false
      };
      params = $$.util.extend({}, defaults, params);
      
      return function onImpl(events, selector, data, callback){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);
        var p = params;

        if( $$.is.plainObject(selector) ){ // selector is actually data
          callback = data;
          data = selector;
          selector = undefined;
        } else if( $$.is.fn(selector) || selector === false ){ // selector is actually callback
          callback = selector;
          data = undefined;
          selector = undefined;
        }

        if( $$.is.fn(data) || data === false ){ // data is actually callback
          callback = data;
          data = undefined;
        }

        // if there isn't a callback, we can't really do anything
        // (can't speak for mapped events arg version)
        if( !($$.is.fn(callback) || callback === false) && eventsIsString ){
          return self; // maintain chaining
        }

        if( eventsIsString ){ // then convert to map
          var map = {};
          map[ events ] = callback;
          events = map;
        }

        for( var evts in events ){
          callback = events[evts];
          if( callback === false ){
            callback = $$.define.event.falseCallback;
          }

          if( !$$.is.fn(callback) ){ continue; }

          evts = evts.split(/\s+/);
          for( var i = 0; i < evts.length; i++ ){
            var evt = evts[i];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.regex ); // type[.namespace]

            if( match ){
              var type = match[1];
              var namespace = match[2] ? match[2] : undefined;

              var listener = {
                callback: callback, // callback to run
                data: data, // extra data in eventObj.data
                delegated: selector ? true : false, // whether the evt is delegated
                selector: selector, // the selector to match for delegated events
                selObj: new $$.Selector(selector), // cached selector object to save rebuilding
                type: type, // the event type (e.g. 'click')
                namespace: namespace, // the event namespace (e.g. ".foo")
                unbindSelfOnTrigger: p.unbindSelfOnTrigger,
                unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,
                binders: all // who bound together
              };

              for( var j = 0; j < all.length; j++ ){
                var _p = all[j]._private;

                _p.listeners = _p.listeners || [];
                _p.listeners.push( listener );
              }
            }
          } // for events array
        } // for events map
        
        return self; // maintain chaining
      }; // function
    }, // on

    eventAliasesOn: function( proto ){
      var p = proto;

      p.addListener = p.listen = p.bind = p.on;
      p.removeListener = p.unlisten = p.unbind = p.off;
      p.emit = p.trigger;

      // this is just a wrapper alias of .on()
      p.pon = p.promiseOn = function( events, selector ){
        var self = this;
        var args = Array.prototype.slice.call( arguments, 0 );

        return new $$.Promise(function( resolve, reject ){
          var callback = function( e ){
            self.off.apply( self, offArgs );

            resolve( e );
          };

          var onArgs = args.concat([ callback ]);
          var offArgs = onArgs.concat([]);

          self.on.apply( self, onArgs );
        });
      };
    },

    off: function offImpl( params ){
      var defaults = {
      };
      params = $$.util.extend({}, defaults, params);
      
      return function(events, selector, callback){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);

        if( arguments.length === 0 ){ // then unbind all

          for( var i = 0; i < all.length; i++ ){
            all[i]._private.listeners = [];
          }

          return self; // maintain chaining
        }

        if( $$.is.fn(selector) || selector === false ){ // selector is actually callback
          callback = selector;
          selector = undefined;
        }

        if( eventsIsString ){ // then convert to map
          var map = {};
          map[ events ] = callback;
          events = map;
        }

        for( var evts in events ){
          callback = events[evts];

          if( callback === false ){
            callback = $$.define.event.falseCallback;
          }

          evts = evts.split(/\s+/);
          for( var h = 0; h < evts.length; h++ ){
            var evt = evts[h];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.optionalTypeRegex ); // [type][.namespace]
            if( match ){
              var type = match[1] ? match[1] : undefined;
              var namespace = match[2] ? match[2] : undefined;

              for( var i = 0; i < all.length; i++ ){ //
                var listeners = all[i]._private.listeners = all[i]._private.listeners || [];

                for( var j = 0; j < listeners.length; j++ ){
                  var listener = listeners[j];
                  var nsMatches = !namespace || namespace === listener.namespace;
                  var typeMatches = !type || listener.type === type;
                  var cbMatches = !callback || callback === listener.callback;
                  var listenerMatches = nsMatches && typeMatches && cbMatches;

                  // delete listener if it matches
                  if( listenerMatches ){
                    listeners.splice(j, 1);
                    j--;
                  }
                } // for listeners
              } // for all
            } // if match
          } // for events array

        } // for events map
        
        return self; // maintain chaining
      }; // function
    }, // off

    trigger: function( params ){
      var defaults = {};
      params = $$.util.extend({}, defaults, params);
      
      return function triggerImpl(events, extraParams, fnToTrigger){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);
        var eventsIsObject = $$.is.plainObject(events);
        var eventsIsEvent = $$.is.event(events);
        var cy = this._private.cy || ( $$.is.core(this) ? this : null );
        var hasCompounds = cy ? cy.hasCompoundNodes() : false;

        if( eventsIsString ){ // then make a plain event object for each event name
          var evts = events.split(/\s+/);
          events = [];

          for( var i = 0; i < evts.length; i++ ){
            var evt = evts[i];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.regex ); // type[.namespace]
            var type = match[1];
            var namespace = match[2] ? match[2] : undefined;

            events.push( {
              type: type,
              namespace: namespace
            } );
          }
        } else if( eventsIsObject ){ // put in length 1 array
          var eventArgObj = events;

          events = [ eventArgObj ];
        }

        if( extraParams ){
          if( !$$.is.array(extraParams) ){ // make sure extra params are in an array if specified
            extraParams = [ extraParams ];
          }
        } else { // otherwise, we've got nothing
          extraParams = [];
        }

        for( var i = 0; i < events.length; i++ ){ // trigger each event in order
          var evtObj = events[i];
          
          for( var j = 0; j < all.length; j++ ){ // for each
            var triggerer = all[j];
            var listeners = triggerer._private.listeners = triggerer._private.listeners || [];
            var triggererIsElement = $$.is.element(triggerer);
            var bubbleUp = triggererIsElement || params.layout;

            // create the event for this element from the event object
            var evt;

            if( eventsIsEvent ){ // then just get the object
              evt = evtObj;
              
              evt.cyTarget = evt.cyTarget || triggerer;
              evt.cy = evt.cy || cy;

            } else { // then we have to make one
              evt = new $$.Event( evtObj, {
                cyTarget: triggerer,
                cy: cy,
                namespace: evtObj.namespace
              } );
            }

            // if a layout was specified, then put it in the typed event
            if( evtObj.layout ){
              evt.layout = evtObj.layout;
            }

            // if triggered by layout, put in event
            if( params.layout ){
              evt.layout = triggerer;
            }

            // create a rendered position based on the passed position
            if( evt.cyPosition ){
              var pos = evt.cyPosition;
              var zoom = cy.zoom();
              var pan = cy.pan();

              evt.cyRenderedPosition = {
                x: pos.x * zoom + pan.x,
                y: pos.y * zoom + pan.y
              };
            }

            if( fnToTrigger ){ // then override the listeners list with just the one we specified
              listeners = [{
                namespace: evt.namespace,
                type: evt.type,
                callback: fnToTrigger
              }];
            }

            for( var k = 0; k < listeners.length; k++ ){ // check each listener
              var lis = listeners[k];
              var nsMatches = !lis.namespace || lis.namespace === evt.namespace;
              var typeMatches = lis.type === evt.type;
              var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && $$.is.element(evt.cyTarget) && lis.selObj.matches(evt.cyTarget) ) : (true); // we're not going to validate the hierarchy; that's too expensive
              var listenerMatches = nsMatches && typeMatches && targetMatches;

              if( listenerMatches ){ // then trigger it
                var args = [ evt ];
                args = args.concat( extraParams ); // add extra params to args list

                if( lis.data ){ // add on data plugged into binding
                  evt.data = lis.data;
                } else { // or clear it in case the event obj is reused
                  evt.data = undefined;
                }

                if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener
                  listeners.splice(k, 1);
                  k--;
                }

                if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders
                  var binders = lis.binders;
                  for( var l = 0; l < binders.length; l++ ){
                    var binder = binders[l];
                    if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it

                    var binderListeners = binder._private.listeners;
                    for( var m = 0; m < binderListeners.length; m++ ){
                      var binderListener = binderListeners[m];

                      if( binderListener === lis ){ // delete listener from list
                        binderListeners.splice(m, 1);
                        m--;
                      }
                    }
                  }
                }

                // run the callback
                var context = lis.delegated ? evt.cyTarget : triggerer;
                var ret = lis.callback.apply( context, args );

                if( ret === false || evt.isPropagationStopped() ){
                  // then don't bubble
                  bubbleUp = false;

                  if( ret === false ){
                    // returning false is a shorthand for stopping propagation and preventing the def. action
                    evt.stopPropagation();
                    evt.preventDefault();
                  }
                }
              } // if listener matches
            } // for each listener

            // bubble up event for elements
            if( bubbleUp ){
              var parent = hasCompounds ? triggerer._private.parent : null;
              var hasParent = parent != null && parent.length !== 0;

              if( hasParent ){ // then bubble up to parent
                parent = parent[0];
                parent.trigger(evt);
              } else { // otherwise, bubble up to the core
                cy.trigger(evt);
              }
            }

          } // for each of all
        } // for each event
        
        return self; // maintain chaining
      }; // function
    }, // trigger


    animated: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function animatedImpl(){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return false; }

        var ele = all[0];

        if( ele ){
          return ele._private.animation.current.length > 0;
        }
      };
    }, // animated

    clearQueue: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function clearQueueImpl(){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
          ele._private.animation.queue = [];
        }

        return this;
      };
    }, // clearQueue

    delay: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function delayImpl( time, complete ){
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        this.animate({
          delay: time
        }, {
          duration: time,
          complete: complete
        });

        return this;
      };
    }, // delay

    animate: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function animateImpl( properties, params ){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;
        var isCore = !selfIsArrayLike;
        var isEles = !isCore;

        if( !cy.styleEnabled() ){ return this; }

        var callTime = +new Date();
        var style = cy.style();
        var q;
        
        if( params === undefined ){
          params = {};
        }

        if( params.duration === undefined ){
          params.duration = 400;
        }
        
        switch( params.duration ){
        case 'slow':
          params.duration = 600;
          break;
        case 'fast':
          params.duration = 200;
          break;
        }
        
        var propertiesEmpty = true;
        if( properties ){ for( var i in properties ){
          propertiesEmpty = false;
          break;
        } }

        if( propertiesEmpty ){
          return this; // nothing to animate
        }

        if( properties.css && isEles ){
          properties.css = style.getValueStyle( properties.css, { array: true } );
        }

        if( properties.renderedPosition && isEles ){
          var rpos = properties.renderedPosition;
          var pan = cy.pan();
          var zoom = cy.zoom();

          properties.position = {
            x: ( rpos.x - pan.x ) /zoom,
            y: ( rpos.y - pan.y ) /zoom
          };
        }

        // override pan w/ panBy if set
        if( properties.panBy && isCore ){
          var panBy = properties.panBy;
          var cyPan = cy.pan();

          properties.pan = {
            x: cyPan.x + panBy.x,
            y: cyPan.y + panBy.y
          };
        }

        // override pan w/ center if set
        var center = properties.center || properties.centre;
        if( center && isCore ){
          var centerPan = cy.getCenterPan( center.eles, properties.zoom );

          if( centerPan ){
            properties.pan = centerPan;
          }
        }

        // override pan & zoom w/ fit if set
        if( properties.fit && isCore ){
          var fit = properties.fit;
          var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );

          if( fitVp ){
            properties.pan = fitVp.pan; //{ x: fitVp.pan.x, y: fitVp.pan.y };
            properties.zoom = fitVp.zoom;
          }
        }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
         
          if( ele.animated() && (params.queue === undefined || params.queue) ){
            q = ele._private.animation.queue;
          } else {
            q = ele._private.animation.current;
          }

          q.push({
            properties: properties,
            duration: params.duration,
            params: params,
            callTime: callTime
          });
        }

        if( isEles ){
          cy.addToAnimationPool( this );
        }

        return this; // chaining
      };
    }, // animate

    stop: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function stopImpl( clearQueue, jumpToEnd ){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
          var anis = ele._private.animation.current;

          for( var j = 0; j < anis.length; j++ ){
            var animation = anis[j];    
            if( jumpToEnd ){
              // next iteration of the animation loop, the animation
              // will go straight to the end and be removed
              animation.duration = 0; 
            }
          }
          
          // clear the queue of future animations
          if( clearQueue ){
            ele._private.animation.queue = [];
          }

          if( !jumpToEnd ){
            ele._private.animation.current = [];
          }
        }
        
        // we have to notify (the animation loop doesn't do it for us on `stop`)
        cy.notify({
          collection: this,
          type: 'draw'
        });
        
        return this;
      };
    } // stop

  }; // define

  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.selector = function(map, options){
    for( var name in map ){
      var fn = map[name];
      $$.Selector.prototype[ name ] = fn;
    }
  };

  $$.Selector = function(onlyThisGroup, selector){
    
    if( !(this instanceof $$.Selector) ){
      return new $$.Selector(onlyThisGroup, selector);
    }
  
    if( selector === undefined && onlyThisGroup !== undefined ){
      selector = onlyThisGroup;
      onlyThisGroup = undefined;
    }
    
    var self = this;
    
    self._private = {
      selectorText: null,
      invalid: true
    };
    
    if( !selector || ( $$.is.string(selector) && selector.match(/^\s*$/) ) ){
      
      if( onlyThisGroup == null ){
        // ignore
        self.length = 0;
      } else {
        self[0] = newQuery();
        self[0].group = onlyThisGroup;
        self.length = 1;
      }
              
    } else if( $$.is.element( selector ) ){
      var collection = new $$.Collection(self.cy(), [ selector ]);
      
      self[0] = newQuery();
      self[0].collection = collection;
      self.length = 1;
      
    } else if( $$.is.collection( selector ) ){
      self[0] = newQuery();
      self[0].collection = selector;
      self.length = 1;
      
    } else if( $$.is.fn( selector ) ) {
      self[0] = newQuery();
      self[0].filter = selector;
      self.length = 1;
      
    } else if( $$.is.string( selector ) ){

      // the current subject in the query
      var currentSubject = null;
      
      // storage for parsed queries
      var newQuery = function(){
        return {
          classes: [], 
          colonSelectors: [],
          data: [],
          group: null,
          ids: [],
          meta: [],

          // fake selectors
          collection: null, // a collection to match against
          filter: null, // filter function

          // these are defined in the upward direction rather than down (e.g. child)
          // because we need to go up in Selector.filter()
          parent: null, // parent query obj
          ancestor: null, // ancestor query obj
          subject: null, // defines subject in compound query (subject query obj; points to self if subject)

          // use these only when subject has been defined
          child: null,
          descendant: null
        };
      };

      // tokens in the query language
      var tokens = {
        metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in var names, etc
        comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
        boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
        string: '"(?:\\\\"|[^"])+"' + '|' + "'(?:\\\\'|[^'])+'", // string literals (used in data selectors) -- doublequotes | singlequotes
        number: $$.util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
        meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from $$.Collection)
        separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
        descendant: '\\s+',
        child: '\\s+>\\s+',
        subject: '\\$'
      };
      tokens.variable = '(?:[\\w-]|(?:\\\\'+ tokens.metaChar +'))+'; // a variable name
      tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
      tokens.className = tokens.variable; // a class name (follows variable conventions)
      tokens.id = tokens.variable; // an element id (follows variable conventions)

      // when a token like a variable has escaped meta characters, we need to clean the backslashes out
      // so that values get compared properly in Selector.filter()
      var cleanMetaChars = function(str){
        return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1, offset, original){
          return $1;
        });
      };
      
      // add @ variants to comparatorOp
      var ops = tokens.comparatorOp.split('|');
      for( var i = 0; i < ops.length; i++ ){
        var op = ops[i];
        tokens.comparatorOp += '|@' + op;
      }

      // add ! variants to comparatorOp
      var ops = tokens.comparatorOp.split('|');
      for( var i = 0; i < ops.length; i++ ){
        var op = ops[i];

        if( op.indexOf('!') >= 0 ){ continue; } // skip ops that explicitly contain !
        if( op === '=' ){ continue; } // skip = b/c != is explicitly defined

        tokens.comparatorOp += '|\\!' + op;
      }

      // NOTE: add new expression syntax here to have it recognised by the parser;
      // - a query contains all adjacent (i.e. no separator in between) expressions;
      // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
      // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
      // - when you add something here, also add to Selector.toString()
      var exprs = {
        group: {
          query: true,
          regex: '(node|edge|\\*)',
          populate: function( group ){
            this.group = group == "*" ? group : group + 's';
          }
        },
        
        state: {
          query: true,
          // NB: if one colon selector is a substring of another from its start, place the longer one first
          // e.g. :foobar|:foo
          regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch|:backgrounding|:nonbackgrounding)',
          populate: function( state ){
            this.colonSelectors.push( state );
          }
        },
        
        id: {
          query: true,
          regex: '\\#('+ tokens.id +')',
          populate: function( id ){
            this.ids.push( cleanMetaChars(id) );
          }
        },
        
        className: {
          query: true,
          regex: '\\.('+ tokens.className +')',
          populate: function( className ){
            this.classes.push( cleanMetaChars(className) );
          }
        },
        
        dataExists: {
          query: true,
          regex: '\\[\\s*('+ tokens.variable +')\\s*\\]',
          populate: function( variable ){
            this.data.push({
              field: cleanMetaChars(variable)
            });
          }
        },
        
        dataCompare: {
          query: true,
          regex: '\\[\\s*('+ tokens.variable +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.value +')\\s*\\]',
          populate: function( variable, comparatorOp, value ){ 
            var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

            if( valueIsString ){
              value = value.substring(1, value.length - 1);
            } else {
              value = parseFloat(value);
            }

            this.data.push({
              field: cleanMetaChars(variable),
              operator: comparatorOp,
              value: value
            });
          }
        },
        
        dataBool: {
          query: true,
          regex: '\\[\\s*('+ tokens.boolOp +')\\s*('+ tokens.variable +')\\s*\\]',
          populate: function( boolOp, variable ){
            this.data.push({
              field: cleanMetaChars(variable),
              operator: boolOp
            });
          }
        },
        
        metaCompare: {
          query: true,
          regex: '\\[\\[\\s*('+ tokens.meta +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.number +')\\s*\\]\\]',
          populate: function( meta, comparatorOp, number ){
            this.meta.push({
              field: cleanMetaChars(meta),
              operator: comparatorOp,
              value: parseFloat(number)
            });
          }
        },

        nextQuery: {
          separator: true,
          regex: tokens.separator,
          populate: function(){
            // go on to next query
            self[++i] = newQuery();
            currentSubject = null;
          }
        },

        child: {
          separator: true,
          regex: tokens.child,
          populate: function(){
            // this query is the parent of the following query
            var childQuery = newQuery();
            childQuery.parent = this;
            childQuery.subject = currentSubject;

            // we're now populating the child query with expressions that follow
            self[i] = childQuery;
          }
        },

        descendant: {
          separator: true,
          regex: tokens.descendant,
          populate: function(){
            // this query is the ancestor of the following query
            var descendantQuery = newQuery();
            descendantQuery.ancestor = this;
            descendantQuery.subject = currentSubject;

            // we're now populating the descendant query with expressions that follow
            self[i] = descendantQuery;
          }
        },

        subject: {
          modifier: true,
          regex: tokens.subject,
          populate: function(){
            if( currentSubject != null && this.subject != this ){
              $$.util.error('Redefinition of subject in selector `' + selector + '`');
              return false;
            }

            currentSubject = this;
            this.subject = this;
          }

        }
      };

      var j = 0;
      for( var name in exprs ){
        exprs[j] = exprs[name];
        exprs[j].name = name;

        j++;
      }
      exprs.length = j;

      self._private.selectorText = selector;
      var remaining = selector;
      var i = 0;
      
      // of all the expressions, find the first match in the remaining text
      var consumeExpr = function( expectation ){
        var expr;
        var match;
        var name;
        
        for( var j = 0; j < exprs.length; j++ ){
          var e = exprs[j];
          var n = e.name;

          // ignore this expression if it doesn't meet the expectation function
          if( $$.is.fn( expectation ) && !expectation(n, e) ){ continue; }

          var m = remaining.match(new RegExp( '^' + e.regex ));
          
          if( m != null ){
            match = m;
            expr = e;
            name = n;
            
            var consumed = m[0];
            remaining = remaining.substring( consumed.length );                
            
            break; // we've consumed one expr, so we can return now
          }
        }
        
        return {
          expr: expr,
          match: match,
          name: name
        };
      };
      
      // consume all leading whitespace
      var consumeWhitespace = function(){
        var match = remaining.match(/^\s+/);
        
        if( match ){
          var consumed = match[0];
          remaining = remaining.substring( consumed.length );
        }
      };
      
      self[0] = newQuery(); // get started

      consumeWhitespace(); // get rid of leading whitespace
      for(;;){        
        var check = consumeExpr();
        
        if( check.expr == null ){
          $$.util.error('The selector `'+ selector +'`is invalid');
          return;
        } else {
          var args = [];
          for(var j = 1; j < check.match.length; j++){
            args.push( check.match[j] );
          }
          
          // let the token populate the selector object (i.e. in self[i])
          var ret = check.expr.populate.apply( self[i], args );

          if( ret === false ){ return; } // exit if population failed
        }
        
        // we're done when there's nothing left to parse
        if( remaining.match(/^\s*$/) ){
          break;
        }
      }
      
      self.length = i + 1;

      // adjust references for subject
      for(j = 0; j < self.length; j++){
        var query = self[j];

        if( query.subject != null ){
          // go up the tree until we reach the subject
          for(;;){
            if( query.subject == query ){ break; } // done if subject is self

            if( query.parent != null ){ // swap parent/child reference
              var parent = query.parent;
              var child = query;

              child.parent = null;
              parent.child = child;

              query = parent; // go up the tree
            } else if( query.ancestor != null ){ // swap ancestor/descendant
              var ancestor = query.ancestor;
              var descendant = query;

              descendant.ancestor = null;
              ancestor.descendant = descendant;

              query = ancestor; // go up the tree
            } else {
              $$.util.error('When adjusting references for the selector `'+ query +'`, neither parent nor ancestor was found');
              break;
            }
          } // for

          self[j] = query.subject; // subject should be the root query
        } // if
      } // for

      // make sure for each query that the subject group matches the implicit group if any
      if( onlyThisGroup != null ){
        for(var j = 0; j < self.length; j++){
          if( self[j].group != null && self[j].group != onlyThisGroup ){
            $$.util.error('Group `'+ self[j].group +'` conflicts with implicit group `'+ onlyThisGroup +'` in selector `'+ selector +'`');
            return;
          }

          self[j].group = onlyThisGroup; // set to implicit group
        }
      }
      
    } else {
      $$.util.error('A selector must be created from a string; found ' + selector);
      return;
    }

    self._private.invalid = false;
    
  };

  $$.selfn = $$.Selector.prototype;
  
  $$.selfn.size = function(){
    return this.length;
  };
  
  $$.selfn.eq = function(i){
    return this[i];
  };
  
  // get elements from the core and then filter them
  $$.selfn.find = function(){
    // TODO impl if we decide to use a DB for storing elements
  };
  
  var queryMatches = function(query, element){
    // check group
    if( query.group != null && query.group != '*' && query.group != element._private.group ){
      return false;
    }

    var cy = element.cy();
    
    // check colon selectors
    var allColonSelectorsMatch = true;
    for(var k = 0; k < query.colonSelectors.length; k++){
      var sel = query.colonSelectors[k];
      
      switch(sel){
      case ':selected':
        allColonSelectorsMatch = element.selected();
        break;
      case ':unselected':
        allColonSelectorsMatch = !element.selected();
        break;
      case ':selectable':
        allColonSelectorsMatch = element.selectable();
        break;
      case ':unselectable':
        allColonSelectorsMatch = !element.selectable();
        break;
      case ':locked':
        allColonSelectorsMatch = element.locked();
        break;
      case ':unlocked':
        allColonSelectorsMatch = !element.locked();
        break;
      case ':visible':
        allColonSelectorsMatch = element.visible();
        break;
      case ':hidden':
        allColonSelectorsMatch = !element.visible();
        break;
      case ':transparent':
        allColonSelectorsMatch = element.transparent();
        break;
      case ':grabbed':
        allColonSelectorsMatch = element.grabbed();
        break;
      case ':free':
        allColonSelectorsMatch = !element.grabbed();
        break;
      case ':removed':
        allColonSelectorsMatch = element.removed();
        break;
      case ':inside':
        allColonSelectorsMatch = !element.removed();
        break;
      case ':grabbable':
        allColonSelectorsMatch = element.grabbable();
        break;
      case ':ungrabbable':
        allColonSelectorsMatch = !element.grabbable();
        break;
      case ':animated':
        allColonSelectorsMatch = element.animated();
        break;
      case ':unanimated':
        allColonSelectorsMatch = !element.animated();
        break;
      case ':parent':
        allColonSelectorsMatch = element.isNode() && element.children().nonempty();
        break;
      case ':child':
      case ':nonorphan':
        allColonSelectorsMatch = element.isNode() && element.parent().nonempty();
        break;
      case ':orphan':
        allColonSelectorsMatch = element.isNode() && element.parent().empty();
        break;
      case ':loop':
        allColonSelectorsMatch = element.isEdge() && element.data('source') === element.data('target');
        break;
      case ':simple':
        allColonSelectorsMatch = element.isEdge() && element.data('source') !== element.data('target');
        break;
      case ':active':
        allColonSelectorsMatch = element.active();
        break;
      case ':inactive':
        allColonSelectorsMatch = !element.active();
        break;
      case ':touch':
        allColonSelectorsMatch = $$.is.touch();
        break;
      case ':backgrounding':
        allColonSelectorsMatch = element.backgrounding();
        break;
      case ':nonbackgrounding':
        allColonSelectorsMatch = !element.backgrounding();
        break;
      }
      
      if( !allColonSelectorsMatch ) break;
    }
    if( !allColonSelectorsMatch ) return false;
    
    // check id
    var allIdsMatch = true;
    for(var k = 0; k < query.ids.length; k++){
      var id = query.ids[k];
      var actualId = element._private.data.id;
      
      allIdsMatch = allIdsMatch && (id == actualId);
      
      if( !allIdsMatch ) break;
    }
    if( !allIdsMatch ) return false;
    
    // check classes
    var allClassesMatch = true;
    for(var k = 0; k < query.classes.length; k++){
      var cls = query.classes[k];
      
      allClassesMatch = allClassesMatch && element.hasClass(cls);
      
      if( !allClassesMatch ) break;
    }
    if( !allClassesMatch ) return false;
    
    // generic checking for data/metadata
    var operandsMatch = function(params){
      var allDataMatches = true;
      for(var k = 0; k < query[params.name].length; k++){
        var data = query[params.name][k];
        var operator = data.operator;
        var value = data.value;
        var field = data.field;
        var matches;
        
        if( operator != null && value != null ){
          
          var fieldVal = params.fieldValue(field);
          var fieldStr = !$$.is.string(fieldVal) && !$$.is.number(fieldVal) ? '' : '' + fieldVal;
          var valStr = '' + value;
          
          var caseInsensitive = false;
          if( operator.indexOf('@') >= 0 ){
            fieldStr = fieldStr.toLowerCase();
            valStr = valStr.toLowerCase();
            
            operator = operator.replace('@', '');
            caseInsensitive = true;
          }

          var notExpr = false;
          var handledNotExpr = false;
          if( operator.indexOf('!') >= 0 ){
            operator = operator.replace('!', '');
            notExpr = true;
          }
          
          // if we're doing a case insensitive comparison, then we're using a STRING comparison
          // even if we're comparing numbers
          if( caseInsensitive ){
            value = valStr.toLowerCase();
            fieldVal = fieldStr.toLowerCase();
          }

          switch(operator){
          case '*=':
            matches = fieldStr.search(valStr) >= 0;
            break;
          case '$=':
            matches = new RegExp(valStr + '$').exec(fieldStr) != null;
            break;
          case '^=':
            matches = new RegExp('^' + valStr).exec(fieldStr) != null;
            break;
          case '=':
            matches = fieldVal === value;
            break;
          case '!=':
            matches = fieldVal !== value;
            break;
          case '>':
            matches = !notExpr ? fieldVal > value : fieldVal <= value;
            handledNotExpr = true;
            break;
          case '>=':
            matches = !notExpr ? fieldVal >= value : fieldVal < value;
            handledNotExpr = true;
            break;
          case '<':
            matches = !notExpr ? fieldVal < value : fieldVal >= value;
            handledNotExpr = true;
            break;
          case '<=':
            matches = !notExpr ? fieldVal <= value : fieldVal > value;
            handledNotExpr = true;
            break;
          default:
            matches = false;
            break;
            
          }
        } else if( operator != null ){
          switch(operator){
          case '?':
            matches = params.fieldTruthy(field);
            break;
          case '!':
            matches = !params.fieldTruthy(field);
            break;
          case '^':
            matches = params.fieldUndefined(field);
            break;
          }
        } else {   
          matches = !params.fieldUndefined(field);
        }

        if( notExpr && !handledNotExpr ){
          matches = !matches;
          handledNotExpr = true;
        }
        
        if( !matches ){
          allDataMatches = false;
          break;
        }
      } // for
      
      return allDataMatches;
    }; // operandsMatch
    
    // check data matches
    var allDataMatches = operandsMatch({
      name: 'data',
      fieldValue: function(field){
        return element._private.data[field];
      },
      fieldRef: function(field){
        return 'element._private.data.' + field;
      },
      fieldUndefined: function(field){
        return element._private.data[field] === undefined;
      },
      fieldTruthy: function(field){
        if( element._private.data[field] ){
          return true;
        }
        return false;
      }
    });
    
    if( !allDataMatches ){
      return false;
    }
    
    // check metadata matches
    var allMetaMatches = operandsMatch({
      name: 'meta',
      fieldValue: function(field){
        return element[field]();
      },
      fieldRef: function(field){
        return 'element.' + field + '()';
      },
      fieldUndefined: function(field){
        return element[field]() == null;
      },
      fieldTruthy: function(field){
        if( element[field]() ){
          return true;
        }
        return false;
      }
    });
    
    if( !allMetaMatches ){
      return false;
    }
    
    // check collection
    if( query.collection != null ){
      var matchesAny = query.collection._private.ids[ element.id() ] != null;
      
      if( !matchesAny ){
        return false;
      }
    }
    
    // check filter function
    if( query.filter != null && element.collection().filter( query.filter ).size() === 0 ){
      return false;
    }
    

    // check parent/child relations
    var confirmRelations = function( query, elements ){
      if( query != null ){
        var matches = false;

        if( !cy.hasCompoundNodes() ){
          return false;
        }

        elements = elements(); // make elements functional so we save cycles if query == null

        // query must match for at least one element (may be recursive)
        for(var i = 0; i < elements.length; i++){
          if( queryMatches( query, elements[i] ) ){
            matches = true;
            break;
          }
        }

        return matches;
      } else {
        return true;
      }
    };

    if (! confirmRelations(query.parent, function(){
      return element.parent();
    }) ){ return false; }

    if (! confirmRelations(query.ancestor, function(){
      return element.parents();
    }) ){ return false; }

    if (! confirmRelations(query.child, function(){
      return element.children();
    }) ){ return false; }

    if (! confirmRelations(query.descendant, function(){
      return element.descendants();
    }) ){ return false; }

    // we've reached the end, so we've matched everything for this query
    return true;
  }; // queryMatches

  // filter an existing collection
  $$.selfn.filter = function(collection){
    var self = this;
    var cy = collection.cy();
    
    // don't bother trying if it's invalid
    if( self._private.invalid ){
      return new $$.Collection( cy );
    }
  
    var selectorFunction = function(i, element){
      for(var j = 0; j < self.length; j++){
        var query = self[j];
        
        if( queryMatches(query, element) ){
          return true;
        }
      }
      
      return false;
    };
    
    if( self._private.selectorText == null ){
      selectorFunction = function(){ return true; };
    }
    
    var filteredCollection = collection.filter( selectorFunction );
    
    return filteredCollection;
  }; // filter

  // does selector match a single element?
  $$.selfn.matches = function(ele){
    var self = this;
    
    // don't bother trying if it's invalid
    if( self._private.invalid ){
      return false;
    }
  
    for(var j = 0; j < self.length; j++){
      var query = self[j];
      
      if( queryMatches(query, ele) ){
        return true;
      }
    }
    
    return false;
  }; // filter
  
  // ith query to string
  $$.selfn.toString = $$.selfn.selector = function(){
    
    var str = '';
    
    var clean = function(obj, isValue){
      if( $$.is.string(obj) ){
        return isValue ? '"' + obj + '"' : obj;
      } 
      return '';
    };
    
    var queryToString = function(query){
      var str = '';

      if( query.subject === query ){
        str += '$';
      }

      var group = clean(query.group);
      str += group.substring(0, group.length - 1);
      
      for(var j = 0; j < query.data.length; j++){
        var data = query.data[j];
        
        if( data.value ){
          str += '[' + data.field + clean(data.operator) + clean(data.value, true) + ']';
        } else {
          str += '[' + clean(data.operator) + data.field + ']';
        }
      }

      for(var j = 0; j < query.meta.length; j++){
        var meta = query.meta[j];
        str += '[[' + meta.field + clean(meta.operator) + clean(meta.value, true) + ']]';
      }
      
      for(var j = 0; j < query.colonSelectors.length; j++){
        var sel = query.colonSelectors[i];
        str += sel;
      }
      
      for(var j = 0; j < query.ids.length; j++){
        var sel = '#' + query.ids[i];
        str += sel;
      }
      
      for(var j = 0; j < query.classes.length; j++){
        var sel = '.' + query.classes[i];
        str += sel;
      }

      if( query.parent != null ){
        str = queryToString( query.parent ) + ' > ' + str; 
      }

      if( query.ancestor != null ){
        str = queryToString( query.ancestor ) + ' ' + str; 
      }

      if( query.child != null ){
        str += ' > ' + queryToString( query.child ); 
      }

      if( query.descendant != null ){
        str += ' ' + queryToString( query.descendant ); 
      }

      return str;
    };

    for(var i = 0; i < this.length; i++){
      var query = this[i];
      
      str += queryToString( query );
      
      if( this.length > 1 && i < this.length - 1 ){
        str += ', ';
      }
    }
    
    return str;
  };
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.Style = function( cy ){

    if( !(this instanceof $$.Style) ){
      return new $$.Style(cy);
    }

    if( !$$.is.core(cy) ){
      $$.util.error('A style must have a core reference');
      return;
    }

    this._private = {
      cy: cy,
      coreStyle: {},
      newStyle: true
    };

    this.length = 0;

    this.addDefaultStylesheet();
  };

  // nice-to-have aliases
  $$.style = $$.Style;
  $$.styfn = $$.Style.prototype;

  // define functions in the Style prototype
  $$.fn.style = function( fnMap, options ){
    for( var fnName in fnMap ){
      var fn = fnMap[ fnName ];
      $$.Style.prototype = fn;
    }
  };

  (function(){
    var number = $$.util.regex.number;
    var rgba = $$.util.regex.rgbaNoBackRefs;
    var hsla = $$.util.regex.hslaNoBackRefs;
    var hex3 = $$.util.regex.hex3;
    var hex6 = $$.util.regex.hex6;
    var data = function( prefix ){ return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$'; };
    var mapData = function( prefix ){ return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\s*\\,\\s*(' + number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\)$'; };

    // each visual style property has a type and needs to be validated according to it
    $$.style.types = {
      time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
      percent: { number: true, min: 0, max: 100, units: '%' },
      zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
      nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
      nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
      position: { enums: ['parent', 'origin'] },
      autoSize: { number: true, min: 0, enums: ['auto'] },
      number: { number: true },
      size: { number: true, min: 0 },
      bgSize: { number: true, min: 0, allowPercent: true },
      bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'] },
      bgPos: { number: true, allowPercent: true },
      bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'] },
      bgFit: { enums: ['none', 'contain', 'cover'] },
      bgClip: { enums: ['none', 'node'] },
      color: { color: true },
      lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
      borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
      curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack'] },
      fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
      fontVariant: { enums: ['small-caps', 'normal'] },
      fontStyle: { enums: ['italic', 'normal', 'oblique'] },
      fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
      textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
      textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
      textWrap: { enums: ['none', 'wrap'] },
      textBackgroundShape: { enums: ['rectangle', 'roundrectangle']},
      nodeShape: { enums: ['rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star', 'diamond', 'vee', 'rhomboid'] },
      compoundIncludeLabels: { enums: ['include', 'exclude'] },
      arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'square', 'circle', 'diamond', 'none'] },
      arrowFill: { enums: ['filled', 'hollow'] },
      display: { enums: ['element', 'none'] },
      visibility: { enums: ['hidden', 'visible'] },
      valign: { enums: ['top', 'center', 'bottom'] },
      halign: { enums: ['left', 'center', 'right'] },
      text: { string: true },
      data: { mapping: true, regex: data('data') },
      layoutData: { mapping: true, regex: data('layoutData') },
      scratch: { mapping: true, regex: data('scratch') },
      mapData: { mapping: true, regex: mapData('mapData') },
      mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
      mapScratch: { mapping: true, regex: mapData('mapScratch') },
      fn: { mapping: true, fn: true },
      url: { regex: '^url\\s*\\(\\s*([^\\s]+)\\s*\\s*\\)|none|(.+)$' },
      propList: { propList: true },
      angle: { number: true, units: 'deg|rad' },
      textRotation: { enums: ['none', 'autorotate'] }
    };

    // define visual style properties
    var t = $$.style.types;
    var props = $$.style.properties = [
      // labels
      { name: 'text-valign', type: t.valign },
      { name: 'text-halign', type: t.halign },
      { name: 'color', type: t.color },
      { name: 'content', type: t.text },
      { name: 'text-outline-color', type: t.color },
      { name: 'text-outline-width', type: t.size },
      { name: 'text-outline-opacity', type: t.zeroOneNumber },
      { name: 'text-opacity', type: t.zeroOneNumber },
      { name: 'text-background-color', type: t.color },
      { name: 'text-background-opacity', type: t.zeroOneNumber },
      { name: 'text-border-opacity', type: t.zeroOneNumber },
      { name: 'text-border-color', type: t.color },
      { name: 'text-border-width', type: t.size },
      { name: 'text-border-style', type: t.borderStyle },
      { name: 'text-background-shape', type: t.textBackgroundShape},
      // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
      { name: 'text-transform', type: t.textTransform },
      { name: 'text-wrap', type: t.textWrap },
      { name: 'text-max-width', type: t.size },

      // { name: 'text-rotation', type: t.angle }, // TODO disabled b/c rotation breaks bounding boxes
      { name: 'font-family', type: t.fontFamily },
      { name: 'font-style', type: t.fontStyle },
      // { name: 'font-variant', type: t.fontVariant }, // not useful
      { name: 'font-weight', type: t.fontWeight },
      { name: 'font-size', type: t.size },
      { name: 'min-zoomed-font-size', type: t.size },
      { name: 'edge-text-rotation', type: t.textRotation },

      // visibility
      { name: 'display', type: t.display },
      { name: 'visibility', type: t.visibility },
      { name: 'opacity', type: t.zeroOneNumber },
      { name: 'z-index', type: t.nonNegativeInt },

      // overlays
      { name: 'overlay-padding', type: t.size },
      { name: 'overlay-color', type: t.color },
      { name: 'overlay-opacity', type: t.zeroOneNumber },

      // shadows
      { name: 'shadow-blur', type: t.size },
      { name: 'shadow-color', type: t.color },
      { name: 'shadow-opacity', type: t.zeroOneNumber },
      { name: 'shadow-offset-x', type: t.number },
      { name: 'shadow-offset-y', type: t.number },

      // label shadows
      { name: 'text-shadow-blur', type: t.size },
      { name: 'text-shadow-color', type: t.color },
      { name: 'text-shadow-opacity', type: t.zeroOneNumber },
      { name: 'text-shadow-offset-x', type: t.number },
      { name: 'text-shadow-offset-y', type: t.number },

      // transition anis
      { name: 'transition-property', type: t.propList },
      { name: 'transition-duration', type: t.time },
      { name: 'transition-delay', type: t.time },

      // node body
      { name: 'height', type: t.autoSize },
      { name: 'width', type: t.autoSize },
      { name: 'shape', type: t.nodeShape },
      { name: 'background-color', type: t.color },
      { name: 'background-opacity', type: t.zeroOneNumber },
      { name: 'background-blacken', type: t.nOneOneNumber },

      // node border
      { name: 'border-color', type: t.color },
      { name: 'border-opacity', type: t.zeroOneNumber },
      { name: 'border-width', type: t.size },
      { name: 'border-style', type: t.borderStyle },

      // node background images
      { name: 'background-image', type: t.url },
      { name: 'background-image-opacity', type: t.zeroOneNumber },
      { name: 'background-position-x', type: t.bgPos },
      { name: 'background-position-y', type: t.bgPos },
      { name: 'background-repeat', type: t.bgRepeat },
      { name: 'background-fit', type: t.bgFit },
      { name: 'background-clip', type: t.bgClip },
      { name: 'background-width', type: t.bgWH },
      { name: 'background-height', type: t.bgWH },

      // compound props
      { name: 'padding-left', type: t.size },
      { name: 'padding-right', type: t.size },
      { name: 'padding-top', type: t.size },
      { name: 'padding-bottom', type: t.size },
      { name: 'position', type: t.position },
      { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels },

      // edge line
      { name: 'line-style', type: t.lineStyle },
      { name: 'line-color', type: t.color },
      { name: 'control-point-step-size', type: t.size },
      { name: 'control-point-distance', type: t.number },
      { name: 'control-point-weight', type: t.zeroOneNumber },
      { name: 'curve-style', type: t.curveStyle },
      { name: 'haystack-radius', type: t.zeroOneNumber },

      // edge arrows
      { name: 'source-arrow-shape', type: t.arrowShape },
      { name: 'target-arrow-shape', type: t.arrowShape },
      { name: 'mid-source-arrow-shape', type: t.arrowShape },
      { name: 'mid-target-arrow-shape', type: t.arrowShape },
      { name: 'source-arrow-color', type: t.color },
      { name: 'target-arrow-color', type: t.color },
      { name: 'mid-source-arrow-color', type: t.color },
      { name: 'mid-target-arrow-color', type: t.color },
      { name: 'source-arrow-fill', type: t.arrowFill },
      { name: 'target-arrow-fill', type: t.arrowFill },
      { name: 'mid-source-arrow-fill', type: t.arrowFill },
      { name: 'mid-target-arrow-fill', type: t.arrowFill },

      // these are just for the core
      { name: 'selection-box-color', type: t.color },
      { name: 'selection-box-opacity', type: t.zeroOneNumber },
      { name: 'selection-box-border-color', type: t.color },
      { name: 'selection-box-border-width', type: t.size },
      { name: 'active-bg-color', type: t.color },
      { name: 'active-bg-opacity', type: t.zeroOneNumber },
      { name: 'active-bg-size', type: t.size },
      { name: 'outside-texture-bg-color', type: t.color },
      { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }
    ];

    // pie backgrounds for nodes
    $$.style.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
    props.push({ name: 'pie-size', type: t.bgSize });
    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){
      props.push({ name: 'pie-'+i+'-background-color', type: t.color });
      props.push({ name: 'pie-'+i+'-background-size', type: t.percent });
      props.push({ name: 'pie-'+i+'-background-opacity', type: t.zeroOneNumber });
    }

    // allow access of properties by name ( e.g. $$.style.properties.height )
    for( var i = 0; i < props.length; i++ ){
      var prop = props[i];

      props[ prop.name ] = prop; // allow lookup by name
    }
  })();

  // adds the default stylesheet to the current style
  $$.styfn.addDefaultStylesheet = function(){
    // to be nice, we build font related style properties from the core container
    // so that cytoscape matches the style of its container by default
    //
    // unfortunately, this doesn't seem work consistently and can grab the default stylesheet values
    // instead of the developer's values so let's just make it explicit for the dev for now
    //
    // delaying the read of these val's is not an opt'n: that would delay init'l load time
    var fontFamily = 'Helvetica' || this.containerPropertyAsString('font-family') || 'sans-serif';
    var fontStyle = 'normal' || this.containerPropertyAsString('font-style') || 'normal';
    // var fontVariant = 'normal' || this.containerPropertyAsString('font-variant') || 'normal';
    var fontWeight = 'normal' || this.containerPropertyAsString('font-weight') || 'normal';
    var color = '#000' || this.containerPropertyAsString('color') || '#000';
    var textTransform = 'none' || this.containerPropertyAsString('text-transform') || 'none';
    var fontSize = 16 || this.containerPropertyAsString('font-size') || 16;
    var textMaxWidth = 9999 || this.containerPropertyAsString('text-max-width') || 9999;

    // fill the style with the default stylesheet
    this
      .selector('node, edge') // common properties
        .css({
          'text-valign': 'top',
          'text-halign': 'center',
          'color': color,
          'text-outline-color': '#000',
          'text-outline-width': 0,
          'text-outline-opacity': 1,
          'text-opacity': 1,
          'text-decoration': 'none',
          'text-transform': textTransform,
          'text-wrap': 'none',
          'text-max-width': textMaxWidth,
          'text-background-color': '#000',
          'text-background-opacity': 0,
          'text-border-opacity': 0,
          'text-border-width': 0,
          'text-border-style': 'solid',
          'text-border-color':'#000',
          'text-background-shape':'rectangle',
          'font-family': fontFamily,
          'font-style': fontStyle,
          // 'font-variant': fontVariant,
          'font-weight': fontWeight,
          'font-size': fontSize,
          'min-zoomed-font-size': 0,
          'edge-text-rotation': 'none',
          'visibility': 'visible',
          'display': 'element',
          'opacity': 1,
          'z-index': 0,
          'content': '',
          'overlay-opacity': 0,
          'overlay-color': '#000',
          'overlay-padding': 10,
          'shadow-opacity': 0,
          'shadow-color': '#000',
          'shadow-blur': 10,
          'shadow-offset-x': 0,
          'shadow-offset-y': 0,
          'text-shadow-opacity': 0,
          'text-shadow-color': '#000',
          'text-shadow-blur': 5,
          'text-shadow-offset-x': 0,
          'text-shadow-offset-y': 0,
          'transition-property': 'none',
          'transition-duration': 0,
          'transition-delay': 0,

          // node props
          'background-blacken': 0,
          'background-color': '#888',
          'background-opacity': 1,
          'background-image': 'none',
          'background-image-opacity': 1,
          'background-position-x': '50%',
          'background-position-y': '50%',
          'background-repeat': 'no-repeat',
          'background-fit': 'none',
          'background-clip': 'node',
          'background-width': 'auto',
          'background-height': 'auto',
          'border-color': '#000',
          'border-opacity': 1,
          'border-width': 0,
          'border-style': 'solid',
          'height': 30,
          'width': 30,
          'shape': 'ellipse',

          // compound props
          'padding-top': 0,
          'padding-bottom': 0,
          'padding-left': 0,
          'padding-right': 0,
          'position': 'origin',
          'compound-sizing-wrt-labels': 'include',


          // node pie bg
          'pie-size': '100%',
          'pie-1-background-color': 'black',
          'pie-2-background-color': 'black',
          'pie-3-background-color': 'black',
          'pie-4-background-color': 'black',
          'pie-5-background-color': 'black',
          'pie-6-background-color': 'black',
          'pie-7-background-color': 'black',
          'pie-8-background-color': 'black',
          'pie-9-background-color': 'black',
          'pie-10-background-color': 'black',
          'pie-11-background-color': 'black',
          'pie-12-background-color': 'black',
          'pie-13-background-color': 'black',
          'pie-14-background-color': 'black',
          'pie-15-background-color': 'black',
          'pie-16-background-color': 'black',
          'pie-1-background-size': '0%',
          'pie-2-background-size': '0%',
          'pie-3-background-size': '0%',
          'pie-4-background-size': '0%',
          'pie-5-background-size': '0%',
          'pie-6-background-size': '0%',
          'pie-7-background-size': '0%',
          'pie-8-background-size': '0%',
          'pie-9-background-size': '0%',
          'pie-10-background-size': '0%',
          'pie-11-background-size': '0%',
          'pie-12-background-size': '0%',
          'pie-13-background-size': '0%',
          'pie-14-background-size': '0%',
          'pie-15-background-size': '0%',
          'pie-16-background-size': '0%',
          'pie-1-background-opacity': 1,
          'pie-2-background-opacity': 1,
          'pie-3-background-opacity': 1,
          'pie-4-background-opacity': 1,
          'pie-5-background-opacity': 1,
          'pie-6-background-opacity': 1,
          'pie-7-background-opacity': 1,
          'pie-8-background-opacity': 1,
          'pie-9-background-opacity': 1,
          'pie-10-background-opacity': 1,
          'pie-11-background-opacity': 1,
          'pie-12-background-opacity': 1,
          'pie-13-background-opacity': 1,
          'pie-14-background-opacity': 1,
          'pie-15-background-opacity': 1,
          'pie-16-background-opacity': 1,

          // edge props
          'source-arrow-shape': 'none',
          'mid-source-arrow-shape': 'none',
          'target-arrow-shape': 'none',
          'mid-target-arrow-shape': 'none',
          'source-arrow-color': '#ddd',
          'mid-source-arrow-color': '#ddd',
          'target-arrow-color': '#ddd',
          'mid-target-arrow-color': '#ddd',
          'source-arrow-fill': 'filled',
          'mid-source-arrow-fill': 'filled',
          'target-arrow-fill': 'filled',
          'mid-target-arrow-fill': 'filled',
          'line-style': 'solid',
          'line-color': '#ddd',
          'control-point-step-size': 40,
          'control-point-weight': 0.5,
          'curve-style': 'bezier',
          'haystack-radius': 0.8
        })
      .selector('$node > node') // compound (parent) node properties
        .css({
          'width': 'auto',
          'height': 'auto',
          'shape': 'rectangle',
          'background-opacity': 0.5,
          'padding-top': 10,
          'padding-right': 10,
          'padding-left': 10,
          'padding-bottom': 10
        })
      .selector('edge') // just edge properties
        .css({
          'width': 1
        })
      .selector(':active')
        .css({
          'overlay-color': 'black',
          'overlay-padding': 10,
          'overlay-opacity': 0.25
        })
      .selector('core') // just core properties
        .css({
          'selection-box-color': '#ddd',
          'selection-box-opacity': 0.65,
          'selection-box-border-color': '#aaa',
          'selection-box-border-width': 1,
          'active-bg-color': 'black',
          'active-bg-opacity': 0.15,
          'active-bg-size': 30,
          'outside-texture-bg-color': '#000',
          'outside-texture-bg-opacity': 0.125
        })
    ;

    this.defaultLength = this.length;
  };

  // remove all contexts
  $$.styfn.clear = function(){
    for( var i = 0; i < this.length; i++ ){
      this[i] = undefined;
    }
    this.length = 0;
    this._private.newStyle = true;

    return this; // chaining
  };

  $$.styfn.resetToDefault = function(){
    this.clear();
    this.addDefaultStylesheet();

    return this;
  };

  // builds a style object for the 'core' selector
  $$.styfn.core = function(){
    return this._private.coreStyle;
  };

  // parse a property; return null on invalid; return parsed property otherwise
  // fields :
  // - name : the name of the property
  // - value : the parsed, native-typed value of the property
  // - strValue : a string value that represents the property value in valid css
  // - bypass : true iff the property is a bypass property
  $$.styfn.parse = function( name, value, propIsBypass, propIsFlat ){

    name = $$.util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')
    var property = $$.style.properties[ name ];
    var passedValue = value;
    var types = $$.style.types;

    if( !property ){ return null; } // return null on property of unknown name
    if( value === undefined || value === null ){ return null; } // can't assign null

    var valueIsString = $$.is.string(value);
    if( valueIsString ){ // trim the value to make parsing easier
      value = $$.util.trim( value );
    }

    var type = property.type;
    if( !type ){ return null; } // no type, no luck

    // check if bypass is null or empty string (i.e. indication to delete bypass property)
    if( propIsBypass && (value === '' || value === null) ){
      return {
        name: name,
        value: value,
        bypass: true,
        deleteBypass: true
      };
    }

    var hasPie = name.match(/pie-(\d+)-background-size/);

    // check if value is a function used as a mapper
    if( $$.is.fn(value) ){
      return {
        name: name,
        value: value,
        strValue: 'fn',
        mapped: types.fn,
        bypass: propIsBypass,
        hasPie: hasPie
      };
    }

    // check if value is mapped
    var data, mapData, layoutData, mapLayoutData, scratch, mapScratch;
    if( !valueIsString || propIsFlat ){
      // then don't bother to do the expensive regex checks

    } else if(
      ( data = new RegExp( types.data.regex ).exec( value ) ) ||
      ( layoutData = new RegExp( types.layoutData.regex ).exec( value ) ) ||
      ( scratch = new RegExp( types.scratch.regex ).exec( value ) )
    ){
      if( propIsBypass ){ return false; } // mappers not allowed in bypass

      var mapped;
      if( data ){
        mapped = types.data;
      } else if( layoutData ){
        mapped = types.layoutData;
      } else {
        mapped = types.scratch;
      }

      data = data || layoutData || scratch;

      return {
        name: name,
        value: data,
        strValue: '' + value,
        mapped: mapped,
        field: data[1],
        bypass: propIsBypass,
        hasPie: hasPie
      };

    } else if(
      ( mapData = new RegExp( types.mapData.regex ).exec( value ) ) ||
      ( mapLayoutData = new RegExp( types.mapLayoutData.regex ).exec( value ) ) ||
      ( mapScratch = new RegExp( types.mapScratch.regex ).exec( value ) )
    ){
      if( propIsBypass ){ return false; } // mappers not allowed in bypass

      var mapped;
      if( mapData ){
        mapped = types.mapData;
      } else if( mapLayoutData ){
        mapped = types.mapLayoutData;
      } else {
        mapped = types.mapScratch;
      }

      mapData = mapData || mapLayoutData || mapScratch;

      // we can map only if the type is a colour or a number
      if( !(type.color || type.number) ){ return false; }

      var valueMin = this.parse( name, mapData[4]); // parse to validate
      if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped

      var valueMax = this.parse( name, mapData[5]); // parse to validate
      if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped

      // check if valueMin and valueMax are the same
      if( valueMin.value === valueMax.value ){
        return false; // can't make much of a mapper without a range

      } else if( type.color ){
        var c1 = valueMin.value;
        var c2 = valueMax.value;

        var same = c1[0] === c2[0] // red
          && c1[1] === c2[1] // green
          && c1[2] === c2[2] // blue
          && ( // optional alpha
            c1[3] === c2[3] // same alpha outright
            || (
              (c1[3] == null || c1[3] === 1) // full opacity for colour 1?
              &&
              (c2[3] == null || c2[3] === 1) // full opacity for colour 2?
            )
          )
        ;

        if( same ){ return false; } // can't make a mapper without a range
      }

      return {
        name: name,
        value: mapData,
        strValue: '' + value,
        mapped: mapped,
        field: mapData[1],
        fieldMin: parseFloat( mapData[2] ), // min & max are numeric
        fieldMax: parseFloat( mapData[3] ),
        valueMin: valueMin.value,
        valueMax: valueMax.value,
        bypass: propIsBypass,
        hasPie: hasPie
      };
    }

    // check the type and return the appropriate object
    if( type.number ){
      var units;
      var implicitUnits = 'px'; // not set => px

      if( type.units ){ // use specified units if set
        units = type.units;
      }

      if( type.implicitUnits ){
        implicitUnits = type.implicitUnits;
      }

      if( !type.unitless ){
        if( valueIsString ){
          var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
          if( units ){ unitsRegex = units; } // only allow explicit units if so set
          var match = value.match( '^(' + $$.util.regex.number + ')(' + unitsRegex + ')?' + '$' );

          if( match ){
            value = match[1];
            units = match[2] || implicitUnits;
          }

        } else if( !units || type.implicitUnits ) {
          units = implicitUnits; // implicitly px if unspecified
        }
      }

      value = parseFloat( value );

      // if not a number and enums not allowed, then the value is invalid
      if( isNaN(value) && type.enums === undefined ){
        return null;
      }

      // check if this number type also accepts special keywords in place of numbers
      // (i.e. `left`, `auto`, etc)
      if( isNaN(value) && type.enums !== undefined ){
        value = passedValue;

        for( var i = 0; i < type.enums.length; i++ ){
          var en = type.enums[i];

          if( en === value ){
            return {
              name: name,
              value: value,
              strValue: '' + value,
              bypass: propIsBypass
            };
          }
        }

        return null; // failed on enum after failing on number
      }

      // check if value must be an integer
      if( type.integer && !$$.is.integer(value) ){
        return null;
      }

      // check value is within range
      if( (type.min !== undefined && value < type.min)
      || (type.max !== undefined && value > type.max)
      ){
        return null;
      }

      var ret = {
        name: name,
        value: value,
        strValue: '' + value + (units ? units : ''),
        units: units,
        bypass: propIsBypass,
        hasPie: hasPie && value != null && value !== 0 && value !== ''
      };

      // normalise value in pixels
      if( type.unitless || (units !== 'px' && units !== 'em') ){
        // then pxValue does not apply
      } else {
        ret.pxValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );
      }

      // normalise value in ms
      if( units === 'ms' || units === 's' ){
        ret.msValue = units === 'ms' ? value : 1000 * value;
      }

      return ret;

    } else if( type.propList ) {

      var props = [];
      var propsStr = '' + value;

      if( propsStr === 'none' ){
        // leave empty

      } else { // go over each prop

        var propsSplit = propsStr.split(',');
        for( var i = 0; i < propsSplit.length; i++ ){
          var propName = $$.util.trim( propsSplit[i] );

          if( $$.style.properties[propName] ){
            props.push( propName );
          }
        }

        if( props.length === 0 ){ return null; }

      }

      return {
        name: name,
        value: props,
        strValue: props.length === 0 ? 'none' : props.join(', '),
        bypass: propIsBypass
      };

    } else if( type.color ){
      var tuple = $$.util.color2tuple( value );

      if( !tuple ){ return null; }

      return {
        name: name,
        value: tuple,
        strValue: '' + value,
        bypass: propIsBypass
      };

    } else if( type.enums ){
      for( var i = 0; i < type.enums.length; i++ ){
        var en = type.enums[i];

        if( en === value ){
          return {
            name: name,
            value: value,
            strValue: '' + value,
            bypass: propIsBypass
          };
        }
      }

      return null;

    } else if( type.regex ){
      var regex = new RegExp( type.regex ); // make a regex from the type
      var m = regex.exec( value );

      if( m ){ // regex matches
        return {
          name: name,
          value: m,
          strValue: '' + value,
          bypass: propIsBypass
        };
      } else { // regex doesn't match
        return null; // didn't match the regex so the value is bogus
      }

    } else if( type.string ){
      // just return
      return {
        name: name,
        value: value,
        strValue: '' + value,
        bypass: propIsBypass
      };

    } else {
      return null; // not a type we can handle
    }

  };

  // create a new context from the specified selector string and switch to that context
  $$.styfn.selector = function( selectorStr ){
    // 'core' is a special case and does not need a selector
    var selector = selectorStr === 'core' ? null : new $$.Selector( selectorStr );

    var i = this.length++; // new context means new index
    this[i] = {
      selector: selector,
      properties: [],
      mappedProperties: [],
      index: i
    };

    return this; // chaining
  };

  // add one or many css rules to the current context
  $$.styfn.css = function(){
    var args = arguments;

    switch( args.length ){
    case 1:
      var map = args[0];

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var mapVal = map[ prop.name ];

        if( mapVal === undefined ){
          mapVal = map[ $$.util.dash2camel(prop.name) ];
        }

        if( mapVal !== undefined ){
          this.cssRule( prop.name, mapVal );
        }
      }

      break;

    case 2:
      this.cssRule( args[0], args[1] );
      break;

    default:
      break; // do nothing if args are invalid
    }

    return this; // chaining
  };
  $$.styfn.style = $$.styfn.css;

  // add a single css rule to the current context
  $$.styfn.cssRule = function( name, value ){
    // name-value pair
    var property = this.parse( name, value );

    // add property to current context if valid
    if( property ){
      var i = this.length - 1;
      this[i].properties.push( property );
      this[i].properties[ property.name ] = property; // allow access by name as well

      if( property.hasPie ){
        this._private.hasPie = true;
      }

      if( property.mapped ){
        this[i].mappedProperties.push( property );
      }

      // add to core style if necessary
      var currentSelectorIsCore = !this[i].selector;
      if( currentSelectorIsCore ){
        this._private.coreStyle[ property.name ] = property;
      }
    }

    return this; // chaining
  };

})( cytoscape );

;(function($$){ 'use strict';

  // (potentially expensive calculation)
  // apply the style to the element based on
  // - its bypass
  // - what selectors match it
  $$.styfn.apply = function( eles ){
    var self = this;

    if( self._private.newStyle ){ // clear style caches
      this._private.contextStyles = {};
      this._private.propDiffs = {};
    }

    for( var ie = 0; ie < eles.length; ie++ ){
      var ele = eles[ie];
      var cxtMeta = self.getContextMeta( ele );
      var cxtStyle = self.getContextStyle( cxtMeta );
      var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );

      self.updateTransitions( ele, app.diffProps );
      self.updateStyleHints( ele );

    } // for elements

    self._private.newStyle = false;
  };

  $$.styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){
    var self = this;
    var cache = self._private.propDiffs = self._private.propDiffs || {};
    var dualCxtKey = oldCxtKey + '-' + newCxtKey;
    var cachedVal = cache[dualCxtKey];

    if( cachedVal ){
      return cachedVal;
    }

    var diffProps = [];
    var addedProp = {};

    for( var i = 0; i < self.length; i++ ){
      var cxt = self[i];
      var oldHasCxt = oldCxtKey[i] === 't';
      var newHasCxt = newCxtKey[i] === 't';
      var cxtHasDiffed = oldHasCxt !== newHasCxt;
      var cxtHasMappedProps = cxt.mappedProperties.length > 0;

      if( cxtHasDiffed || cxtHasMappedProps ){
        var props;

        if( cxtHasDiffed && cxtHasMappedProps ){
          props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
        } else if( cxtHasDiffed ){
          props = cxt.properties; // need to check them all
        } else if( cxtHasMappedProps ){
          props = cxt.mappedProperties; // only need to check mapped
        }

        for( var j = 0; j < props.length; j++ ){
          var prop = props[j];
          var name = prop.name;

          // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
          // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
          // is cached)
          var laterCxtOverrides = false;
          for( var k = i + 1; k < self.length; k++ ){
            var laterCxt = self[k];
            var hasLaterCxt = newCxtKey[k] === 't';

            if( !hasLaterCxt ){ continue; } // can't override unless the context is active

            laterCxtOverrides = laterCxt.properties[ prop.name ] != null;

            if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides
          }

          if( !addedProp[name] && !laterCxtOverrides ){
            addedProp[name] = true;
            diffProps.push( name );
          }
        } // for props
      } // if

    } // for contexts

    cache[ dualCxtKey ] = diffProps;
    return diffProps;
  };

  $$.styfn.getContextMeta = function( ele ){
    var self = this;
    var cxtKey = '';
    var diffProps;
    var prevKey = ele._private.styleCxtKey || '';

    if( self._private.newStyle ){
      prevKey = ''; // since we need to apply all style if a fresh stylesheet
    }

    // get the cxt key
    for( var i = 0; i < self.length; i++ ){
      var context = self[i];
      var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'

      if( contextSelectorMatches ){
        cxtKey += 't';
      } else {
        cxtKey += 'f';
      }
    } // for context

    diffProps = self.getPropertiesDiff( prevKey, cxtKey );

    ele._private.styleCxtKey = cxtKey;

    return {
      key: cxtKey,
      diffPropNames: diffProps
    };
  };

  // gets a computed ele style object based on matched contexts
  $$.styfn.getContextStyle = function( cxtMeta ){
    var cxtKey = cxtMeta.key;
    var self = this;
    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

    // if already computed style, returned cached copy
    if( cxtStyles[cxtKey] ){ return cxtStyles[cxtKey]; }

    var style = {
      _private: {
        key: cxtKey
      }
    };

    for( var i = 0; i < self.length; i++ ){
      var cxt = self[i];
      var hasCxt = cxtKey[i] === 't';

      if( !hasCxt ){ continue; }

      for( var j = 0; j < cxt.properties.length; j++ ){
        var prop = cxt.properties[j];
        var styProp = style[ prop.name ] = prop;

        styProp.context = cxt;
      }
    }

    cxtStyles[cxtKey] = style;
    return style;
  };

  $$.styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){
    var self = this;
    var diffProps = cxtMeta.diffPropNames;
    var retDiffProps = {};

    for( var i = 0; i < diffProps.length; i++ ){
      var diffPropName = diffProps[i];
      var cxtProp = cxtStyle[ diffPropName ];
      var eleProp = ele._private.style[ diffPropName ];

      // save cycles when the context prop doesn't need to be applied
      if( !cxtProp || eleProp === cxtProp ){ continue; }

      var retDiffProp = retDiffProps[ diffPropName ] = {
        prev: eleProp
      };

      self.applyParsedProperty( ele, cxtProp );

      retDiffProp.next = ele._private.style[ diffPropName ];

      if( retDiffProp.next && retDiffProp.next.bypass ){
        retDiffProp.next = retDiffProp.next.bypassed;
      }
    }

    return {
      diffProps: retDiffProps
    };
  };

  $$.styfn.updateStyleHints = function(ele){
    var _p = ele._private;
    var self = this;
    var style = _p.style;

    // set whether has pie or not; for greater efficiency
    var hasPie = false;
    if( _p.group === 'nodes' && self._private.hasPie ){
      for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N
        var size = _p.style['pie-' + i + '-background-size'].value;

        if( size > 0 ){
          hasPie = true;
          break;
        }
      }
    }

    _p.hasPie = hasPie;

    var transform = style['text-transform'].strValue;
    var content = style['content'].strValue;
    var fStyle = style['font-style'].strValue;
    var size = style['font-size'].pxValue + 'px';
    var family = style['font-family'].strValue;
    // var variant = style['font-variant'].strValue;
    var weight = style['font-weight'].strValue;
    var valign = style['text-valign'].strValue;
    var halign = style['text-valign'].strValue;
    var oWidth = style['text-outline-width'].pxValue;
    var wrap = style['text-wrap'].strValue;
    var wrapW = style['text-max-width'].pxValue;
    _p.labelKey = fStyle +'$'+ size +'$'+ family +'$'+ weight +'$'+ content +'$'+ transform +'$'+ valign +'$'+ halign +'$'+ oWidth + '$' + wrap + '$' + wrapW;
    _p.fontKey = fStyle +'$'+ weight +'$'+ size +'$'+ family;

    var width = style['width'].pxValue;
    var height = style['height'].pxValue;
    var borderW = style['border-width'].pxValue;
    _p.boundingBoxKey = width +'$'+ height +'$'+ borderW;

    if( ele._private.group === 'edges' ){
      var cpss = style['control-point-step-size'].pxValue;
      var cpd = style['control-point-distance'] ? style['control-point-distance'].pxValue : undefined;
      var cpw = style['control-point-weight'].value;
      var curve = style['curve-style'].strValue;

      _p.boundingBoxKey += '$'+ cpss +'$'+ cpd +'$'+ cpw +'$'+ curve;
    }

    _p.styleKey = Date.now(); // probably safe to use applied time and much faster
    // for( var i = 0; i < $$.style.properties.length; i++ ){
    //   var prop = $$.style.properties[i];
    //   var eleProp = _p.style[ prop.name ];
    //   var val = eleProp && eleProp.strValue ? eleProp.strValue : 'undefined';

    //   _p.styleKey += '$' + val;
    // }
  };

  // apply a property to the style (for internal use)
  // returns whether application was successful
  //
  // now, this function flattens the property, and here's how:
  //
  // for parsedProp:{ bypass: true, deleteBypass: true }
  // no property is generated, instead the bypass property in the
  // element's style is replaced by what's pointed to by the `bypassed`
  // field in the bypass property (i.e. restoring the property the
  // bypass was overriding)
  //
  // for parsedProp:{ mapped: truthy }
  // the generated flattenedProp:{ mapping: prop }
  //
  // for parsedProp:{ bypass: true }
  // the generated flattenedProp:{ bypassed: parsedProp }
  $$.styfn.applyParsedProperty = function( ele, parsedProp ){
    var prop = parsedProp;
    var style = ele._private.style;
    var fieldVal, flatProp;
    var types = $$.style.types;
    var type = $$.style.properties[ prop.name ].type;
    var propIsBypass = prop.bypass;
    var origProp = style[ prop.name ];
    var origPropIsBypass = origProp && origProp.bypass;
    var _p = ele._private;

    // can't apply auto to width or height unless it's a parent node
    if( (parsedProp.name === 'height' || parsedProp.name === 'width') && ele.isNode() ){
      if( parsedProp.value === 'auto' && !ele.isParent() ){
        return false;
      } else if( parsedProp.value !== 'auto' && ele.isParent() ){
        prop = parsedProp = this.parse( parsedProp.name, 'auto', propIsBypass );
      }
    }

    // check if we need to delete the current bypass
    if( propIsBypass && prop.deleteBypass ){ // then this property is just here to indicate we need to delete
      var currentProp = style[ prop.name ];

      // can only delete if the current prop is a bypass and it points to the property it was overriding
      if( !currentProp ){
        return true; // property is already not defined
      } else if( currentProp.bypass && currentProp.bypassed ){ // then replace the bypass property with the original

        // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
        style[ prop.name ] = currentProp.bypassed;
        return true;

      } else {
        return false; // we're unsuccessful deleting the bypass
      }
    }

    var printMappingErr = function(){
      $$.util.error('Do not assign mappings to elements without corresponding data (e.g. ele `'+ ele.id() +'` for property `'+ prop.name +'` with data field `'+ prop.field +'`); try a `['+ prop.field +']` selector to limit scope to elements with `'+ prop.field +'` defined');
    };

    // put the property in the style objects
    switch( prop.mapped ){ // flatten the property if mapped
    case types.mapData:
    case types.mapLayoutData:
    case types.mapScratch:

      var isLayout = prop.mapped === types.mapLayoutData;
      var isScratch = prop.mapped === types.mapScratch;

      // flatten the field (e.g. data.foo.bar)
      var fields = prop.field.split(".");
      var fieldVal;

      if( isScratch || isLayout ){
        fieldVal = _p.scratch;
      } else {
        fieldVal = _p.data;
      }

      for( var i = 0; i < fields.length && fieldVal; i++ ){
        var field = fields[i];
        fieldVal = fieldVal[ field ];
      }

      var percent;
      if( !$$.is.number(fieldVal) ){ // then keep the mapping but assume 0% for now
        percent = 0;
      } else {
        percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
      }

      // make sure to bound percent value
      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      if( type.color ){
        var r1 = prop.valueMin[0];
        var r2 = prop.valueMax[0];
        var g1 = prop.valueMin[1];
        var g2 = prop.valueMax[1];
        var b1 = prop.valueMin[2];
        var b2 = prop.valueMax[2];
        var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
        var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

        var clr = [
          Math.round( r1 + (r2 - r1)*percent ),
          Math.round( g1 + (g2 - g1)*percent ),
          Math.round( b1 + (b2 - b1)*percent ),
          Math.round( a1 + (a2 - a1)*percent )
        ];

        flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
          bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
          name: prop.name,
          value: clr,
          strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
        };

      } else if( type.number ){
        var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
        flatProp = this.parse( prop.name, calcValue, prop.bypass, true );

      } else {
        return false; // can only map to colours and numbers
      }

      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
        flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );
      }

      if( !flatProp ){ printMappingErr(); }
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want

      break;

    // direct mapping
    case types.data:
    case types.layoutData:
    case types.scratch:
      var isLayout = prop.mapped === types.layoutData;
      var isScratch = prop.mapped === types.scratch;

      // flatten the field (e.g. data.foo.bar)
      var fields = prop.field.split(".");
      var fieldVal;

      if( isScratch || isLayout ){
        fieldVal = _p.scratch;
      } else {
        fieldVal = _p.data;
      }

      if( fieldVal ){ for( var i = 0; i < fields.length; i++ ){
        var field = fields[i];
        fieldVal = fieldVal[ field ];
      } }

      flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );

      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
        var flatPropVal = origProp ? origProp.strValue : '';

        flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );
      }

      if( !flatProp ){ printMappingErr(); }
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want

      break;

    case types.fn:
      var fn = prop.value;
      var fnRetVal = fn( ele );

      flatProp = this.parse( prop.name, fnRetVal, prop.bypass, true );
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want

      break;

    case undefined:
      break; // just set the property

    default:
      return false; // not a valid mapping
    }

    // if the property is a bypass property, then link the resultant property to the original one
    if( propIsBypass ){
      if( origPropIsBypass ){ // then this bypass overrides the existing one
        prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
      } else { // then link the orig prop to the new bypass
        prop.bypassed = origProp;
      }

      style[ prop.name ] = prop; // and set

    } else { // prop is not bypass
      if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop
        origProp.bypassed = prop;
      } else { // then just replace the old prop with the new one
        style[ prop.name ] = prop;
      }
    }

    return true;
  };

  // updates the visual style for all elements (useful for manual style modification after init)
  $$.styfn.update = function(){
    var cy = this._private.cy;
    var eles = cy.elements();

    eles.updateStyle();
  };

  // just update the functional properties (i.e. mappings) in the elements'
  // styles (less expensive than recalculation)
  $$.styfn.updateMappers = function( eles ){
    for( var i = 0; i < eles.length; i++ ){ // for each ele
      var ele = eles[i];
      var style = ele._private.style;

      for( var j = 0; j < $$.style.properties.length; j++ ){ // for each prop
        var prop = $$.style.properties[j];
        var propInStyle = style[ prop.name ];

        if( propInStyle && propInStyle.mapping ){
          var mapping = propInStyle.mapping;
          this.applyParsedProperty( ele, mapping ); // reapply the mapping property
        }
      }

      this.updateStyleHints( ele );
    }
  };

  // diffProps : { name => { prev, next } }
  $$.styfn.updateTransitions = function( ele, diffProps, isBypass ){
    var self = this;
    var style = ele._private.style;

    var props = style['transition-property'].value;
    var duration = style['transition-duration'].msValue;
    var delay = style['transition-delay'].msValue;
    var css = {};

    if( props.length > 0 && duration > 0 ){

      // build up the style to animate towards
      var anyPrev = false;
      for( var i = 0; i < props.length; i++ ){
        var prop = props[i];
        var styProp = style[ prop ];
        var diffProp = diffProps[ prop ];

        if( !diffProp ){ continue; }

        var prevProp = diffProp.prev;
        var fromProp = prevProp;
        var toProp = diffProp.next != null ? diffProp.next : styProp;
        var diff = false;

        if( !fromProp ){ continue; }

        // consider px values
        if( $$.is.number( fromProp.pxValue ) && $$.is.number( toProp.pxValue ) ){
          diff = fromProp.pxValue !== toProp.pxValue;

        // consider numerical values
        } else if( $$.is.number( fromProp.value ) && $$.is.number( toProp.value ) ){
          diff = fromProp.value !== toProp.value;

        // consider colour values
        } else if( $$.is.array( fromProp.value ) && $$.is.array( toProp.value ) ){
          diff = fromProp.value[0] !== toProp.value[0]
            || fromProp.value[1] !== toProp.value[1]
            || fromProp.value[2] !== toProp.value[2]
          ;
        }

        // the previous value is good for an animation only if it's different
        if( diff ){
          css[ prop ] = toProp.strValue; // to val
          this.applyBypass(ele, prop, fromProp.strValue); // from val
          anyPrev = true;
        }

      } // end if props allow ani

      // can't transition if there's nothing previous to transition from
      if( !anyPrev ){ return; }

      ele._private.transitioning = true;

      ele.stop();

      if( delay > 0 ){
        ele.delay( delay );
      }

      ele.animate({
        css: css
      }, {
        duration: duration,
        queue: false,
        complete: function(){
          if( !isBypass ){
            self.removeBypasses( ele, props );
          }

          ele._private.transitioning = false;
        }
      });

    } else if( ele._private.transitioning ){
      ele.stop();

      this.removeBypasses( ele, props );

      ele._private.transitioning = false;
    }
  };

})( cytoscape );

;(function($$){ 'use strict';

  // bypasses are applied to an existing style on an element, and just tacked on temporarily
  // returns true iff application was successful for at least 1 specified property
  $$.styfn.applyBypass = function( eles, name, value, updateTransitions ){
    var props = [];
    var isBypass = true;
    
    // put all the properties (can specify one or many) in an array after parsing them
    if( name === "*" || name === "**" ){ // apply to all property names

      if( value !== undefined ){
        for( var i = 0; i < $$.style.properties.length; i++ ){
          var prop = $$.style.properties[i];
          var name = prop.name;

          var parsedProp = this.parse(name, value, true);
          
          if( parsedProp ){
            props.push( parsedProp );
          }
        }
      }

    } else if( $$.is.string(name) ){ // then parse the single property
      var parsedProp = this.parse(name, value, true);

      if( parsedProp ){
        props.push( parsedProp );
      }
    } else if( $$.is.plainObject(name) ){ // then parse each property
      var specifiedProps = name;
      updateTransitions = value;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var name = prop.name;
        var value = specifiedProps[ name ];

        if( value === undefined ){ // try camel case name too
          value = specifiedProps[ $$.util.dash2camel(name) ];
        }

        if( value !== undefined ){
          var parsedProp = this.parse(name, value, true);
          
          if( parsedProp ){
            props.push( parsedProp );
          }
        }
      }
    } else { // can't do anything without well defined properties
      return false;
    }

    // we've failed if there are no valid properties
    if( props.length === 0 ){ return false; }

    // now, apply the bypass properties on the elements
    var ret = false; // return true if at least one succesful bypass applied
    for( var i = 0; i < eles.length; i++ ){ // for each ele
      var ele = eles[i];
      var style = ele._private.style;
      var diffProps = {};
      var diffProp;

      for( var j = 0; j < props.length; j++ ){ // for each prop
        var prop = props[j];

        if( updateTransitions ){
          var prevProp = style[ prop.name ];
          diffProp = diffProps[ prop.name ] = { prev: prevProp };
        }

        ret = this.applyParsedProperty( ele, prop ) || ret;

        if( updateTransitions ){
          diffProp.next = style[ prop.name ];
        }

      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles

    return ret;
  };

  // only useful in specific cases like animation
  $$.styfn.overrideBypass = function( eles, name, value ){
    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var prop = ele._private.style[ $$.util.camel2dash(name) ];

      if( !prop.bypass ){ // need a bypass if one doesn't exist
        this.applyBypass( ele, name, value );
        continue;
      }

      prop.value = value;
      prop.pxValue = value;
    }
  };

  $$.styfn.removeAllBypasses = function( eles, updateTransitions ){
    var isBypass = true;

    for( var j = 0; j < eles.length; j++ ){
      var ele = eles[j];
      var diffProps = {};
      var style = ele._private.style;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var name = prop.name;
        var value = ''; // empty => remove bypass
        var parsedProp = this.parse(name, value, true);
        var prevProp = style[ prop.name ];
        var diffProp = diffProps[ prop.name ] = { prev: prevProp };

        this.applyParsedProperty(ele, parsedProp);

        diffProp.next = style[ prop.name ];
      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles
  };

  $$.styfn.removeBypasses = function( eles, props, updateTransitions ){
    var isBypass = true;

    for( var j = 0; j < eles.length; j++ ){
      var ele = eles[j];
      var diffProps = {};
      var style = ele._private.style;

      for( var i = 0; i < props.length; i++ ){
        var name = props[i];
        var prop = $$.style.properties[ name ];
        var value = ''; // empty => remove bypass
        var parsedProp = this.parse(name, value, true);
        var prevProp = style[ prop.name ];
        var diffProp = diffProps[ prop.name ] = { prev: prevProp };

        this.applyParsedProperty(ele, parsedProp);

        diffProp.next = style[ prop.name ];
      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles
  };

})( cytoscape );
;(function($$, window){ 'use strict';

  // gets what an em size corresponds to in pixels relative to a dom element
  $$.styfn.getEmSizeInPixels = function(){
    var cy = this._private.cy;
    var domElement = cy.container();

    if( window && domElement && window.getComputedStyle ){
      var pxAsStr = window.getComputedStyle(domElement).getPropertyValue('font-size');
      var px = parseFloat( pxAsStr );
      return px;
    } else {
      return 1; // in case we're running outside of the browser
    }
  };

  // gets css property from the core container
  $$.styfn.containerCss = function( propName ){
    var cy = this._private.cy;
    var domElement = cy.container();

    if( window && domElement && window.getComputedStyle ){
      return window.getComputedStyle(domElement).getPropertyValue( propName );
    }
  };

  $$.styfn.containerProperty = function( propName ){
    var propStr = this.containerCss( propName );
    var prop = this.parse( propName, propStr );
    return prop;
  };

  $$.styfn.containerPropertyAsString = function( propName ){
    var prop = this.containerProperty( propName );

    if( prop ){
      return prop.strValue;
    }
  };

})( cytoscape, typeof window === 'undefined' ? null : window );
;(function($$){ 'use strict';

  // gets the rendered style for an element
  $$.styfn.getRenderedStyle = function( ele ){
    var ele = ele[0]; // insure it's an element

    if( ele ){
      var rstyle = {};
      var style = ele._private.style;
      var cy = this._private.cy;
      var zoom = cy.zoom();

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ];

        if( styleProp ){
          var val = styleProp.unitless ? styleProp.strValue : (styleProp.pxValue * zoom) + 'px';
          rstyle[ prop.name ] = val;
          rstyle[ $$.util.dash2camel(prop.name) ] = val;
        }
      }

      return rstyle;
    }
  };

  // gets the raw style for an element
  $$.styfn.getRawStyle = function( ele ){
    var ele = ele[0]; // insure it's an element

    if( ele ){
      var rstyle = {};
      var style = ele._private.style;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ];

        if( styleProp ){
          rstyle[ prop.name ] = styleProp.strValue;
          rstyle[ $$.util.dash2camel(prop.name) ] = styleProp.strValue;
        }
      }

      return rstyle;
    }
  };

  // gets the value style for an element (useful for things like animations)
  $$.styfn.getValueStyle = function( ele, opts ){
    opts = opts || {};

    var rstyle = opts.array ? [] : {}; 
    var style;

    if( $$.is.element(ele) ){
      style = ele._private.style;    
    } else {
      style = ele; // just passed the style itself
    }

    if( style ){
      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ] || style[ $$.util.dash2camel(prop.name) ];

        if( styleProp !== undefined && !$$.is.plainObject( styleProp ) ){ // then make a prop of it
          styleProp = this.parse(prop.name, styleProp);
        }

        if( styleProp ){
          if( opts.array ){
            rstyle.push( styleProp );
          } else {
            rstyle[ prop.name ] = styleProp;
            rstyle[ $$.util.dash2camel(prop.name) ] = styleProp;
          }
        }
      }
    }

    return rstyle;
  };

})( cytoscape );
;(function($$){ 'use strict';

  $$.style.applyFromJson = function( style, json ){
    for( var i = 0; i < json.length; i++ ){
      var context = json[i];
      var selector = context.selector;
      var props = context.style || context.css;

      style.selector( selector ); // apply selector

      for( var name in props ){
        var value = props[name];

        style.css( name, value ); // apply property
      }
    }

    return style;
  };

  // static function
  $$.style.fromJson = function( cy, json ){
    var style = new $$.Style(cy);

    $$.style.applyFromJson( style, json );

    return style;
  };

  // accessible cy.style() function
  $$.styfn.fromJson = function( json ){
    var style = this;

    style.resetToDefault();

    $$.style.applyFromJson( style, json );

    return style;
  };

  // get json from cy.style() api
  $$.styfn.json = function(){
    var json = [];

    for( var i = this.defaultLength; i < this.length; i++ ){
      var cxt = this[i];
      var selector = cxt.selector;
      var props = cxt.properties;
      var css = {};

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];
        css[ prop.name ] = prop.strValue;
      }

      json.push({
        selector: !selector ? 'core' : selector.toString(),
        style: css
      });
    }

    return json;
  };

})( cytoscape );
;(function($$){ 'use strict';

  $$.style.applyFromString = function( style, string ){
    var remaining = '' + string;
    var selAndBlockStr;
    var blockRem;
    var propAndValStr;

    // remove comments from the style string
    remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

    function removeSelAndBlockFromRemaining(){
      // remove the parsed selector and block from the remaining text to parse
      if( remaining.length > selAndBlockStr.length ){
        remaining = remaining.substr( selAndBlockStr.length );
      } else {
        remaining = '';
      }
    }

    function removePropAndValFromRem(){
      // remove the parsed property and value from the remaining block text to parse
      if( blockRem.length > propAndValStr.length ){
        blockRem = blockRem.substr( propAndValStr.length );
      } else {
        blockRem = '';
      }
    }

    while(true){
      var nothingLeftToParse = remaining.match(/^\s*$/);
      if( nothingLeftToParse ){ break; }

      var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

      if( !selAndBlock ){
        $$.util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
        break;
      }

      selAndBlockStr = selAndBlock[0];

      // parse the selector
      var selectorStr = selAndBlock[1];
      if( selectorStr !== 'core' ){
        var selector = new $$.Selector( selectorStr );
        if( selector._private.invalid ){
          $$.util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);

          // skip this selector and block
          removeSelAndBlockFromRemaining();
          continue; 
        }
      }

      // parse the block of properties and values
      var blockStr = selAndBlock[2];
      var invalidBlock = false;
      blockRem = blockStr;
      var props = [];

      while(true){
        var nothingLeftToParse = blockRem.match(/^\s*$/);
        if( nothingLeftToParse ){ break; }

        var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

        if( !propAndVal ){
          $$.util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
          invalidBlock = true;
          break;
        }

        propAndValStr = propAndVal[0];
        var propStr = propAndVal[1];
        var valStr = propAndVal[2];

        var prop = $$.style.properties[ propStr ];
        if( !prop ){
          $$.util.error('Skipping property: Invalid property name in: ' + propAndValStr);

          // skip this property in the block
          removePropAndValFromRem();
          continue;
        }

        var parsedProp = style.parse( propStr, valStr );

        if( !parsedProp ){
          $$.util.error('Skipping property: Invalid property definition in: ' + propAndValStr);

          // skip this property in the block
          removePropAndValFromRem();
          continue;
        }

        props.push({
          name: propStr,
          val: valStr
        });
        removePropAndValFromRem();
      }

      if( invalidBlock ){
        removeSelAndBlockFromRemaining();
        break;
      }

      // put the parsed block in the style
      style.selector( selectorStr );
      for( var i = 0; i < props.length; i++ ){
        var prop = props[i];
        style.css( prop.name, prop.val );
      }

      removeSelAndBlockFromRemaining();
    }

    return style;
  };

  $$.style.fromString = function( cy, string ){
    var style = new $$.Style(cy);
    
    $$.style.applyFromString( style, string );

    return style;
  };

  $$.styfn.fromString = function( string ){
    var style = this;

    style.resetToDefault();

    $$.style.applyFromString( style, string );

    return style;
  };

})( cytoscape );

;(function($$){ 'use strict';

  // a dummy stylesheet object that doesn't need a reference to the core
  // (useful for init)
  $$.stylesheet = $$.Stylesheet = function(){
    if( !(this instanceof $$.Stylesheet) ){
      return new $$.Stylesheet();
    }

    this.length = 0;
  };

  $$.sheetfn = $$.Stylesheet.prototype;

  // just store the selector to be parsed later
  $$.sheetfn.selector = function( selector ){
    var i = this.length++;

    this[i] = {
      selector: selector,
      properties: []
    };

    return this; // chaining
  };

  // just store the property to be parsed later
  $$.sheetfn.css = function( name, value ){
    var i = this.length - 1;

    if( $$.is.string(name) ){
      this[i].properties.push({
        name: name,
        value: value
      });
    } else if( $$.is.plainObject(name) ){
      var map = name;

      for( var j = 0; j < $$.style.properties.length; j++ ){
        var prop = $$.style.properties[j];
        var mapVal = map[ prop.name ];

        if( mapVal === undefined ){ // also try camel case name
          mapVal = map[ $$.util.dash2camel(prop.name) ];
        }

        if( mapVal !== undefined ){
          var name = prop.name;
          var value = mapVal;

          this[i].properties.push({
            name: name,
            value: value
          });
        }
      }
    }

    return this; // chaining
  };

  $$.sheetfn.style = $$.sheetfn.css;

  // generate a real style object from the dummy stylesheet
  $$.sheetfn.generateStyle = function( cy ){
    var style = new $$.Style(cy);

    for( var i = 0; i < this.length; i++ ){
      var context = this[i];
      var selector = context.selector;
      var props = context.properties;

      style.selector(selector); // apply selector

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];

        style.css( prop.name, prop.value ); // apply property
      }
    }

    return style;
  };

})( cytoscape );
// cross-env thread/worker
// NB : uses (heavyweight) processes on nodejs so best not to create too many threads

;(function($$, window){ 'use strict';

  $$.Thread = function( fn ){
    if( !(this instanceof $$.Thread) ){
      return new $$.Thread( fn );
    }

    this._private = {
      requires: [],
      files: [],
      queue: null,
      pass: []
    };

    if( fn ){
      this.run( fn );
    }

  };

  $$.thread = $$.Thread;
  $$.thdfn = $$.Thread.prototype; // short alias

  $$.fn.thread = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Thread.prototype[ name ] = fn;
    }
  };

  var stringifyFieldVal = function( val ){
    var valStr = $$.is.fn( val ) ? val.toString() : 'JSON.parse("' + JSON.stringify(val) + '")';

    return valStr;
  };

  // allows for requires with prototypes and subobjs etc
  var fnAsRequire = function( fn ){
    var req;
    var fnName;

    if( $$.is.object(fn) && fn.fn ){ // manual fn
      req = fnAs( fn.fn, fn.name );
      fnName = fn.name;
      fn = fn.fn;
    } else if( $$.is.fn(fn) ){ // auto fn
      req = fn.toString();
      fnName = fn.name;
    } else if( $$.is.string(fn) ){ // stringified fn
      req = fn;
    } else if( $$.is.object(fn) ){ // plain object
      if( fn.proto ){
        req = '';
      } else {
        req = fn.name + ' = {};';
      }

      fnName = fn.name;
      fn = fn.obj;
    }

    req += '\n';

    var protoreq = function( val, subname ){
      if( val.prototype ){
        var protoNonempty = false;
        for( var prop in val.prototype ){ protoNonempty = true; break; }

        if( protoNonempty ){
          req += fnAsRequire( {
            name: subname,
            obj: val,
            proto: true
          }, val );
        }
      }
    };

    // pull in prototype
    if( fn.prototype && fnName != null ){

      for( var name in fn.prototype ){
        var protoStr = '';

        var val = fn.prototype[ name ];
        var valStr = stringifyFieldVal( val );
        var subname = fnName + '.prototype.' + name;

        protoStr += subname + ' = ' + valStr + ';\n';

        if( protoStr ){
          req += protoStr;
        }

        protoreq( val, subname ); // subobject with prototype
      }
  
    }

    // pull in properties for obj/fns
    if( !$$.is.string(fn) ){ for( var name in fn ){
      var propsStr = '';

      if( fn.hasOwnProperty(name) ){
        var val = fn[ name ];
        var valStr = stringifyFieldVal( val );
        var subname = fnName + '["' + name + '"]';

        propsStr += subname + ' = ' + valStr + ';\n';
      }

      if( propsStr ){
        req += propsStr;
      }

      protoreq( val, subname ); // subobject with prototype
    } }

    return req;
  };
  
  var isPathStr = function( str ){
    return $$.is.string(str) && str.match(/\.js$/);
  };

  $$.fn.thread({

    require: function( fn, as ){
      if( isPathStr(fn) ){
        this._private.files.push( fn );
        
        return this;
      }
        
      if( as ){
        if( $$.is.fn(fn) ){
          // disabled b/c doesn't work with forced names on functions w/ prototypes
          //fn = fnAs( fn, as );

          as = as || fn.name;

          fn = { name: as, fn: fn };
        } else {
          fn = { name: as, obj: fn };
        }
      }

      this._private.requires.push( fn );

      return this; // chaining
    },

    pass: function( data ){
      this._private.pass.push( data );

      return this; // chaining
    },

    run: function( fn, pass ){ // fn used like main()
      var self = this;
      var _p = this._private;
      pass = pass || _p.pass.shift();

      if( _p.stopped ){
        $$.util.error('Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.');
        return;
      }

      if( _p.running ){
        return _p.queue = _p.queue.then(function(){ // inductive step
          return self.run( fn, pass );
        });
      }
      
      var useWW = window != null;
      var useNode = typeof module !== 'undefined';

      self.trigger('run');

      var runP = new $$.Promise(function( resolve, reject ){

        _p.running = true;

        var threadTechAlreadyExists = _p.ran;

        var fnImplStr = $$.is.string( fn ) ? fn : fn.toString();

        // worker code to exec
        var fnStr = '\n' + ( _p.requires.map(function( r ){
          return fnAsRequire( r );
        }) ).concat( _p.files.map(function( f ){
          if( useWW ){
            var wwifyFile = function( file ){
              if( file.match(/^\.\//) || file.match(/^\.\./) ){
                return window.location.origin + window.location.pathname + file;
              } else if( file.match(/^\//) ){
                return window.location.origin + '/' + file;
              }
              return file;
            };
            
            return 'importScripts("' + wwifyFile(f) + '");';
          } else if( useNode ) {
            return 'eval( require("fs").readFileSync("' + f + '", { encoding: "utf8" }) );';
          }
        }) ).concat([
          '( function(){',
            'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');',
            'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it
          '} )()\n'
        ]).join('\n');

        // because we've now consumed the requires, empty the list so we don't dupe on next run()
        _p.requires = [];
        _p.files = [];

        if( useWW ){
          var fnBlob, fnUrl;

          // add normalised thread api functions
          if( !threadTechAlreadyExists ){
            var fnPre = fnStr + '';

            fnStr = [
              'function broadcast(m){ return message(m); };', // alias
              'function message(m){ postMessage(m); };',
              'function listen(fn){',
              '  self.addEventListener("message", function(m){ ',
              '    if( typeof m === "object" && (m.data.$$eval || m.data === "$$start") ){',
              '    } else { ',
              '      fn( m.data );',
              '    }',
              '  });',
              '};', 
              'self.addEventListener("message", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });',
              'function resolve(v){ postMessage({ $$resolve: v }); };', 
              'function reject(v){ postMessage({ $$reject: v }); };'
            ].join('\n');
          
            fnStr += fnPre;

            fnBlob = new Blob([ fnStr ], {
              type: 'application/javascript'
            });
            fnUrl = window.URL.createObjectURL( fnBlob );
          }
          // create webworker and let it exec the serialised code
          var ww = _p.webworker = _p.webworker || new Worker( fnUrl );

          if( threadTechAlreadyExists ){ // then just exec new run() code
            ww.postMessage({
              $$eval: fnStr
            });
          }

          // worker messages => events
          var cb;
          ww.addEventListener('message', cb = function( m ){
            var isObject = $$.is.object(m) && $$.is.object( m.data );
            
            if( isObject && ('$$resolve' in m.data) ){
              ww.removeEventListener('message', cb); // done listening b/c resolve()

              resolve( m.data.$$resolve );
            } else if( isObject && ('$$reject' in m.data) ){
              ww.removeEventListener('message', cb); // done listening b/c reject()

              reject( m.data.$$reject );
            } else {
              self.trigger( new $$.Event(m, { type: 'message', message: m.data }) );
            }
          }, false);

          if( !threadTechAlreadyExists ){
            ww.postMessage('$$start'); // start up the worker
          }

        } else if( useNode ){
          // create a new process
          var path = require('path');
          var child_process = require('child_process');
          var child = _p.child = _p.child || child_process.fork( path.join(__dirname, 'thread-node-fork') );

          // child process messages => events
          var cb;
          child.on('message', cb = function( m ){
            if( $$.is.object(m) && ('$$resolve' in m) ){
              child.removeListener('message', cb); // done listening b/c resolve()

              resolve( m.$$resolve );
            } else if( $$.is.object(m) && ('$$reject' in m) ){
              child.removeListener('message', cb); // done listening b/c reject()

              reject( m.$$reject );
            } else {
              self.trigger( new $$.Event({}, { type: 'message', message: m }) );
            }
          });

          // ask the child process to eval the worker code
          child.send({
            $$eval: fnStr
          });
        } else {
          $$.error('Tried to create thread but no underlying tech found!');
          // TODO fallback on main JS thread?
        }

      }).then(function( v ){
        _p.running = false;
        _p.ran = true;

        self.trigger('ran');

        return v;
      });

      if( _p.queue == null ){
        _p.queue = runP; // i.e. first step of inductive promise chain (for queue)
      }

      return runP;
    },

    // send the thread a message
    message: function( m ){
      var _p = this._private;

      if( _p.webworker ){
        _p.webworker.postMessage( m );
      }

      if( _p.child ){
        _p.child.send( m );
      } 

      return this; // chaining
    },

    stop: function(){
      var _p = this._private;

      if( _p.webworker ){
        _p.webworker.terminate();
      }

      if( _p.child ){
        _p.child.kill();
      } 

      _p.stopped = true;

      return this.trigger('stop'); // chaining
    },

    stopped: function(){
      return this._private.stopped;
    }

  });

  var fnAs = function( fn, name ){
    var fnStr = fn.toString();
    fnStr = fnStr.replace(/function.*\(/, 'function ' + name + '(');

    return fnStr;
  };

  var defineFnal = function( opts ){
    opts = opts || {};

    return function fnalImpl( fn, arg1 ){
      var fnStr = fnAs( fn, '_$_$_' + opts.name );

      this.require( fnStr );

      return this.run( [ 
        'function( data ){',
        '  var origResolve = resolve;',
        '  var res = [];',
        '  ',
        '  resolve = function( val ){',
        '    res.push( val );',
        '  };',
        '  ',
        '  var ret = data.' + opts.name + '( _$_$_' + opts.name + ( arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '' ) + ' );',
        '  ',
        '  resolve = origResolve;',
        '  resolve( res.length > 0 ? res : ret );',
        '}'
      ].join('\n') );
    };
  };

  $$.fn.thread({
    reduce: defineFnal({ name: 'reduce' }),

    reduceRight: defineFnal({ name: 'reduceRight' }),

    map: defineFnal({ name: 'map' })
  });

  // aliases
  var fn = $$.thdfn;
  fn.promise = fn.run;
  fn.terminate = fn.halt = fn.stop;
  fn.include = fn.require;

  // higher level alias (in case you like the worker metaphor)
  $$.worker = $$.Worker = $$.Thread;

  // pull in event apis
  $$.fn.thread({
    on: $$.define.on(),
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    off: $$.define.off(), 
    trigger: $$.define.trigger()
  });

  $$.define.eventAliasesOn( $$.thdfn );
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';

  $$.Fabric = function( N ){
    if( !(this instanceof $$.Fabric) ){
      return new $$.Fabric( N );
    }

    this._private = {
      pass: []
    };

    var defN = 4;

    if( $$.is.number(N) ){
      // then use the specified number of threads
    } if( typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null ){
      N = navigator.hardwareConcurrency;
    } else if( typeof module !== 'undefined' ){
      N = require('os').cpus().length;
    } else { // TODO could use an estimation here but would the additional expense be worth it?
      N = defN;
    }

    for( var i = 0; i < N; i++ ){
      this[i] = $$.Thread();
    }

    this.length = N;
  };

  $$.fabric = $$.Fabric;
  $$.fabfn = $$.Fabric.prototype; // short alias

  $$.fn.fabric = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Fabric.prototype[ name ] = fn;
    }
  };

  $$.fn.fabric({

    // require fn in all threads
    require: function( fn, as ){
      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];

        thread.require( fn, as );
      }

      return this;
    },

    // get a random thread
    random: function(){
      var i = Math.round( (this.length - 1) * Math.random() );
      var thread = this[i];

      return thread;
    },

    // run on random thread
    run: function( fn ){
      var pass = this._private.pass.shift();

      return this.random().pass( pass ).run( fn );
    },

    // sends a random thread a message
    message: function( m ){
      return this.random().message( m );
    },

    // send all threads a message
    broadcast: function( m ){
      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];

        thread.message( m );
      }

      return this; // chaining
    },

    // stop all threads
    stop: function(){
      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];

        thread.stop();
      }

      return this; // chaining
    },

    // pass data to be used with .spread() etc.
    pass: function( data ){
      var pass = this._private.pass;

      if( $$.is.array(data) ){
        pass.push( data );
      } else {
        $$.util.error('Only arrays or collections may be used with fabric.pass()');
      }

      return this; // chaining
    },

    spreadSize: function(){
      var subsize =  Math.ceil( this._private.pass[0].length / this.length );

      subsize = Math.max( 1, subsize ); // don't pass less than one ele to each thread

      return subsize;
    },

    // split the data into slices to spread the data equally among threads
    spread: function( fn ){
      var self = this;
      var _p = self._private;
      var subsize = self.spreadSize(); // number of pass eles to handle in each thread
      var pass = _p.pass.shift().concat([]); // keep a copy
      var runPs = [];

      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];
        var slice = pass.splice( 0, subsize );

        var runP = thread.pass( slice ).run( fn );

        runPs.push( runP );

        var doneEarly = pass.length === 0;
        if( doneEarly ){ break; }
      }

      return $$.Promise.all( runPs ).then(function( thens ){
        var postpass = [];
        var p = 0;

        // fill postpass with the total result joined from all threads
        for( var i = 0; i < thens.length; i++ ){
          var then = thens[i]; // array result from thread i

          for( var j = 0; j < then.length; j++ ){
            var t = then[j]; // array element

            postpass[ p++ ] = t;
          }
        }

        return postpass;
      });
    },

    // parallel version of array.map()
    map: function( fn ){
      var self = this;

      self.require( fn, '_$_$_fabmap' );

      return self.spread(function( split ){
        var mapped = [];
        var origResolve = resolve;

        resolve = function( val ){
          mapped.push( val );
        };

        for( var i = 0; i < split.length; i++ ){
          var oldLen = mapped.length;
          var ret = _$_$_fabmap( split[i] );
          var nothingInsdByResolve = oldLen === mapped.length;

          if( nothingInsdByResolve ){
            mapped.push( ret );
          }
        }

        resolve = origResolve;

        return mapped;
      });

    },

    // parallel version of array.filter()
    filter: function( fn ){
      var _p = this._private;
      var pass = _p.pass[0];

      return this.map( fn ).then(function( include ){
        var ret = [];

        for( var i = 0; i < pass.length; i++ ){
          var datum = pass[i];
          var incDatum = include[i];

          if( incDatum ){
            ret.push( datum );
          }
        }

        return ret;
      });
    },

    // sorts the passed array using a divide and conquer strategy
    sort: function( cmp ){
      var self = this;
      var P = this._private.pass[0].length;
      var subsize = this.spreadSize();

      cmp = cmp || function( a, b ){ // default comparison function
        if( a < b ){
          return -1;
        } else if( a > b ){
          return 1;
        }

        return 0;
      };

      self.require( cmp, '_$_$_cmp' );

      return self.spread(function( split ){ // sort each split normally
        var sortedSplit = split.sort( _$_$_cmp );
        resolve( sortedSplit );

      }).then(function( joined ){
        // do all the merging in the main thread to minimise data transfer

        // TODO could do merging in separate threads but would incur add'l cost of data transfer
        // for each level of the merge

        var merge = function( i, j, max ){
          // don't overflow array
          j = Math.min( j, P );
          max = Math.min( max, P );

          // left and right sides of merge
          var l = i;
          var r = j;

          var sorted = [];

          for( var k = l; k < max; k++ ){

            var eleI = joined[i];
            var eleJ = joined[j];

            if( i < r && ( j >= max || cmp(eleI, eleJ) <= 0 ) ){
              sorted.push( eleI );
              i++;
            } else {
              sorted.push( eleJ );
              j++;
            }

          }

          // in the array proper, put the sorted values
          for( var k = 0; k < sorted.length; k++ ){ // kth sorted item
            var index = l + k;

            joined[ index ] = sorted[k];
          }
        };

        for( var splitL = subsize; splitL < P; splitL *= 2 ){ // merge until array is "split" as 1

          for( var i = 0; i < P; i += 2*splitL ){
            merge( i, i + splitL, i + 2*splitL );
          }

        }

        return joined;
      });
    }


  });

  var defineRandomPasser = function( opts ){
    opts = opts || {};

    return function( fn, arg1 ){
      var pass = this._private.pass.shift();

      return this.random().pass( pass )[ opts.threadFn ]( fn, arg1 );
    };
  };

  $$.fn.fabric({
    randomMap: defineRandomPasser({ threadFn: 'map' }),

    reduce: defineRandomPasser({ threadFn: 'reduce' }),

    reduceRight: defineRandomPasser({ threadFn: 'reduceRight' })
  });

  // aliases
  var fn = $$.fabfn;
  fn.promise = fn.run;
  fn.terminate = fn.halt = fn.stop;
  fn.include = fn.require;

  // pull in event apis
  $$.fn.fabric({
    on: $$.define.on(),
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    off: $$.define.off(),
    trigger: $$.define.trigger()
  });

  $$.define.eventAliasesOn( $$.fabfn );

})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';

  var defaults = {
  };
  
  var origDefaults = $$.util.copy( defaults );

  $$.defaults = function( opts ){
    defaults = $$.util.extend({}, origDefaults, opts);
  };

  $$.fn.core = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Core.prototype[ name ] = fn;
    }
  };
  
  $$.Core = function( opts ){
    if( !(this instanceof $$.Core) ){
      return new $$.Core(opts);
    }
    var cy = this;

    opts = $$.util.extend({}, defaults, opts);

    var container = opts.container;
    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
    reg = reg || {};

    if( reg && reg.cy ){ 
      if( container ){
        while( container.firstChild ){ // clean the container
          container.removeChild( container.firstChild );
        }
      }
      
      reg.cy.notify({ type: 'destroy' }); // destroy the renderer

      reg = {}; // old instance => replace reg completely
    }

    var readies = reg.readies = reg.readies || [];
    
    if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy
    reg.cy = cy;

    var head = window !== undefined && container !== undefined && !opts.headless;
    var options = opts;
    options.layout = $$.util.extend( { name: head ? 'grid' : 'null' }, options.layout );
    options.renderer = $$.util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );
    
    var defVal = function( def, val, altVal ){
      if( val !== undefined ){
        return val;
      } else if( altVal !== undefined ){
        return altVal;
      } else {
        return def;
      }
    };

    var _p = this._private = {
      container: options.container, // html dom ele container
      ready: false, // whether ready has been triggered
      initrender: false, // has initrender has been triggered
      options: options, // cached options
      elements: [], // array of elements
      id2index: {}, // element id => index in elements array
      listeners: [], // list of listeners
      onRenders: [], // rendering listeners
      aniEles: $$.Collection(this), // elements being animated
      scratch: {}, // scratch object for core
      layout: null,
      renderer: null,
      notificationsEnabled: true, // whether notifications are sent to the renderer
      minZoom: 1e-50,
      maxZoom: 1e50,
      zoomingEnabled: defVal(true, options.zoomingEnabled),
      userZoomingEnabled: defVal(true, options.userZoomingEnabled),
      panningEnabled: defVal(true, options.panningEnabled),
      userPanningEnabled: defVal(true, options.userPanningEnabled),
      boxSelectionEnabled: defVal(false, options.boxSelectionEnabled),
      autolock: defVal(false, options.autolock, options.autolockNodes),
      autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
      autounselectify: defVal(false, options.autounselectify),
      styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
      zoom: $$.is.number(options.zoom) ? options.zoom : 1,
      pan: {
        x: $$.is.plainObject(options.pan) && $$.is.number(options.pan.x) ? options.pan.x : 0,
        y: $$.is.plainObject(options.pan) && $$.is.number(options.pan.y) ? options.pan.y : 0
      },
      animation: { // object for currently-running animations
        current: [],
        queue: []
      },
      hasCompoundNodes: false,
      deferredExecQueue: []
    };

    // set selection type
    var selType = options.selectionType;
    if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){
      // then set default

      _p.selectionType = 'single';
    } else {
      _p.selectionType = selType;
    }

    // init zoom bounds
    if( $$.is.number(options.minZoom) && $$.is.number(options.maxZoom) && options.minZoom < options.maxZoom ){
      _p.minZoom = options.minZoom;
      _p.maxZoom = options.maxZoom;
    } else if( $$.is.number(options.minZoom) && options.maxZoom === undefined ){
      _p.minZoom = options.minZoom;
    } else if( $$.is.number(options.maxZoom) && options.minZoom === undefined ){
      _p.maxZoom = options.maxZoom;
    }

    var loadExtData = function( next ){
      var anyIsPromise = false;

      for( var i = 0; i < extData.length; i++ ){
        var datum = extData[i];

        if( $$.is.promise(datum) ){
          anyIsPromise = true;
          break;
        }
      }

      if( anyIsPromise ){
        return $$.Promise.all( extData ).then( next ); // load all data asynchronously, then exec rest of init
      } else {
        next( extData ); // exec synchronously for convenience
      }
    };

    var extData = [ options.style, options.elements ];
    loadExtData(function( thens ){
      var initStyle = thens[0];
      var initEles = thens[1];
   
      // init style
      if( _p.styleEnabled ){
        cy.setStyle( initStyle );
      }

      // create the renderer
      cy.initRenderer( $$.util.extend({
        hideEdgesOnViewport: options.hideEdgesOnViewport,
        hideLabelsOnViewport: options.hideLabelsOnViewport,
        textureOnViewport: options.textureOnViewport,
        wheelSensitivity: $$.is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
        motionBlur: options.motionBlur === undefined ? true : options.motionBlur, // on by default
        motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
        pixelRatio: $$.is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : (options.pixelRatio === 'auto' ? undefined : 1),
        desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
        touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
      }, options.renderer) );

      // trigger the passed function for the `initrender` event
      if( options.initrender ){
        cy.on('initrender', options.initrender);
        cy.on('initrender', function(){
          cy._private.initrender = true;
        });
      }

      // initial load
      cy.load(initEles, function(){ // onready
        cy.startAnimationLoop();
        cy._private.ready = true;

        // if a ready callback is specified as an option, the bind it
        if( $$.is.fn( options.ready ) ){
          cy.on('ready', options.ready);
        }

        // bind all the ready handlers registered before creating this instance
        for( var i = 0; i < readies.length; i++ ){
          var fn = readies[i];
          cy.on('ready', fn);
        }
        if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc
        
        cy.trigger('ready');
      }, options.done);

    });
  };

  $$.corefn = $$.Core.prototype; // short alias
  

  $$.fn.core({
    isReady: function(){
      return this._private.ready;
    },

    ready: function( fn ){
      if( this.isReady() ){
        this.trigger('ready', [], fn); // just calls fn as though triggered via ready event
      } else {
        this.on('ready', fn);
      }
    },

    initrender: function(){
      return this._private.initrender;
    },

    destroy: function(){
      this.notify({ type: 'destroy' }); // destroy the renderer

      var domEle = this.container();
      var parEle = domEle.parentNode;
      if( parEle ){
        parEle.removeChild( domEle );
      }

      return this;
    },

    getElementById: function( id ){
      var index = this._private.id2index[ id ];
      if( index !== undefined ){
        return this._private.elements[ index ];
      }

      // worst case, return an empty collection
      return new $$.Collection( this );
    },

    selectionType: function(){
      return this._private.selectionType;
    },

    hasCompoundNodes: function(){
      return this._private.hasCompoundNodes;
    },

    styleEnabled: function(){
      return this._private.styleEnabled;
    },

    addToPool: function( eles ){
      var elements = this._private.elements;
      var id2index = this._private.id2index;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        var id = ele._private.data.id;
        var index = id2index[ id ];
        var alreadyInPool = index !== undefined;

        if( !alreadyInPool ){
          index = elements.length;
          elements.push( ele );
          id2index[ id ] = index;
          ele._private.index = index;
        }
      }

      return this; // chaining
    },

    removeFromPool: function( eles ){
      var elements = this._private.elements;
      var id2index = this._private.id2index;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        var id = ele._private.data.id;
        var index = id2index[ id ];
        var inPool = index !== undefined;

        if( inPool ){
          this._private.id2index[ id ] = undefined;
          elements.splice(index, 1);

          // adjust the index of all elements past this index
          for( var j = index; j < elements.length; j++ ){
            var jid = elements[j]._private.data.id;
            id2index[ jid ]--;
            elements[j]._private.index--;
          }
        }
      }
    },

    container: function(){
      return this._private.container;
    },

    options: function(){
      return $$.util.copy( this._private.options );
    },
    
    json: function(params){
      var json = {};
      var cy = this;
      
      json.elements = {};
      cy.elements().each(function(i, ele){
        var group = ele.group();
        
        if( !json.elements[group] ){
          json.elements[group] = [];
        }
        
        json.elements[group].push( ele.json() );
      });

      if( this._private.styleEnabled ){
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = cy._private.pan;
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.layout = cy._private.options.layout;
      json.renderer = cy._private.options.renderer;
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.hideLabelsOnViewport = cy._private.options.hideLabelsOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;
      
      return json;
    },

    // defer execution until not busy and guarantee relative execution order of deferred functions
    defer: function( fn ){
      var cy = this;
      var _p = cy._private;
      var q = _p.deferredExecQueue;

      q.push( fn );

      if( !_p.deferredTimeout ){
        _p.deferredTimeout = setTimeout(function(){
          while( q.length > 0 ){
            ( q.shift() )();
          }

          _p.deferredTimeout = null;
        }, 0);
      }
    }
    
  });  
  
})( cytoscape, typeof window === 'undefined' ? null : window );

(function($$, window){ 'use strict';

  function ready(f) {
    var fn = ( document && (document.readyState === 'interactive' || document.readyState === 'complete') )  ? f : ready;

    setTimeout(fn, 9, f);
  }

  $$.fn.core({
    add: function(opts){
      
      var elements;
      var cy = this;
      
      // add the elements
      if( $$.is.elementOrCollection(opts) ){
        var eles = opts;

        if( eles._private.cy === cy ){ // same instance => just restore
          elements = eles.restore();

        } else { // otherwise, copy from json
          var jsons = [];

          for( var i = 0; i < eles.length; i++ ){
            var ele = eles[i];
            jsons.push( ele.json() );
          }

          elements = new $$.Collection( cy, jsons );
        }
      }
      
      // specify an array of options
      else if( $$.is.array(opts) ){
        var jsons = opts;

        elements = new $$.Collection(cy, jsons);
      }
      
      // specify via opts.nodes and opts.edges
      else if( $$.is.plainObject(opts) && ($$.is.array(opts.nodes) || $$.is.array(opts.edges)) ){
        var elesByGroup = opts;
        var jsons = [];

        var grs = ['nodes', 'edges'];
        for( var i = 0, il = grs.length; i < il; i++ ){
          var group = grs[i];
          var elesArray = elesByGroup[group];

          if( $$.is.array(elesArray) ){

            for( var j = 0, jl = elesArray.length; j < jl; j++ ){
              var json = elesArray[j];
              json.group = group;

              jsons.push( json );
            }
          } 
        }

        elements = new $$.Collection(cy, jsons);
      }
      
      // specify options for one element
      else {
        var json = opts;
        elements = (new $$.Element( cy, json )).collection();
      }
      
      return elements;
    },
    
    remove: function(collection){
      if( $$.is.elementOrCollection(collection) ){
        collection = collection;
      } else if( $$.is.string(collection) ){
        var selector = collection;
        collection = this.$( selector );
      }
      
      return collection.remove();
    },
    
    load: function(elements, onload, ondone){
      var cy = this;
      
      cy.notifications(false);

      // remove old elements
      var oldEles = cy.elements();
      if( oldEles.length > 0 ){
        oldEles.remove();
      }
      
      if( elements != null ){
        if( $$.is.plainObject(elements) || $$.is.array(elements) ){
          cy.add( elements );
        } 
      }
      
      function callback(){        
        cy.one('layoutready', function(e){
          cy.notifications(true);
          cy.trigger(e); // we missed this event by turning notifications off, so pass it on

          cy.notify({
            type: 'load',
            collection: cy.elements()
          });

          cy.one('load', onload);
          cy.trigger('load');
        }).one('layoutstop', function(){
          cy.one('done', ondone);
          cy.trigger('done');
        });
        
        var layoutOpts = $$.util.extend({}, cy._private.options.layout);
        layoutOpts.eles = cy.$();

        cy.layout( layoutOpts );

      }

      if( window ){
        ready( callback );
      } else {
        callback();
      }

      return this;
    }
  });
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';
  
  $$.fn.core({
    
    // pull in animation functions
    animated: $$.define.animated(),
    clearQueue: $$.define.clearQueue(),
    delay: $$.define.delay(),
    animate: $$.define.animate(),
    stop: $$.define.stop(),

    addToAnimationPool: function( eles ){
      var cy = this;

      if( !cy.styleEnabled() ){ return; } // save cycles when no style used
      
      cy._private.aniEles.merge( eles );
    },

    startAnimationLoop: function(){
      var cy = this;

      if( !cy.styleEnabled() ){ return; } // save cycles when no style used

      // don't execute the animation loop in headless environments
      if( !window ){
        return;
      }
      
      function globalAnimationStep(){
        $$.util.requestAnimationFrame(function(now){
          handleElements(now);
          globalAnimationStep();
        });
      }
      
      globalAnimationStep(); // first call
      
      function handleElements(now){
        now = +new Date();

        var eles = cy._private.aniEles;
        var doneEles = [];

        function handleElement( ele, isCore ){
          var current = ele._private.animation.current;
          var queue = ele._private.animation.queue;
          var ranAnis = false;
          
          // if nothing currently animating, get something from the queue
          if( current.length === 0 ){
            var next = queue.length > 0 ? queue.shift() : null;
            
            if( next ){
              next.callTime = now; // was queued, so update call time
              current.push( next );
            }
          }
          
          // step and remove if done
          var completes = [];
          for(var i = current.length - 1; i >= 0; i--){
            var ani = current[i];

            // start if need be
            if( !ani.started ){ startAnimation( ele, ani ); }
            
            step( ele, ani, now, isCore );

            if( ani.done ){
              completes.push( ani );
              
              // remove current[i]
              current.splice(i, 1);
            }

            ranAnis = true;
          }
          
          // call complete callbacks
          for( var i = 0; i < completes.length; i++ ){
            var ani = completes[i];
            var complete = ani.params.complete;

            if( $$.is.fn(complete) ){
              complete.apply( ele, [ now ] );
            }
          }

          if( !isCore && current.length === 0 && queue.length === 0 ){
            doneEles.push( ele );
          }

          return ranAnis;
        } // handleElements

        // handle all eles
        for( var e = 0; e < eles.length; e++ ){
          var ele = eles[e];
          
          handleElement( ele );
        } // each element

        var ranCoreAni = handleElement( cy, true );
        
        // notify renderer
        if( eles.length > 0 || ranCoreAni ){
          var toNotify;

          if( eles.length > 0 ){
            var updatedEles = eles.updateCompoundBounds();
            toNotify = updatedEles.length > 0 ? eles.add( updatedEles ) : eles;
          }

          cy.notify({
            type: 'draw',
            collection: toNotify
          });
        }

        // remove elements from list of currently animating if its queues are empty
        eles.unmerge( doneEles );

      } // handleElements
      
      function startAnimation( self, ani ){
        var isCore = $$.is.core( self );
        var isEles = !isCore;
        var ele = self;
        var style = cy._private.style;

        if( isEles ){
          var pos = ele._private.position;
          var startPosition = {
            x: pos.x,
            y: pos.y
          };
          var startStyle = style.getValueStyle( ele );
        }

        if( isCore ){
          var pan = cy._private.pan;
          var startPan = {
            x: pan.x,
            y: pan.y
          };

          var startZoom = cy._private.zoom;
        }

        ani.started = true;
        ani.startTime = Date.now();
        ani.startPosition = startPosition;
        ani.startStyle = startStyle;
        ani.startPan = startPan;
        ani.startZoom = startZoom;
      }

      function step( self, animation, now, isCore ){
        var style = cy._private.style;
        var properties = animation.properties;
        var params = animation.params;
        var startTime = animation.startTime;
        var percent;
        var isEles = !isCore;
        
        if( animation.duration === 0 ){
          percent = 1;
        } else {
          percent = Math.min(1, (now - startTime)/animation.duration);
        }

        if( percent < 0 ){
          percent = 0;
        } else if( percent > 1 ){
          percent = 1;
        }
        
        if( properties.delay == null ){ // then update

          var startPos = animation.startPosition;
          var endPos = properties.position;
          var pos = self._private.position;
          if( endPos && isEles ){
            if( valid( startPos.x, endPos.x ) ){
              pos.x = ease( startPos.x, endPos.x, percent );
            }

            if( valid( startPos.y, endPos.y ) ){
              pos.y = ease( startPos.y, endPos.y, percent );
            }
          }

          var startPan = animation.startPan;
          var endPan = properties.pan;
          var pan = self._private.pan;
          var animatingPan = endPan != null && isCore;
          if( animatingPan ){
            if( valid( startPan.x, endPan.x ) ){
              pan.x = ease( startPan.x, endPan.x, percent );
            }

            if( valid( startPan.y, endPan.y ) ){
              pan.y = ease( startPan.y, endPan.y, percent );
            }

            self.trigger('pan');
          }

          var startZoom = animation.startZoom;
          var endZoom = properties.zoom;
          var animatingZoom = endZoom != null && isCore;
          if( animatingZoom ){
            if( valid( startZoom, endZoom ) ){
              self._private.zoom = ease( startZoom, endZoom, percent );
            }

            self.trigger('zoom');
          }

          if( animatingPan || animatingZoom ){
            self.trigger('viewport');
          }

          var props = properties.style || properties.css;
          if( props && isEles ){

            for( var i = 0; i < props.length; i++ ){
              var name = props[i].name;
              var prop = props[i];
              var end = prop;

              var start = animation.startStyle[ name ];
              var easedVal = ease( start, end, percent );
              
              style.overrideBypass( self, name, easedVal );
            } // for props
            
          } // if 

        }
        
        if( $$.is.fn(params.step) ){
          params.step.apply( self, [ now ] );
        }
        
        if( percent >= 1 ){
          animation.done = true;
        }
        
        return percent;
      }
      
      function valid(start, end){
        if( start == null || end == null ){
          return false;
        }
        
        if( $$.is.number(start) && $$.is.number(end) ){
          return true;
        } else if( (start) && (end) ){
          return true;
        }
        
        return false;
      }
      
      function ease(startProp, endProp, percent){
        if( percent < 0 ){
          percent = 0;
        } else if( percent > 1 ){
          percent = 1;
        }

        var start, end;

        if( startProp.pxValue != null || startProp.value != null ){
          start = startProp.pxValue != null ? startProp.pxValue : startProp.value;
        } else {
          start = startProp;
        }

        if( endProp.pxValue != null || endProp.value != null ){
          end = endProp.pxValue != null ? endProp.pxValue : endProp.value;
        } else {
          end = endProp;
        }

        if( $$.is.number(start) && $$.is.number(end) ){
          return start + (end - start) * percent;

        } else if( $$.is.number(start[0]) && $$.is.number(end[0]) ){ // then assume a colour
          var c1 = start;
          var c2 = end;

          var ch = function(ch1, ch2){
            var diff = ch2 - ch1;
            var min = ch1;
            return Math.round( percent * diff + min );
          };
          
          var r = ch( c1[0], c2[0] );
          var g = ch( c1[1], c2[1] );
          var b = ch( c1[2], c2[2] );
          
          return [r, g, b];
        }
        
        return undefined;
      }
      
    }
    
  });
  
})( cytoscape, typeof window === 'undefined' ? null : window );


  
    
;(function($$){ 'use strict';
  
  $$.fn.core({
    data: $$.define.data({
      field: 'data',
      bindingEvent: 'data',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'data',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true
    }),

    removeData: $$.define.removeData({
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: true
    }),

    scratch: $$.define.data({
      field: 'scratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeScratch: $$.define.removeData({
      field: 'scratch',
      triggerEvent: false
    })
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.core({
    on: $$.define.on(), // .on( events [, selector] [, data], handler)
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    once: $$.define.on({ unbindAllBindersOnTrigger: true }),
    off: $$.define.off(), // .off( events [, selector] [, handler] )
    trigger: $$.define.trigger() // .trigger( events [, extraParams] )
  });

  $$.define.eventAliasesOn( $$.corefn );

})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    png: function( options ){
      var renderer = this._private.renderer;
      options = options || {};

      return renderer.png( options );      
    },
    
    jpg: function( options ){
      var renderer = this._private.renderer;
      options = options || {};
      
      options.bg = options.bg || '#fff';

      return renderer.jpg( options );      
    }
    
  });
  
  $$.corefn.jpeg = $$.corefn.jpg;
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    layout: function( params ){
      var layout;

      // always use a new layout w/ init opts; slightly different backwards compatibility
      // but fixes layout reuse issues like dagre #819 
      if( params == null ){ 
        params = $$.util.extend({}, this._private.options.layout);
        params.eles = this.$();
      }

      layout = this.initLayout( params );
      layout.run();

      return this; // chaining
    },

    makeLayout: function( params ){
      return this.initLayout( params );
    },
    
    initLayout: function( options ){
      if( options == null ){
        $$.util.error('Layout options must be specified to make a layout');
        return;
      }
      
      if( options.name == null ){
        $$.util.error('A `name` must be specified to make a layout');
        return;
      }
      
      var name = options.name;
      var LayoutProto = $$.extension('layout', name);
      
      if( LayoutProto == null ){
        $$.util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
        return;
      }

      options.eles = options.eles != null ? options.eles : this.$();

      if( $$.is.string( options.eles ) ){
        options.eles = this.$( options.eles );
      }
      
      var layout = new LayoutProto( $$.util.extend({}, options, {
        cy: this
      }) );

      // make sure layout has _private for use w/ std apis like .on()
      if( !$$.is.plainObject(layout._private) ){
        layout._private = {};
      }

      layout._private.cy = this;
      layout._private.listeners = [];
      
      return layout;
    }
    
  });

  $$.corefn.createLayout = $$.corefn.makeLayout;
  
})( cytoscape );
(function($$){ 'use strict';
  
  $$.fn.core({
    notify: function( params ){
      if( this._private.batchingNotify ){
        var bEles = this._private.batchNotifyEles;
        var bTypes = this._private.batchNotifyTypes;

        if( params.collection ){ for( var i = 0; i < params.collection.length; i++ ){
          var ele = params.collection[i];

          if( !bEles.ids[ ele._private.id ] ){
            bEles.push( ele );
          }
        } }

        if( !bTypes.ids[ params.type ] ){
          bTypes.push( params.type );
        }

        return; // notifications are disabled during batching
      }

      if( !this._private.notificationsEnabled ){ return; } // exit on disabled

      var renderer = this.renderer();
      
      renderer.notify(params);
    },
    
    notifications: function( bool ){
      var p = this._private;
      
      if( bool === undefined ){
        return p.notificationsEnabled;
      } else {
        p.notificationsEnabled = bool ? true : false;
      }
    },
    
    noNotifications: function( callback ){
      this.notifications(false);
      callback();
      this.notifications(true);
    },

    startBatch: function(){
      var _p = this._private;

      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = [];
      _p.batchNotifyEles = [];
      _p.batchNotifyTypes = [];

      _p.batchStyleEles.ids = {};
      _p.batchNotifyEles.ids = {};
      _p.batchNotifyTypes.ids = {};

      return this;
    },

    endBatch: function(){
      var _p = this._private;

      // update style for dirty eles
      _p.batchingStyle = false;
      new $$.Collection(this, _p.batchStyleEles).updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify({
        type: _p.batchNotifyTypes,
        collection: _p.batchNotifyEles
      });

      return this;
    },

    batch: function( callback ){
      this.startBatch();
      callback();
      this.endBatch();

      return this;
    },

    // for backwards compatibility
    batchData: function( map ){
      var cy = this;

      return this.batch(function(){
        for( var id in map ){
          var data = map[id];
          var ele = cy.getElementById( id );
          
          ele.data( data );
        }
      });
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    renderTo: function( context, zoom, pan, pxRatio ){
      var r = this._private.renderer;

      r.renderTo( context, zoom, pan, pxRatio );
      return this;
    },

    renderer: function(){
      return this._private.renderer;
    },

    forceRender: function(){
      this.notify({
        type: 'draw'
      });

      return this;
    },

    resize: function(){
      this.notify({
        type: 'resize'
      });

      this.trigger('resize');

      return this;
    },
    
    initRenderer: function( options ){
      var cy = this;

      var RendererProto = $$.extension('renderer', options.name);
      if( RendererProto == null ){
        $$.util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
        return;
      }
      
      this._private.renderer = new RendererProto(
        $$.util.extend({}, options, {
          cy: cy,
          style: cy._private.style
        })
      );
       
    },

    triggerOnRender: function(){
      var cbs = this._private.onRenders;

      for( var i = 0; i < cbs.length; i++ ){
        var cb = cbs[i];

        cb();
      }

      return this;
    },

    onRender: function( cb ){
      this._private.onRenders.push( cb );

      return this;
    },

    offRender: function( fn ){
      var cbs = this._private.onRenders;

      if( fn == null ){ // unbind all
        this._private.onRenders = [];
        return this;
      }

      for( var i = 0; i < cbs.length; i++ ){ // unbind specified
        var cb = cbs[i];

        if( fn === cb ){
          cbs.splice( i, 1 );
          break;
        }
      }

      return this;
    }
    
  });  
  
})( cytoscape );
;(function($$){ 'use strict';
  
  $$.fn.core({

    // get a collection
    // - empty collection on no args
    // - collection of elements in the graph on selector arg
    // - guarantee a returned collection when elements or collection specified
    collection: function( eles ){

      if( $$.is.string( eles ) ){
        return this.$( eles );

      } else if( $$.is.elementOrCollection( eles ) ){
        return eles.collection();

      } else if( $$.is.array( eles ) ){
        return new $$.Collection( this, eles );
      }

      return new $$.Collection( this );
    },
    
    nodes: function( selector ){
      var nodes = this.$(function(){
        return this.isNode();
      });

      if( selector ){
        return nodes.filter( selector );
      } 

      return nodes;
    },
    
    edges: function( selector ){
      var edges = this.$(function(){
        return this.isEdge();
      });

      if( selector ){
        return edges.filter( selector );
      }

      return edges;
    },
      
    // search the graph like jQuery
    $: function( selector ){
      var eles = new $$.Collection( this, this._private.elements );

      if( selector ){
        return eles.filter( selector );
      }

      return eles;
    }
    
  });  

  // aliases
  $$.corefn.elements = $$.corefn.filter = $$.corefn.$;  
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    style: function( newStyle ){
      if( newStyle ){
        var s = this.setStyle( newStyle );

        s.update();
      }

      return this._private.style;
    },

    setStyle: function( style ){
      var _p = this._private;

      if( $$.is.stylesheet(style) ){
        _p.style = style.generateStyle(this);
      
      } else if( $$.is.array(style) ) {
        _p.style = $$.style.fromJson(this, style);
      
      } else if( $$.is.string(style) ){
        _p.style = $$.style.fromString(this, style);
      
      } else {
        _p.style = new $$.Style( this );
      }

      return _p.style;
    }
  });
  
})( cytoscape );


;(function($$){ 'use strict';
  
  $$.fn.core({

    autolock: function(bool){
      if( bool !== undefined ){
        this._private.autolock = bool ? true : false;
      } else {
        return this._private.autolock;
      }
      
      return this; // chaining
    },

    autoungrabify: function(bool){
      if( bool !== undefined ){
        this._private.autoungrabify = bool ? true : false;
      } else {
        return this._private.autoungrabify;
      }
      
      return this; // chaining
    },

    autounselectify: function(bool){
      if( bool !== undefined ){
        this._private.autounselectify = bool ? true : false;
      } else {
        return this._private.autounselectify;
      }
      
      return this; // chaining
    },

    panningEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.panningEnabled = bool ? true : false;
      } else {
        return this._private.panningEnabled;
      }
      
      return this; // chaining
    },

    userPanningEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.userPanningEnabled = bool ? true : false;
      } else {
        return this._private.userPanningEnabled;
      }
      
      return this; // chaining
    },
    
    zoomingEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.zoomingEnabled = bool ? true : false;
      } else {
        return this._private.zoomingEnabled;
      }
      
      return this; // chaining
    },

    userZoomingEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.userZoomingEnabled = bool ? true : false;
      } else {
        return this._private.userZoomingEnabled;
      }
      
      return this; // chaining
    },

    boxSelectionEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.boxSelectionEnabled = bool ? true : false;
      } else {
        return this._private.boxSelectionEnabled;
      }
      
      return this; // chaining
    },
    
    pan: function(){
      var args = arguments;
      var pan = this._private.pan;
      var dim, val, dims, x, y;

      switch( args.length ){
      case 0: // .pan()
        return pan;

      case 1: 

        if( $$.is.string( args[0] ) ){ // .pan('x')
          dim = args[0];
          return pan[ dim ];

        } else if( $$.is.plainObject( args[0] ) ) { // .pan({ x: 0, y: 100 })
          if( !this._private.panningEnabled ){
            return this;
          }

          dims = args[0];
          x = dims.x;
          y = dims.y;

          if( $$.is.number(x) ){
            pan.x = x;
          }

          if( $$.is.number(y) ){
            pan.y = y;
          }

          this.trigger('pan viewport');
        }
        break;

      case 2: // .pan('x', 100)
        if( !this._private.panningEnabled ){
          return this;
        }

        dim = args[0];
        val = args[1];

        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){
          pan[dim] = val;
        }

        this.trigger('pan viewport');
        break;

      default:
        break; // invalid
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },
    
    panBy: function(params){
      var args = arguments;
      var pan = this._private.pan;
      var dim, val, dims, x, y;

      if( !this._private.panningEnabled ){
        return this;
      }

      switch( args.length ){
      case 1: 

        if( $$.is.plainObject( args[0] ) ) { // .panBy({ x: 0, y: 100 })
          dims = args[0];
          x = dims.x;
          y = dims.y;

          if( $$.is.number(x) ){
            pan.x += x;
          }

          if( $$.is.number(y) ){
            pan.y += y;
          }

          this.trigger('pan viewport');
        }
        break;

      case 2: // .panBy('x', 100)
        dim = args[0];
        val = args[1];

        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){
          pan[dim] += val;
        }

        this.trigger('pan viewport');
        break;

      default:
        break; // invalid
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },
    
    fit: function( elements, padding ){
      var viewportState = this.getFitViewport( elements, padding );

      if( viewportState ){
        var _p = this._private;
        _p.zoom = viewportState.zoom;
        _p.pan = viewportState.pan;

        this.trigger('pan zoom viewport');

        this.notify({ // notify the renderer that the viewport changed
          type: 'viewport'
        });
      }

      return this; // chaining
    },

    getFitViewport: function( elements, padding ){
      if( $$.is.number(elements) && padding === undefined ){ // elements is optional
        padding = elements;
        elements = undefined;
      }

      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
        return;
      }

      var bb;

      if( $$.is.string(elements) ){
        var sel = elements;
        elements = this.$( sel );

      } else if( $$.is.boundingBox(elements) ){ // assume bb
        var bbe = elements;
        bb = {
          x1: bbe.x1,
          y1: bbe.y1,
          x2: bbe.x2,
          y2: bbe.y2
        };

        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;

      } else if( !$$.is.elementOrCollection(elements) ){
        elements = this.elements();
      }

      bb = bb || elements.boundingBox();

      var w = this.width();
      var h = this.height();
      var zoom;
      padding = $$.is.number(padding) ? padding : 0;

      if( !isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) &&  bb.w > 0 && bb.h > 0 ){
        zoom = Math.min( (w - 2*padding)/bb.w, (h - 2*padding)/bb.h );

        // crop zoom
        zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
        zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

        var pan = { // now pan to middle
          x: (w - zoom*( bb.x1 + bb.x2 ))/2,
          y: (h - zoom*( bb.y1 + bb.y2 ))/2
        };

        return {
          zoom: zoom, 
          pan: pan
        };
      }

      return;
    },
    
    minZoom: function( zoom ){
      if( zoom === undefined ){
        return this._private.minZoom;
      } else if( $$.is.number(zoom) ){
        this._private.minZoom = zoom;
      }

      return this;
    },

    maxZoom: function( zoom ){
      if( zoom === undefined ){
        return this._private.maxZoom;
      } else if( $$.is.number(zoom) ){
        this._private.maxZoom = zoom;
      }

      return this;
    },

    zoom: function( params ){
      var pos; // in rendered px
      var zoom;

      if( params === undefined ){ // then get the zoom
        return this._private.zoom;

      } else if( $$.is.number(params) ){ // then set the zoom
        zoom = params;

      } else if( $$.is.plainObject(params) ){ // then zoom about a point
        zoom = params.level;

        if( params.position ){
          var p = params.position;
          var pan = this._private.pan;
          var z = this._private.zoom;

          pos = { // convert to rendered px
            x: p.x * z + pan.x,
            y: p.y * z + pan.y
          };
        } else if( params.renderedPosition ){
          pos = params.renderedPosition;
        }

        if( pos && !this._private.panningEnabled ){
          return this; // panning disabled
        }
      }

      if( !this._private.zoomingEnabled ){
        return this; // zooming disabled
      }

      if( !$$.is.number(zoom) || ( pos && (!$$.is.number(pos.x) || !$$.is.number(pos.y)) ) ){
        return this; // can't zoom with invalid params
      }

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      if( pos ){ // set zoom about position
        var pan1 = this._private.pan;
        var zoom1 = this._private.zoom;
        var zoom2 = zoom;
        
        var pan2 = {
          x: -zoom2/zoom1 * (pos.x - pan1.x) + pos.x,
          y: -zoom2/zoom1 * (pos.y - pan1.y) + pos.y
        };

        this._private.zoom = zoom;
        this._private.pan = pan2;

        var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;
        this.trigger(' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );
      
      } else { // just set the zoom
        this._private.zoom = zoom;
        this.trigger('zoom viewport');
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },

    viewport: function( opts ){ 
      var _p = this._private;
      var zoomDefd = true;
      var panDefd = true;
      var events = []; // to trigger
      var zoomFailed = false;
      var panFailed = false;

      if( !opts ){ return this; }
      if( !$$.is.number(opts.zoom) ){ zoomDefd = false; }
      if( !$$.is.plainObject(opts.pan) ){ panDefd = false; }
      if( !zoomDefd && !panDefd ){ return this; }

      if( zoomDefd ){
        var z = opts.zoom;

        if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){
          zoomFailed = true;

        } else {
          _p.zoom = z;

          events.push('zoom');
        }
      }

      if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){
        var p = opts.pan;

        if( $$.is.number(p.x) ){
          _p.pan.x = p.x;
          panFailed = false;
        }

        if( $$.is.number(p.y) ){
          _p.pan.y = p.y;
          panFailed = false;
        }

        if( !panFailed ){
          events.push('pan');
        }
      }

      if( events.length > 0 ){
        events.push('viewport');
        this.trigger( events.join(' ') );

        this.notify({
          type: 'viewport'
        });
      }

      return this; // chaining
    },
    
    center: function( elements ){
      var pan = this.getCenterPan( elements );

      if( pan ){
        this._private.pan = pan;

        this.trigger('pan viewport');

        this.notify({ // notify the renderer that the viewport changed
          type: 'viewport'
        });
      }

      return this; // chaining
    },

    getCenterPan: function( elements, zoom ){
      if( !this._private.panningEnabled ){
        return;
      }

      if( $$.is.string(elements) ){
        var selector = elements;
        elements = this.elements( selector );
      } else if( !$$.is.elementOrCollection(elements) ){
        elements = this.elements();
      }

      var bb = elements.boundingBox();
      var w = this.width();
      var h = this.height();
      zoom = zoom === undefined ? this._private.zoom : zoom;

      var pan = { // middle
        x: (w - zoom*( bb.x1 + bb.x2 ))/2,
        y: (h - zoom*( bb.y1 + bb.y2 ))/2
      };
      
      return pan;
    },
    
    reset: function(){
      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
        return this;
      }

      this.viewport({
        pan: { x: 0, y: 0 },
        zoom: 1
      });
      
      return this; // chaining
    },

    width: function(){
      var container = this._private.container;

      if( container ){
        return container.clientWidth;
      }

      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
    },

    height: function(){
      var container = this._private.container;

      if( container ){
        return container.clientHeight;
      }

      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
    },

    extent: function(){
      var pan = this._private.pan;
      var zoom = this._private.zoom;
      var rb = this.renderedExtent();

      var b = {
        x1: ( rb.x1 - pan.x )/zoom,
        x2: ( rb.x2 - pan.x )/zoom,
        y1: ( rb.y1 - pan.y )/zoom,
        y2: ( rb.y2 - pan.y )/zoom,
      };

      b.w = b.x2 - b.x1;
      b.h = b.y2 - b.y1;

      return b;
    },

    renderedExtent: function(){
      var width = this.width();
      var height = this.height();

      return {
        x1: 0,
        y1: 0,
        x2: width,
        y2: height,
        w: width,
        h: height
      };
    }
  });

  // aliases
  $$.corefn.centre = $$.corefn.center;

  // backwards compatibility
  $$.corefn.autolockNodes = $$.corefn.autolock;
  $$.corefn.autoungrabifyNodes = $$.corefn.autoungrabify;

})( cytoscape );

;(function($$){ 'use strict';
  
  // Use this interface to define functions for collections/elements.
  // This interface is good, because it forces you to think in terms
  // of the collections case (more than 1 element), so we don't need
  // notification blocking nonsense everywhere.
  //
  // Other collection-*.js files depend on this being defined first.
  // It's a trade off: It simplifies the code for Collection and 
  // Element integration so much that it's worth it to create the
  // JS dependency.
  //
  // Having this integration guarantees that we can call any
  // collection function on an element and vice versa.

  // e.g. $$.fn.collection({ someFunc: function(){ /* ... */ } })
  $$.fn.collection = $$.fn.eles = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];

      $$.Collection.prototype[ name ] = fn;
    }
  };
  
  // factory for generating edge ids when no id is specified for a new element
  var idFactory = {
    prefix: {
      nodes: 'n',
      edges: 'e'
    },
    id: {
      nodes: 0,
      edges: 0
    },
    generate: function(cy, element, tryThisId){
      var json = $$.is.element( element ) ? element._private : element;
      var group = json.group;
      var id = tryThisId != null ? tryThisId : this.prefix[group] + this.id[group];
      
      if( cy.getElementById(id).empty() ){
        this.id[group]++; // we've used the current id, so move it up
      } else { // otherwise keep trying successive unused ids
        while( !cy.getElementById(id).empty() ){
          id = this.prefix[group] + ( ++this.id[group] );
        }
      }
      
      return id;
    }
  };
  
  // Element
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // represents a node or an edge
  $$.Element = function(cy, params, restore){
    if( !(this instanceof $$.Element) ){
      return new $$.Element(cy, params, restore);
    }

    var self = this;
    restore = (restore === undefined || restore ? true : false);
    
    if( cy === undefined || params === undefined || !$$.is.core(cy) ){
      $$.util.error('An element must have a core reference and parameters set');
      return;
    }
    
    // validate group
    if( params.group !== 'nodes' && params.group !== 'edges' ){
      $$.util.error('An element must be of type `nodes` or `edges`; you specified `' + params.group + '`');
      return;
    }
    
    // make the element array-like, just like a collection
    this.length = 1;
    this[0] = this;
    
    // NOTE: when something is added here, add also to ele.json()
    this._private = {
      cy: cy,
      single: true, // indicates this is an element
      data: params.data || {}, // data object
      position: params.position || {}, // (x, y) position pair
      autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
      autoHeight: undefined, 
      listeners: [], // array of bound listeners
      group: params.group, // string; 'nodes' or 'edges'
      style: {}, // properties as set by the style
      rstyle: {}, // properties for style sent from the renderer to the core
      styleCxts: [], // applied style contexts from the styler
      removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
      selected: params.selected ? true : false, // whether it's selected
      selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable
      locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
      grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
      grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed
      active: false, // whether the element is active from user interaction
      classes: {}, // map ( className => true )
      animation: { // object for currently-running animations
        current: [],
        queue: []
      },
      rscratch: {}, // object in which the renderer can store information
      scratch: params.scratch || {}, // scratch objects
      edges: [], // array of connected edges
      children: [] // array of children
    };
    
    // renderedPosition overrides if specified
    if( params.renderedPosition ){
      var rpos = params.renderedPosition;
      var pan = cy.pan();
      var zoom = cy.zoom();

      this._private.position = {
        x: (rpos.x - pan.x)/zoom,
        y: (rpos.y - pan.y)/zoom
      };
    }
    
    if( $$.is.string(params.classes) ){
      var classes = params.classes.split(/\s+/);
      for( var i = 0, l = classes.length; i < l; i++ ){
        var cls = classes[i];
        if( !cls || cls === '' ){ continue; }

        self._private.classes[cls] = true;
      }
    }

    if( params.css ){
      cy.style().applyBypass( this, params.css );
    }
    
    if( restore === undefined || restore ){
      this.restore();
    }
    
  };

  
  // Collection
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // represents a set of nodes, edges, or both together
  $$.Collection = function(cy, elements, options){
    if( !(this instanceof $$.Collection) ){
      return new $$.Collection(cy, elements);
    }

    if( cy === undefined || !$$.is.core(cy) ){
      $$.util.error('A collection must have a reference to the core');
      return;
    }
    
    var ids = {};
    var indexes = {};
    var createdElements = false;
    
    if( !elements ){
      elements = [];
    } else if( elements.length > 0 && $$.is.plainObject( elements[0] ) && !$$.is.element( elements[0] ) ){
      createdElements = true;

      // make elements from json and restore all at once later
      var eles = [];
      var elesIds = {};

      for( var i = 0, l = elements.length; i < l; i++ ){
        var json = elements[i];

        if( json.data == null ){
          json.data = {};
        }
        
        var data = json.data;

        // make sure newly created elements have valid ids
        if( data.id == null ){
          data.id = idFactory.generate( cy, json );
        } else if( cy.getElementById( data.id ).length !== 0 || elesIds[ data.id ] ){
          continue; // can't create element if prior id already exists
        }

        var ele = new $$.Element( cy, json, false );
        eles.push( ele );
        elesIds[ data.id ] = true;
      }

      elements = eles;
    }
    
    this.length = 0;

    for( var i = 0, l = elements.length; i < l; i++ ){
      var element = elements[i];
      if( !element ){  continue; }
      
      var id = element._private.data.id;
      
      if( !options || (options.unique && !ids[ id ] ) ){
        ids[ id ] = element;
        indexes[ id ] = this.length;

        this[ this.length ] = element;
        this.length++;
      }
    }
    
    this._private = {
      cy: cy,
      ids: ids,
      indexes: indexes
    };

    // restore the elements if we created them from json
    if( createdElements ){
      this.restore();
    }
  };
  
  
  // Functions
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // keep the prototypes in sync (an element has the same functions as a collection)
  // and use $$.elefn and $$.elesfn as shorthands to the prototypes
  $$.elefn = $$.elesfn = $$.Element.prototype = $$.Collection.prototype;

  $$.elesfn.cy = function(){
    return this._private.cy;
  };
  
  $$.elesfn.element = function(){
    return this[0];
  };
  
  $$.elesfn.collection = function(){
    if( $$.is.collection(this) ){
      return this;
    } else { // an element
      return new $$.Collection( this._private.cy, [this] );
    }
  };

  $$.elesfn.unique = function(){
    return new $$.Collection( this._private.cy, this, { unique: true } );
  };

  $$.elesfn.getElementById = function( id ){
    var cy = this._private.cy;
    var ele = this._private.ids[ id ];

    return ele ? ele : $$.Collection(cy); // get ele or empty collection
  };

  $$.elesfn.json = function(){
    var ele = this.element();
    if( ele == null ){ return undefined; }

    var p = ele._private;
    
    var json = $$.util.copy({
      data: p.data,
      position: p.position,
      group: p.group,
      bypass: p.bypass,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbed: p.grabbed,
      grabbable: p.grabbable,
      classes: ''
    });
    
    var classes = [];
    for( var cls in p.classes ){
      if( p.classes[cls] ){
        classes.push(cls);
      }
    }
    
    for( var i = 0; i < classes.length; i++ ){
      var cls = classes[i];
      json.classes += cls + ( i < classes.length - 1 ? ' ' : '' );
    }
    
    return json;
  };

  $$.elesfn.jsons = function(){
    var jsons = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var json = ele.json();

      jsons.push( json );
    }

    return jsons;
  };

  $$.elesfn.clone = function(){
    var cy = this.cy();
    var elesArr = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var json = ele.json();
      var clone = new $$.Element(cy, json, false); // NB no restore

      elesArr.push( clone );
    }

    return new $$.Collection( cy, elesArr );
  };
  $$.elesfn.copy = $$.elesfn.clone;

  $$.elesfn.restore = function( notifyRenderer ){
    var self = this;
    var restored = [];
    var cy = self.cy();
    
    if( notifyRenderer === undefined ){
      notifyRenderer = true;
    }

    // create arrays of nodes and edges, since we need to
    // restore the nodes first
    var elements = [];
    var nodes = [], edges = [];
    var numNodes = 0;
    var numEdges = 0;
    for( var i = 0, l = self.length; i < l; i++ ){
      var ele = self[i];
      
      // keep nodes first in the array and edges after
      if( ele.isNode() ){ // put to front of array if node
        nodes.push( ele );
        numNodes++;
      } else { // put to end of array if edge
        edges.push( ele );
        numEdges++;
      }
    }

    elements = nodes.concat( edges );

    // now, restore each element
    for( var i = 0, l = elements.length; i < l; i++ ){
      var ele = elements[i];

      if( !ele.removed() ){
        // don't need to do anything
        continue;
      }
      
      var _private = ele._private;
      var data = _private.data;
      
      // set id and validate
      if( data.id === undefined ){
        data.id = idFactory.generate( cy, ele );
      } else if( $$.is.emptyString(data.id) || !$$.is.string(data.id) ){
        $$.util.error('Can not create element with invalid string ID `' + data.id + '`');
        
        // can't create element if it has empty string as id or non-string id
        continue;
      } else if( cy.getElementById( data.id ).length !== 0 ){
        $$.util.error('Can not create second element with ID `' + data.id + '`');
        
        // can't create element if one already has that id
        continue;
      }

      var id = data.id; // id is finalised, now let's keep a ref
      
      if( ele.isEdge() ){ // extra checks for edges
        
        var edge = ele;
        var fields = ['source', 'target'];
        var fieldsLength = fields.length;
        var badSourceOrTarget = false;
        for(var j = 0; j < fieldsLength; j++){
          
          var field = fields[j];
          var val = data[field];
          
          if( val == null || val === '' ){
            // can't create if source or target is not defined properly
            $$.util.error('Can not create edge `' + id + '` with unspecified ' + field);
            badSourceOrTarget = true;
          } else if( cy.getElementById(val).empty() ){ 
            // can't create edge if one of its nodes doesn't exist
            $$.util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
            badSourceOrTarget = true;
          }
        }

        if( badSourceOrTarget ){ continue; } // can't create this
        
        var src = cy.getElementById( data.source );
        var tgt = cy.getElementById( data.target );

        src._private.edges.push( edge );
        tgt._private.edges.push( edge );

        edge._private.source = src;
        edge._private.target = tgt;

      } // if is edge
       
      // create mock ids map for element so it can be used like collections
      _private.ids = {};
      _private.ids[ id ] = ele;

      _private.removed = false;
      cy.addToPool( ele );
      
      restored.push( ele );
    } // for each element

    // do compound node sanity checks
    for( var i = 0; i < numNodes; i++ ){ // each node 
      var node = elements[i];
      var data = node._private.data;

      var parentId = node._private.data.parent;
      var specifiedParent = parentId != null;

      if( specifiedParent ){
        var parent = cy.getElementById( parentId );

        if( parent.empty() ){
          // non-existant parent; just remove it
          data.parent = undefined;
        } else {
          var selfAsParent = false;
          var ancestor = parent;
          while( !ancestor.empty() ){
            if( node.same(ancestor) ){
              // mark self as parent and remove from data
              selfAsParent = true;
              data.parent = undefined; // remove parent reference

              // exit or we loop forever
              break;
            }

            ancestor = ancestor.parent();
          }

          if( !selfAsParent ){
            // connect with children
            parent[0]._private.children.push( node );
            node._private.parent = parent[0];

            // let the core know we have a compound graph
            cy._private.hasCompoundNodes = true;
          }
        } // else
      } // if specified parent
    } // for each node
    
    restored = new $$.Collection( cy, restored );
    if( restored.length > 0 ){

      var toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );
      toUpdateStyle.updateStyle( notifyRenderer );

      if( notifyRenderer ){
        restored.rtrigger('add');
      } else {
        restored.trigger('add');
      }
    }
    
    return self; // chainability
  };
  
  $$.elesfn.removed = function(){
    var ele = this[0];
    return ele && ele._private.removed;
  };

  $$.elesfn.inside = function(){
    var ele = this[0];
    return ele && !ele._private.removed;
  };

  $$.elesfn.remove = function( notifyRenderer ){
    var self = this;
    var removed = [];
    var elesToRemove = [];
    var elesToRemoveIds = {};
    var cy = self._private.cy;
    
    if( notifyRenderer === undefined ){
      notifyRenderer = true;
    }
    
    // add connected edges
    function addConnectedEdges(node){
      var edges = node._private.edges; 
      for( var i = 0; i < edges.length; i++ ){
        add( edges[i] );
      }
    }
    

    // add descendant nodes
    function addChildren(node){
      var children = node._private.children;
      
      for( var i = 0; i < children.length; i++ ){
        add( children[i] );
      }
    }

    function add( ele ){
      var alreadyAdded =  elesToRemoveIds[ ele.id() ];
      if( alreadyAdded ){
        return;
      } else {
        elesToRemoveIds[ ele.id() ] = true;
      }

      if( ele.isNode() ){
        elesToRemove.push( ele ); // nodes are removed last

        addConnectedEdges( ele );
        addChildren( ele );
      } else {
        elesToRemove.unshift( ele ); // edges are removed first
      }
    }

    // make the list of elements to remove
    // (may be removing more than specified due to connected edges etc)

    for( var i = 0, l = self.length; i < l; i++ ){
      var ele = self[i];

      add( ele );
    }
    
    function removeEdgeRef(node, edge){
      var connectedEdges = node._private.edges;
      for( var j = 0; j < connectedEdges.length; j++ ){
        var connectedEdge = connectedEdges[j];
        
        if( edge === connectedEdge ){
          connectedEdges.splice( j, 1 );
          break;
        }
      }
    }

    function removeChildRef(parent, ele){
      ele = ele[0];
      parent = parent[0];
      var children = parent._private.children;

      for( var j = 0; j < children.length; j++ ){
        if( children[j][0] === ele[0] ){
          children.splice(j, 1);
          break;
        }
      }
    }

    for( var i = 0; i < elesToRemove.length; i++ ){
      var ele = elesToRemove[i];

      // mark as removed
      ele._private.removed = true;

      // remove from core pool
      cy.removeFromPool( ele );

      // add to list of removed elements
      removed.push( ele );

      if( ele.isEdge() ){ // remove references to this edge in its connected nodes
        var src = ele.source()[0];
        var tgt = ele.target()[0];

        removeEdgeRef( src, ele );
        removeEdgeRef( tgt, ele );

      } else { // remove reference to parent 
        var parent = ele.parent();

        if( parent.length !== 0 ){
          removeChildRef(parent, ele);
        }
      }
    }

    // check to see if we have a compound graph or not
    var elesStillInside = cy._private.elements;
    cy._private.hasCompoundNodes = false;
    for( var i = 0; i < elesStillInside.length; i++ ){
      var ele = elesStillInside[i];

      if( ele.isParent() ){
        cy._private.hasCompoundNodes = true;
        break;
      }
    }

    var removedElements = new $$.Collection( this.cy(), removed );
    if( removedElements.size() > 0 ){
      // must manually notify since trigger won't do this automatically once removed
      
      if( notifyRenderer ){
        this.cy().notify({
          type: 'remove',
          collection: removedElements
        });
      }
      
      removedElements.trigger('remove');
    }

    // check for empty remaining parent nodes
    var checkedParentId = {};
    for( var i = 0; i < elesToRemove.length; i++ ){
      var ele = elesToRemove[i];
      var isNode = ele._private.group === 'nodes';
      var parentId = ele._private.data.parent;

      if( isNode && parentId !== undefined && !checkedParentId[ parentId ] ){
        checkedParentId[ parentId ] = true;
        var parent = cy.getElementById( parentId );

        if( parent && parent.length !== 0 && !parent._private.removed && parent.children().length === 0 ){
          parent.updateStyle();
        }
      }
    }

    return this;
  };

  $$.elesfn.move = function( struct ){
    var cy = this._private.cy;

    if( struct.source !== undefined || struct.target !== undefined ){
      var srcId = struct.source;
      var tgtId = struct.target;
      var srcExists = cy.getElementById( srcId ).length > 0;
      var tgtExists = cy.getElementById( tgtId ).length > 0;

      if( srcExists || tgtExists ){
        var jsons = this.jsons();

        this.remove();

        for( var i = 0; i < jsons.length; i++ ){
          var json = jsons[i];

          if( json.group === 'edges' ){
            if( srcExists ){ json.data.source = srcId; }
            if( tgtExists ){ json.data.target = tgtId; }
          }
        }

        return cy.add( jsons );
      }
 
    } else if( struct.parent !== undefined ){ // move node to new parent
      var parentId = struct.parent;
      var parentExists = parentId === null || cy.getElementById( parentId ).length > 0;
    
      if( parentExists ){
        var jsons = this.jsons();
        var descs = this.descendants();
        var descsEtc = descs.merge( descs.add(this).connectedEdges() );

        this.remove(); // NB: also removes descendants and their connected edges

        for( var i = 0; i < this.length; i++ ){
          var json = jsons[i];

          if( json.group === 'nodes' ){
            json.data.parent = parentId === null ? undefined : parentId;
          }
        }
      }

      return cy.add( jsons ).merge( descsEtc.restore() );
    }

    return this; // if nothing done
  };
  
})( cytoscape );


;(function($$){ 'use strict';

  // search, spanning trees, etc
  $$.fn.eles({

    // std functional ele first callback style
    stdBreadthFirstSearch: function( options ){
      options = $$.util.extend( {}, options, {
        std: true
      } );

      return this.breadthFirstSearch( options );
    },

    // do a breadth first search from the nodes in the collection
    // from pseudocode on wikipedia
    breadthFirstSearch: function( roots, fn, directed ){
      var options;
      var std;
      var thisArg;
      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){
        options = roots;
        roots = options.roots;
        fn = options.visit;
        directed = options.directed;
        std = options.std;
        thisArg = options.thisArg;
      }

      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;
      fn = $$.is.fn(fn) ? fn : function(){};
      
      var cy = this._private.cy;
      var v = $$.is.string(roots) ? this.filter(roots) : roots;
      var Q = [];
      var connectedNodes = [];
      var connectedBy = {};
      var id2depth = {};
      var V = {};
      var j = 0;
      var found;
      var nodes = this.nodes();
      var edges = this.edges();

      // enqueue v
      for( var i = 0; i < v.length; i++ ){
        if( v[i].isNode() ){
          Q.unshift( v[i] );
          V[ v[i].id() ] = true; 

          connectedNodes.push( v[i] );
          id2depth[ v[i].id() ] = 0;
        }
      }

      while( Q.length !== 0 ){
        var v = Q.shift();
        var depth = id2depth[ v.id() ];
        var prevEdge = connectedBy[ v.id() ];
        var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
        var ret;

        if( std ){
          ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
        } else {
          ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
        }

        if( ret === true ){
          found = v;
          break;
        }

        if( ret === false ){
          break;
        }

        var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
        for( var i = 0; i < vwEdges.length; i++ ){
          var e = vwEdges[i];
          var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

          if( w.length !== 0 && !V[ w.id() ] ){
            w = w[0];

            Q.push( w );
            V[ w.id() ] = true;

            id2depth[ w.id() ] = id2depth[ v.id() ] + 1;

            connectedNodes.push( w );
            connectedBy[ w.id() ] = e;
          }
        }
        
      }

      var connectedEles = [];

      for( var i = 0; i < connectedNodes.length; i++ ){
        var node = connectedNodes[i];
        var edge = connectedBy[ node.id() ];

        if( edge ){
          connectedEles.push( edge );
        }

        connectedEles.push( node );
      }

      return {
        path: new $$.Collection( cy, connectedEles, { unique: true } ),
        found: new $$.Collection( cy, found, { unique: true } )
      };
    },

    // std functional ele first callback style
    stdDepthFirstSearch: function( options ){
      options = $$.util.extend( {}, options, {
        std: true
      } );

      return this.depthFirstSearch( options );
    },

    // do a depth first search on the nodes in the collection
    // from pseudocode on wikipedia (iterative impl)
    depthFirstSearch: function( roots, fn, directed ){
      var options;
      var std;
      var thisArg;
      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){
        options = roots;
        roots = options.roots;
        fn = options.visit;
        directed = options.directed;
        std = options.std;
        thisArg = options.thisArg;
      }
      
      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;
      fn = $$.is.fn(fn) ? fn : function(){};
      var cy = this._private.cy;
      var v = $$.is.string(roots) ? this.filter(roots) : roots;
      var S = [];
      var connectedNodes = [];
      var connectedBy = {};
      var id2depth = {};
      var discovered = {};
      var j = 0;
      var found;
      var edges = this.edges();
      var nodes = this.nodes();

      // push v
      for( var i = 0; i < v.length; i++ ){
        if( v[i].isNode() ){
          S.push( v[i] );

          connectedNodes.push( v[i] );
          id2depth[ v[i].id() ] = 0;
        }
      }

      while( S.length !== 0 ){
        var v = S.pop();

        if( !discovered[ v.id() ] ){
          discovered[ v.id() ] = true;

          var depth = id2depth[ v.id() ];
          var prevEdge = connectedBy[ v.id() ];
          var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
          var ret;

          if( std ){
            ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
          } else {
            ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
          }

          if( ret === true ){
            found = v;
            break;
          }

          if( ret === false ){
            break;
          }

          var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
          
          for( var i = 0; i < vwEdges.length; i++ ){
            var e = vwEdges[i];
            var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

            if( w.length !== 0 && !discovered[ w.id() ] ){
              w = w[0];

              S.push( w );

              id2depth[ w.id() ] = id2depth[ v.id() ] + 1;

              connectedNodes.push( w );
              connectedBy[ w.id() ] = e;
            }
          }
        }
      }

      var connectedEles = [];

      for( var i = 0; i < connectedNodes.length; i++ ){
        var node = connectedNodes[i];
        var edge = connectedBy[ node.id() ];

        if( edge ){
          connectedEles.push( edge );
        }

        connectedEles.push( node );
      }

      return {
        path: new $$.Collection( cy, connectedEles, { unique: true } ),
        found: new $$.Collection( cy, found, { unique: true } )
      };
    },

    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
    // implemented from pseudocode from wikipedia
    kruskal: function( weightFn ){
      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

      function findSet(ele){
        for( var i = 0; i < forest.length; i++ ){
          var eles = forest[i];

          if( eles.anySame(ele) ){
            return {
              eles: eles,
              index: i
            };
          }
        }
      }

      var A = new $$.Collection(this._private.cy, []);
      var forest = [];
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        forest.push( nodes[i].collection() );
      }

      var edges = this.edges();
      var S = edges.toArray().sort(function(a, b){
        var weightA = weightFn.call(a, a);
        var weightB = weightFn.call(b, b);

        return weightA - weightB;
      });

      for(var i = 0; i < S.length; i++){
        var edge = S[i];
        var u = edge.source()[0];
        var v = edge.target()[0];
        var setU = findSet(u);
        var setV = findSet(v);

        if( setU.index !== setV.index ){
          A = A.add( edge );

          // combine forests for u and v
          forest[ setU.index ] = setU.eles.add( setV.eles );
          forest.splice( setV.index, 1 );
        }
      }

      return nodes.add( A );

    },

    dijkstra: function( root, weightFn, directed ){
      var options;
      if( $$.is.plainObject(root) && !$$.is.elementOrCollection(root) ){
        options = root;
        root = options.root;
        weightFn = options.weight;
        directed = options.directed;
      }

      var cy = this._private.cy;
      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

      var source = $$.is.string(root) ? this.filter(root)[0] : root[0];
      var dist = {};
      var prev = {};
      var knownDist = {};

      var edges = this.edges().filter(function(){ return !this.isLoop(); });
      var nodes = this.nodes();
      var Q = [];

      for( var i = 0; i < nodes.length; i++ ){
        dist[ nodes[i].id() ] = nodes[i].same( source ) ? 0 : Infinity;
        Q.push( nodes[i] );
      }

      var valueFn = function(node) {
        return dist[ node.id() ];
      };
      
      Q = new $$.Collection(cy, Q);
    
      var heap = $$.Minheap(cy, Q, valueFn);
    
      var distBetween = function(u, v){
        var uvs = ( directed ? u.edgesTo(v) : u.edgesWith(v) ).intersect(edges);
        var smallestDistance = Infinity;
        var smallestEdge;

        for( var i = 0; i < uvs.length; i++ ){
          var edge = uvs[i];
          var weight = weightFn.apply( edge, [edge] );

          if( weight < smallestDistance || !smallestEdge ){
            smallestDistance = weight;
            smallestEdge = edge;
          }
        }

        return {
          edge: smallestEdge,
          dist: smallestDistance
        };
      };

      while(heap.size() > 0){
        var smallestEl = heap.pop(),
        smalletsDist = smallestEl.value,
        uid = smallestEl.id,
        u = cy.getElementById(uid);
    
        knownDist[uid] = smalletsDist;
      
        if( smalletsDist === Math.Infinite ){
          break;
        }

        var neighbors = u.neighborhood().intersect(nodes);
        for( var i = 0; i < neighbors.length; i++ ){
          var v = neighbors[i];
          var vid = v.id();
          var vDist = distBetween(u, v);

          var alt = smalletsDist + vDist.dist;

          if( alt < heap.getValueById(vid) ){
            heap.edit(vid, alt);
            prev[ vid ] = {
              node: u,
              edge: vDist.edge
            };
          }
        } // for 
      } // while

      return {
        distanceTo: function(node){
          var target = $$.is.string(node) ? nodes.filter(node)[0] : node[0];

          return knownDist[ target.id() ];
        },

        pathTo: function(node){
          var target = $$.is.string(node) ? nodes.filter(node)[0] : node[0];
          var S = [];
          var u = target;

          if( target.length > 0 ){
            S.unshift( target );

            while( prev[ u.id() ] ){
              var p = prev[ u.id() ];

              S.unshift( p.edge );
              S.unshift( p.node );

              u = p.node;
            }
          }

          return new $$.Collection( cy, S );
        }
      };
    }  
  });

  // nice, short mathemathical alias
  $$.elesfn.bfs = $$.elesfn.breadthFirstSearch;
  $$.elesfn.dfs = $$.elesfn.depthFirstSearch;
  $$.elesfn.stdBfs = $$.elesfn.stdBreadthFirstSearch;
  $$.elesfn.stdDfs = $$.elesfn.stdDepthFirstSearch;
  
})( cytoscape );

;(function($$) { 
  'use strict';

  // Additional graph analysis algorithms
  $$.fn.eles({

    // Implemented from pseudocode from wikipedia

    // options => options object
    //   root // starting node (either element or selector string)
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   heuristic: function( node ){} // specifies heuristic value for `node`/`this`
    //   directed // default false
    //   goal // target node (either element or selector string). Mandatory.

    // retObj => returned object by function
    //   found : true/false // whether a path from root to goal has been found
    //   distance // Distance for the shortest path from root to goal
    //   path // Array of ids of nodes in shortest path
    aStar: function(options) {
      options = options || {};

      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Reconstructs the path from Start to End, acumulating the result in pathAcum
      var reconstructPath = function(start, end, cameFromMap, pathAcum) {
        // Base case
        if (start == end) {
          pathAcum.push( cy.getElementById(end) );
          return pathAcum;
        }
        
        if (end in cameFromMap) {
          // We know which node is before the last one
          var previous = cameFromMap[end];
          var previousEdge = cameFromEdge[end];

          pathAcum.push( cy.getElementById(end) );
          pathAcum.push( cy.getElementById(previousEdge) );


          return reconstructPath(start, 
                       previous, 
                       cameFromMap, 
                       pathAcum);
        }

        // We should not reach here!
        return undefined;       
      };

      // Returns the index of the element in openSet which has minimum fScore
      var findMin = function(openSet, fScore) {
        if (openSet.length === 0) {
          // Should never be the case
          return undefined;
        }
        var minPos = 0;
        var tempScore = fScore[openSet[0]];
        for (var i = 1; i < openSet.length; i++) {
          var s = fScore[openSet[i]];
          if (s < tempScore) {
            tempScore = s;
            minPos = i;
          }
        }
        return minPos;
      };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting aStar..."); 
      var cy = this._private.cy;

      // root - mandatory!
      if (options != null && options.root != null) {        
        var source = $$.is.string(options.root) ? 
          // use it as a selector, e.g. "#rootID
          this.filter(options.root)[0] : 
          options.root[0];
        // logDebug("Source node: %s", source.id()); 
      } else {
        return undefined;
      }
      
      // goal - mandatory!
      if (options.goal != null) {       
        var target = $$.is.string(options.goal) ? 
          // use it as a selector, e.g. "#goalID
          this.filter(options.goal)[0] : 
          options.goal[0];
        // logDebug("Target node: %s", target.id()); 
      } else {
        return undefined;
      }

      // Heuristic function - optional
      if (options.heuristic != null && $$.is.fn(options.heuristic)) {       
        var heuristic = options.heuristic;
      } else {
        var heuristic = function(){ return 0; }; // use constant if unspecified
        // $$.util.error("Missing required parameter (heuristic)! Aborting.");
        // return;
      }

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var closedSet = [];
      var openSet = [source.id()];
      var cameFrom = {};
      var cameFromEdge = {};
      var gScore = {};
      var fScore = {};

      gScore[source.id()] = 0;
      fScore[source.id()] = heuristic(source);
      
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();

      // Counter
      var steps = 0;

      // Main loop 
      while (openSet.length > 0) {
        var minPos = findMin(openSet, fScore);
        var cMin = cy.getElementById( openSet[minPos] );
        steps++;

        // logDebug("\nStep: %s", steps);
        // logDebug("Processing node: %s, fScore = %s", cMin.id(), fScore[cMin.id()]);
        
        // If we've found our goal, then we are done
        if (cMin.id() == target.id()) {
          // logDebug("Found goal node!");
          var rPath = reconstructPath(source.id(), target.id(), cameFrom, []);
          rPath.reverse();
          // logDebug("Path: %s", rPath);
          return {
            found : true,
            distance : gScore[cMin.id()],
            path : new $$.Collection(cy, rPath),
            steps : steps
          };          
        }
        
        // Add cMin to processed nodes
        closedSet.push(cMin.id());
        // Remove cMin from boundary nodes
        openSet.splice(minPos, 1);
        // logDebug("Added node to closedSet, removed from openSet.");
        // logDebug("Processing neighbors...");

        // Update scores for neighbors of cMin
        // Take into account if graph is directed or not
        var vwEdges = cMin.connectedEdges();
        if( directed ){ vwEdges = vwEdges.stdFilter(function(ele){ return ele.data('source') === cMin.id(); }); }
        vwEdges = vwEdges.intersect(edges);  
        
        for (var i = 0; i < vwEdges.length; i++) {
          var e = vwEdges[i];
          var w = e.connectedNodes().stdFilter(function(n){ return n.id() !== cMin.id(); }).intersect(nodes);

          // logDebug("   processing neighbor: %s", w.id());
          // if node is in closedSet, ignore it
          if (closedSet.indexOf(w.id()) != -1) {
            // logDebug("   already in closedSet, ignoring it.");
            continue;
          }
          
          // New tentative score for node w
          var tempScore = gScore[cMin.id()] + weightFn.apply(e, [e]);
          // logDebug("   tentative gScore: %d", tempScore);

          // Update gScore for node w if:
          //   w not present in openSet
          // OR
          //   tentative gScore is less than previous value

          // w not in openSet
          if (openSet.indexOf(w.id()) == -1) {
            gScore[w.id()] = tempScore;
            fScore[w.id()] = tempScore + heuristic(w);
            openSet.push(w.id()); // Add node to openSet
            cameFrom[w.id()] = cMin.id();
            cameFromEdge[w.id()] = e.id();
            // logDebug("   not in openSet, adding it. ");
            // logDebug("   fScore(%s) = %s", w.id(), tempScore);
            continue;
          }
          // w already in openSet, but with greater gScore
          if (tempScore < gScore[w.id()]) {
            gScore[w.id()] = tempScore;
            fScore[w.id()] = tempScore + heuristic(w);
            cameFrom[w.id()] = cMin.id();
            // logDebug("   better score, replacing gScore. ");
            // logDebug("   fScore(%s) = %s", w.id(), tempScore);
          }

        } // End of neighbors update

      } // End of main loop

      // If we've reached here, then we've not reached our goal
      // logDebug("Reached end of computation without finding our goal");
      return {
        found : false,
        distance : undefined,
        path : undefined,
        steps : steps
      };
    }, // aStar()


    // Implemented from pseudocode from wikipedia
    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   pathTo : function(fromId, toId) // Returns the shortest path from node with ID "fromID" to node with ID "toId", as an array of node IDs
    //   distanceTo: function(fromId, toId) // Returns the distance of the shortest path from node with ID "fromID" to node with ID "toId"
    floydWarshall: function(options) {
      options = options || {};

      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting floydWarshall..."); 

      var cy = this._private.cy;

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;

      // mapping: node id -> position in nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }     

      // Initialize distance matrix
      var dist = [];
      for (var i = 0; i < numNodes; i++) {
        var newRow = new Array(numNodes);
        for (var j = 0; j < numNodes; j++) {
          if (i == j) {
            newRow[j] = 0;
          } else {
            newRow[j] = Infinity;
          }
        }
        dist.push(newRow);
      }           

      // Initialize matrix used for path reconstruction
      // Initialize distance matrix
      var next = [];
      var edgeNext = [];

      var initMatrix = function(next){
        for (var i = 0; i < numNodes; i++) {
          var newRow = new Array(numNodes);
          for (var j = 0; j < numNodes; j++) {
            newRow[j] = undefined;
          }
          next.push(newRow);
        }
      };

      initMatrix(next);
      initMatrix(edgeNext);
      
      // Process edges
      for (var i = 0; i < edges.length ; i++) {     
        var sourceIndex = id2position[edges[i].source().id()];
        var targetIndex = id2position[edges[i].target().id()];    
        var weight = weightFn.apply(edges[i], [edges[i]]);
        
        // Check if already process another edge between same 2 nodes
        if (dist[sourceIndex][targetIndex] > weight) {
          dist[sourceIndex][targetIndex] = weight;
          next[sourceIndex][targetIndex] = targetIndex;
          edgeNext[sourceIndex][targetIndex] = edges[i];
        }
      }

      // If undirected graph, process 'reversed' edges
      if (!directed) {
        for (var i = 0; i < edges.length ; i++) {     
          var sourceIndex = id2position[edges[i].target().id()];    
          var targetIndex = id2position[edges[i].source().id()];
          var weight = weightFn.apply(edges[i], [edges[i]]);
          
          // Check if already process another edge between same 2 nodes
          if (dist[sourceIndex][targetIndex] > weight) {
            dist[sourceIndex][targetIndex] = weight;
            next[sourceIndex][targetIndex] = targetIndex;
            edgeNext[sourceIndex][targetIndex] = edges[i];
          }
        }
      }

      // Main loop
      for (var k = 0; k < numNodes; k++) {
        for (var i = 0; i < numNodes; i++) {
          for (var j = 0; j < numNodes; j++) {            
            if (dist[i][k] + dist[k][j] < dist[i][j]) {
              dist[i][j] = dist[i][k] + dist[k][j];
              next[i][j] = next[i][k];
            }
          }
        }
      }

      // Build result object       
      var position2id = [];
      for (var i = 0; i < numNodes; i++) {
        position2id.push(nodes[i].id());
      }

      var res = {
        distance: function(from, to) {
          if ($$.is.string(from)) {
            // from is a selector string
            var fromId = (cy.filter(from)[0]).id();
          } else {
            // from is a node
            var fromId = from.id();
          }

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }

          return dist[id2position[fromId]][id2position[toId]];
        },

        path: function(from, to) {
          var reconstructPathAux = function(from, to, next, position2id, edgeNext) {
            if (from === to) {
              return cy.getElementById( position2id[from] );
            }
            if (next[from][to] === undefined) {
              return undefined;
            }

            var path = [ cy.getElementById(position2id[from]) ];
            var prev = from;
            while (from !== to) {
              prev = from;
              from = next[from][to];

              var edge = edgeNext[prev][from];
              path.push( edge );

              path.push( cy.getElementById(position2id[from]) );
            }
            return path;
          };

          if ($$.is.string(from)) {
            // from is a selector string
            var fromId = (cy.filter(from)[0]).id();
          } else {
            // from is a node
            var fromId = from.id();
          }

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }
          
          var pathArr = reconstructPathAux(id2position[fromId], 
                        id2position[toId], 
                        next,
                        position2id,
                        edgeNext);

          return new $$.Collection( cy, pathArr );
        },
      };

      return res;

    }, // floydWarshall


    // Implemented from pseudocode from wikipedia
    // options => options object
    //   root: starting node (either element or selector string)
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   pathTo : function(toId) // Returns the shortest path from root node to node with ID "toId", as an array of node IDs
    //   distanceTo: function(toId) // Returns the distance of the shortest path from root node to node with ID "toId"
    //   hasNegativeWeightCycle: true/false (if true, pathTo and distanceTo will be undefined)
    bellmanFord: function(options) {
      options = options || {};

      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting bellmanFord..."); 

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      // root - mandatory!
      if (options.root != null) {       
        if ($$.is.string(options.root)) {
          // use it as a selector, e.g. "#rootID
          var source = this.filter(options.root)[0];
        } else {
          var source = options.root[0];
        }
        // logDebug("Source node: %s", source.id()); 
      } else {
        $$.util.error("options.root required");
        return undefined;
      }

      var cy = this._private.cy;
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;

      // mapping: node id -> position in nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }     

      // Initializations
      var cost = [];
      var predecessor = [];
      var predEdge = [];
      
      for (var i = 0; i < numNodes; i++) {
        if (nodes[i].id() === source.id()) {
          cost[i] = 0;
        } else {
          cost[i] = Infinity;
        } 
        predecessor[i] = undefined;
      }
      
      // Edges relaxation      
      var flag = false;
      for (var i = 1; i < numNodes; i++) {
        flag = false;
        for (var e = 0; e < edges.length; e++) {
          var sourceIndex = id2position[edges[e].source().id()];
          var targetIndex = id2position[edges[e].target().id()];    
          var weight = weightFn.apply(edges[e], [edges[e]]);
          
          var temp = cost[sourceIndex] + weight;
          if (temp < cost[targetIndex]) {
            cost[targetIndex] = temp;
            predecessor[targetIndex] = sourceIndex;
            predEdge[targetIndex] = edges[e];
            flag = true;
          }

          // If undirected graph, we need to take into account the 'reverse' edge
          if (!directed) {
            var temp = cost[targetIndex] + weight;
            if (temp < cost[sourceIndex]) {
              cost[sourceIndex] = temp;
              predecessor[sourceIndex] = targetIndex;
              predEdge[sourceIndex] = edges[e];
              flag = true;
            }
          }
        }

        if (!flag) {
          break;
        }
      }      
            
      if (flag) {
        // Check for negative weight cycles
        for (var e = 0; e < edges.length; e++) {
          var sourceIndex = id2position[edges[e].source().id()];
          var targetIndex = id2position[edges[e].target().id()];    
          var weight = weightFn.apply(edges[e], [edges[e]]);
          
          if (cost[sourceIndex] + weight < cost[targetIndex]) {
            $$.util.error("Error: graph contains a negative weigth cycle!"); 
            return { pathTo: undefined,
                 distanceTo: undefined,
                 hasNegativeWeightCycle: true};
          }
        }     
      }

      // Build result object       
      var position2id = [];
      for (var i = 0; i < numNodes; i++) {
        position2id.push(nodes[i].id());
      }
      
      
      var res = {       
        distanceTo : function(to) {
          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }

          return cost[id2position[toId]];
        }, 

        pathTo : function(to) {

          var reconstructPathAux = function(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
            for(;;){
              // Add toId to path
              acumPath.push( cy.getElementById(position2id[toPos]) );
              acumPath.push( predEdge[toPos] );

              if (fromPos === toPos) {
                // reached starting node
                return acumPath;
              }

              // If no path exists, discart acumulated path and return undefined
              var predPos = predecessor[toPos];
              if (typeof predPos === "undefined") {
                return undefined;
              }

              toPos = predPos;
            }

          };

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }
          var path = [];

          // This returns a reversed path 
          var res =  reconstructPathAux(predecessor, 
                        id2position[source.id()],
                        id2position[toId], 
                        position2id, 
                        path,
                        predEdge);

          // Get it in the correct order and return it
          if (res != null) {
            res.reverse();
          }

          return new $$.Collection(cy, res);                       
        }, 

        hasNegativeWeightCycle: false
      };

      return res;

    }, // bellmanFord


    // Computes the minimum cut of an undirected graph
    // Returns the correct answer with high probability
    // options => options object
    // 
    // retObj => returned object by function
    //   cut : list of IDs of edges in the cut,
    //   partition1: list of IDs of nodes in one partition
    //   partition2: list of IDs of nodes in the other partition
    kargerStein: function(options) {
      options = options || {};
      
      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Function which colapses 2 (meta) nodes into one
      // Updates the remaining edge lists
      // Receives as a paramater the edge which causes the collapse
      var colapse = function(edgeIndex, nodeMap, remainingEdges) {
        var edgeInfo = remainingEdges[edgeIndex];
        var sourceIn = edgeInfo[1];
        var targetIn = edgeInfo[2];
        var partition1 = nodeMap[sourceIn];
        var partition2 = nodeMap[targetIn];

        // Delete all edges between partition1 and partition2
        var newEdges = remainingEdges.filter(function(edge) {
          if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
            return false;
          }
          if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
            return false;
          }
          return true;
        });
        
        // All edges pointing to partition2 should now point to partition1
        for (var i = 0; i < newEdges.length; i++) {
          var edge = newEdges[i];
          if (edge[1] === partition2) { // Check source
            newEdges[i] = edge.slice(0);
            newEdges[i][1] = partition1;
          } else if (edge[2] === partition2) { // Check target
            newEdges[i] = edge.slice(0);
            newEdges[i][2] = partition1;
          }
        } 
        
        // Move all nodes from partition2 to partition1
        for (var i = 0; i < nodeMap.length; i++) {
          if (nodeMap[i] === partition2) {
            nodeMap[i] = partition1;
          }
        }
        
        return newEdges;
      };


      // Contracts a graph until we reach a certain number of meta nodes
      var contractUntil = function(metaNodeMap, 
                     remainingEdges,
                     size, 
                     sizeLimit) {
        // Stop condition
        if (size <= sizeLimit) {
          return remainingEdges;
        }
        
        // Choose an edge randomly
        var edgeIndex = Math.floor((Math.random() * remainingEdges.length));

        // Colapse graph based on edge
        var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);
        
        return contractUntil(metaNodeMap, 
                   newEdges, 
                   size - 1, 
                   sizeLimit);        
      };


      // Parse options
      // debug - optional
      // if (options != null && options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting kargerStein..."); 

      var cy = this._private.cy;
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;
      var numEdges = edges.length;
      var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
      var stopSize = Math.floor(numNodes / Math.sqrt(2));

      if (numNodes < 2) {
        $$.util.error("At least 2 nodes are required for KargerSteing algorithm!"); 
        return undefined;
      }

      // Create numerical identifiers for each node
      // mapping: node id -> position in nodes array
      // for reverse mapping, simply use nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }

      // Now store edge destination as indexes
      // Format for each edge (edge index, source node index, target node index)
      var edgeIndexes = [];
      for (var i = 0; i < numEdges; i++) {
        var e = edges[i];
        edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
      }

      // We will store the best cut found here
      var minCutSize = Infinity;
      var minCut;     

      // Initial meta node partition
      var originalMetaNode = [];
      for (var i = 0; i < numNodes; i++) {
        originalMetaNode.push(i);
      }

      // Main loop
      for (var iter = 0; iter <= numIter; iter++) {
        // Create new meta node partition
        var metaNodeMap = originalMetaNode.slice(0);

        // Contract until stop point (stopSize nodes)
        var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);
        
        // Create a copy of the colapsed nodes state
        var metaNodeMap2 = metaNodeMap.slice(0);

        // Run 2 iterations starting in the stop state
        var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
        var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);

        // Is any of the 2 results the best cut so far?
        if (res1.length <= res2.length && res1.length < minCutSize) {
          minCutSize = res1.length;
          minCut = [res1, metaNodeMap];
        } else if (res2.length <= res1.length && res2.length < minCutSize) {
          minCutSize = res2.length;
          minCut = [res2, metaNodeMap2];
        }
      } // end of main loop

      
      // Construct result
      var resEdges = (minCut[0]).map(function(e){ return edges[e[0]]; });
      var partition1 = [];
      var partition2 = [];

      // traverse metaNodeMap for best cut
      var witnessNodePartition = minCut[1][0];
      for (var i = 0; i < minCut[1].length; i++) { 
        var partitionId = minCut[1][i]; 
        if (partitionId === witnessNodePartition) {
          partition1.push(nodes[i]);
        } else {
          partition2.push(nodes[i]);
        }       
      }
      
      var ret = {
        cut: new $$.Collection(cy, resEdges),
        partition1: new $$.Collection(cy, partition1),
        partition2: new $$.Collection(cy, partition2)
      };
      
      return ret;
    },


    // 
    // options => options object
    //   dampingFactor: optional
    //   precision: optional
    //   iterations : optional
    // retObj => returned object by function
    //  rank : function that returns the pageRank of a given node (object or selector string)
    pageRank: function(options) {
      options = options || {};
      
      var normalizeVector = function(vector) {
        var length = vector.length;

        // First, get sum of all elements
        var total = 0; 
        for (var i = 0; i < length; i++) {
          total += vector[i];
        }

        // Now, divide each by the sum of all elements
        for (var i = 0; i < length; i++) {
          vector[i] = vector[i] / total;
        }
      };
      
      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };
      
      // Parse options
      // debug - optional
      // if (options != null && 
      //   options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting pageRank..."); 

      // dampingFactor - optional
      if (options != null && 
        options.dampingfactor != null) {
        var dampingFactor = options.dampingFactor;
      } else {
        var dampingFactor = 0.8; // Default damping factor
      }

      // desired precision - optional
      if (options != null && 
        options.precision != null) {
        var epsilon = options.precision;
      } else {
        var epsilon = 0.000001; // Default precision
      }

      // Max number of iterations - optional
      if (options != null && 
        options.iterations != null) {
        var numIter = options.iterations;
      } else {
        var numIter = 200; // Default number of iterations
      }

      // Weight function - optional
      if (options != null && 
        options.weight != null && 
        $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;}; 
      }

      var cy = this._private.cy;
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;
      var numEdges = edges.length;

      // Create numerical identifiers for each node
      // mapping: node id -> position in nodes array
      // for reverse mapping, simply use nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }

      // Construct transposed adjacency matrix
      // First lets have a zeroed matrix of the right size
      // We'll also keep track of the sum of each column
      var matrix = [];
      var columnSum = [];
      var additionalProb = (1 - dampingFactor) / numNodes;

      // Create null matric
      for (var i = 0; i < numNodes; i++) { 
        var newRow = [];
        for (var j = 0; j < numNodes; j++) {
          newRow.push(0.0);
        }
        matrix.push(newRow);
        columnSum.push(0.0);
      }

      // Now, process edges
      for (var i = 0; i < numEdges; i++) {
        var edge = edges[i];
        var s = id2position[edge.source().id()];
        var t = id2position[edge.target().id()];
        var w = weightFn.apply(edge, [edge]);
        
        // Update matrix
        matrix[t][s] += w;

        // Update column sum
        columnSum[s] += w; 
      }

      // Add additional probability based on damping factor
      // Also, take into account columns that have sum = 0
      var p = 1.0 / numNodes + additionalProb; // Shorthand
      // Traverse matrix, column by column
      for (var j = 0; j < numNodes; j++) { 
        if (columnSum[j] === 0) {
          // No 'links' out from node jth, assume equal probability for each possible node
          for (var i = 0; i < numNodes; i++) {
            matrix[i][j] = p;
          }
        } else {
          // Node jth has outgoing link, compute normalized probabilities
          for (var i = 0; i < numNodes; i++) {
            matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
          }         
        }
      }

      // Compute dominant eigenvector using power method
      var eigenvector = [];
      var nullVector = [];
      var previous;

      // Start with a vector of all 1's
      // Also, initialize a null vector which will be used as shorthand
      for (var i = 0; i < numNodes; i++) {
        eigenvector.push(1.0);
        nullVector.push(0.0);
      }
            
      for (var iter = 0; iter < numIter; iter++) {
        // New array with all 0's
        var temp = nullVector.slice(0);
        
        // Multiply matrix with previous result
        for (var i = 0; i < numNodes; i++) {
          for (var j = 0; j < numNodes; j++) {        
            temp[i] += matrix[i][j] * eigenvector[j];
          }
        }

        normalizeVector(temp);
        previous = eigenvector;
        eigenvector = temp;

        var diff = 0;
        // Compute difference (squared module) of both vectors
        for (var i = 0; i < numNodes; i++) {
          diff += Math.pow(previous[i] - eigenvector[i], 2);
        }
        
        // If difference is less than the desired threshold, stop iterating
        if (diff < epsilon) {
          // logDebug("Stoped at iteration %s", iter);
          break;
        }
      }
            
      // logDebug("Result:\n" + eigenvector);

      // Construct result
      var res = {
        rank : function(node) {
          if ($$.is.string(node)) {
            // is a selector string
            var nodeId = (cy.filter(node)[0]).id();
          } else {
            // is a node object
            var nodeId = node.id();
          }
          return eigenvector[id2position[nodeId]];
        }
      };


      return res;
    }, // pageRank


    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    // if directed
    //   indegree : function(node) // Returns the normalized indegree of the given node
    //   outdegree: function(node) // Returns the normalized outdegree of the given node
    // if undirected
    //   degree : function(node) // Returns the normalized degree of the given node
    degreeCentralityNormalized: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // directed - optional
      if (options.directed != null) {
        var directed = options.directed;
      } else {
        var directed = false;
      }

      // logDebug("Starting degree centrality...");
      var nodes = this.nodes();
      var numNodes = nodes.length;

      if (!directed) {
        var degrees = {};
        var maxDegree = 0;

        for (var i = 0; i < numNodes; i++) {
          var node = nodes[i];
          // add current node to the current options object and call degreeCentrality 
          var currDegree = this.degreeCentrality($$.util.extend({}, options, {root: node}));
          if (maxDegree < currDegree.degree)
            maxDegree = currDegree.degree;

          degrees[node.id()] = currDegree.degree;
        }

        return {
          degree: function (node) {
            if ($$.is.string(node)) {
              // from is a selector string
              var node = (cy.filter(node)[0]).id();
            } else {
              // from is a node
              var node = node.id();
            }

            return degrees[node] / maxDegree;
          }
        };
      } else {
        var indegrees = {};
        var outdegrees = {};
        var maxIndegree = 0;
        var maxOutdegree = 0;

        for (var i = 0; i < numNodes; i++) {
          var node = nodes[i];
          // add current node to the current options object and call degreeCentrality 
          var currDegree = this.degreeCentrality($$.util.extend({}, options, {root: node}));

          if (maxIndegree < currDegree.indegree)
            maxIndegree = currDegree.indegree;

          if (maxOutdegree < currDegree.outdegree)
            maxOutdegree = currDegree.outdegree;

          indegrees[node.id()] = currDegree.indegree;
          outdegrees[node.id()] = currDegree.outdegree;
        }

        return {
          indegree: function (node) {
            if ($$.is.string(node)) {
              // from is a selector string
              var node = (cy.filter(node)[0]).id();
            } else {
              // from is a node
              var node = node.id();
            }

            return indegrees[node] / maxIndegree;
          },
          outdegree: function (node) {
            if ($$.is.string(node)) {
              // from is a selector string
              var node = (cy.filter(node)[0]).id();
            } else {
              // from is a node
              var node = node.id();
            }

            return outdegrees[node] / maxOutdegree;
          }

        };
      }

    }, // degreeCentralityNormalized

    // Implemented from the algorithm in Opsahl's paper "Node centrality in weighted networks: Generalizing degree and shortest paths" check the heading 2 "Degree"
    // options => options object
    //   node : focal node
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   alpha : alpha value for the algorithm (Benchmark values of alpha: 0 -> disregards the weights focuses on number of edges
    //                                                                     1 -> disregards the number of edges focuses on total amount of weight 
    //   directed // default false
    // retObj => returned object by function
    // if directed
    //   indegree : indegree of the given node
    //   outdegree: outdegree of the given node
    // if undirected
    //   degree : degree of the given node
    degreeCentrality: function (options) {
      options = options || {};

      var callingEles = this;

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting degree centrality...");

      // root - mandatory!
      if (options != null && options.root != null) {
        var root = $$.is.string(options.root) ? this.filter(options.root)[0] : options.root[0];
        // logDebug("Source node: %s", root.id());
      } else {
        return undefined;
      }

      // weight - optional
      if (options.weight != null && $$.is.fn(options.weight)) {
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function (e) {
          return 1;
        };
      }

      // directed - optional
      if (options.directed != null) {
        var directed = options.directed;
      } else {
        var directed = false;
      }

      // alpha - optional
      if (options.alpha != null && $$.is.number(options.alpha)) {
        var alpha = options.alpha;
      } else {
        alpha = 0;
      }


      if (!directed) {
        var connEdges = root.connectedEdges().intersection( callingEles );
        var k = connEdges.length;
        var s = 0;

        // Now, sum edge weights
        for (var i = 0; i < connEdges.length; i++) {
          var edge = connEdges[i];
          s += weightFn.apply(edge, [edge]);
        }

        return {
          degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
        };
      } else {
        var incoming = root.connectedEdges('edge[target = "' + root.id() + '"]').intersection( callingEles );
        var outgoing = root.connectedEdges('edge[source = "' + root.id() + '"]').intersection( callingEles );
        var k_in = incoming.length;
        var k_out = outgoing.length;
        var s_in = 0;
        var s_out = 0;

        // Now, sum incoming edge weights
        for (var i = 0; i < incoming.length; i++) {
          var edge = incoming[i];
          s_in += weightFn.apply(edge, [edge]);
        }

        // Now, sum outgoing edge weights
        for (var i = 0; i < outgoing.length; i++) {
          var edge = outgoing[i];
          s_out += weightFn.apply(edge, [edge]);
        }

        return {
          indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
          outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
        };
      }
    }, // degreeCentrality

    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    //   harmonic // use harmonic mean instead of arithmetic mean
    // retObj => returned object by function
    //   closeness : function(node) // Returns the normalized closeness of the given node
    closenessCentralityNormalized: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting closeness centrality...");

      var harmonic = options.harmonic;
      if( harmonic === undefined ){
        harmonic = true;
      }
 
      var closenesses = {};
      var maxCloseness = 0;
      var nodes = this.nodes();
      var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });

      // Compute closeness for every node and find the maximum closeness
      for(var i = 0; i < nodes.length; i++){
        var currCloseness = 0;
        for (var j = 0; j < nodes.length; j++) {
          if (i != j) {
            var d = fw.distance(nodes[i], nodes[j]);
            
            if( harmonic ){
              currCloseness += 1 / d;
            } else {
              currCloseness += d;
            }
          }
        }
        
        if( !harmonic ){
          currCloseness = 1 / currCloseness;
        }

        if (maxCloseness < currCloseness){
          maxCloseness = currCloseness;
        }

        closenesses[nodes[i].id()] = currCloseness;
      }

      return {
        closeness: function (node) {
          if ($$.is.string(node)) {
            // from is a selector string
            var node = (cy.filter(node)[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return closenesses[node] / maxCloseness;
        }
      };
    },
    // Implemented from pseudocode from wikipedia
    // options => options object
    //   root : focal node
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // closeness => returned value by the function. Closeness value of the given node.
    closenessCentrality: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting closeness centrality...");

      // root - mandatory!
      if (options.root != null) {
        if ($$.is.string(options.root)) {
          // use it as a selector, e.g. "#rootID
          var root = this.filter(options.root)[0];
        } else {
          var root = options.root[0];
        }
        // logDebug("Source node: %s", root.id());
      } else {
        $$.util.error("options.root required");
        return undefined;
      }

      // weight - optional
      if (options.weight != null && $$.is.fn(options.weight)) {
        var weight = options.weight;
      } else {
        var weight = function(){return 1;};
      }

      // directed - optional
      if (options.directed != null && $$.is.bool(options.directed)) {
        var directed = options.directed;
      } else {
        var directed = false;
      }
      
      var harmonic = options.harmonic;
      if( harmonic === undefined ){
        harmonic = true;
      }

      // we need distance from this node to every other node
      var dijkstra = this.dijkstra({
        root: root,
        weight: weight,
        directed: directed
      });
      var totalDistance = 0;

      var nodes = this.nodes();
      for (var i = 0; i < nodes.length; i++){
        if (nodes[i].id() != root.id()){
          var d = dijkstra.distanceTo(nodes[i]);
          
          if( harmonic ){
            totalDistance += 1 / d; 
          } else {
            totalDistance += d;
          }
        }
      }

      return harmonic ? totalDistance : 1 / totalDistance;
    }, // closenessCentrality

    // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   betweenness : function(node) // Returns the betweenness centrality of the given node
    //   betweennessNormalized : function(node) // Returns the normalized betweenness centrality of the given node
    betweennessCentrality: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting betweenness centrality...");

      // Weight - optional
      if (options.weight != null && $$.is.fn(options.weight)) {
        var weightFn = options.weight;
        var weighted = true;
      } else {
        var weighted = false;
      }

      // Directed - default false
      if (options.directed != null && $$.is.bool(options.directed)) {
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var priorityInsert = function (queue, ele) {
        queue.unshift(ele);
        for (var i = 0; d[queue[i]] < d[queue[i + 1]] && i < queue.length - 1; i++) {
          var tmp = queue[i];
          queue[i] = queue[i + 1];
          queue[i + 1] = tmp;
        }
      };

      var cy = this._private.cy;

      // starting
      var V = this.nodes();
      var A = {};
      var C = {};

      // A contains the neighborhoods of every node
      for (var i = 0; i < V.length; i++) {
        if (directed) {
          A[V[i].id()] = V[i].outgoers("node"); // get outgoers of every node
        } else {
          A[V[i].id()] = V[i].openNeighborhood("node"); // get neighbors of every node          
        }
      }

      // C contains the betweenness values
      for (var i = 0; i < V.length; i++) {
        C[V[i].id()] = 0;
      }

      for (var s = 0; s < V.length; s++) {
        var S = []; // stack
        var P = {};
        var g = {};
        var d = {};
        var Q = []; // queue

        // init dictionaries
        for (var i = 0; i < V.length; i++) {
          P[V[i].id()] = [];
          g[V[i].id()] = 0;
          d[V[i].id()] = Number.POSITIVE_INFINITY;
        }

        g[V[s].id()] = 1; // sigma
        d[V[s].id()] = 0; // distance to s

        Q.unshift(V[s].id());

        while (Q.length > 0) {
          var v = Q.pop();
          S.push(v);
          if (weighted) {
            A[v].forEach(function (w) {
              if (cy.$('#' + v).edgesTo(w).length > 0) {
                var edge = cy.$('#' + v).edgesTo(w)[0];
              } else {
                var edge = w.edgesTo('#' + v)[0];
              }
              
              var edgeWeight = weightFn.apply(edge, [edge]);

              if (d[w.id()] > d[v] + edgeWeight) {
                d[w.id()] = d[v] + edgeWeight;
                if (Q.indexOf(w.id()) < 0) { //if w is not in Q
                  priorityInsert(Q, w.id());
                } else { // update position if w is in Q
                  Q.splice(Q.indexOf(w.id()), 1);
                  priorityInsert(Q, w.id());
                }
                g[w.id()] = 0;
                P[w.id()] = [];
              }
              if (d[w.id()] == d[v] + edgeWeight) {
                g[w.id()] = g[w.id()] + g[v];
                P[w.id()].push(v);
              }
            });
          } else {
            A[v].forEach(function (w) {
              if (d[w.id()] == Number.POSITIVE_INFINITY) {
                Q.unshift(w.id());
                d[w.id()] = d[v] + 1;
              }
              if (d[w.id()] == d[v] + 1) {
                g[w.id()] = g[w.id()] + g[v];
                P[w.id()].push(v);
              }
            });
          }
        }

        var e = {};
        for (var i = 0; i < V.length; i++) {
          e[V[i].id()] = 0;
        }

        while (S.length > 0) {
          var w = S.pop();
          P[w].forEach(function (v) {
            e[v] = e[v] + (g[v] / g[w]) * (1 + e[w]);
            if (w != V[s].id())
              C[w] = C[w] + e[w];
          });
        }
      }

      var max = 0;
      for (var key in C) {
        if (max < C[key])
          max = C[key];
      }

      var ret = {
        betweenness: function (node) {
          if ($$.is.string(node)) {
            var node = (cy.filter(node)[0]).id();
          } else {
            var node = node.id();
          }

          return C[node];
        },

        betweennessNormalized: function (node) {
          if ($$.is.string(node)) {
            var node = (cy.filter(node)[0]).id();
          } else {
            var node = node.id();
          }

          return C[node] / max;
        }
      };

      // alias
      ret.betweennessNormalised = ret.betweennessNormalized;

      return ret;
    } // betweennessCentrality
  }); // $$.fn.eles

  // nice, short mathemathical alias
  $$.elesfn.dc = $$.elesfn.degreeCentrality;
  $$.elesfn.dcn = $$.elesfn.degreeCentralityNormalised = $$.elesfn.degreeCentralityNormalized;
  $$.elesfn.cc = $$.elesfn.closenessCentrality;
  $$.elesfn.ccn = $$.elesfn.closenessCentralityNormalised = $$.elesfn.closenessCentralityNormalized;
  $$.elesfn.bc = $$.elesfn.betweennessCentrality;
}) (cytoscape);

;(function( $$ ){ 'use strict';

  $$.fn.eles({
    animated: $$.define.animated(),
    clearQueue: $$.define.clearQueue(),
    delay: $$.define.delay(),
    animate: $$.define.animate(),
    stop: $$.define.stop()
  });
  
})( cytoscape );  

;(function( $$ ){ 'use strict';
  
  $$.fn.eles({
    addClass: function(classes){
      classes = classes.split(/\s+/);
      var self = this;
      var changed = [];
      
      for( var i = 0; i < classes.length; i++ ){
        var cls = classes[i];
        if( $$.is.emptyString(cls) ){ continue; }
        
        for( var j = 0; j < self.length; j++ ){
          var ele = self[j];
          var hasClass = ele._private.classes[cls];
          ele._private.classes[cls] = true;

          if( !hasClass ){ // if didn't already have, add to list of changed
            changed.push( ele );
          }
        }
      }
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(this._private.cy, changed)
          .updateStyle()
          .trigger('class')
        ;
      }

      return self;
    },

    hasClass: function(className){
      var ele = this[0];
      return ( ele != null && ele._private.classes[className] ) ? true : false;
    },

    toggleClass: function(classesStr, toggle){
      var classes = classesStr.split(/\s+/);
      var self = this;
      var changed = []; // eles who had classes changed
      
      for( var i = 0, il = self.length; i < il; i++ ){
        var ele = self[i];

        for( var j = 0; j < classes.length; j++ ){
          var cls = classes[j];

          if( $$.is.emptyString(cls) ){ continue; }
          
          var hasClass = ele._private.classes[cls];
          var shouldAdd = toggle || (toggle === undefined && !hasClass);

          if( shouldAdd ){
            ele._private.classes[cls] = true;

            if( !hasClass ){ changed.push(ele); }
          } else { // then remove
            ele._private.classes[cls] = false;

            if( hasClass ){ changed.push(ele); }
          }

        } // for j classes
      } // for i eles
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(this._private.cy, changed)
          .updateStyle()
          .trigger('class')
        ;
      }

      return self;
    },

    removeClass: function(classes){
      classes = classes.split(/\s+/);
      var self = this;
      var changed = [];

      for( var i = 0; i < self.length; i++ ){
        var ele = self[i];

        for( var j = 0; j < classes.length; j++ ){
          var cls = classes[j];
          if( !cls || cls === '' ){ continue; }

          var hasClass = ele._private.classes[cls];
          ele._private.classes[cls] = undefined;

          if( hasClass ){ // then we changed its set of classes
            changed.push( ele );
          }
        }
      }
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(self._private.cy, changed).updateStyle();
      }

      self.trigger('class');
      return self;
    },

    flashClass: function(classes, duration){
      var self = this;

      if( duration == null ){
        duration = 250;
      } else if( duration === 0 ){
        return self; // nothing to do really
      }

      self.addClass( classes );
      setTimeout(function(){
        self.removeClass( classes );
      }, duration);

      return self;
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({
    allAre: function( selector ){
      return this.filter(selector).length === this.length;
    },

    is: function( selector ){
      return this.filter(selector).length > 0;
    },

    some: function( fn, thisArg ){
      for( var i = 0; i < this.length; i++ ){
        var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );

        if( ret ){
          return true;
        }
      }

      return false;
    },

    every: function( fn, thisArg ){
      for( var i = 0; i < this.length; i++ ){
        var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );

        if( !ret ){
          return false;
        }
      }

      return true;
    },

    same: function( collection ){
      collection = this.cy().collection( collection );

      // cheap extra check
      if( this.length !== collection.length ){
        return false;
      }

      return this.intersect( collection ).length === this.length;
    },

    anySame: function( collection ){
      collection = this.cy().collection( collection );

      return this.intersect( collection ).length > 0;
    },

    allAreNeighbors: function( collection ){
      collection = this.cy().collection( collection );

      return this.neighborhood().intersect( collection ).length === collection.length;
    }
  });

  $$.elesfn.allAreNeighbours = $$.elesfn.allAreNeighbors;
  
})( cytoscape );

;(function($$){ 'use strict';

  // Compound functions
  /////////////////////

  $$.fn.eles({
    parent: function( selector ){
      var parents = [];
      var cy = this._private.cy;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var parent = cy.getElementById( ele._private.data.parent );

        if( parent.size() > 0 ){
          parents.push( parent );
        }
      }
      
      return new $$.Collection( cy, parents, { unique: true } ).filter( selector );
    },

    parents: function( selector ){
      var parents = [];

      var eles = this.parent();
      while( eles.nonempty() ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];
          parents.push( ele );
        }

        eles = eles.parent();
      }

      return new $$.Collection( this.cy(), parents, { unique: true } ).filter( selector );
    },

    commonAncestors: function( selector ){
      var ancestors;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var parents = ele.parents();
        
        ancestors = ancestors || parents;

        ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set
      }

      return ancestors.filter( selector );
    },

    orphans: function( selector ){
      return this.stdFilter(function( ele ){
        return ele.isNode() && ele.parent().empty();
      }).filter( selector );
    },

    nonorphans: function( selector ){
      return this.stdFilter(function( ele ){
        return ele.isNode() && ele.parent().nonempty();
      }).filter( selector );
    },

    children: function( selector ){
      var children = [];

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        children = children.concat( ele._private.children );
      }

      return new $$.Collection( this.cy(), children, { unique: true } ).filter( selector );
    },

    siblings: function( selector ){
      return this.parent().children().not( this ).filter( selector );
    },

    isParent: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.children.length !== 0;
      }
    },

    isChild: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.data.parent !== undefined && ele.parent().length !== 0;
      }
    },

    descendants: function( selector ){
      var elements = [];

      function add( eles ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          elements.push( ele );

          if( ele.children().nonempty() ){
            add( ele.children() );
          }
        }
      }

      add( this.children() );

      return new $$.Collection( this.cy(), elements, { unique: true } ).filter( selector );
    }
  });

  // aliases
  $$.elesfn.ancestors = $$.elesfn.parents;
  
})( cytoscape );
;(function($$){ 'use strict';

  var borderWidthMultiplier = 2 * 0.5;
  var borderWidthAdjustment = 0;

  $$.fn.eles({

    data: $$.define.data({
      field: 'data',
      bindingEvent: 'data',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'data',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true,
      immutableKeys: {
        'id': true,
        'source': true,
        'target': true,
        'parent': true
      },
      updateStyle: true
    }),

    removeData: $$.define.removeData({
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: true,
      immutableKeys: {
        'id': true,
        'source': true,
        'target': true,
        'parent': true
      },
      updateStyle: true
    }),

    scratch: $$.define.data({
      field: 'scratch',
      bindingEvent: 'scratch',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'scratch',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true,
      updateStyle: true
    }),

    removeScratch: $$.define.removeData({
      field: 'scratch',
      event: 'scratch',
      triggerFnName: 'trigger',
      triggerEvent: true,
      updateStyle: true
    }),

    rscratch: $$.define.data({
      field: 'rscratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeRscratch: $$.define.removeData({
      field: 'rscratch',
      triggerEvent: false
    }),

    id: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.data.id;
      }
    },

    position: $$.define.data({
      field: 'position',
      bindingEvent: 'position',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'position',
      settingTriggersEvent: true,
      triggerFnName: 'rtrigger',
      allowGetting: true,
      validKeys: ['x', 'y'],
      onSet: function( eles ){
        var updatedEles = eles.updateCompoundBounds();
        updatedEles.rtrigger('position');
      },
      canSet: function( ele ){
        return !ele.locked();
      }
    }),

    // position but no notification to renderer
    silentPosition: $$.define.data({
      field: 'position',
      bindingEvent: 'position',
      allowBinding: false,
      allowSetting: true,
      settingEvent: 'position',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      allowGetting: true,
      validKeys: ['x', 'y'],
      onSet: function( eles ){
        eles.updateCompoundBounds();
      },
      canSet: function( ele ){
        return !ele.locked();
      }
    }),

    positions: function( pos, silent ){
      if( $$.is.plainObject(pos) ){
        this.position(pos);

      } else if( $$.is.fn(pos) ){
        var fn = pos;

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          var pos = fn.apply(ele, [i, ele]);

          if( pos && !ele.locked() ){
            var elePos = ele._private.position;
            elePos.x = pos.x;
            elePos.y = pos.y;
          }
        }

        var updatedEles = this.updateCompoundBounds();
        var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;

        if( silent ){
          toTrigger.trigger('position');
        } else {
          toTrigger.rtrigger('position');
        }
      }

      return this; // chaining
    },

    silentPositions: function( pos ){
      return this.positions( pos, true );
    },

    updateCompoundBounds: function(){
      var cy = this.cy();

      if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); } // save cycles for non compound graphs or when style disabled

      var updated = [];

      function update( parent ){
        var children = parent.children();
        var style = parent._private.style;
        var includeLabels = style['compound-sizing-wrt-labels'].value === 'include';
        var bb = children.boundingBox({ includeLabels: includeLabels, includeEdges: true });
        var padding = {
          top: style['padding-top'].pxValue,
          bottom: style['padding-bottom'].pxValue,
          left: style['padding-left'].pxValue,
          right: style['padding-right'].pxValue
        };
        var pos = parent._private.position;
        var didUpdate = false;

        if( style['width'].value === 'auto' ){
          parent._private.autoWidth = bb.w + padding.left + padding.right;
          pos.x = (bb.x1 + bb.x2 - padding.left + padding.right)/2;
          didUpdate = true;
        }

        if( style['height'].value === 'auto' ){
          parent._private.autoHeight = bb.h + padding.top + padding.bottom;
          pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom)/2;
          didUpdate = true;
        }

        if( didUpdate ){
          updated.push( parent );
        }
      }

      // go up, level by level
      var eles = this.parent();
      while( eles.nonempty() ){

        // update each parent node in this level
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          update( ele );
        }

        // next level
        eles = eles.parent();
      }

      // return changed
      return new $$.Collection( cy, updated );
    },

    // get/set the rendered (i.e. on screen) positon of the element
    renderedPosition: function( dim, val ){
      var ele = this[0];
      var cy = this.cy();
      var zoom = cy.zoom();
      var pan = cy.pan();
      var rpos = $$.is.plainObject( dim ) ? dim : undefined;
      var setting = rpos !== undefined || ( val !== undefined && $$.is.string(dim) );

      if( ele && ele.isNode() ){ // must have an element and must be a node to return position
        if( setting ){
          for( var i = 0; i < this.length; i++ ){
            var ele = this[i];

            if( val !== undefined ){ // set one dimension
              ele._private.position[dim] = ( val - pan[dim] )/zoom;
            } else if( rpos !== undefined ){ // set whole position
              ele._private.position = {
                x: ( rpos.x - pan.x ) /zoom,
                y: ( rpos.y - pan.y ) /zoom
              };
            }
          }

          this.rtrigger('position');
        } else { // getting
          var pos = ele._private.position;
          rpos = {
            x: pos.x * zoom + pan.x,
            y: pos.y * zoom + pan.y
          };

          if( dim === undefined ){ // then return the whole rendered position
            return rpos;
          } else { // then return the specified dimension
            return rpos[ dim ];
          }
        }
      } else if( !setting ){
        return undefined; // for empty collection case
      }

      return this; // chaining
    },

    // get/set the position relative to the parent
    relativePosition: function( dim, val ){
      var ele = this[0];
      var cy = this.cy();
      var ppos = $$.is.plainObject( dim ) ? dim : undefined;
      var setting = ppos !== undefined || ( val !== undefined && $$.is.string(dim) );
      var hasCompoundNodes = cy.hasCompoundNodes();

      if( ele && ele.isNode() ){ // must have an element and must be a node to return position
        if( setting ){
          for( var i = 0; i < this.length; i++ ){
            var ele = this[i];
            var parent = hasCompoundNodes ? ele.parent() : null;
            var hasParent = parent && parent.length > 0;
            var relativeToParent = hasParent;

            if( hasParent ){
              parent = parent[0];
            }

            var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

            if( val !== undefined ){ // set one dimension
              ele._private.position[dim] = val + origin[dim];
            } else if( ppos !== undefined ){ // set whole position
              ele._private.position = {
                x: ppos.x + origin.x,
                y: ppos.y + origin.y,
              };
            }
          }

          this.rtrigger('position');

        } else { // getting
          var pos = ele._private.position;
          var parent = hasCompoundNodes ? ele.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if( hasParent ){
            parent = parent[0];
          }

          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

          ppos = {
            x: pos.x - origin.x,
            y: pos.y - origin.y
          };

          if( dim === undefined ){ // then return the whole rendered position
            return ppos;
          } else { // then return the specified dimension
            return ppos[ dim ];
          }
        }
      } else if( !setting ){
        return undefined; // for empty collection case
      }

      return this; // chaining
    },

    // convenience function to get a numerical value for the width of the node/edge
    width: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele ){
        if( styleEnabled ){
          var w = ele._private.style.width;
          return w.strValue === 'auto' ? ele._private.autoWidth : w.pxValue;
        } else {
          return 1;
        }
      }
    },

    outerWidth: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele ){
        if( styleEnabled ){
          var style = ele._private.style;
          var width = style.width.strValue === 'auto' ? ele._private.autoWidth : style.width.pxValue;
          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;

          return width + border;
        } else {
          return 1;
        }
      }
    },

    renderedWidth: function(){
      var ele = this[0];

      if( ele ){
        var width = ele.width();
        return width * this.cy().zoom();
      }
    },

    renderedOuterWidth: function(){
      var ele = this[0];

      if( ele ){
        var owidth = ele.outerWidth();
        return owidth * this.cy().zoom();
      }
    },

    // convenience function to get a numerical value for the height of the node
    height: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele && ele._private.group === 'nodes' ){
        if( styleEnabled ){
          var h = ele._private.style.height;
          return h.strValue === 'auto' ? ele._private.autoHeight : h.pxValue;
        } else {
          return 1;
        }
      }
    },

    outerHeight: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele && ele._private.group === 'nodes' ){
        if( styleEnabled ){
          var style = ele._private.style;
          var height = style.height.strValue === 'auto' ? ele._private.autoHeight : style.height.pxValue;
          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;
        } else {
          return 1;
        }

        return height + border;
      }
    },

    renderedHeight: function(){
      var ele = this[0];

      if( ele && ele._private.group === 'nodes' ){
        var height = ele.height();
        return height * this.cy().zoom();
      }
    },

    renderedOuterHeight: function(){
      var ele = this[0];

      if( ele && ele._private.group === 'nodes' ){
        var oheight = ele.outerHeight();
        return oheight * this.cy().zoom();
      }
    },

    renderedBoundingBox: function( options ){
      var bb = this.boundingBox( options );
      var cy = this.cy();
      var zoom = cy.zoom();
      var pan = cy.pan();

      var x1 = bb.x1 * zoom + pan.x;
      var x2 = bb.x2 * zoom + pan.x;
      var y1 = bb.y1 * zoom + pan.y;
      var y2 = bb.y2 * zoom + pan.y;

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
      };
    },

    // get the bounding box of the elements (in raw model position)
    boundingBox: function( options ){
      var eles = this;
      var cy = eles._private.cy;
      var cy_p = cy._private;
      var styleEnabled = cy_p.styleEnabled;

      options = options || {};

      var includeNodes = options.includeNodes === undefined ? true : options.includeNodes;
      var includeEdges = options.includeEdges === undefined ? true : options.includeEdges;
      var includeLabels = options.includeLabels === undefined ? true : options.includeLabels;

      // recalculate projections etc
      if( styleEnabled ){
        cy_p.renderer.recalculateRenderedStyle( this );
      }

      var x1 = Infinity;
      var x2 = -Infinity;
      var y1 = Infinity;
      var y2 = -Infinity;

      // find bounds of elements
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var _p = ele._private;
        var style = _p.style;
        var display = styleEnabled ? _p.style['display'].value : 'element';
        var isNode = _p.group === 'nodes';
        var ex1, ex2, ey1, ey2, x, y;
        var includedEle = false;

        if( display === 'none' ){ continue; } // then ele doesn't take up space

        if( isNode && includeNodes ){
          includedEle = true;

          var pos = _p.position;
          x = pos.x;
          y = pos.y;
          var w = ele.outerWidth();
          var halfW = w/2;
          var h = ele.outerHeight();
          var halfH = h/2;

          // handle node dimensions
          /////////////////////////

          ex1 = x - halfW;
          ex2 = x + halfW;
          ey1 = y - halfH;
          ey2 = y + halfH;

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;

        } else if( ele.isEdge() && includeEdges ){
          includedEle = true;

          var n1 = _p.source;
          var n1_p = n1._private;
          var n1pos = n1_p.position;
          
          var n2 = _p.target;
          var n2_p = n2._private;
          var n2pos = n2_p.position;
          

          // handle edge dimensions (rough box estimate)
          //////////////////////////////////////////////

          var rstyle = _p.rstyle || {};

          ex1 = n1pos.x;
          ex2 = n2pos.x;
          ey1 = n1pos.y;
          ey2 = n2pos.y;
          
          if( ex1 > ex2 ){
            var temp = ex1;
            ex1 = ex2;
            ex2 = temp;
          }

          if( ey1 > ey2 ){
            var temp = ey1;
            ey1 = ey2;
            ey2 = temp;
          }

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;

          // handle points along edge (sanity check)
          //////////////////////////////////////////

          if( styleEnabled ){
            var bpts = rstyle.bezierPts || [];

            var w = style['width'].pxValue;
            var wHalf = w/2;

            for( var j = 0; j < bpts.length; j++ ){
              var bpt = bpts[j];

              ex1 = bpt.x - wHalf;
              ex2 = bpt.x + wHalf;
              ey1 = bpt.y - wHalf;
              ey2 = bpt.y + wHalf;

              x1 = ex1 < x1 ? ex1 : x1;
              x2 = ex2 > x2 ? ex2 : x2;
              y1 = ey1 < y1 ? ey1 : y1;
              y2 = ey2 > y2 ? ey2 : y2;
            }
          }
          
          // precise haystacks (sanity check)
          ///////////////////////////////////
          
          if( styleEnabled && style['curve-style'].strValue === 'haystack' ){
            var hpts = _p.rscratch.haystackPts;
            
            ex1 = hpts[0];
            ey1 = hpts[1];
            ex2 = hpts[2];
            ey2 = hpts[3];

            if( ex1 > ex2 ){
              var temp = ex1;
              ex1 = ex2;
              ex2 = temp;
            }

            if( ey1 > ey2 ){
              var temp = ey1;
              ey1 = ey2;
              ey2 = temp;
            }

            x1 = ex1 < x1 ? ex1 : x1;
            x2 = ex2 > x2 ? ex2 : x2;
            y1 = ey1 < y1 ? ey1 : y1;
            y2 = ey2 > y2 ? ey2 : y2;  
          }

        } // edges
            

        // handle label dimensions
        //////////////////////////

        if( styleEnabled ){

          var style = ele._private.style;
          var rstyle = ele._private.rstyle;
          var label = style['content'].strValue;
          var fontSize = style['font-size'];
          var halign = style['text-halign'];
          var valign = style['text-valign'];
          var labelWidth = rstyle.labelWidth;
          var labelHeight = rstyle.labelHeight;
          var labelX = rstyle.labelX;
          var labelY = rstyle.labelY;

          if( includedEle && includeLabels && label && fontSize && labelHeight != null && labelWidth != null && labelX != null && labelY != null && halign && valign ){
            var lh = labelHeight;
            var lw = labelWidth;
            var lx1, lx2, ly1, ly2;

            if( ele.isEdge() ){
              lx1 = labelX - lw/2;
              lx2 = labelX + lw/2;
              ly1 = labelY - lh/2;
              ly2 = labelY + lh/2;
            } else {
              switch( halign.value ){
                case 'left':
                  lx1 = labelX - lw;
                  lx2 = labelX;
                  break;

                case 'center':
                  lx1 = labelX - lw/2;
                  lx2 = labelX + lw/2;
                  break;

                case 'right':
                  lx1 = labelX;
                  lx2 = labelX + lw;
                  break;
              }

              switch( valign.value ){
                case 'top':
                  ly1 = labelY - lh;
                  ly2 = labelY;
                  break;

                case 'center':
                  ly1 = labelY - lh/2;
                  ly2 = labelY + lh/2;
                  break;

                case 'bottom':
                  ly1 = labelY;
                  ly2 = labelY + lh;
                  break;
              }
            }

            x1 = lx1 < x1 ? lx1 : x1;
            x2 = lx2 > x2 ? lx2 : x2;
            y1 = ly1 < y1 ? ly1 : y1;
            y2 = ly2 > y2 ? ly2 : y2;
          }
        } // style enabled
      } // for

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
      };
    }
  });

  // aliases
  var fn = $$.elesfn;
  fn.attr = fn.data;
  fn.removeAttr = fn.removeData;
  fn.modelPosition = fn.point = fn.position;
  fn.modelPositions = fn.points = fn.positions;
  fn.renderedPoint = fn.renderedPosition;
  fn.relativePoint = fn.relativePosition;
  fn.boundingbox = fn.boundingBox;
  fn.renderedBoundingbox = fn.renderedBoundingBox;

})( cytoscape );

;(function( $$ ){ 'use strict';
  
  // Regular degree functions (works on single element)
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  function defineDegreeFunction(callback){
    return function( includeLoops ){
      var self = this;

      if( includeLoops === undefined ){
        includeLoops = true;
      }
      
      if( self.length === 0 ){ return; }

      if( self.isNode() && !self.removed() ){
        var degree = 0;
        var node = self[0];
        var connectedEdges = node._private.edges;

        for( var i = 0; i < connectedEdges.length; i++ ){
          var edge = connectedEdges[i];

          if( !includeLoops && edge.isLoop() ){
            continue;
          }

          degree += callback( node, edge );
        }
        
        return degree;
      } else {
        return;
      }
    };
  }
  
  $$.fn.eles({
    degree: defineDegreeFunction(function(node, edge){
      if( edge.source().same( edge.target() ) ){
        return 2;
      } else {
        return 1;
      }
    }),

    indegree: defineDegreeFunction(function(node, edge){
      if( edge.target().same(node) ){
        return 1;
      } else {
        return 0;
      }
    }),

    outdegree: defineDegreeFunction(function(node, edge){
      if( edge.source().same(node) ){
        return 1;
      } else {
        return 0;
      }
    })
  });
  
  
  // Collection degree stats
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  function defineDegreeBoundsFunction(degreeFn, callback){
    return function( includeLoops ){
      var ret;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        var ele = nodes[i];
        var degree = ele[degreeFn]( includeLoops );
        if( degree !== undefined && (ret === undefined || callback(degree, ret)) ){
          ret = degree;
        }
      }
      
      return ret;
    };
  }
  
  $$.fn.eles({
    minDegree: defineDegreeBoundsFunction('degree', function(degree, min){
      return degree < min;
    }),

    maxDegree: defineDegreeBoundsFunction('degree', function(degree, max){
      return degree > max;
    }),

    minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min){
      return degree < min;
    }),

    maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max){
      return degree > max;
    }),

    minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min){
      return degree < min;
    }),

    maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max){
      return degree > max;
    })
  });
  
  $$.fn.eles({
    totalDegree: function( includeLoops ){
      var total = 0;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        total += nodes[i].degree( includeLoops );
      }

      return total;
    }
  });
  
})( cytoscape );

  
;(function($$){ 'use strict';
  
  // Functions for binding & triggering events
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({
    on: $$.define.on(), // .on( events [, selector] [, data], handler)
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    once: $$.define.on({ unbindAllBindersOnTrigger: true }),
    off: $$.define.off(), // .off( events [, selector] [, handler] )
    trigger: $$.define.trigger(), // .trigger( events [, extraParams] )

    rtrigger: function(event, extraParams){ // for internal use only
      if( this.length === 0 ){ return; } // empty collections don't need to notify anything

      // notify renderer
      this.cy().notify({
        type: event,
        collection: this
      });
      
      this.trigger(event, extraParams);
      return this;
    }
  });

  // aliases:
  $$.define.eventAliasesOn( $$.elesfn );
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({
    nodes: function( selector ){
      return this.filter(function(i, element){
        return element.isNode();
      }).filter(selector);
    },

    edges: function( selector ){
      return this.filter(function(i, element){
        return element.isEdge();
      }).filter(selector);
    },

    filter: function( filter ){
      var cy = this._private.cy;
      
      if( $$.is.fn(filter) ){
        var elements = [];

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( filter.apply(ele, [i, ele]) ){
            elements.push(ele);
          }
        }
        
        return new $$.Collection(cy, elements);
      
      } else if( $$.is.string(filter) || $$.is.elementOrCollection(filter) ){
        return new $$.Selector(filter).filter(this);
      
      } else if( filter === undefined ){
        return this;
      }

      return new $$.Collection( cy ); // if not handled by above, give 'em an empty collection
    },

    not: function( toRemove ){
      var cy = this._private.cy;

      if( !toRemove ){
        return this;
      } else {
      
        if( $$.is.string( toRemove ) ){
          toRemove = this.filter( toRemove );
        }
        
        var elements = [];
        
        for( var i = 0; i < this.length; i++ ){
          var element = this[i];

          var remove = toRemove._private.ids[ element.id() ];
          if( !remove ){
            elements.push( element );
          }
        }
        
        return new $$.Collection( cy, elements );
      }
      
    },

    absoluteComplement: function(){
      var cy = this._private.cy;

      return cy.elements().not( this );
    },

    intersect: function( other ){
      var cy = this._private.cy;
      
      // if a selector is specified, then filter by it instead
      if( $$.is.string(other) ){
        var selector = other;
        return this.filter( selector );
      }
      
      var elements = [];
      var col1 = this;
      var col2 = other;
      var col1Smaller = this.length < other.length;
      // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;
      var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;
      var col = col1Smaller ? col1 : col2;
      
      for( var i = 0; i < col.length; i++ ){
        var id = col[i]._private.data.id;
        var ele = ids2[ id ];

        if( ele ){
          elements.push( ele );
        }
      }
      
      return new $$.Collection( cy, elements );
    },

    xor: function( other ){
      var cy = this._private.cy;

      if( $$.is.string(other) ){
        other = cy.$( other );
      }

      var elements = [];
      var col1 = this;
      var col2 = other;
      
      var add = function( col, other ){

        for( var i = 0; i < col.length; i++ ){
          var ele = col[i];
          var id = ele._private.data.id;
          var inOther = other._private.ids[ id ];
          
          if( !inOther ){
            elements.push( ele );
          }
        }

      };

      add( col1, col2 );
      add( col2, col1 );

      return new $$.Collection( cy, elements );
    },  

    diff: function( other ){
      var cy = this._private.cy;

      if( $$.is.string(other) ){
        other = cy.$( other );
      }

      var left = [];
      var right = [];
      var both = [];
      var col1 = this;
      var col2 = other;

      var add = function( col, other, retEles ){

        for( var i = 0; i < col.length; i++ ){
          var ele = col[i];
          var id = ele._private.data.id;
          var inOther = other._private.ids[ id ];
          
          if( inOther ){
            both.push( ele );
          } else {
            retEles.push( ele );
          }
        }

      };

      add( col1, col2, left );
      add( col2, col1, right );

      return {
        left: new $$.Collection( cy, left, { unique: true } ),
        right: new $$.Collection( cy, right, { unique: true } ),
        both: new $$.Collection( cy, both, { unique: true } )
      };
    },

    add: function( toAdd ){
      var cy = this._private.cy;    
      
      if( !toAdd ){
        return this;
      }
      
      if( $$.is.string(toAdd) ){
        var selector = toAdd;
        toAdd = cy.elements(selector);
      }
      
      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        elements.push( this[i] );
      }

      for( var i = 0; i < toAdd.length; i++ ){

        var add = !this._private.ids[ toAdd[i].id() ];
        if( add ){
          elements.push( toAdd[i] );
        }
      }
      
      return new $$.Collection(cy, elements);
    },

    // in place merge on calling collection
    merge: function( toAdd ){
      var _p = this._private;
      var cy = _p.cy;    
      
      if( !toAdd ){
        return this;
      }
      
      if( $$.is.string(toAdd) ){
        var selector = toAdd;
        toAdd = cy.elements(selector);
      }

      for( var i = 0; i < toAdd.length; i++ ){
        var toAddEle = toAdd[i];
        var id = toAddEle.id();
        var add = !_p.ids[ id ];

        if( add ){
          var index = this.length++;

          this[ index ] = toAddEle;
          _p.ids[ id ] = toAddEle;
          _p.indexes[ id ] = index;
        }
      }
      
      return this; // chaining
    },

    // remove single ele in place in calling collection
    unmergeOne: function( ele ){
      ele = ele[0];

      var _p = this._private;
      var id = ele.id();
      var i = _p.indexes[ id ];

      if( i == null ){
        return this; // no need to remove
      }

      // remove ele
      this[i] = undefined;
      _p.ids[ id ] = undefined;
      _p.indexes[ id ] = undefined;

      var unmergedLastEle = i === this.length - 1;

      // replace empty spot with last ele in collection
      if( this.length > 1 && !unmergedLastEle ){
        var lastEleI = this.length - 1;
        var lastEle = this[ lastEleI ];

        this[ lastEleI ] = undefined;
        this[i] = lastEle;
        _p.indexes[ lastEle.id() ] = i;
      }

      // the collection is now 1 ele smaller
      this.length--;

      return this;
    },

    // remove eles in place on calling collection
    unmerge: function( toRemove ){
      var cy = this._private.cy;    
      
      if( !toRemove ){
        return this;
      }

      if( $$.is.string(toRemove) ){
        var selector = toRemove;
        toRemove = cy.elements(selector);
      }

      for( var i = 0; i < toRemove.length; i++ ){
        this.unmergeOne( toRemove[i] );
      }
      
      return this; // chaining
    },

    map: function( mapFn, thisArg ){
      var arr = [];
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var ret = thisArg ? mapFn.apply( thisArg, [ele, i, eles] ) : mapFn( ele, i, eles );

        arr.push( ret );
      }

      return arr;
    },

    stdFilter: function( fn, thisArg ){
      var filterEles = [];
      var eles = this;
      var cy = this._private.cy;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var include = thisArg ? fn.apply( thisArg, [ele, i, eles] ) : fn( ele, i, eles );

        if( include ){
          filterEles.push( ele );
        }
      }

      return new $$.Collection( cy, filterEles );
    },

    max: function( valFn, thisArg ){
      var max = -Infinity;
      var maxEle;
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

        if( val > max ){
          max = val;
          maxEle = ele;
        }
      }

      return {
        value: max,
        ele: maxEle
      };
    },

    min: function( valFn, thisArg ){
      var min = Infinity;
      var minEle;
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

        if( val < min ){
          min = val;
          minEle = ele;
        }
      }

      return {
        value: min,
        ele: minEle
      };
    }
  });

  // aliases
  var fn = $$.elesfn;
  fn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;
  fn['\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.not;
  fn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;
  fn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;
  fn.fnFilter = fn.filterFn = fn.stdFilter;
  fn.complement = fn.abscomp = fn.absoluteComplement;
  
})( cytoscape );
;(function($$){ 'use strict';

  $$.fn.eles({
    isNode: function(){
      return this.group() === 'nodes';
    },

    isEdge: function(){
      return this.group() === 'edges';
    },

    isLoop: function(){
      return this.isEdge() && this.source().id() === this.target().id();
    },

    isSimple: function(){
      return this.isEdge() && this.source().id() !== this.target().id();
    },

    group: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.group;
      }
    }
  });

  
})( cytoscape );

;(function($$){ 'use strict';
  
  // Functions for iterating over collections
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({
    each: function(fn){
      if( $$.is.fn(fn) ){
        for(var i = 0; i < this.length; i++){
          var ele = this[i];
          var ret = fn.apply( ele, [ i, ele ] );

          if( ret === false ){ break; } // exit each early on return false
        }
      }
      return this;
    },

    forEach: function(fn, thisArg){
      if( $$.is.fn(fn) ){

        for(var i = 0; i < this.length; i++){
          var ele = this[i];
          var ret = thisArg ? fn.apply( thisArg, [ ele, i, this ] ) : fn( ele, i, this );

          if( ret === false ){ break; } // exit each early on return false
        }
      }

      return this;
    },

    toArray: function(){
      var array = [];
      
      for(var i = 0; i < this.length; i++){
        array.push( this[i] );
      }
      
      return array;
    },

    slice: function(start, end){
      var array = [];
      var thisSize = this.length;
      
      if( end == null ){
        end = thisSize;
      }

      if( start == null ){
        start = 0;
      }
      
      if( start < 0 ){
        start = thisSize + start;
      }

      if( end < 0 ){
        end = thisSize + end;
      }
      
      for(var i = start; i >= 0 && i < end && i < thisSize; i++){
        array.push( this[i] );
      }
      
      return new $$.Collection(this.cy(), array);
    },

    size: function(){
      return this.length;
    },

    eq: function(i){
      return this[i] || new $$.Collection( this.cy() );
    },

    first: function(){
      return this[0] || new $$.Collection( this.cy() );
    },

    last: function(){
      return this[ this.length - 1 ] || new $$.Collection( this.cy() );
    },

    empty: function(){
      return this.length === 0;
    },

    nonempty: function(){
      return !this.empty();
    },

    sort: function( sortFn ){
      if( !$$.is.fn( sortFn ) ){
        return this;
      }

      var cy = this.cy();      
      var sorted = this.toArray().sort( sortFn );

      return new $$.Collection(cy, sorted);
    },

    sortByZIndex: function(){
      return this.sort( $$.Collection.zIndexSort );
    },

    zDepth: function(){
      var ele = this[0];
      if( !ele ){ return undefined; }

      // var cy = ele.cy();
      var _p = ele._private;
      var group = _p.group;

      if( group === 'nodes' ){
        var depth = _p.data.parent ? ele.parents().size() : 0;
        
        if( !ele.isParent() ){
          return Number.MAX_VALUE; // childless nodes always on top
        }
        
        return depth;
      } else {
        var src = _p.source;
        var tgt = _p.target;
        var srcDepth = src.zDepth();
        var tgtDepth = tgt.zDepth();

        return Math.max( srcDepth, tgtDepth, 0 ); // depth of deepest parent
      }
    }
  });

  $$.Collection.zIndexSort = function(a, b){
    var cy = a.cy();
    var a_p = a._private;
    var b_p = b._private;
    var zDiff = a_p.style['z-index'].value - b_p.style['z-index'].value;
    var depthA = 0;
    var depthB = 0;
    var hasCompoundNodes = cy.hasCompoundNodes();
    var aIsNode = a_p.group === 'nodes';
    var aIsEdge = a_p.group === 'edges';
    var bIsNode = b_p.group === 'nodes';
    var bIsEdge = b_p.group === 'edges';

    // no need to calculate element depth if there is no compound node
    if( hasCompoundNodes ){
      depthA = a.zDepth();
      depthB = b.zDepth();
    }

    var depthDiff = depthA - depthB;
    var sameDepth = depthDiff === 0;

    if( sameDepth ){
      
      if( aIsNode && bIsEdge ){      
        return 1; // 'a' is a node, it should be drawn later       
      
      } else if( aIsEdge && bIsNode ){
        return -1; // 'a' is an edge, it should be drawn first

      } else { // both nodes or both edges        
        if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)
          return a_p.index - b_p.index;
        } else {
          return zDiff;
        }
      }
    
    // elements on different level
    } else {      
      return depthDiff; // deeper element should be drawn later
    }

  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  // Functions for layouts on nodes
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({

    // using standard layout options, apply position function (w/ or w/o animation)
    layoutPositions: function( layout, options, fn ){
      var nodes = this.nodes();
      var cy = this.cy();

      layout.trigger({ type: 'layoutstart', layout: layout });

      if( options.animate ){
        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var lastNode = i === nodes.length - 1;

          var newPos = fn.call( node, i, node );
          var pos = node.position();

          if( !$$.is.number(pos.x) || !$$.is.number(pos.y) ){
            node.silentPosition({ x: 0, y: 0 });
          }

          node.animate({
            position: newPos
          }, {
            duration: options.animationDuration,
            step: !lastNode ? undefined : function(){
              if( options.fit ){
                cy.fit( options.eles, options.padding );
              } 
            },
            complete: !lastNode ? undefined : function(){
              if( options.zoom != null ){
                cy.zoom( options.zoom );
              }

              if( options.pan ){
                cy.pan( options.pan );
              } 

              if( options.fit ){
                cy.fit( options.eles, options.padding );
              } 
              
              layout.one('layoutstop', options.stop);
              layout.trigger({ type: 'layoutstop', layout: layout });
            }
          });
        }

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
      } else {
        nodes.positions( fn );

        if( options.fit ){
          cy.fit( options.eles, options.padding );
        }

        if( options.zoom != null ){
          cy.zoom( options.zoom );
        }

        if( options.pan ){
          cy.pan( options.pan );
        } 

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
        
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      }

      return this; // chaining
    },

    layout: function( options ){
      var cy = this.cy();

      cy.layout( $$.util.extend({}, options, {
        eles: this
      }) );

      return this;
    },

    makeLayout: function( options ){
      var cy = this.cy();

      return cy.makeLayout( $$.util.extend({}, options, {
        eles: this
      }) );
    }

  });

  // aliases:
  $$.elesfn.createLayout = $$.elesfn.makeLayout;
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({

    // fully updates (recalculates) the style for the elements
    updateStyle: function( notifyRenderer ){
      var cy = this._private.cy;

      if( !cy.styleEnabled() ){ return this; }

      if( cy._private.batchingStyle ){
        var bEles = cy._private.batchStyleEles;

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( !bEles.ids[ ele._private.id ] ){
            bEles.push( ele );
          }
        }

        return this; // chaining and exit early when batching
      }

      var style = cy.style();
      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

      style.apply( this );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

      if( notifyRenderer ){
        toNotify.rtrigger('style'); // let renderer know we changed style
      } else {
        toNotify.trigger('style'); // just fire the event
      }
      return this; // chaining
    },

    // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
    updateMappers: function( notifyRenderer ){
      var cy = this._private.cy;
      var style = cy.style();
      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

      if( !cy.styleEnabled() ){ return this; }

      style.updateMappers( this );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

      if( notifyRenderer ){
        toNotify.rtrigger('style'); // let renderer know we changed style
      } else {
        toNotify.trigger('style'); // just fire the event
      }
      return this; // chaining
    },

    // get the specified css property as a rendered value (i.e. on-screen value)
    // or get the whole rendered style if no property specified (NB doesn't allow setting)
    renderedCss: function( property ){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return this; }

      var ele = this[0];

      if( ele ){
        var renstyle = ele.cy().style().getRenderedStyle( ele );

        if( property === undefined ){
          return renstyle;
        } else {
          return renstyle[ property ];
        }
      }
    },

    // read the calculated css style of the element or override the style (via a bypass)
    css: function( name, value ){
      var cy = this.cy();
      
      if( !cy.styleEnabled() ){ return this; }

      var updateTransitions = false;
      var style = cy.style();

      if( $$.is.plainObject(name) ){ // then extend the bypass
        var props = name;
        style.applyBypass( this, props, updateTransitions );

        var updatedCompounds = this.updateCompoundBounds();
        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
        toNotify.rtrigger('style'); // let the renderer know we've updated style

      } else if( $$.is.string(name) ){
  
        if( value === undefined ){ // then get the property from the style
          var ele = this[0];

          if( ele ){
            return ele._private.style[ name ].strValue;
          } else { // empty collection => can't get any value
            return;
          }

        } else { // then set the bypass with the property value
          style.applyBypass( this, name, value, updateTransitions );

          var updatedCompounds = this.updateCompoundBounds();
          var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
          toNotify.rtrigger('style'); // let the renderer know we've updated style
        }

      } else if( name === undefined ){
        var ele = this[0];

        if( ele ){
          return style.getRawStyle( ele );
        } else { // empty collection => can't get any value
          return;
        }
      }

      return this; // chaining
    },

    removeCss: function( names ){
      var cy = this.cy();
      
      if( !cy.styleEnabled() ){ return this; }

      var updateTransitions = false;
      var style = cy.style();
      var eles = this;

      if( names === undefined ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          style.removeAllBypasses( ele, updateTransitions );
        }
      } else {
        names = names.split(/\s+/);

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          style.removeBypasses( ele, names, updateTransitions );
        }
      }

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
      toNotify.rtrigger('style'); // let the renderer know we've updated style

      return this; // chaining
    },

    show: function(){
      this.css('display', 'element');
      return this; // chaining
    },

    hide: function(){
      this.css('display', 'none');
      return this; // chaining
    },

    visible: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return true; }

      var ele = this[0];
      var hasCompoundNodes = cy.hasCompoundNodes();

      if( ele ){
        var style = ele._private.style;

        if(
          style['visibility'].value !== 'visible'
          || style['display'].value !== 'element'
        ){
          return false;
        }
        
        if( ele._private.group === 'nodes' ){
          if( !hasCompoundNodes ){ return true; }

          var parents = ele._private.data.parent ? ele.parents() : null;

          if( parents ){
            for( var i = 0; i < parents.length; i++ ){
              var parent = parents[i];
              var pStyle = parent._private.style;
              var pVis = pStyle['visibility'].value;
              var pDis = pStyle['display'].value;

              if( pVis !== 'visible' || pDis !== 'element' ){
                return false;
              }
            }
          }

          return true;
        } else {
          var src = ele._private.source;
          var tgt = ele._private.target;

          return src.visible() && tgt.visible();
        }

      }
    },

    hidden: function(){
      var ele = this[0];

      if( ele ){
        return !ele.visible();
      }
    },

    effectiveOpacity: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return 1; }

      var hasCompoundNodes = cy.hasCompoundNodes();
      var ele = this[0];

      if( ele ){
        var _p = ele._private;
        var parentOpacity = _p.style.opacity.value;

        if( !hasCompoundNodes ){ return parentOpacity; }

        var parents = !_p.data.parent ? null : ele.parents();
        
        if( parents ){
          for( var i = 0; i < parents.length; i++ ){
            var parent = parents[i];
            var opacity = parent._private.style.opacity.value;

            parentOpacity = opacity * parentOpacity;
          }
        }

        return parentOpacity;
      }
    },

    transparent: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return false; }

      var ele = this[0];
      var hasCompoundNodes = ele.cy().hasCompoundNodes();

      if( ele ){
        if( !hasCompoundNodes ){
          return ele._private.style.opacity.value === 0;
        } else {
          return ele.effectiveOpacity() === 0;
        }
      }
    },

    isFullAutoParent: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return false; }

      var ele = this[0];

      if( ele ){
        var autoW = ele._private.style['width'].value === 'auto';
        var autoH = ele._private.style['height'].value === 'auto';

        return ele.isParent() && autoW && autoH;
      }
    },

    backgrounding: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return false; }

      var ele = this[0];

      return ele._private.backgrounding ? true : false;
    }

  });


  $$.elesfn.bypass = $$.elesfn.style = $$.elesfn.css;
  $$.elesfn.renderedStyle = $$.elesfn.renderedCss;
  $$.elesfn.removeBypass = $$.elesfn.removeStyle = $$.elesfn.removeCss;
  
})( cytoscape );
;(function($$){ 'use strict';
  
  // Collection functions that toggle a boolean value
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  
  function defineSwitchFunction(params){
    return function(){
      var args = arguments;
      var changedEles = [];
      
      // e.g. cy.nodes().select( data, handler )
      if( args.length === 2 ){
        var data = args[0];
        var handler = args[1];
        this.bind( params.event, data, handler );
      } 
      
      // e.g. cy.nodes().select( handler )
      else if( args.length === 1 ){
        var handler = args[0];
        this.bind( params.event, handler );
      }
      
      // e.g. cy.nodes().select()
      else if( args.length === 0 ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];
          var able = !params.ableField || ele._private[params.ableField];
          var changed = ele._private[params.field] != params.value;

          if( params.overrideAble ){
            var overrideAble = params.overrideAble(ele);

            if( overrideAble !== undefined ){
              able = overrideAble;

              if( !overrideAble ){ return this; } // to save cycles assume not able for all on override
            }
          }

          if( able ){
            ele._private[params.field] = params.value;

            if( changed ){
              changedEles.push( ele );
            }
          }
        }

        var changedColl = $$.Collection( this.cy(), changedEles );
        changedColl.updateStyle(); // change of state => possible change of style
        changedColl.trigger( params.event );
      }

      return this;
    };
  }
  
  function defineSwitchSet( params ){
    $$.elesfn[ params.field ] = function(){
      var ele = this[0];

      if( ele ){
        if( params.overrideField ){
          var val = params.overrideField(ele);

          if( val !== undefined ){
            return val;
          }
        }

        return ele._private[ params.field ];
      }
    };
    
    $$.elesfn[ params.on ] = defineSwitchFunction({
      event: params.on,
      field: params.field,
      ableField: params.ableField,
      overrideAble: params.overrideAble,
      value: true
    });

    $$.elesfn[ params.off ] = defineSwitchFunction({
      event: params.off,
      field: params.field,
      ableField: params.ableField,
      overrideAble: params.overrideAble,
      value: false
    });
  }
  
  defineSwitchSet({
    field: 'locked',
    overrideField: function(ele){
      return ele.cy().autolock() ? true : undefined;
    },
    on: 'lock',
    off: 'unlock'
  });
  
  defineSwitchSet({
    field: 'grabbable',
    overrideField: function(ele){
      return ele.cy().autoungrabify() ? false : undefined;
    },
    on: 'grabify',
    off: 'ungrabify'
  });
  
  defineSwitchSet({
    field: 'selected',
    ableField: 'selectable',
    overrideAble: function(ele){
      return ele.cy().autounselectify() ? false : undefined;
    },
    on: 'select',
    off: 'unselect'
  });
  
  defineSwitchSet({
    field: 'selectable',
    overrideField: function(ele){
      return ele.cy().autounselectify() ? false : undefined;
    },
    on: 'selectify',
    off: 'unselectify'
  });

  $$.elesfn.deselect = $$.elesfn.unselect;
  
  $$.elesfn.grabbed = function(){
    var ele = this[0];
    if( ele ){
      return ele._private.grabbed;
    }
  };

  defineSwitchSet({
    field: 'active',
    on: 'activate',
    off: 'unactivate'
  });

  $$.elesfn.inactive = function(){
    var ele = this[0];
    if( ele ){
      return !ele._private.active;
    }
  };
  
})( cytoscape );

;(function($$){ 'use strict';

  // DAG functions
  //////////////////////////

  $$.fn.eles({
    // get the root nodes in the DAG
    roots: function( selector ){
      var eles = this;
      var roots = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        if( !ele.isNode() ){
          continue;
        }

        var hasEdgesPointingIn = ele.connectedEdges(function(){
          return this.data('target') === ele.id() && this.data('source') !== ele.id();
        }).length > 0;

        if( !hasEdgesPointingIn ){
          roots.push( ele );
        }
      }

      return new $$.Collection( this._private.cy, roots, { unique: true } ).filter( selector );
    },

    // get the leaf nodes in the DAG
    leaves: function( selector ){
      var eles = this;
      var leaves = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        if( !ele.isNode() ){
          continue;
        }

        var hasEdgesPointingOut = ele.connectedEdges(function(){
          return this.data('source') === ele.id() && this.data('target') !== ele.id();
        }).length > 0;

        if( !hasEdgesPointingOut ){
          leaves.push( ele );
        }
      }

      return new $$.Collection( this._private.cy, leaves, { unique: true } ).filter( selector );
    },

    // normally called children in graph theory
    // these nodes =edges=> outgoing nodes
    outgoers: function( selector ){
      var eles = this;
      var oEles = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var eleId = ele.id();

        if( !ele.isNode() ){ continue; }

        var edges = ele._private.edges;
        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];
          var srcId = edge._private.data.source;
          var tgtId = edge._private.data.target;

          if( srcId === eleId && tgtId !== eleId ){
            oEles.push( edge );
            oEles.push( edge.target()[0] );
          }
        }
      }

      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );
    },

    // aka DAG descendants
    successors: function( selector ){
      var eles = this;
      var sEles = [];
      var sElesIds = {};

      for(;;){
        var outgoers = eles.outgoers();

        if( outgoers.length === 0 ){ break; } // done if no outgoers left

        var newOutgoers = false;
        for( var i = 0; i < outgoers.length; i++ ){
          var outgoer = outgoers[i];
          var outgoerId = outgoer.id();

          if( !sElesIds[ outgoerId ] ){
            sElesIds[ outgoerId ] = true;
            sEles.push( outgoer );
            newOutgoers = true;
          }
        }

        if( !newOutgoers ){ break; } // done if touched all outgoers already

        eles = outgoers;
      }

      return new $$.Collection( this._private.cy, sEles, { unique: true } ).filter( selector );
    },

    // normally called parents in graph theory
    // these nodes <=edges= incoming nodes
    incomers: function( selector ){
      var eles = this;
      var oEles = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var eleId = ele.id();

        if( !ele.isNode() ){ continue; }

        var edges = ele._private.edges;
        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];
          var srcId = edge._private.data.source;
          var tgtId = edge._private.data.target;

          if( tgtId === eleId && srcId !== eleId ){
            oEles.push( edge );
            oEles.push( edge.source()[0] );
          }
        }
      }

      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );
    },

    // aka DAG ancestors
    predecessors: function( selector ){
      var eles = this;
      var pEles = [];
      var pElesIds = {};

      for(;;){
        var incomers = eles.incomers();

        if( incomers.length === 0 ){ break; } // done if no incomers left

        var newIncomers = false;
        for( var i = 0; i < incomers.length; i++ ){
          var incomer = incomers[i];
          var incomerId = incomer.id();

          if( !pElesIds[ incomerId ] ){
            pElesIds[ incomerId ] = true;
            pEles.push( incomer );
            newIncomers = true;
          }
        }

        if( !newIncomers ){ break; } // done if touched all incomers already

        eles = incomers;
      }

      return new $$.Collection( this._private.cy, pEles, { unique: true } ).filter( selector );
    }
  });


  // Neighbourhood functions
  //////////////////////////

  $$.fn.eles({
    neighborhood: function(selector){
      var elements = [];
      var cy = this._private.cy;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){ // for all nodes
        var node = nodes[i];
        var connectedEdges = node.connectedEdges();

        // for each connected edge, add the edge and the other node
        for( var j = 0; j < connectedEdges.length; j++ ){
          var edge = connectedEdges[j];
          var otherNode = edge.connectedNodes().not(node);

          // need check in case of loop
          if( otherNode.length > 0 ){
            elements.push( otherNode[0] ); // add node 1 hop away
          }
          
          // add connected edge
          elements.push( edge[0] );
        }

      }
      
      return ( new $$.Collection( cy, elements, { unique: true } ) ).filter( selector );
    },

    closedNeighborhood: function(selector){
      return this.neighborhood().add( this ).filter( selector );
    },

    openNeighborhood: function(selector){
      return this.neighborhood( selector );
    }
  });  

  // aliases
  $$.elesfn.neighbourhood = $$.elesfn.neighborhood;
  $$.elesfn.closedNeighbourhood = $$.elesfn.closedNeighborhood;
  $$.elesfn.openNeighbourhood = $$.elesfn.openNeighborhood;


  // Edge functions
  /////////////////

  $$.fn.eles({
    source: function( selector ){
      var ele = this[0];
      var src;

      if( ele ){
        src = ele._private.source;
      }

      return src && selector ? src.filter( selector ) : src;
    },

    target: function( selector ){
      var ele = this[0];
      var tgt;

      if( ele ){
        tgt = ele._private.target;
      }

      return tgt && selector ? tgt.filter( selector ) : tgt;
    },

    sources: defineSourceFunction({
      attr: 'source'
    }),

    targets: defineSourceFunction({
      attr: 'target'
    })
  });
  
  function defineSourceFunction( params ){
    return function( selector ){
      var sources = [];
      var cy = this._private.cy;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var src = ele._private[ params.attr ];

        if( src ){
          sources.push( src );
        }
      }
      
      return new $$.Collection( cy, sources, { unique: true } ).filter( selector );
    };
  }

  $$.fn.eles({
    edgesWith: defineEdgesWithFunction(),

    edgesTo: defineEdgesWithFunction({
      thisIs: 'source'
    })
  });
  
  function defineEdgesWithFunction( params ){
    
    return function(otherNodes){
      var elements = [];
      var cy = this._private.cy;
      var p = params || {};

      // get elements if a selector is specified
      if( $$.is.string(otherNodes) ){
        otherNodes = cy.$( otherNodes );
      }
      
      var thisIds = this._private.ids;
      var otherIds = otherNodes._private.ids;
      
      for( var h = 0; h < otherNodes.length; h++ ){
        var edges = otherNodes[h]._private.edges;
        
        for( var i = 0; i < edges.length; i++ ){
          var edge = edges[i];
          var foundId;
          var edgeData = edge._private.data;
          var thisToOther = thisIds[ edgeData.source ] && otherIds[ edgeData.target ];
          var otherToThis = otherIds[ edgeData.source ] && thisIds[ edgeData.target ];
          var edgeConnectsThisAndOther = thisToOther || otherToThis;

          if( !edgeConnectsThisAndOther ){ continue; }

          if( p.thisIs ){
            if( p.thisIs === 'source' && !thisToOther ){ continue; }
            
            if( p.thisIs === 'target' && !otherToThis ){ continue; }
          }
          
          elements.push( edge );
        }
      }
      
      return new $$.Collection( cy, elements, { unique: true } );
    };
  }
  
  $$.fn.eles({
    connectedEdges: function( selector ){
      var retEles = [];
      var cy = this._private.cy;
      
      var eles = this;
      for( var i = 0; i < eles.length; i++ ){
        var node = eles[i];
        if( !node.isNode() ){ continue; }

        var edges = node._private.edges;

        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];          
          retEles.push( edge );
        }
      }
      
      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );
    },

    connectedNodes: function( selector ){
      var retEles = [];
      var cy = this._private.cy;

      var eles = this;
      for( var i = 0; i < eles.length; i++ ){
        var edge = eles[i];
        if( !edge.isEdge() ){ continue; }

        retEles.push( edge.source()[0] );
        retEles.push( edge.target()[0] );
      }

      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );
    },

    parallelEdges: defineParallelEdgesFunction(),

    codirectedEdges: defineParallelEdgesFunction({
      codirected: true
    })
  });
  
  function defineParallelEdgesFunction(params){
    var defaults = {
      codirected: false
    };
    params = $$.util.extend({}, defaults, params);
    
    return function( selector ){
      var cy = this._private.cy;
      var elements = [];
      var edges = this.edges();
      var p = params;

      // look at all the edges in the collection
      for( var i = 0; i < edges.length; i++ ){
        var edge1 = edges[i];
        var src1 = edge1.source()[0];
        var srcid1 = src1.id();
        var tgt1 = edge1.target()[0];
        var tgtid1 = tgt1.id();
        var srcEdges1 = src1._private.edges;

        // look at edges connected to the src node of this edge
        for( var j = 0; j < srcEdges1.length; j++ ){
          var edge2 = srcEdges1[j];
          var edge2data = edge2._private.data;
          var tgtid2 = edge2data.target;
          var srcid2 = edge2data.source;

          var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
          var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;
          
          if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){
            elements.push( edge2 );
          }
        }
      }
      
      return new $$.Collection( cy, elements, { unique: true } ).filter( selector );
    };
  
  }

  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({

    fit: function(){},
    center: function(){}

  });
  
})( cytoscape );
;(function ($$) {
  "use strict";

  /*  Min and Max heap predefaults */
  
  $$.Minheap = function (cy, eles, valueFn) {
    return new $$.Heap(cy, eles, $$.Heap.minHeapComparator, valueFn);
  };

  $$.Maxheap = function (cy, eles, valueFn) {
    return new $$.Heap(cy, eles, $$.Heap.maxHeapComparator, valueFn);
  };
  
  $$.Heap = function (cy, eles, comparator, valueFn) {
    if (typeof comparator === "undefined" || typeof eles === "undefined") {
      return;
    }
    
    if (typeof valueFn === "undefined") {
      valueFn = $$.Heap.idFn;
    }

    var sourceHeap = [],
      pointers = {},
      elements = [],
      i = 0,
      id,
      heap,
      elesLen;

    eles = this.getArgumentAsCollection(eles, cy);
    elesLen = eles.length;

    for (i = 0; i < elesLen; i += 1) {
      sourceHeap.push(valueFn.call(cy, eles[i], i, eles));

      id = eles[i].id();
      
      if (pointers.hasOwnProperty(id)) {
        throw "ERROR: Multiple items with the same id found: " + id;
      }
      
      pointers[id] = i;
      elements.push(id);
    }

    this._private = {
      cy: cy,
      heap: sourceHeap,
      pointers: pointers,
      elements: elements,
      comparator: comparator,
      extractor: valueFn,
      length: elesLen
    };

    for (i = Math.floor(elesLen / 2); i >= 0; i -= 1) {
      heap = this.heapify(i);
    }

    return heap;
  };

  /* static methods */
  $$.Heap.idFn = function (node) {
    return node.id();
  };

  $$.Heap.minHeapComparator = function (a, b) {
    return a >= b;
  };

  $$.Heap.maxHeapComparator = function (a, b) {
    return a <= b;
  };

  $$.fn.heap = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Heap.prototype[ name ] = fn;
    }
  };

  $$.heapfn = $$.Heap.prototype; // short alias

  /* object methods */
  $$.heapfn.size = function () {
    return this._private.length;
  };

  $$.heapfn.getArgumentAsCollection = function (eles, cy) {
    var result;
    if(typeof cy === "undefined") {
      cy = this._private.cy;
    }

    if ($$.is.elementOrCollection(eles)) {
      result = eles;

    } else {
      var resultArray = [],
        sourceEles = [].concat.apply([], [eles]);

      for (var i = 0; i < sourceEles.length; i++) {
        var id = sourceEles[i],
          ele = cy.getElementById(id);

        if(ele.length > 0) {
          resultArray.push(ele);
        }
      }

      result = new $$.Collection(cy, resultArray);
    }

    return result;
  };

  $$.heapfn.isHeap = function () {
    var array = this._private.heap,
      arrlen = array.length,
      i,
      left,
      right,
      lCheck,
      rCheck,
      comparator = this._private.comparator;

    for (i = 0; i < arrlen; i += 1) {
      left = 2 * i + 1;
      right = left + 1;
      lCheck = left < arrlen ? comparator(array[left], array[i]) : true;
      rCheck = right < arrlen ? comparator(array[right], array[i]) : true;

      if (!lCheck || !rCheck) {
        return false;
      }
    }

    return true;
  };

  $$.heapfn.heapSwap = function (i, j) {
    var heap = this._private.heap,
      pointers = this._private.pointers,
      elements = this._private.elements,
      swapValue = heap[i],
      swapElems = elements[i],
      idI = elements[i],
      idJ = elements[j];

    heap[i] = heap[j];
    elements[i] = elements[j];

    pointers[idI] = j;
    pointers[idJ] = i;

    heap[j] = swapValue;
    elements[j] = swapElems;
  };

  $$.heapfn.heapify = function (i, rootToLeaf) {
    var treeLen = 0,
      condHeap = false,
      array,
      current,
      left,
      right,
      best,
      comparator,
      parent;
    
    if (typeof rootToLeaf === "undefined") {
      rootToLeaf = true;
    }

    array = this._private.heap;
    treeLen = array.length;
    comparator = this._private.comparator;
    current = i;

    while (!condHeap) {

      if (rootToLeaf) {
        left = 2 * current + 1;
        right = left + 1;
        best = current;
        
        if (left < treeLen && !comparator(array[left], array[best])) {
          best = left;
        }
        
        if (right < treeLen && !comparator(array[right], array[best])) {
          best = right;
        }
        
        condHeap = best === current;
        
        if (!condHeap) {
          this.heapSwap(best, current);
          current = best;
        }

      } else {
        parent = Math.floor((current - 1) / 2);
        best = current;
        condHeap = parent < 0 || comparator(array[best], array[parent]);

        if (!condHeap) {
          this.heapSwap(best, parent);
          current = parent;
        }
      }

    } // while
  };

  /* collectionOrElement */
  $$.heapfn.insert = function (eles) {
    var elements = this.getArgumentAsCollection(eles),
      elsize = elements.length,
      element,
      elindex,
      elvalue,
      elid,
      i;

    for (i = 0; i < elsize; i += 1) {
      element = elements[i];
      elindex = this._private.heap.length;
      elvalue = this._private.extractor(element);
      elid = element.id();

      if (this._private.pointers.hasOwnProperty(elid)) {
        throw "ERROR: Multiple items with the same id found: " + elid;
      }

      this._private.heap.push(elvalue);
      this._private.elements.push(elid);
      this._private.pointers[elid] = elindex;
      this.heapify(elindex, false);
    }

    this._private.length = this._private.heap.length;
  };

  $$.heapfn.getValueById = function (elementId) {
    if (this._private.pointers.hasOwnProperty(elementId)) {
      var elementIndex = this._private.pointers[elementId];

      return this._private.heap[elementIndex];
    }
  };
  
  $$.heapfn.contains = function (eles) {
    var elements = this.getArgumentAsCollection(eles);

    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id();

      if(!this._private.pointers.hasOwnProperty(elementId)) {
        return false;
      }
    }

    return true;
  };
  
  $$.heapfn.top = function () {
    if (this._private.length > 0) {

      return {
        value: this._private.heap[0],
        id: this._private.elements[0]
      };

    }
  };

  $$.heapfn.pop = function () {
    if (this._private.length > 0) {
      var top = this.top(),
        lastIndex = this._private.length - 1,
        removeCandidate,
        removeValue,
        remId;

      this.heapSwap(0, lastIndex);

      removeCandidate = this._private.elements[lastIndex];
      removeValue = this._private.heap[lastIndex];
      remId = removeCandidate;

      this._private.heap.pop();
      this._private.elements.pop();
      this._private.length = this._private.heap.length;
      this._private.pointers[remId] = undefined;

      this.heapify(0);
      return top;
    }
  };

  $$.heapfn.findDirectionHeapify = function (index) {
    var parent = Math.floor((index - 1) / 2),
      array = this._private.heap,
      condHeap = parent < 0 || this._private.comparator(array[index], array[parent]);

    this.heapify(index, condHeap);
  };

  /* edit is a new value or function */
  // only values in heap are updated. elements themselves are not!
  $$.heapfn.edit = function (eles, edit) {
    var elements = this.getArgumentAsCollection(eles);
    
    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id(),
        elementIndex = this._private.pointers[elementId],
        elementValue = this._private.heap[elementIndex];
      
      if ($$.is.number(edit)) {
        this._private.heap[elementIndex] = edit;
        
      } else if ($$.is.fn(edit)) {
        this._private.heap[elementIndex] = edit.call(this._private.cy, elementValue, elementIndex);
      }

      this.findDirectionHeapify(elementIndex);
    }
  };

  $$.heapfn.remove = function (eles) {
    var elements = this.getArgumentAsCollection(eles);
    
    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id(),
        elementIndex = this._private.pointers[elementId],
        lastIndex = this._private.length - 1,
        removeCandidate,
        removeValue,
        remId;

      if (elementIndex !== lastIndex) {
        this.heapSwap(elementIndex, lastIndex);
      }

      removeCandidate = this._private.elements[lastIndex];
      removeValue = this._private.heap[lastIndex];
      remId = removeCandidate;

      this._private.heap.pop();
      this._private.elements.pop();
      this._private.length = this._private.heap.length;
      this._private.pointers[remId] = undefined;

      this.findDirectionHeapify(elementIndex);
    }

    return removeValue;
  };

})(cytoscape);
/*
  The canvas renderer was written by Yue Dong.

  Modifications tracked on Github.
*/

(function($$) { 'use strict';

  CanvasRenderer.CANVAS_LAYERS = 3;
  //
  CanvasRenderer.SELECT_BOX = 0;
  CanvasRenderer.DRAG = 1;
  CanvasRenderer.NODE = 2;

  CanvasRenderer.BUFFER_COUNT = 3;
  //
  CanvasRenderer.TEXTURE_BUFFER = 0;
  CanvasRenderer.MOTIONBLUR_BUFFER_NODE = 1;
  CanvasRenderer.MOTIONBLUR_BUFFER_DRAG = 2;

  function CanvasRenderer(options) {  

    this.options = options;

    this.data = {
        
      select: [undefined, undefined, undefined, undefined, 0], // Coordinates for selection box, plus enabled flag 
      renderer: this, cy: options.cy, container: options.cy.container(),
      
      canvases: new Array(CanvasRenderer.CANVAS_LAYERS),
      contexts: new Array(CanvasRenderer.CANVAS_LAYERS),
      canvasNeedsRedraw: new Array(CanvasRenderer.CANVAS_LAYERS),
      
      bufferCanvases: new Array(CanvasRenderer.BUFFER_COUNT),
      bufferContexts: new Array(CanvasRenderer.CANVAS_LAYERS)

    };
    
    //--Pointer-related data
    this.hoverData = {down: null, last: null, 
        downTime: null, triggerMode: null, 
        dragging: false, 
        initialPan: [null, null], capture: false};
    
    this.timeoutData = {panTimeout: null};
    
    this.dragData = {possibleDragElements: []};
    
    this.touchData = {start: null, capture: false,
        // These 3 fields related to tap, taphold events
        startPosition: [null, null, null, null, null, null],
        singleTouchStartTime: null,
        singleTouchMoved: true,
        
        
        now: [null, null, null, null, null, null], 
        earlier: [null, null, null, null, null, null] };
    //--
    
    //--Wheel-related data 
    this.zoomData = {freeToZoom: false, lastPointerX: null};
    //--
    
    this.redraws = 0;
    this.showFps = options.showFps;

    this.bindings = [];
    
    this.data.canvasContainer = document.createElement('div');
    var containerStyle = this.data.canvasContainer.style;
    containerStyle.position = 'absolute';
    containerStyle.zIndex = '0';
    containerStyle.overflow = 'hidden';

    this.data.container.appendChild( this.data.canvasContainer );

    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {
      this.data.canvases[i] = document.createElement('canvas');
      this.data.contexts[i] = this.data.canvases[i].getContext('2d');
      this.data.canvases[i].style.position = 'absolute';
      this.data.canvases[i].setAttribute('data-id', 'layer' + i);
      this.data.canvases[i].style.zIndex = String(CanvasRenderer.CANVAS_LAYERS - i);
      this.data.canvasContainer.appendChild(this.data.canvases[i]);
      
      this.data.canvasNeedsRedraw[i] = false;
    }
    this.data.topCanvas = this.data.canvases[0];

    this.data.canvases[CanvasRenderer.NODE].setAttribute('data-id', 'layer' + CanvasRenderer.NODE + '-node');
    this.data.canvases[CanvasRenderer.SELECT_BOX].setAttribute('data-id', 'layer' + CanvasRenderer.SELECT_BOX + '-selectbox');
    this.data.canvases[CanvasRenderer.DRAG].setAttribute('data-id', 'layer' + CanvasRenderer.DRAG + '-drag');
    
    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {
      this.data.bufferCanvases[i] = document.createElement('canvas');
      this.data.bufferContexts[i] = this.data.bufferCanvases[i].getContext('2d');
      this.data.bufferCanvases[i].style.position = 'absolute';
      this.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
      this.data.bufferCanvases[i].style.zIndex = String(-i - 1);
      this.data.bufferCanvases[i].style.visibility = 'hidden';
      //this.data.canvasContainer.appendChild(this.data.bufferCanvases[i]);
    }

    this.hideEdgesOnViewport = options.hideEdgesOnViewport;
    this.hideLabelsOnViewport = options.hideLabelsOnViewport;
    this.textureOnViewport = options.textureOnViewport;
    this.wheelSensitivity = options.wheelSensitivity;
    this.motionBlurEnabled = options.motionBlur; // on by default
    this.forcedPixelRatio = options.pixelRatio;
    this.motionBlur = true; // for initial kick off
    this.motionBlurOpacity = options.motionBlurOpacity;
    this.motionBlurTransparency = 1 - this.motionBlurOpacity;
    this.motionBlurPxRatio = 1;
    this.mbPxRBlurry = 1; //0.8;
    this.minMbLowQualFrames = 4;
    this.fullQualityMb = false;
    this.clearedForMotionBlur = [];
    this.desktopTapThreshold = options.desktopTapThreshold;
    this.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
    this.touchTapThreshold = options.touchTapThreshold;
    this.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
    this.tapholdDuration = 500;

    this.load();
  }

  CanvasRenderer.panOrBoxSelectDelay = 400;

  // whether to use Path2D caching for drawing
  var pathsImpld = typeof Path2D !== 'undefined';
  CanvasRenderer.usePaths = function(){
    return pathsImpld;
  };

  CanvasRenderer.prototype.notify = function(params) {
    var types;

    if( $$.is.array( params.type ) ){
      types = params.type;

    } else {
      types = [ params.type ];
    }

    for( var i = 0; i < types.length; i++ ){
      var type = types[i];

      switch( type ){
        case 'destroy':
          this.destroy();
          return;

        case 'add':
        case 'remove':
        case 'load':
          this.updateNodesCache();
          this.updateEdgesCache();
          break;

        case 'viewport':
          this.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
          break;

        case 'style':
          this.updateCachedZSortedEles();
          break;
      }

      if( type === 'load' || type === 'resize' ){
        this.invalidateContainerClientCoordsCache();
        this.matchCanvasSize(this.data.container);
      }
    } // for
    
    this.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
    this.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

    this.redraw();
  };

  CanvasRenderer.prototype.destroy = function(){
    this.destroyed = true;

    for( var i = 0; i < this.bindings.length; i++ ){
      var binding = this.bindings[i];
      var b = binding;

      b.target.removeEventListener(b.event, b.handler, b.useCapture);
    }

    if( this.removeObserver ){
      this.removeObserver.disconnect();
    }

    if( this.labelCalcDiv ){
      document.body.removeChild(this.labelCalcDiv);
    }
  };

  

  // copy the math functions into the renderer prototype
  // unfortunately these functions are used interspersed t/o the code
  // and this makes sure things work just in case a ref was missed in refactoring
  // TODO remove this eventually
  for( var fnName in $$.math ){
    CanvasRenderer.prototype[ fnName ] = $$.math[ fnName ];
  }
  
  
  $$('renderer', 'canvas', CanvasRenderer);
  
})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var rendFunc = CanvasRenderer.prototype;
  var arrowShapes = CanvasRenderer.arrowShapes = {};

  CanvasRenderer.arrowShapeHeight = 0.3;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function(x, y, centerX, centerY, width, height, direction, padding){
    var x1 = centerX - width/2;
    var x2 = centerX + width/2;
    var y1 = centerY - height/2;
    var y2 = centerY + height/2;

    return (x1 <= x && x <= x2) && (y1 <= y && y <= y2);
  };

  var transform = function(x, y, size, angle, translation){
    angle = -angle; // b/c of notation used in arrow draw fn

    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);
    
    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;
    
    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  arrowShapes['arrow'] = {
    _points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['arrow']._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['arrow']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }

    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['triangle'] = arrowShapes['arrow'];
  
  arrowShapes['triangle-backcurve'] = {
    _ctrlPt: [ 0, -0.15 ],

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['triangle']._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['triangle']._points;
      var firstPt;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        if( i === 0 ){
          firstPt = pt;
        }

        context.lineTo(pt.x, pt.y);
      }

      var ctrlPt = this._ctrlPt;
      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );

      context.quadraticCurveTo( ctrlPtTrans.x, ctrlPtTrans.y, firstPt.x, firstPt.y );
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };
  

  arrowShapes['triangle-tee'] = {
    _points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    _pointsTee: [
      -0.15, -0.4,
      -0.15, -0.5,
      0.15, -0.5,
      0.15, -0.4
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var triPts = arrowShapes['triangle-tee']._points;
      var teePts = arrowShapes['triangle-tee']._pointsTee;
      
      var inside = $$.math.pointInsidePolygon(x, y, teePts, centerX, centerY, width, height, direction, padding) 
        || $$.math.pointInsidePolygon(x, y, triPts, centerX, centerY, width, height, direction, padding);

      return inside;
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var triPts = arrowShapes['triangle-tee']._points;
      for (var i = 0; i < triPts.length / 2; i++){
        var pt = transform( triPts[ i * 2 ],  triPts[ i * 2 + 1 ], size, angle, translation );
        
        context.lineTo( pt.x, pt.y );
      }

      var teePts = arrowShapes['triangle-tee']._pointsTee;
      var firstTeePt = transform( teePts[0], teePts[1], size, angle, translation );
      context.moveTo( firstTeePt.x, firstTeePt.y );

      for (var i = 0; i < teePts.length / 2; i++){
        var pt = transform( teePts[ i * 2 ],  teePts[ i * 2 + 1 ], size, angle, translation );
        
        context.lineTo( pt.x, pt.y );
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['half-triangle-overshot'] = {
    _points: [
      0, -0.25,
      -0.5, -0.25,
      0.5, 0.25
    ],
    
    leavePathOpen: true,
    matchEdgeWidth: true,

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = this._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = this._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['none'] = {
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      return false;
    },
    
    roughCollide: function(x, y, centerX, centerY, width, height, direction, padding) {
      return false;
    },
    
    draw: function(context) {
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return 0;
    }
  };
  
  arrowShapes['circle'] = {
    _baseRadius: 0.15,
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      // Transform x, y to get non-rotated ellipse
      
      if (width != height) {                  
        var aspectRatio = (height + padding) / (width + padding);
        y /= aspectRatio;
        centerY /= aspectRatio;
        
        return (Math.pow(centerX - x, 2) 
          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)
            * arrowShapes['circle']._baseRadius, 2));
      } else {
        return (Math.pow(centerX - x, 2) 
          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)
            * arrowShapes['circle']._baseRadius, 2));
      }
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      context.arc(translation.x, translation.y, arrowShapes['circle']._baseRadius * size, 0, Math.PI * 2, false);
    },
    
    spacing: function(edge) {
      return rendFunc.getArrowWidth(edge._private.style['width'].pxValue)
        * arrowShapes['circle']._baseRadius;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };
  
  arrowShapes['inhibitor'] = {
    _points: [
      -0.25, 0,
      -0.25, -0.1,
      0.25, -0.1,
      0.25, 0
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['inhibitor']._points;
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['inhibitor']._points;
      
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 1;
    },
    
    gap: function(edge) {
      return 1;
    }
  };

  arrowShapes['tee'] = arrowShapes['inhibitor'];

  arrowShapes['square'] = {
    _points: [
      -0.15, 0.00,
      0.15, 0.00,
      0.15, -0.3,
      -0.15, -0.3
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['square']._points;
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['square']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },

    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['diamond'] = {
    _points: [
      -0.15, -0.15,
      0, -0.3,
      0.15, -0.15,
      0, 0
    ],

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['diamond']._points;
          
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },

    roughCollide: bbCollide,

    draw: function(context, size, angle, translation) {
      var points = arrowShapes['diamond']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue;
    }
  };

})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  CRp.getCachedNodes = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    if (data.cache.cachedNodes == null) {
      data.cache.cachedNodes = cy.nodes();
    }
    
    return data.cache.cachedNodes;
  };
  
  CRp.updateNodesCache = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    data.cache.cachedNodes = cy.nodes();
  };
  
  CRp.getCachedEdges = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    if (data.cache.cachedEdges == null) {
      data.cache.cachedEdges = cy.edges();
    }
    
    return data.cache.cachedEdges;
  };
  
  CRp.updateEdgesCache = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    data.cache.cachedEdges = cy.edges();
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // Project mouse
  CRp.projectIntoViewport = function(clientX, clientY) {
    var offsets = this.findContainerClientCoords();
    var offsetLeft = offsets[0];
    var offsetTop = offsets[1];
    
    var x = clientX - offsetLeft; 
    var y = clientY - offsetTop;
    
    x -= this.data.cy.pan().x; y -= this.data.cy.pan().y; x /= this.data.cy.zoom(); y /= this.data.cy.zoom();
    return [x, y];
  };

  CRp.findContainerClientCoords = function() {
    var container = this.data.container;

    var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();

    return [bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top];
  };

  CRp.invalidateContainerClientCoordsCache = function(){
    this.containerBB = null;
  };

  // Find nearest element
  CRp.findNearestElement = function(x, y, visibleElementsOnly, isTouch){
    var self = this;
    var eles = this.getCachedZSortedEles();
    var near = [];
    var zoom = this.data.cy.zoom();
    var hasCompounds = this.data.cy.hasCompoundNodes();
    var edgeThreshold = (isTouch ? 24 : 8) / zoom;
    var nodeThreshold = (isTouch ? 8 : 2) / zoom;

    function checkNode(node){
      var width = node.outerWidth() + 2*nodeThreshold;
      var height = node.outerHeight() + 2*nodeThreshold;
      var hw = width/2;
      var hh = height/2;
      var pos = node._private.position;

      if(
        pos.x - hw <= x && x <= pos.x + hw // bb check x
          &&
        pos.y - hh <= y && y <= pos.y + hh // bb check y
      ){
        var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );

        // exit early if invisible edge and must be visible
        if( visibleElementsOnly && !visible ){
          return;
        }

        var shape = CanvasRenderer.nodeShapes[ self.getNodeShape(node) ];
        var borderWO = node._private.style['border-width'].pxValue / 2;

        if(
          shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)
        ){
          near.push( node );
        }

      }
    }

    function checkEdge(edge){
      var rs = edge._private.rscratch;
      var style = edge._private.style;
      var width = style['width'].pxValue/2 + edgeThreshold; // more like a distance radius from centre
      var widthSq = width * width;
      var width2 = width * 2;
      var src = edge._private.source;
      var tgt = edge._private.target;
      var inEdgeBB = false;
      var sqDist;

      // exit early if invisible edge and must be visible
      var passedVisibilityCheck;
      var passesVisibilityCheck = function(){
        if( passedVisibilityCheck !== undefined ){
          return passedVisibilityCheck;
        }

        if( !visibleElementsOnly ){
          passedVisibilityCheck = true;
          return true;
        }

        var visible = edge.visible() && !edge.transparent();
        if( visible ){
          passedVisibilityCheck = true;
          return true;
        }

        passedVisibilityCheck = false;
        return false;
      };

      if (rs.edgeType === 'self' || rs.edgeType === 'compound') {
        if(
            (
              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY, widthSq))
                && passesVisibilityCheck() &&
              ( widthSq > (sqDist = $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY)) )
            )
              ||
            (
              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY, widthSq))
                && passesVisibilityCheck() &&
              ( widthSq > (sqDist = $$.math.sqDistanceToQuadraticBezier(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY)) )
            )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'haystack') {
        var radius = style['haystack-radius'].value;
        var halfRadius = radius/2; // b/c have to half width/height

        var tgtPos = tgt._private.position;
        var tgtW = tgt.width();
        var tgtH = tgt.height();
        var srcPos = src._private.position;
        var srcW = src.width();
        var srcH = src.height();

        var startX = srcPos.x + rs.source.x * srcW * halfRadius;
        var startY = srcPos.y + rs.source.y * srcH * halfRadius;
        var endX = tgtPos.x + rs.target.x * tgtW * halfRadius;
        var endY = tgtPos.y + rs.target.y * tgtH * halfRadius;

        if( 
          (inEdgeBB = $$.math.inLineVicinity(x, y, startX, startY, endX, endY, width2))
            && passesVisibilityCheck() &&
          widthSq > ( sqDist = $$.math.sqDistanceToFiniteLine( x, y, startX, startY, endX, endY ) )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'straight') {
        if(
          (inEdgeBB = $$.math.inLineVicinity(x, y, rs.startX, rs.startY, rs.endX, rs.endY, width2))
            && passesVisibilityCheck() &&
          widthSq > ( sqDist = $$.math.sqDistanceToFiniteLine(x, y, rs.startX, rs.startY, rs.endX, rs.endY) )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'bezier') {
        if(
          (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY, widthSq))
            && passesVisibilityCheck() &&
          (widthSq > (sqDist = $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY)) )
        ){
          near.push( edge );
        }
      }
      
      // if we're close to the edge but didn't hit it, maybe we hit its arrows
      if( inEdgeBB && passesVisibilityCheck() && near.length === 0 || near[near.length - 1] !== edge ){
        var srcShape = CanvasRenderer.arrowShapes[ style['source-arrow-shape'].value ];
        var tgtShape = CanvasRenderer.arrowShapes[ style['target-arrow-shape'].value ];

        var src = src || edge._private.source;
        var tgt = tgt || edge._private.target;

        var tgtPos = tgt._private.position;
        var srcPos = src._private.position;

        var srcArW = self.getArrowWidth( style['width'].pxValue );
        var srcArH = self.getArrowHeight( style['width'].pxValue );

        var tgtArW = srcArW;
        var tgtArH = srcArH;

        if(
          (
            srcShape.roughCollide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], edgeThreshold)
              && 
            srcShape.collide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], edgeThreshold)
          )
            ||
          (
            tgtShape.roughCollide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], edgeThreshold)
              &&
            tgtShape.collide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], edgeThreshold)
          )
        ){
          near.push( edge );
        }
      }

      // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
      if( hasCompounds &&  near.length > 0 && near[ near.length - 1 ] === edge ){
        checkNode( src );
        checkNode( tgt );
      }
    }

    for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence
      var ele = eles[i];

      if( near.length > 0 ){ break; } // since we check in z-order, first found is top and best result => exit early

      if( ele._private.group === 'nodes' ){ 
        checkNode( eles[i] );

      } else  { // then edge
        checkEdge( eles[i] );
      }

    }
  
    
    if( near.length > 0 ){
      return near[ near.length - 1 ];
    } else {
      return null;
    }
  }; 

  // 'Give me everything from this box'
  CRp.getAllInBox = function(x1, y1, x2, y2) {
    var nodes = this.getCachedNodes();
    var edges = this.getCachedEdges();
    var box = [];
    
    var x1c = Math.min(x1, x2);
    var x2c = Math.max(x1, x2);
    var y1c = Math.min(y1, y2);
    var y2c = Math.max(y1, y2); 

    x1 = x1c; 
    x2 = x2c; 
    y1 = y1c; 
    y2 = y2c; 

    var heur;
    
    for ( var i = 0; i < nodes.length; i++ ){
      var pos = nodes[i]._private.position;
      var nShape = this.getNodeShape(nodes[i]);
      var w = this.getNodeWidth(nodes[i]);
      var h = this.getNodeHeight(nodes[i]);
      var border = nodes[i]._private.style['border-width'].pxValue / 2;
      var shapeObj = CanvasRenderer.nodeShapes[ nShape ];

      if ( shapeObj.intersectBox(x1, y1, x2, y2, w, h, pos.x, pos.y, border) ){
        box.push(nodes[i]);
      }
    }
    
    for ( var i = 0; i < edges.length; i++ ){
      var rs = edges[i]._private.rscratch;

      if (edges[i]._private.rscratch.edgeType == 'self') {
        if ((heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2ax, rs.cp2ay,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2ax, rs.cp2ay,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))
                ||
          (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2cx, rs.cp2cy,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2cx, rs.cp2cy,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))
          )
        { box.push(edges[i]); }
      }
      
      if (rs.edgeType == 'bezier' &&
        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2x, rs.cp2y,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2x, rs.cp2y,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))
        { box.push(edges[i]); }
    
      if (rs.edgeType == 'straight' &&
        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.startX * 0.5 + rs.endX * 0.5, 
            rs.startY * 0.5 + rs.endY * 0.5, 
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              && /* console.log('test', heur) == undefined && */
            (heur == 2 || (heur == 1 && $$.math.checkStraightEdgeInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))
        { box.push(edges[i]); }


      if (rs.edgeType == 'haystack'){
        var tgt = edges[i].target()[0];
        var tgtPos = tgt.position();
        var src = edges[i].source()[0];
        var srcPos = src.position();

        var startX = srcPos.x + rs.source.x;
        var startY = srcPos.y + rs.source.y;
        var endX = tgtPos.x + rs.target.x;
        var endY = tgtPos.y + rs.target.y;

        var startInBox = (x1 <= startX && startX <= x2) && (y1 <= startY && startY <= y2);
        var endInBox = (x1 <= endX && endX <= x2) && (y1 <= endY && endY <= y2);

        if( startInBox && endInBox ){
          box.push( edges[i] );
        }
      }
      
    }
    
    return box;
  };


  /**
   * Returns the width of the given node. If the width is set to auto,
   * returns the value of the autoWidth field.
   *
   * @param node          a node
   * @return {number}     width of the node
   */
  CRp.getNodeWidth = function(node)
  {
    return node.width();
  };

  /**
   * Returns the height of the given node. If the height is set to auto,
   * returns the value of the autoHeight field.
   *
   * @param node          a node
   * @return {number}     width of the node
   */
  CRp.getNodeHeight = function(node)
  {
    return node.height();
  };

  /**
   * Returns the shape of the given node. If the height or width of the given node
   * is set to auto, the node is considered to be a compound.
   *
   * @param node          a node
   * @return {String}     shape of the node
   */
  CRp.getNodeShape = function(node)
  {
    // TODO only allow rectangle for a compound node?
//    if (node._private.style['width'].value == 'auto' ||
//        node._private.style['height'].value == 'auto')
//    {
//      return 'rectangle';
//    }

    var shape = node._private.style['shape'].value;

    if( node.isParent() ){
      if( shape === 'rectangle' || shape === 'roundrectangle' ){
        return shape;
      } else {
        return 'rectangle';
      }
    }

    return shape;
  };


  CRp.getNodePadding = function(node)
  {
    var left = node._private.style['padding-left'].pxValue;
    var right = node._private.style['padding-right'].pxValue;
    var top = node._private.style['padding-top'].pxValue;
    var bottom = node._private.style['padding-bottom'].pxValue;

    if (isNaN(left))
    {
      left = 0;
    }

    if (isNaN(right))
    {
      right = 0;
    }

    if (isNaN(top))
    {
      top = 0;
    }

    if (isNaN(bottom))
    {
      bottom = 0;
    }

    return {left : left,
      right : right,
      top : top,
      bottom : bottom};
  };

  CRp.zOrderSort = $$.Collection.zIndexSort;

  CRp.updateCachedZSortedEles = function(){
    this.getCachedZSortedEles( true );
  };

  CRp.getCachedZSortedEles = function( forceRecalc ){
    var lastNodes = this.lastZOrderCachedNodes;
    var lastEdges = this.lastZOrderCachedEdges;
    var nodes = this.getCachedNodes();
    var edges = this.getCachedEdges();
    var eles = [];

    if( forceRecalc || !lastNodes || !lastEdges || lastNodes !== nodes || lastEdges !== edges ){ 
      //console.time('cachezorder')
      
      for( var i = 0; i < nodes.length; i++ ){
        if( nodes[i].visible() && !nodes[i].transparent() ){
          eles.push( nodes[i] );
        }
      }

      for( var i = 0; i < edges.length; i++ ){
        if( edges[i].visible() && !edges[i].transparent() ){
          eles.push( edges[i] );
        }
      }

      eles.sort( this.zOrderSort );
      this.cachedZSortedEles = eles;
      //console.log('make cache')

      //console.timeEnd('cachezorder')
    } else {
      eles = this.cachedZSortedEles;
      //console.log('read cache')
    }

    this.lastZOrderCachedNodes = nodes;
    this.lastZOrderCachedEdges = edges;

    return eles;
  };

  CRp.projectBezier = function(edge){
    var qbezierAt = $$.math.qbezierAt;
    var rs = edge._private.rscratch;
    var bpts = edge._private.rstyle.bezierPts = [];

    function pushBezierPts(pts){
      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.05 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.05 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.25 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.25 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.4 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.4 )
      });

      var mid = {
        x: qbezierAt( pts[0], pts[2], pts[4], 0.5 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.5 )
      };

      bpts.push( mid );

      if( rs.edgeType === 'self' || rs.edgeType === 'compound' ){
        rs.midX = rs.selfEdgeMidX;
        rs.midY = rs.selfEdgeMidY;
      } else {
        rs.midX = mid.x;
        rs.midY = mid.y;
      }

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.6 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.6 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.75 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.75 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.95 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.95 )
      });
    }

    if( rs.edgeType === 'self' ){
      pushBezierPts( [rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY] );
      pushBezierPts( [rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY] );
    } else if( rs.edgeType === 'bezier' ){
      pushBezierPts( [rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY] );
    }
  };

  CRp.recalculateNodeLabelProjection = function( node ){ 
    var content = node._private.style['content'].strValue;
    if( !content || content.match(/^\s+$/) ){ return; }

    var textX, textY;
    var nodeWidth = node.outerWidth();
    var nodeHeight = node.outerHeight();
    var nodePos = node._private.position;
    var textHalign = node._private.style['text-halign'].strValue;
    var textValign = node._private.style['text-valign'].strValue;
    var rs = node._private.rscratch;
    var rstyle = node._private.rstyle;

    switch( textHalign ){
      case 'left':
        textX = nodePos.x - nodeWidth / 2;
        break;

      case 'right':
        textX = nodePos.x + nodeWidth / 2;
        break;

      default: // e.g. center
        textX = nodePos.x;
    }

    switch( textValign ){
      case 'top':
        textY = nodePos.y - nodeHeight / 2;
        break;

      case 'bottom':
        textY = nodePos.y + nodeHeight / 2;
        break;

      default: // e.g. middle
        textY = nodePos.y;
    }
  
    rs.labelX = textX;
    rs.labelY = textY;
    rstyle.labelX = textX;
    rstyle.labelY = textY;

    this.applyLabelDimensions( node );
  };

  CRp.recalculateEdgeLabelProjection = function( edge ){
    var content = edge._private.style['content'].strValue;
    if( !content || content.match(/^\s+$/) ){ return; }

    var textX, textY;  
    var edgeCenterX, edgeCenterY;
    var _p = edge._private;
    var rs = _p.rscratch;
    //var style = _p.style;
    var rstyle = _p.rstyle;
    
    if (rs.edgeType == 'self') {
      edgeCenterX = rs.selfEdgeMidX;
      edgeCenterY = rs.selfEdgeMidY;
    } else if (rs.edgeType == 'straight') {
      edgeCenterX = (rs.startX + rs.endX) / 2;
      edgeCenterY = (rs.startY + rs.endY) / 2;
    } else if (rs.edgeType == 'bezier') {
      edgeCenterX = $$.math.qbezierAt( rs.startX, rs.cp2x, rs.endX, 0.5 );
      edgeCenterY = $$.math.qbezierAt( rs.startY, rs.cp2y, rs.endY, 0.5 );
    } else if (rs.edgeType == 'haystack') {
      // var src = _p.source;
      // var tgt = _p.target;
      // var srcPos = src._private.position;
      // var tgtPos = tgt._private.position;
      var pts = rs.haystackPts;

      edgeCenterX = ( pts[0] + pts[2] )/2;
      edgeCenterY = ( pts[1] + pts[3] )/2;
    }
    
    textX = edgeCenterX;
    textY = edgeCenterY;

    // add center point to style so bounding box calculations can use it
    rs.labelX = textX;
    rs.labelY = textY;
    rstyle.labelX = textX;
    rstyle.labelY = textY;

    this.applyLabelDimensions( edge );
  };

  CRp.applyLabelDimensions = function( ele ){
    var rs = ele._private.rscratch;
    var rstyle = ele._private.rstyle;

    var text = this.getLabelText( ele );
    var labelDims = this.calculateLabelDimensions( ele, text );
 
    rstyle.labelWidth = labelDims.width;
    rs.labelWidth = labelDims.width;
 
    rstyle.labelHeight = labelDims.height;
    rs.labelHeight = labelDims.height;
  };

  CRp.getLabelText = function( ele ){ 
    var style = ele._private.style;
    var text = ele._private.style['content'].strValue;
    var textTransform = style['text-transform'].value;
    var rscratch = ele._private.rscratch;
    
    if (textTransform == 'none') {
    } else if (textTransform == 'uppercase') {
      text = text.toUpperCase();
    } else if (textTransform == 'lowercase') {
      text = text.toLowerCase();
    }

    if( style['text-wrap'].value === 'wrap' ){
      //console.log('wrap'); 
      
      // save recalc if the label is the same as before
      if( rscratch.labelWrapKey === rscratch.labelKey ){ 
        // console.log('wrap cache hit');
        return rscratch.labelWrapCachedText;
      }
      // console.log('wrap cache miss');

      var lines = text.split('\n');
      var maxW = style['text-max-width'].pxValue;
      var wrappedLines = [];

      for( var l = 0; l < lines.length; l++ ){
        var line = lines[l];
        var lineDims = this.calculateLabelDimensions( ele, line, 'line=' + line );
        var lineW = lineDims.width;

        if( lineW > maxW ){ // line is too long
          var words = line.split(/\s+/); // NB: assume collapsed whitespace into single space
          var subline = '';

          for( var w = 0; w < words.length; w++ ){
            var word = words[w];
            var testLine = subline.length === 0 ? word : subline + ' ' + word;
            var testDims = this.calculateLabelDimensions( ele, testLine, 'testLine=' + testLine );
            var testW = testDims.width;

            if( testW <= maxW ){ // word fits on current line
              subline += word + ' ';
            } else { // word starts new line
              wrappedLines.push( subline );
              subline = word + ' ';
            }
          }

          // if there's remaining text, put it in a wrapped line
          if( !subline.match(/^\s+$/) ){
            wrappedLines.push( subline );
          }
        } else { // line is already short enough
          wrappedLines.push( line );
        }
      } // for

      rscratch.labelWrapCachedLines = wrappedLines;
      rscratch.labelWrapCachedText = text = wrappedLines.join('\n');
      rscratch.labelWrapKey = rscratch.labelKey;

      // console.log(text)
    } // if wrap

    return text;
  };

  CRp.calculateLabelDimensions = function( ele, text, extraKey ){
    var r = this;
    var style = ele._private.style;
    var fStyle = style['font-style'].strValue;
    var size = style['font-size'].pxValue + 'px';
    var family = style['font-family'].strValue;
    // var variant = style['font-variant'].strValue;
    var weight = style['font-weight'].strValue;

    var cacheKey = ele._private.labelKey;

    if( extraKey ){
      cacheKey += '$@$' + extraKey;
    }

    var cache = r.labelDimCache || (r.labelDimCache = {});

    if( cache[cacheKey] ){
      return cache[cacheKey];
    }

    var div = this.labelCalcDiv;

    if( !div ){
      div = this.labelCalcDiv = document.createElement('div');
      document.body.appendChild( div );
    }

    var ds = div.style;

    // from ele style
    ds.fontFamily = family;
    ds.fontStyle = fStyle;
    ds.fontSize = size;
    // ds.fontVariant = variant;
    ds.fontWeight = weight;

    // forced style
    ds.position = 'absolute';
    ds.left = '-9999px';
    ds.top = '-9999px';
    ds.zIndex = '-1';
    ds.visibility = 'hidden';
    ds.pointerEvents = 'none';
    ds.padding = '0';
    ds.lineHeight = '1';

    if( style['text-wrap'].value === 'wrap' ){
      ds.whiteSpace = 'pre'; // so newlines are taken into account
    } else {
      ds.whiteSpace = 'normal';
    }

    // put label content in div
    div.textContent = text;

    cache[cacheKey] = {
      width: div.clientWidth,
      height: div.clientHeight
    };

    return cache[cacheKey];
  };  

  CRp.recalculateRenderedStyle = function( eles ){
    var edges = [];
    var nodes = [];
    var handledEdge = {};

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var _p = ele._private;
      var style = _p.style;
      var rs = _p.rscratch;
      var rstyle = _p.rstyle;
      var id = _p.data.id;
      var bbStyleSame = rs.boundingBoxKey != null && _p.boundingBoxKey === rs.boundingBoxKey;
      var labelStyleSame = rs.labelKey != null && _p.labelKey === rs.labelKey;
      var styleSame = bbStyleSame && labelStyleSame;

      if( ele._private.group === 'nodes' ){
        var pos = _p.position;
        var posSame = rstyle.nodeX != null && rstyle.nodeY != null && pos.x === rstyle.nodeX && pos.y === rstyle.nodeY;
        var wSame = rstyle.nodeW != null && rstyle.nodeW === style['width'].pxValue;
        var hSame = rstyle.nodeH != null && rstyle.nodeH === style['height'].pxValue;

        if( !posSame || !styleSame || !wSame || !hSame ){
          nodes.push( ele );
        }

        rstyle.nodeX = pos.x;
        rstyle.nodeY = pos.y;
        rstyle.nodeW = style['width'].pxValue;
        rstyle.nodeH = style['height'].pxValue;
      } else { // edges

        var srcPos = ele._private.source._private.position;
        var tgtPos = ele._private.target._private.position;
        var srcSame = rstyle.srcX != null && rstyle.srcY != null && srcPos.x === rstyle.srcX && srcPos.y === rstyle.srcY;
        var tgtSame = rstyle.tgtX != null && rstyle.tgtY != null && tgtPos.x === rstyle.tgtX && tgtPos.y === rstyle.tgtY;
        var positionsSame = srcSame && tgtSame;

        if( !positionsSame || !styleSame ){
          var curveType = _p.style['curve-style'].value;

          if( curveType === 'bezier' ){
            if( !handledEdge[ id ] ){
              edges.push( ele );
              handledEdge[ id ] = true;

              var parallelEdges = ele.parallelEdges();
              for( var i = 0; i < parallelEdges.length; i++ ){
                var pEdge = parallelEdges[i];
                var pId = pEdge._private.data.id;

                if( !handledEdge[ pId ] ){
                  edges.push( pEdge );
                  handledEdge[ pId ] = true;
                }
                
              }
            }
          } else {
            edges.push( ele );
          }
        } // if positions diff

        // update rstyle positions
        rstyle.srcX = srcPos.x;
        rstyle.srcY = srcPos.y;
        rstyle.tgtX = tgtPos.x;
        rstyle.tgtY = tgtPos.y;

      } // if edges

      rs.boundingBoxKey = _p.boundingBoxKey;
      rs.labelKey = _p.labelKey;
    }

    this.recalculateEdgeProjections( edges );
    this.recalculateLabelProjections( nodes, edges );
  };

  CRp.recalculateLabelProjections = function( nodes, edges ){
    for( var i = 0; i < nodes.length; i++ ){
      this.recalculateNodeLabelProjection( nodes[i] );
    }

    for( var i = 0; i < edges.length; i++ ){
      this.recalculateEdgeLabelProjection( edges[i] );
    }
  };

  CRp.recalculateEdgeProjections = function( edges ){
    this.findEdgeControlPoints( edges );
  };


  // Find edge control points
  CRp.findEdgeControlPoints = function(edges) {
    if( !edges || edges.length === 0 ){ return; }

    var cy = this.data.cy;
    var hasCompounds = cy.hasCompoundNodes();
    var hashTable = {};
    var pairIds = [];
    var haystackEdges = [];

    // create a table of edge (src, tgt) => list of edges between them
    var pairId;
    for (var i = 0; i < edges.length; i++){
      var edge = edges[i];
      var style = edge._private.style;
      var edgeIsUnbundled = style['curve-style'].value === 'unbundled-bezier';

      // ignore edges who are not to be displayed
      // they shouldn't take up space
      if( style.display.value === 'none' ){
        continue;
      }

      if( style['curve-style'].value === 'haystack' ){
        haystackEdges.push( edge );
        continue;
      }

      var srcId = edge._private.data.source;
      var tgtId = edge._private.data.target;

      pairId = srcId > tgtId ?
        tgtId + '-' + srcId :
        srcId + '-' + tgtId ;

      if( edgeIsUnbundled ){
        pairId = 'unbundled' + edge._private.data.id;
      }

      if (hashTable[pairId] == null) {
        hashTable[pairId] = [];
        pairIds.push( pairId );
      }
      
      hashTable[pairId].push( edge );

      if( edgeIsUnbundled ){
        hashTable[pairId].hasUnbundled = true;
      }
    }

    var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape, srcBorder, tgtBorder;
    var vectorNormInverse;
    var badBezier;
    
    // for each pair (src, tgt), create the ctrl pts
    // Nested for loop is OK; total number of iterations for both loops = edgeCount  
    for (var p = 0; p < pairIds.length; p++) {
      pairId = pairIds[p];
      var pairEdges = hashTable[pairId];
    
      // for each pair id, the edges should be sorted by index
      pairEdges.sort(function(edge1, edge2){
        return edge1._private.index - edge2._private.index;
      });

      src = pairEdges[0]._private.source;
      tgt = pairEdges[0]._private.target;

      // make sure src/tgt distinction is consistent
      // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)
      if( src._private.data.id > tgt._private.data.id ){
        var temp = src;
        src = tgt;
        tgt = temp;
      }

      srcPos = src._private.position;
      tgtPos = tgt._private.position;

      srcW = this.getNodeWidth(src);
      srcH = this.getNodeHeight(src);

      tgtW = this.getNodeWidth(tgt);
      tgtH = this.getNodeHeight(tgt);

      srcShape = CanvasRenderer.nodeShapes[ this.getNodeShape(src) ];
      tgtShape = CanvasRenderer.nodeShapes[ this.getNodeShape(tgt) ];

      srcBorder = src._private.style['border-width'].pxValue;
      tgtBorder = tgt._private.style['border-width'].pxValue;

      badBezier = false;
      

      if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){

        // pt outside src shape to calc distance/displacement from src to tgt
        var srcOutside = srcShape.intersectLine(
          srcPos.x,
          srcPos.y,
          srcW,
          srcH,
          tgtPos.x,
          tgtPos.y,
          srcBorder / 2
        );

        // pt outside tgt shape to calc distance/displacement from src to tgt
        var tgtOutside = tgtShape.intersectLine(
          tgtPos.x,
          tgtPos.y,
          tgtW,
          tgtH,
          srcPos.x,
          srcPos.y,
          tgtBorder / 2
        );

        var midptSrcPts = {
          x1: srcOutside[0],
          x2: tgtOutside[0],
          y1: srcOutside[1],
          y2: tgtOutside[1]
        };

        var dy = ( tgtOutside[1] - srcOutside[1] );
        var dx = ( tgtOutside[0] - srcOutside[0] );
        var l = Math.sqrt( dx*dx + dy*dy );

        var vector = {
          x: dx,
          y: dy
        };
        
        var vectorNorm = {
          x: vector.x/l,
          y: vector.y/l
        };
        vectorNormInverse = {
          x: -vectorNorm.y,
          y: vectorNorm.x
        };

        // if src intersection is inside tgt or tgt intersection is inside src, then no ctrl pts to draw
        if( 
          tgtShape.checkPoint( srcOutside[0], srcOutside[1], tgtBorder/2, tgtW, tgtH, tgtPos.x, tgtPos.y )  ||
          srcShape.checkPoint( tgtOutside[0], tgtOutside[1], srcBorder/2, srcW, srcH, srcPos.x, srcPos.y ) 
        ){
          vectorNormInverse = {};
          badBezier = true;
        }
        
      }
      
      var edge;
      var rs;
      
      for (var i = 0; i < pairEdges.length; i++) {
        edge = pairEdges[i];
        rs = edge._private.rscratch;
        
        var edgeIndex1 = rs.lastEdgeIndex;
        var edgeIndex2 = i;

        var numEdges1 = rs.lastNumEdges;
        var numEdges2 = pairEdges.length;

        var eStyle = edge._private.style;
        var stepSize = eStyle['control-point-step-size'].pxValue;
        var stepDist = eStyle['control-point-distance'] !== undefined ? eStyle['control-point-distance'].pxValue : undefined;
        var stepWeight = eStyle['control-point-weight'].value;
        var edgeIsUnbundled = eStyle['curve-style'].value === 'unbundled-bezier';
        
        var swappedDirection = edge._private.source !== src;

        if( swappedDirection && edgeIsUnbundled ){
          stepDist *= -1;
        }

        var srcX1 = rs.lastSrcCtlPtX;
        var srcX2 = srcPos.x;
        var srcY1 = rs.lastSrcCtlPtY;
        var srcY2 = srcPos.y;
        var srcW1 = rs.lastSrcCtlPtW;
        var srcW2 = src.outerWidth();
        var srcH1 = rs.lastSrcCtlPtH;
        var srcH2 = src.outerHeight();

        var tgtX1 = rs.lastTgtCtlPtX;
        var tgtX2 = tgtPos.x;
        var tgtY1 = rs.lastTgtCtlPtY;
        var tgtY2 = tgtPos.y;
        var tgtW1 = rs.lastTgtCtlPtW;
        var tgtW2 = tgt.outerWidth();
        var tgtH1 = rs.lastTgtCtlPtH;
        var tgtH2 = tgt.outerHeight();

        var width1 = rs.lastW;
        var width2 = eStyle['control-point-step-size'].pxValue;

        if( badBezier ){
          rs.badBezier = true;
        } else {
          rs.badBezier = false;
        }

        if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2
        &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2
        &&  width1 === width2
        &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){
          // console.log('edge ctrl pt cache HIT')
          continue; // then the control points haven't changed and we can skip calculating them
        } else {
          rs.lastSrcCtlPtX = srcX2;
          rs.lastSrcCtlPtY = srcY2;
          rs.lastSrcCtlPtW = srcW2;
          rs.lastSrcCtlPtH = srcH2;
          rs.lastTgtCtlPtX = tgtX2;
          rs.lastTgtCtlPtY = tgtY2;
          rs.lastTgtCtlPtW = tgtW2;
          rs.lastTgtCtlPtH = tgtH2;
          rs.lastEdgeIndex = edgeIndex2;
          rs.lastNumEdges = numEdges2;
          rs.lastWidth = width2;
          // console.log('edge ctrl pt cache MISS')
        }

        // Self-edge
        if ( src === tgt ) {
            
          rs.edgeType = 'self';
          
          var j = i;
          var loopDist = stepSize;

          if( edgeIsUnbundled ){
            j = 0;
            loopDist = stepDist;
          }

          // New -- fix for large nodes
          rs.cp2ax = srcPos.x;
          rs.cp2ay = srcPos.y - (1 + Math.pow(srcH, 1.12) / 100) * loopDist * (j / 3 + 1);
          
          rs.cp2cx = srcPos.x - (1 + Math.pow(srcW, 1.12) / 100) * loopDist * (j / 3 + 1);
          rs.cp2cy = srcPos.y;
          
          rs.selfEdgeMidX = (rs.cp2ax + rs.cp2cx) / 2.0;
          rs.selfEdgeMidY = (rs.cp2ay + rs.cp2cy) / 2.0;
        
        // Compound edge
        } else if(
          hasCompounds &&
          ( src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild() ) &&
          ( src.parents().anySame(tgt) || tgt.parents().anySame(src) )
        ){

          rs.edgeType = 'compound';

          // because the line approximation doesn't apply for compound beziers
          // (loop/self edges are already elided b/c of cheap src==tgt check)
          rs.badBezier = false;

          var j = i;
          var loopDist = stepSize;

          if( edgeIsUnbundled ){
            j = 0;
            loopDist = stepDist;
          }

          
          var loopW = 50;

          var loopaPos = {
            x: srcPos.x - srcW/2,
            y: srcPos.y - srcH/2
          };

          var loopbPos = {
            x: tgtPos.x - tgtW/2,
            y: tgtPos.y - tgtH/2
          };

          var minCompoundStretch = 1;

          rs.cp2ax = loopaPos.x;
          rs.compoundStretchA = Math.max( minCompoundStretch, Math.log(srcW * 0.01) ); // avoids cases with impossible beziers
          rs.cp2ay = loopaPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * rs.compoundStretchA;
          
          rs.compoundStretchB = Math.max( minCompoundStretch, Math.log(tgtW * 0.01) ); // avoids cases with impossible beziers
          rs.cp2cx = loopbPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * rs.compoundStretchB;
          rs.cp2cy = loopbPos.y;
          
          rs.selfEdgeMidX = (rs.cp2ax + rs.cp2cx) / 2.0;
          rs.selfEdgeMidY = (rs.cp2ay + rs.cp2cy) / 2.0;

        // Straight edge
        } else if (pairEdges.length % 2 === 1
          && i === Math.floor(pairEdges.length / 2)
          && !edgeIsUnbundled ) {
          
          rs.edgeType = 'straight';
          
        // Bezier edge
        } else {
          var normStepDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
          var manStepDist;
          var sign = $$.math.signum( normStepDist );

          if( edgeIsUnbundled ){
            manStepDist = stepDist;
          } else {
            manStepDist = stepDist !== undefined ? sign * stepDist : undefined; 
          }

          var distanceFromMidpoint = manStepDist !== undefined ? manStepDist : normStepDist;
          
          var w1 = (1 - stepWeight);
          var w2 = stepWeight;

          if( swappedDirection ){
            w1 = stepWeight;
            w2 = (1 - stepWeight);
          }

          var adjustedMidpt = {
            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,
            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2
          };

          rs.edgeType = 'bezier';
          
          rs.cp2x = adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint;
          rs.cp2y = adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint;
          
          // console.log(edge, midPointX, displacementX, distanceFromMidpoint);
        }

        // find endpts for edge
        this.findEndpoints( edge );

        var badStart = !$$.is.number( rs.startX ) || !$$.is.number( rs.startY );
        var badAStart = !$$.is.number( rs.arrowStartX ) || !$$.is.number( rs.arrowStartY );
        var badEnd = !$$.is.number( rs.endX ) || !$$.is.number( rs.endY );
        var badAEnd = !$$.is.number( rs.arrowEndX ) || !$$.is.number( rs.arrowEndY );

        var minCpADistFactor = 3;
        var arrowW = this.getArrowWidth( edge._private.style['width'].pxValue ) * CanvasRenderer.arrowShapeHeight;
        var minCpADist = minCpADistFactor * arrowW;
        var startACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.startX, y: rs.startY } );
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.endX, y: rs.endY } );
        var closeEndACp = endACpDist < minCpADist;

        if( rs.edgeType === 'bezier' ){
          var overlapping = false;

          if( badStart || badAStart || closeStartACp ){
            overlapping = true;

            // project control point along line from src centre to outside the src shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.cp2x - srcPos.x,
              y: rs.cp2y - srcPos.y
            };
            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.cp2x + cpM.x * 2 * radius,
              y: rs.cp2y + cpM.y * 2 * radius
            };

            var srcCtrlPtIntn = srcShape.intersectLine(
              srcPos.x,
              srcPos.y,
              srcW,
              srcH,
              cpProj.x,
              cpProj.y,
              srcBorder / 2
            );

            if( closeStartACp ){
              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - startACpDist); 
              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - startACpDist);
            } else {
              rs.cp2x = srcCtrlPtIntn[0] + cpM.x * minCpADist; 
              rs.cp2y = srcCtrlPtIntn[1] + cpM.y * minCpADist;
            }
          }

          if( badEnd || badAEnd || closeEndACp ){
            overlapping = true;

            // project control point along line from tgt centre to outside the tgt shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.cp2x - tgtPos.x,
              y: rs.cp2y - tgtPos.y
            };
            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.cp2x + cpM.x * 2 * radius,
              y: rs.cp2y + cpM.y * 2 * radius
            };

            var tgtCtrlPtIntn = tgtShape.intersectLine(
              tgtPos.x,
              tgtPos.y,
              tgtW,
              tgtH,
              cpProj.x,
              cpProj.y,
              tgtBorder / 2
            );

            if( closeEndACp ){
              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - endACpDist); 
              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - endACpDist);
            } else {
              rs.cp2x = tgtCtrlPtIntn[0] + cpM.x * minCpADist; 
              rs.cp2y = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
            }
            
          }

          if( overlapping ){
            // recalc endpts
            this.findEndpoints( edge );
          }
        } else if( rs.edgeType === 'straight' ){
          rs.midX = ( srcX2 + tgtX2 )/2;
          rs.midY = ( srcY2 + tgtY2 )/2;
        }

        // project the edge into rstyle
        this.projectBezier( edge );
        this.recalculateEdgeLabelProjection( edge );

      }
    }
      
    for( var i = 0; i < haystackEdges.length; i++ ){
      var edge = haystackEdges[i];
      var _p = edge._private;
      var rscratch = _p.rscratch;
      var rs = rscratch;

      if( !rscratch.haystack ){
        var angle = Math.random() * 2 * Math.PI;

        rscratch.source = {
          x: Math.cos(angle),
          y: Math.sin(angle)
        };

        var angle = Math.random() * 2 * Math.PI;

        rscratch.target = {
          x: Math.cos(angle),
          y: Math.sin(angle)
        };

      }

      var src = _p.source;
      var tgt = _p.target;
      var srcPos = src._private.position;
      var tgtPos = tgt._private.position;
      var srcW = src.width();
      var tgtW = tgt.width();
      var srcH = src.height();
      var tgtH = tgt.height();
      var radius = style['haystack-radius'].value;
      var halfRadius = radius/2; // b/c have to half width/height

      rs.haystackPts = [
        rs.source.x * srcW * halfRadius + srcPos.x,
        rs.source.y * srcH * halfRadius + srcPos.y,
        rs.target.x * tgtW * halfRadius + tgtPos.x,
        rs.target.y * tgtH * halfRadius + tgtPos.y
      ];

      // always override as haystack in case set to different type previously
      rscratch.edgeType = 'haystack';
      rscratch.haystack = true;

      this.recalculateEdgeLabelProjection( edge );
    }

    return hashTable;
  };

  CRp.findEndpoints = function(edge) {
    var intersect;

    var source = edge.source()[0];
    var target = edge.target()[0];
    
    var tgtArShape = edge._private.style['target-arrow-shape'].value;
    var srcArShape = edge._private.style['source-arrow-shape'].value;

    var tgtBorderW = target._private.style['border-width'].pxValue;
    var srcBorderW = source._private.style['border-width'].pxValue;

    var rs = edge._private.rscratch;
    
    if (rs.edgeType == 'self' || rs.edgeType == 'compound') {
      
      var cp = [rs.cp2cx, rs.cp2cy];
      
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        cp[0],
        cp[1], 
        tgtBorderW / 2
      );
      
      var arrowEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));
      
      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
      
      var cp = [rs.cp2ax, rs.cp2ay];

      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        srcBorderW / 2
      );
      
      var arrowStart = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));
      var edgeStart = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[srcArShape].gap(edge));
      
      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];


      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
    } else if (rs.edgeType == 'straight') {
    
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        source.position().x,
        source.position().y,
        tgtBorderW / 2);
        
      if (intersect.length === 0) {
        rs.noArrowPlacement = true;
        // return;
      } else {
        rs.noArrowPlacement = false;
      }
      
      var arrowEnd = $$.math.shortenIntersection(intersect,
        [source.position().x, source.position().y],
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect,
        [source.position().x, source.position().y],
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));

      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
    
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        target.position().x,
        target.position().y,
        srcBorderW / 2);
      
      if (intersect.length === 0) {
        rs.noArrowPlacement = true;
       // return;
      } else {
        rs.noArrowPlacement = false;
      }
      
      /*
      console.log("1: "
        + CanvasRenderer.arrowShapes[srcArShape],
          srcArShape);
      */
      var arrowStart = $$.math.shortenIntersection(intersect,
        [target.position().x, target.position().y],
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));
      var edgeStart = $$.math.shortenIntersection(intersect,
        [target.position().x, target.position().y],
        CanvasRenderer.arrowShapes[srcArShape].gap(edge));

      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];
      
      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
      if( !$$.is.number(rs.startX) || !$$.is.number(rs.startY) || !$$.is.number(rs.endX) || !$$.is.number(rs.endY) ){
        rs.badLine = true;
      } else {
        rs.badLine = false;
      }
            
    } else if (rs.edgeType == 'bezier') {
      // if( window.badArrow) debugger;
      var cp = [rs.cp2x, rs.cp2y];
      
      intersect = CanvasRenderer.nodeShapes[
        this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        tgtBorderW / 2
      );
      
      /*
      console.log("2: "
        + CanvasRenderer.arrowShapes[srcArShape],
          srcArShape);
      */
      var arrowEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));
      
      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
      
      intersect = CanvasRenderer.nodeShapes[
        this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        srcBorderW / 2
      );
      
      var arrowStart = $$.math.shortenIntersection(
        intersect, 
        cp,
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge)
      );
      var edgeStart = $$.math.shortenIntersection(
        intersect, 
        cp,
        CanvasRenderer.arrowShapes[srcArShape].gap(edge)
      );
    
      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];
      
      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
      // if( isNaN(rs.startX) || isNaN(rs.startY) ){
      //   debugger;
      // }

    } else if (rs.isArcEdge) {
      return;
    }
  };

  // Find adjacent edges
  CRp.findEdges = function(nodeSet) {
    
    var edges = this.getCachedEdges();
    
    var hashTable = {};
    var adjacentEdges = [];
    
    for (var i = 0; i < nodeSet.length; i++) {
      hashTable[nodeSet[i]._private.data.id] = nodeSet[i];
    }
    
    for (var i = 0; i < edges.length; i++) {
      if (hashTable[edges[i]._private.data.source]
        || hashTable[edges[i]._private.data.target]) {
        
        adjacentEdges.push(edges[i]);
      }
    }
    
    return adjacentEdges;
  };

  CRp.getArrowWidth = CRp.getArrowHeight = function(edgeWidth) {
    var cache = this.arrowWidthCache = this.arrowWidthCache || {};

    var cachedVal = cache[edgeWidth];
    if( cachedVal ){
      return cachedVal;
    }

    cachedVal =  Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29);
    cache[edgeWidth] = cachedVal;

    return cachedVal;
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

// Draw edge
  CRp.drawEdge = function(context, edge, drawOverlayInstead) {
    var rs = edge._private.rscratch;
    var usePaths = CanvasRenderer.usePaths();

    // if bezier ctrl pts can not be calculated, then die
    if( rs.badBezier || ( (rs.edgeType === 'bezier' || rs.edgeType === 'straight') && isNaN(rs.startX)) ){ // extra isNaN() for safari 7.1 b/c it mangles ctrlpt calcs
      return;
    }

    var style = edge._private.style;
    
    // Edge line width
    if (style['width'].pxValue <= 0) {
      return;
    }

    var overlayPadding = style['overlay-padding'].pxValue;
    var overlayOpacity = style['overlay-opacity'].value;
    var overlayColor = style['overlay-color'].value;

    // Edge color & opacity
    if( drawOverlayInstead ){

      if( overlayOpacity === 0 ){ // exit early if no overlay
        return;
      }

      this.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
      context.lineCap = 'round';

      if( edge._private.rscratch.edgeType == 'self' && !usePaths ){
        context.lineCap = 'butt';
      }

    } else {
      var lineColor = style['line-color'].value;

      this.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], style.opacity.value);
      
      context.lineCap = 'butt'; 
    }
    
    var startNode, endNode, source, target;
    source = startNode = edge._private.source;
    target = endNode = edge._private.target;

    // var targetPos = target._private.position;
    // var targetW = target.width();
    // var targetH = target.height();
    // var sourcePos = source._private.position;
    // var sourceW = source.width();
    // var sourceH = source.height();


    var edgeWidth = style['width'].pxValue + (drawOverlayInstead ? 2 * overlayPadding : 0);
    var lineStyle = drawOverlayInstead ? 'solid' : style['line-style'].value;
    context.lineWidth = edgeWidth;
    
    var shadowBlur = style['shadow-blur'].pxValue;
    var shadowOpacity = style['shadow-opacity'].value;
    var shadowColor = style['shadow-color'].value;
    var shadowOffsetX = style['shadow-offset-x'].pxValue;
    var shadowOffsetY = style['shadow-offset-y'].pxValue;

    this.shadowStyle(context,  shadowColor, drawOverlayInstead ? 0 : shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);
    
    // if( rs.edgeType !== 'haystack' ){
    //   this.findEndpoints(edge);
    // }
    
    if( rs.edgeType === 'haystack' ){
      // var radius = style['haystack-radius'].value;
      // var halfRadius = radius/2; // b/c have to half width/height

      this.drawStyledEdge(
        edge, 
        context, 
        rs.haystackPts,
        lineStyle,
        edgeWidth
      );
    } else if (rs.edgeType === 'self' || rs.edgeType === 'compound') {
      
      var details = edge._private.rscratch;
      var points = [details.startX, details.startY, details.cp2ax,
        details.cp2ay, details.selfEdgeMidX, details.selfEdgeMidY,
        details.selfEdgeMidX, details.selfEdgeMidY,
        details.cp2cx, details.cp2cy, details.endX, details.endY];

      this.drawStyledEdge(edge, context, points, lineStyle, edgeWidth);
      
    } else if (rs.edgeType === 'straight') {
      
      var nodeDirectionX = endNode._private.position.x - startNode._private.position.x;
      var nodeDirectionY = endNode._private.position.y - startNode._private.position.y;
      
      var edgeDirectionX = rs.endX - rs.startX;
      var edgeDirectionY = rs.endY - rs.startY;
      
      if (nodeDirectionX * edgeDirectionX
        + nodeDirectionY * edgeDirectionY < 0) {
        
        rs.straightEdgeTooShort = true;  
      } else {
        
        var details = rs;
        this.drawStyledEdge(edge, context, [details.startX, details.startY,
                                      details.endX, details.endY],
                                      lineStyle,
                                      edgeWidth);
        
        rs.straightEdgeTooShort = false;  
      }  
    } else {
      
      var details = rs;
      
      this.drawStyledEdge(edge, context, [details.startX, details.startY,
        details.cp2x, details.cp2y, details.endX, details.endY],
        lineStyle,
        edgeWidth);
      
    }
    
    if( rs.edgeType === 'haystack' ){
      this.drawArrowheads(context, edge, drawOverlayInstead);
    } else if ( rs.noArrowPlacement !== true && rs.startX !== undefined ){
      this.drawArrowheads(context, edge, drawOverlayInstead);
    }

    this.shadowStyle(context, 'transparent', 0); // reset for next guy

  };
  
  
  CRp.drawStyledEdge = function(
      edge, context, pts, type, width) {

    // 3 points given -> assume Bezier
    // 2 -> assume straight
    
    var rs = edge._private.rscratch;
    var canvasCxt = context;
    var path;
    var pathCacheHit = false;
    var usePaths = CanvasRenderer.usePaths();


    if( usePaths ){

      var pathCacheKey = pts;
      var keyLengthMatches = rs.pathCacheKey && pathCacheKey.length === rs.pathCacheKey.length;
      var keyMatches = keyLengthMatches;

      for( var i = 0; keyMatches && i < pathCacheKey.length; i++ ){
        if( rs.pathCacheKey[i] !== pathCacheKey[i] ){
          keyMatches = false;
        }
      }

      if( keyMatches ){
        path = context = rs.pathCache;
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.pathCacheKey = pathCacheKey;
        rs.pathCache = path;
      }

    }

    if( canvasCxt.setLineDash ){ // for very outofdate browsers
      switch( type ){
        case 'dotted':
          canvasCxt.setLineDash([ 1, 1 ]);
          break;

        case 'dashed':
          canvasCxt.setLineDash([ 6, 3 ]);
          break;

        case 'solid':
          canvasCxt.setLineDash([ ]);
          break;
      }
    }

    if( !pathCacheHit ){
      if( context.beginPath ){ context.beginPath(); }
      context.moveTo(pts[0], pts[1]);
      
      if( pts.length === 6 && !rs.badBezier ){ // bezier
        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);
      } else if( pts.length === 12 && !rs.badBezier ){ // double bezier loop
        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);
        context.quadraticCurveTo(pts[8], pts[9], pts[10], pts[11]);
      } else if( pts.length === 4 && !rs.badLine ){ // line
        context.lineTo(pts[2], pts[3]);
      }
    }

    context = canvasCxt;
    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }
  
    // reset any line dashes
    if( context.setLineDash ){ // for very outofdate browsers
      context.setLineDash([ ]);
    }

  };

  CRp.drawArrowheads = function(context, edge, drawOverlayInstead) {
    if( drawOverlayInstead ){ return; } // don't do anything for overlays 

    var rs = edge._private.rscratch;
    var self = this;
    var isHaystack = rs.edgeType === 'haystack';

    // Displacement gives direction for arrowhead orientation
    var dispX, dispY;
    var startX, startY, endX, endY;

    var srcPos = edge.source().position();
    var tgtPos = edge.target().position();

    if( isHaystack ){
      startX = rs.haystackPts[0];
      startY = rs.haystackPts[1];
      endX = rs.haystackPts[2];
      endY = rs.haystackPts[3];
    } else {
      startX = rs.arrowStartX;
      startY = rs.arrowStartY;
      endX = rs.arrowEndX;
      endY = rs.arrowEndY;
    }

    var style = edge._private.style;
    
    function drawArrowhead( prefix, x, y, dispX, dispY ){
      var arrowShape = style[prefix + '-arrow-shape'].value;

      if( arrowShape === 'none' ){
        return;
      }

      var gco = context.globalCompositeOperation;

      var arrowClearFill = style[prefix + '-arrow-fill'].value === 'hollow' ? 'both' : 'filled';
      var arrowFill = style[prefix + '-arrow-fill'].value;

      if( arrowShape === 'half-triangle-overshot' ){
        arrowFill = 'hollow';
        arrowClearFill = 'hollow';
      }

      if( style.opacity.value !== 1 || arrowFill === 'hollow' ){ // then extra clear is needed
        context.globalCompositeOperation = 'destination-out';
        
        self.fillStyle(context, 255, 255, 255, 1);
        self.strokeStyle(context, 255, 255, 255, 1);
        
        self.drawArrowShape( edge, prefix, context, 
          arrowClearFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, 
          x, y, dispX, dispY
        );

        context.globalCompositeOperation = gco;
      } // otherwise, the opaque arrow clears it for free :)

      var color = style[prefix + '-arrow-color'].value;
      self.fillStyle(context, color[0], color[1], color[2], style.opacity.value);
      self.strokeStyle(context, color[0], color[1], color[2], style.opacity.value);

      self.drawArrowShape( edge, prefix, context, 
        arrowFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, 
        x, y, dispX, dispY
      );
    }

    dispX = startX - srcPos.x;
    dispY = startY - srcPos.y;

    if( !isHaystack && !isNaN(startX) && !isNaN(startY) && !isNaN(dispX) && !isNaN(dispY) ){
      drawArrowhead( 'source', startX, startY, dispX, dispY );

    } else {
      // window.badArrow = true;
      // debugger;
    }
    
    var midX = rs.midX;
    var midY = rs.midY;

    if( isHaystack ){
      midX = ( startX + endX )/2;
      midY = ( startY + endY )/2;
    }

    dispX = startX - endX;
    dispY = startY - endY;

    if( rs.edgeType === 'self' ){
      dispX = 1;
      dispY = -1;
    }

    if( !isNaN(midX) && !isNaN(midY) ){
      drawArrowhead( 'mid-target', midX, midY, dispX, dispY );
    }

    dispX *= -1;
    dispY *= -1;

    if( !isNaN(midX) && !isNaN(midY) ){
      drawArrowhead( 'mid-source', midX, midY, dispX, dispY );
    }
    
    dispX = endX - tgtPos.x;
    dispY = endY - tgtPos.y;
    
    if( !isHaystack && !isNaN(endX) && !isNaN(endY) && !isNaN(dispX) && !isNaN(dispY) ){
      drawArrowhead( 'target', endX, endY, dispX, dispY );
    }
  };
  
  // Draw arrowshape
  CRp.drawArrowShape = function(edge, arrowType, context, fill, edgeWidth, shape, x, y, dispX, dispY) {
    var usePaths = CanvasRenderer.usePaths();
    var rs = edge._private.rscratch;
    var pathCacheHit = false;
    var path;
    var canvasContext = context;
    var translation = { x: x, y: y };

    // Negative of the angle
    var angle = Math.asin(dispY / (Math.sqrt(dispX * dispX + dispY * dispY)));
  
    if (dispX < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = - (Math.PI / 2 + angle);
    }
    
    var size = this.getArrowWidth( edgeWidth );
    var shapeImpl = CanvasRenderer.arrowShapes[shape];

    // context.translate(x, y);

    if( usePaths ){
      var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
      rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
      rs.arrowPathCache = rs.arrowPathCache || {};

      var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
      if( alreadyCached ){
        path = context = rs.arrowPathCache[arrowType];
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.arrowPathCacheKey[arrowType] = pathCacheKey;
        rs.arrowPathCache[arrowType] = path;
      }
    }

    if( context.beginPath ){ context.beginPath(); }

    if( !pathCacheHit ){
      shapeImpl.draw(context, size, angle, translation);
    }
    
    if( !shapeImpl.leavePathOpen && context.closePath ){
      context.closePath();
    }

    context = canvasContext;

    if( fill === 'filled' || fill === 'both' ){
      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }
    }

    if( fill === 'hollow' || fill === 'both' ){
      context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );
      context.lineJoin = 'miter';

      if( usePaths ){
        context.stroke( path );
      } else {
        context.stroke();
      }
      
    }

    // context.translate(-x, -y);
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  CRp.getCachedImage = function(url, onLoad) {
    var r = this;
    var imageCache = r.imageCache = r.imageCache || {};

    if( imageCache[url] && imageCache[url].image ){
      return imageCache[url].image;
    }
    
    var cache = imageCache[url] = imageCache[url] || {};

    var image = cache.image = new Image();
    image.addEventListener('load', onLoad);
    image.src = url;
    
    return image;
  };
  
  CRp.safeDrawImage = function( context, img, ix, iy, iw, ih, x, y, w, h ){
    var r = this;
    
    try {
      context.drawImage( img, ix, iy, iw, ih, x, y, w, h );
    } catch(e){
      r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
      r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;
      
      r.drawingImage = true;
      
      r.redraw();
    }
  };
  
  CRp.drawInscribedImage = function(context, img, node) {
    var r = this;
    var nodeX = node._private.position.x;
    var nodeY = node._private.position.y;
    var style = node._private.style;
    var fit = style['background-fit'].value;
    var xPos = style['background-position-x'];
    var yPos = style['background-position-y'];
    var repeat = style['background-repeat'].value;
    var nodeW = node.width();
    var nodeH = node.height();
    var rs = node._private.rscratch;
    var clip = style['background-clip'].value;
    var shouldClip = clip === 'node';
    var imgOpacity = style['background-image-opacity'].value;
    
    var w = img.width;
    var h = img.height;
    
    if( w === 0 || h === 0 ){
      return; // no point in drawing empty image (and chrome is broken in this case)
    }

    var bgW = style['background-width'];
    if( bgW.value !== 'auto' ){
      if( bgW.units === '%' ){
        w = bgW.value/100 * nodeW;
      } else {
        w = bgW.pxValue;
      }
    }

    var bgH = style['background-height'];
    if( bgH.value !== 'auto' ){
      if( bgH.units === '%' ){
        h = bgH.value/100 * nodeH;
      } else {
        h = bgH.pxValue;
      }
    }

    if( w === 0 || h === 0 ){
      return; // no point in drawing empty image (and chrome is broken in this case)
    }

    if( fit === 'contain' ){
      var scale = Math.min( nodeW/w, nodeH/h );

      w *= scale;
      h *= scale;

    } else if( fit === 'cover' ){
      var scale = Math.max( nodeW/w, nodeH/h );

      w *= scale;
      h *= scale;
    }

    var x = (nodeX - nodeW/2); // left
    if( xPos.units === '%' ){
      x += (nodeW - w) * xPos.value/100;
    } else {
      x += xPos.pxValue;
    }

    var y = (nodeY - nodeH/2); // top
    if( yPos.units === '%' ){
      y += (nodeH - h) * yPos.value/100;
    } else {
      y += yPos.pxValue;
    }

    if( rs.pathCache ){
      x -= nodeX;
      y -= nodeY;

      nodeX = 0;
      nodeY = 0;
    }

    var gAlpha = context.globalAlpha;

    context.globalAlpha = imgOpacity;

    if( repeat === 'no-repeat' ){

      if( shouldClip ){
        context.save();

        if( rs.pathCache ){
          context.clip( rs.pathCache );
        } else {
          CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(
            context,
            nodeX, nodeY, 
            nodeW, nodeH);

          context.clip();
        }
      }

      // context.drawImage( img, 0, 0, img.width, img.height, x, y, w, h );
      r.safeDrawImage( context, img, 0, 0, img.width, img.height, x, y, w, h );

      if( shouldClip ){
        context.restore();
      }
    } else {
      var pattern = context.createPattern( img, repeat );
      context.fillStyle = pattern;

      CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(
          context,
          nodeX, nodeY, 
          nodeW, nodeH);

        context.translate(x, y);
        context.fill();
        context.translate(-x, -y);
    }

    context.globalAlpha = gAlpha;
    
  };

  
})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // Draw edge text
  CRp.drawEdgeText = function(context, edge) {
    var text = edge._private.style['content'].strValue;

    if( !text || text.match(/^\s+$/) ){
      return;
    }

    if( this.hideEdgesOnViewport && (this.dragData.didDrag || this.pinching || this.hoverData.dragging || this.data.wheel || this.swipePanning) ){ return; } // save cycles on pinching

    var computedSize = edge._private.style['font-size'].pxValue * edge.cy().zoom();
    var minSize = edge._private.style['min-zoomed-font-size'].pxValue;

    if( computedSize < minSize ){
      return;
    }

    // Calculate text draw position

    context.textAlign = 'center';
    context.textBaseline = 'middle';
    
    var rs = edge._private.rscratch;
    if( !$$.is.number( rs.labelX ) || !$$.is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered

    var style = edge._private.style;
    var autorotate = style['edge-text-rotation'].strValue === 'autorotate';
    var theta, dx, dy;

    if( autorotate ){
      switch( rs.edgeType ){
        case 'haystack':
          dx = rs.haystackPts[2] - rs.haystackPts[0];
          dy = rs.haystackPts[3] - rs.haystackPts[1];
          break;
        default:
          dx = rs.endX - rs.startX;
          dy = rs.endY - rs.startY;
      }

      theta = Math.atan( dy / dx );

      context.translate(rs.labelX, rs.labelY);
      context.rotate(theta);

      this.drawText(context, edge, 0, 0);

      context.rotate(-theta);
      context.translate(-rs.labelX, -rs.labelY);
    } else {
      this.drawText(context, edge, rs.labelX, rs.labelY);
    }

  };

  // Draw node text
  CRp.drawNodeText = function(context, node) {
    var text = node._private.style['content'].strValue;

    if ( !text || text.match(/^\s+$/) ) {
      return;
    }

    var computedSize = node._private.style['font-size'].pxValue * node.cy().zoom();
    var minSize = node._private.style['min-zoomed-font-size'].pxValue;

    if( computedSize < minSize ){
      return;
    }

    // this.recalculateNodeLabelProjection( node );

    var textHalign = node._private.style['text-halign'].strValue;
    var textValign = node._private.style['text-valign'].strValue;
    var rs = node._private.rscratch;
    if( !$$.is.number( rs.labelX ) || !$$.is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered

    switch( textHalign ){
      case 'left':
        context.textAlign = 'right';
        break;

      case 'right':
        context.textAlign = 'left';
        break;

      default: // e.g. center
        context.textAlign = 'center';
    }

    switch( textValign ){
      case 'top':
        context.textBaseline = 'bottom';
        break;

      case 'bottom':
        context.textBaseline = 'top';
        break;

      default: // e.g. center
        context.textBaseline = 'middle';
    }

    this.drawText(context, node, rs.labelX, rs.labelY);
  };

  CRp.getFontCache = function(context){
    var cache;

    this.fontCaches = this.fontCaches || [];

    for( var i = 0; i < this.fontCaches.length; i++ ){
      cache = this.fontCaches[i];

      if( cache.context === context ){
        return cache;
      }
    }

    cache = {
      context: context
    };
    this.fontCaches.push(cache);

    return cache;
  };

  // set up canvas context with font
  // returns transformed text string
  CRp.setupTextStyle = function( context, element ){
    // Font style
    var parentOpacity = element.effectiveOpacity();
    var style = element._private.style;
    var labelStyle = style['font-style'].strValue;
    var labelSize = style['font-size'].pxValue + 'px';
    var labelFamily = style['font-family'].strValue;
    var labelWeight = style['font-weight'].strValue;
    var opacity = style['text-opacity'].value * style['opacity'].value * parentOpacity;
    var outlineOpacity = style['text-outline-opacity'].value * opacity;
    var color = style['color'].value;
    var outlineColor = style['text-outline-color'].value;
    var shadowBlur = style['text-shadow-blur'].pxValue;
    var shadowOpacity = style['text-shadow-opacity'].value;
    var shadowColor = style['text-shadow-color'].value;
    var shadowOffsetX = style['text-shadow-offset-x'].pxValue;
    var shadowOffsetY = style['text-shadow-offset-y'].pxValue;

    var fontCacheKey = element._private.fontKey;
    var cache = this.getFontCache(context);

    if( cache.key !== fontCacheKey ){
      context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

      cache.key = fontCacheKey;
    }

    var text = this.getLabelText( element );

    // Calculate text draw position based on text alignment

    // so text outlines aren't jagged
    context.lineJoin = 'round';

    this.fillStyle(context, color[0], color[1], color[2], opacity);

    this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);

    this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

    return text;
  };

  function roundRect(ctx, x, y, width, height, radius) {
    var radius = radius || 5;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
  }

  // Draw text
  CRp.drawText = function(context, element, textX, textY) {
    var _p = element._private;
    var style = _p.style;
    var rstyle = _p.rstyle;
    var rscratch = _p.rscratch;
    var parentOpacity = element.effectiveOpacity();
    if( parentOpacity === 0 || style['text-opacity'].value === 0){ return; }

    var text = this.setupTextStyle( context, element );
    var halign = style['text-halign'].value;
    var valign = style['text-valign'].value;

    if( element.isEdge() ){
      halign = 'center';
      valign = 'center';
    }

    if ( text != null && !isNaN(textX) && !isNaN(textY)) {
      var backgroundOpacity = style['text-background-opacity'].value;
      var borderOpacity = style['text-border-opacity'].value;
      var textBorderWidth = style['text-border-width'].pxValue;
      
      if( backgroundOpacity > 0 || (textBorderWidth > 0 && borderOpacity > 0) ){
        var margin = 4 + textBorderWidth/2;

        if (element.isNode()) {
          //Move textX, textY to include the background margins
          if (valign === 'top') {
            textY -= margin;
          } else if (valign === 'bottom') {
            textY += margin;
          }
          if (halign === 'left') {
            textX -= margin;
          } else if (halign === 'right') {
            textX += margin;
          }
        }

        var bgWidth = rstyle.labelWidth;
        var bgHeight = rstyle.labelHeight;
        var bgX = textX;

        if (halign) {
          if (halign == 'center') {
            bgX = bgX - bgWidth / 2;
          } else if (halign == 'left') {
            bgX = bgX- bgWidth;
          }
        }

        var bgY = textY;

        if (element.isNode()) {
          if (valign == 'top') {
             bgY = bgY - bgHeight;
          } else if (valign == 'center') {
            bgY = bgY- bgHeight / 2;
          }
        } else {
          bgY = bgY - bgHeight / 2;
        }

        if (style['edge-text-rotation'].strValue === 'autorotate') {
          textY = 0;
          bgWidth += 4;
          bgX = textX - bgWidth / 2;
          bgY = textY - bgHeight / 2;
        } else {
          // Adjust with border width & margin
          bgX -= margin;
          bgY -= margin;
          bgHeight += margin*2;
          bgWidth += margin*2;
        }

        if( backgroundOpacity > 0 ){
          var textFill = context.fillStyle;
          var textBackgroundColor = style['text-background-color'].value;

          context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
          var styleShape = style['text-background-shape'].strValue;
          if (styleShape == 'roundrectangle') {
            roundRect(context, bgX, bgY, bgWidth, bgHeight, 2);
          } else {
            context.fillRect(bgX,bgY,bgWidth,bgHeight);
          }
          context.fillStyle = textFill;
        }

        if( textBorderWidth > 0 && borderOpacity > 0 ){
          var textStroke = context.strokeStyle;
          var textLineWidth = context.lineWidth;
          var textBorderColor = style['text-border-color'].value;
          var textBorderStyle = style['text-border-style'].value;

          context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
          context.lineWidth = textBorderWidth;

          if( context.setLineDash ){ // for very outofdate browsers
            switch( textBorderStyle ){
              case 'dotted':
                context.setLineDash([ 1, 1 ]);
                break;
              case 'dashed':
                context.setLineDash([ 4, 2 ]);
                break;
              case 'double':
                context.lineWidth = textBorderWidth/4; // 50% reserved for white between the two borders
                context.setLineDash([ ]);
                break;
              case 'solid':
                context.setLineDash([ ]);
                break;
            }
          }

          context.strokeRect(bgX,bgY,bgWidth,bgHeight);

          if( textBorderStyle === 'double' ){
            var whiteWidth = textBorderWidth/2;

            context.strokeRect(bgX+whiteWidth,bgY+whiteWidth,bgWidth-whiteWidth*2,bgHeight-whiteWidth*2);
          }

          if( context.setLineDash ){ // for very outofdate browsers
            context.setLineDash([ ]);
          }
          context.lineWidth = textLineWidth;
          context.strokeStyle = textStroke;
        }

      }

      var lineWidth = 2  * style['text-outline-width'].pxValue; // *2 b/c the stroke is drawn centred on the middle

      if( lineWidth > 0 ){
        context.lineWidth = lineWidth;
      }

      if( style['text-wrap'].value === 'wrap' ){ //console.log('draw wrap');
        var lines = rscratch.labelWrapCachedLines;
        var lineHeight = rstyle.labelHeight / lines.length;

        //console.log('lines', lines);

        switch( valign ){
          case 'top':
            textY -= (lines.length - 1) * lineHeight;
            break;

          case 'bottom':
            // nothing required
            break;

          default:
          case 'center':
            textY -= (lines.length - 1) * lineHeight / 2;
        }

        for( var l = 0; l < lines.length; l++ ){
          if( lineWidth > 0 ){
            context.strokeText( lines[l], textX, textY );
          }

          context.fillText( lines[l], textX, textY );

          textY += lineHeight;
        }

        // var fontSize = style['font-size'].pxValue;
        // wrapText(context, text, textX, textY, style['text-max-width'].pxValue, fontSize + 1);
      } else {
        if( lineWidth > 0 ){
          context.strokeText( text, textX, textY );
        }

        context.fillText( text, textX, textY );
      }


      this.shadowStyle(context, 'transparent', 0); // reset for next guy
    }
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // Draw node
  CRp.drawNode = function(context, node, drawOverlayInstead) {

    var r = this;
    var nodeWidth, nodeHeight;
    var style = node._private.style;
    var rs = node._private.rscratch;
    var _p = node._private;
    
    var usePaths = CanvasRenderer.usePaths();
    var canvasContext = context;
    var path;
    var pathCacheHit = false;

    var overlayPadding = style['overlay-padding'].pxValue;
    var overlayOpacity = style['overlay-opacity'].value;
    var overlayColor = style['overlay-color'].value;

    if( drawOverlayInstead && overlayOpacity === 0 ){ // exit early if drawing overlay but none to draw
      return;
    }

    var parentOpacity = node.effectiveOpacity();
    if( parentOpacity === 0 ){ return; }

    nodeWidth = this.getNodeWidth(node);
    nodeHeight = this.getNodeHeight(node);
    
    context.lineWidth = style['border-width'].pxValue;

    if( drawOverlayInstead === undefined || !drawOverlayInstead ){

      var url = style['background-image'].value[2] ||
        style['background-image'].value[1];
      var image;

      if (url !== undefined) {
        
        // get image, and if not loaded then ask to redraw when later loaded
        image = this.getCachedImage(url, function(){
          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;
          
          r.drawingImage = true;
          
          r.redraw();
        });
        
        var prevBging = _p.backgrounding;
        _p.backgrounding = !image.complete;

        if( prevBging !== _p.backgrounding ){ // update style b/c :backgrounding state changed
          node.updateStyle( false );
        }
      } 

      // Node color & opacity

      var bgColor = style['background-color'].value;
      var borderColor = style['border-color'].value;
      var borderStyle = style['border-style'].value;

      this.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], style['background-opacity'].value * parentOpacity);
      
      this.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], style['border-opacity'].value * parentOpacity);
      
      var shadowBlur = style['shadow-blur'].pxValue;
      var shadowOpacity = style['shadow-opacity'].value;
      var shadowColor = style['shadow-color'].value;
      var shadowOffsetX = style['shadow-offset-x'].pxValue;
      var shadowOffsetY = style['shadow-offset-y'].pxValue;

      this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

      context.lineJoin = 'miter'; // so borders are square with the node shape

      if( context.setLineDash ){ // for very outofdate browsers
        switch( borderStyle ){
          case 'dotted':
            context.setLineDash([ 1, 1 ]);
            break;

          case 'dashed':
            context.setLineDash([ 4, 2 ]);
            break;

          case 'solid':
          case 'double':
            context.setLineDash([ ]);
            break;
        }
      }

      
      var styleShape = style['shape'].strValue;

      var pos = node._private.position;

      if( usePaths ){
        var pathCacheKey = styleShape + '$' + nodeWidth +'$' + nodeHeight;

        context.translate( pos.x, pos.y );

        if( rs.pathCacheKey === pathCacheKey ){
          path = context = rs.pathCache;
          pathCacheHit = true;
        } else {
          path = context = new Path2D();
          rs.pathCacheKey = pathCacheKey;
          rs.pathCache = path;
        }
      }

      if( !pathCacheHit ){

        var npos = pos;

        if( usePaths ){
          npos = {
            x: 0,
            y: 0
          };
        }

        CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(
              context,
              npos.x,
              npos.y,
              nodeWidth,
              nodeHeight);
      }

      context = canvasContext;

      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }

      this.shadowStyle(context, 'transparent', 0); // reset for next guy

      if (url !== undefined) {
        if( image.complete ){
          this.drawInscribedImage(context, image, node);
        }
      } 
      
      var darkness = style['background-blacken'].value;
      var borderWidth = style['border-width'].pxValue;

      if( this.hasPie(node) ){
        this.drawPie( context, node, parentOpacity );

        // redraw path for blacken and border
        if( darkness !== 0 || borderWidth !== 0 ){

          if( !usePaths ){
            CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(
                context,
                pos.x,
                pos.y,
                nodeWidth,
                nodeHeight);
          }
        }
      }

      if( darkness > 0 ){
        this.fillStyle(context, 0, 0, 0, darkness);

        if( usePaths ){
          context.fill( path );
        } else {
          context.fill();
        }
        
      } else if( darkness < 0 ){
        this.fillStyle(context, 255, 255, 255, -darkness);
        
        if( usePaths ){
          context.fill( path );
        } else {
          context.fill();
        }
      }

      // Border width, draw border
      if (borderWidth > 0) {

        if( usePaths ){
          context.stroke( path );
        } else {
          context.stroke();
        }

        if( borderStyle === 'double' ){
          context.lineWidth = style['border-width'].pxValue/3;

          var gco = context.globalCompositeOperation;
          context.globalCompositeOperation = 'destination-out';

          if( usePaths ){
            context.stroke( path );
          } else {
            context.stroke();
          }

          context.globalCompositeOperation = gco;
        }

      }

      if( usePaths ){
        context.translate( -pos.x, -pos.y );
      }

      // reset in case we changed the border style
      if( context.setLineDash ){ // for very outofdate browsers
        context.setLineDash([ ]);
      }

    // draw the overlay
    } else {

      if( overlayOpacity > 0 ){
        this.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);

        CanvasRenderer.nodeShapes['roundrectangle'].drawPath(
          context,
          node._private.position.x,
          node._private.position.y,
          nodeWidth + overlayPadding * 2,
          nodeHeight + overlayPadding * 2
        );

        context.fill();
      }
    }

  };

  // does the node have at least one pie piece?
  CRp.hasPie = function(node){
    node = node[0]; // ensure ele ref
    
    return node._private.hasPie;
  };

  CRp.drawPie = function( context, node, nodeOpacity ){
    node = node[0]; // ensure ele ref

    var _p = node._private;
    var style = _p.style;
    var pieSize = style['pie-size'];
    var nodeW = this.getNodeWidth( node );
    var nodeH = this.getNodeHeight( node );
    var x = _p.position.x;
    var y = _p.position.y;
    var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node
    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
    var usePaths = CanvasRenderer.usePaths();

    if( usePaths ){
      x = 0;
      y = 0;
    }

    if( pieSize.units === '%' ){
      radius = radius * pieSize.value / 100;
    } else if( pieSize.pxValue !== undefined ){
      radius = pieSize.pxValue / 2;
    }

    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N
      var size = style['pie-' + i + '-background-size'].value;
      var color = style['pie-' + i + '-background-color'].value;
      var opacity = style['pie-' + i + '-background-opacity'].value * nodeOpacity;
      var percent = size / 100; // map integer range [0, 100] to [0, 1]
      var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
      var angleDelta = 2 * Math.PI * percent;
      var angleEnd = angleStart + angleDelta;

      // ignore if
      // - zero size
      // - we're already beyond the full circle
      // - adding the current slice would go beyond the full circle
      if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){
        continue;
      }

      context.beginPath();
      context.moveTo(x, y);
      context.arc( x, y, radius, angleStart, angleEnd );
      context.closePath();

      this.fillStyle(context, color[0], color[1], color[2], opacity);

      context.fill();

      lastPercent += percent;
    }

  };

  
})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CR = CanvasRenderer;
  var CRp = CanvasRenderer.prototype;

  // var isFirefox = typeof InstallTrigger !== 'undefined';

  CRp.getPixelRatio = function(){ 
    var context = this.data.contexts[0];

    if( this.forcedPixelRatio != null ){
      return this.forcedPixelRatio;
    }

    var backingStore = context.backingStorePixelRatio ||
      context.webkitBackingStorePixelRatio ||
      context.mozBackingStorePixelRatio ||
      context.msBackingStorePixelRatio ||
      context.oBackingStorePixelRatio ||
      context.backingStorePixelRatio || 1;

    //console.log(window.devicePixelRatio, backingStore);

    // if( isFirefox ){ // because ff can't scale canvas properly
    //   return 1;
    // }

    return (window.devicePixelRatio || 1) / backingStore;
  };

  CRp.paintCache = function(context){
    var caches = this.paintCaches = this.paintCaches || [];
    var needToCreateCache = true;
    var cache;

    for(var i = 0; i < caches.length; i++ ){
      cache = caches[i];

      if( cache.context === context ){
        needToCreateCache = false;
        break;
      }
    }

    if( needToCreateCache ){
      cache = {
        context: context
      };
      caches.push( cache );
    }

    return cache;
  };

  CRp.fillStyle = function(context, r, g, b, a){
    context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    
    // turn off for now, seems context does its own caching

    // var cache = this.paintCache(context);

    // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

    // if( cache.fillStyle !== fillStyle ){
    //   context.fillStyle = cache.fillStyle = fillStyle;
    // }
  };

  CRp.strokeStyle = function(context, r, g, b, a){
    context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    
    // turn off for now, seems context does its own caching

    // var cache = this.paintCache(context);

    // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

    // if( cache.strokeStyle !== strokeStyle ){
    //   context.strokeStyle = cache.strokeStyle = strokeStyle;
    // }
  };
  
  CRp.shadowStyle = function(context, color, opacity, blur, offsetX, offsetY){
    var zoom = this.data.cy.zoom();

    var cache = this.paintCache(context);
    
    // don't make expensive changes to the shadow style if it's not used
    if( cache.shadowOpacity === 0 && opacity === 0 ){
      return;
    }

    cache.shadowOpacity = opacity;

    if (opacity > 0) {
      context.shadowBlur = blur * zoom;
      context.shadowColor = "rgba(" + color[0] + "," + color[1] + "," + color[2] + "," + opacity + ")";
      context.shadowOffsetX = offsetX * zoom;
      context.shadowOffsetY = offsetY * zoom;
    } else {
      context.shadowBlur = 0;
      context.shadowColor = "transparent";
    }
  };

  // Resize canvas
  CRp.matchCanvasSize = function(container) {
    var data = this.data;
    var width = container.clientWidth;
    var height = container.clientHeight;
    var pixelRatio = this.getPixelRatio();
    var mbPxRatio = this.motionBlurPxRatio;

    if(
      container === this.data.bufferCanvases[CR.MOTIONBLUR_BUFFER_NODE] ||
      container === this.data.bufferCanvases[CR.MOTIONBLUR_BUFFER_DRAG]
    ){
      pixelRatio = mbPxRatio;
    }

    var canvasWidth = width * pixelRatio;
    var canvasHeight = height * pixelRatio;
    var canvas;

    if( canvasWidth === this.canvasWidth && canvasHeight === this.canvasHeight ){
      return; // save cycles if same
    }

    this.fontCaches = null; // resizing resets the style

    var canvasContainer = data.canvasContainer;
    canvasContainer.style.width = width + 'px';
    canvasContainer.style.height = height + 'px';

    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {

      canvas = data.canvases[i];
      
      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
    }
    
    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {
      
      canvas = data.bufferCanvases[i];
      
      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
    }

    this.textureMult = 1;
    if( pixelRatio <= 1 ){
      canvas = data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];

      this.textureMult = 2;
      canvas.width = canvasWidth * this.textureMult;
      canvas.height = canvasHeight * this.textureMult;
    }

    this.canvasWidth = canvasWidth;
    this.canvasHeight = canvasHeight;

  };

  CRp.renderTo = function( cxt, zoom, pan, pxRatio ){
    this.redraw({
      forcedContext: cxt,
      forcedZoom: zoom,
      forcedPan: pan,
      drawAllLayers: true,
      forcedPxRatio: pxRatio
    });
  };

  CRp.timeToRender = function(){
    return this.redrawTotalTime / this.redrawCount;
  };

  CanvasRenderer.minRedrawLimit = 1000/60; // people can't see much better than 60fps
  CanvasRenderer.maxRedrawLimit = 1000;  // don't cap max b/c it's more important to be responsive than smooth
  CanvasRenderer.motionBlurDelay = 100;

  // Redraw frame
  CRp.redraw = function( options ) {
    options = options || {};

    // console.log('redraw()');

    var forcedContext = options.forcedContext;
    var drawAllLayers = options.drawAllLayers;
    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
    var forcedZoom = options.forcedZoom;
    var forcedPan = options.forcedPan;
    var r = this;
    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
    var cy = r.data.cy; var data = r.data; 
    var needDraw = data.canvasNeedsRedraw;
    var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
    var mbPxRatio = r.motionBlurPxRatio;
    var hasCompoundNodes = cy.hasCompoundNodes();
    var inNodeDragGesture = r.hoverData.draggingEles;
    var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
    var motionBlurFadeEffect = motionBlur;

    // console.log('textureDraw?', textureDraw);


    if( !forcedContext && r.motionBlurTimeout ){
      clearTimeout( r.motionBlurTimeout );
    }

    if( !forcedContext && this.redrawTimeout ){
      clearTimeout( this.redrawTimeout );
    }
    this.redrawTimeout = null;

    if( this.averageRedrawTime === undefined ){ this.averageRedrawTime = 0; }

    var minRedrawLimit = CanvasRenderer.minRedrawLimit; 
    var maxRedrawLimit = CanvasRenderer.maxRedrawLimit;

    var redrawLimit = this.averageRedrawTime; // estimate the ideal redraw limit based on how fast we can draw
    redrawLimit = minRedrawLimit > redrawLimit ? minRedrawLimit : redrawLimit;
    redrawLimit = redrawLimit < maxRedrawLimit ? redrawLimit : maxRedrawLimit;

    //console.log('--\nideal: %i; effective: %i', this.averageRedrawTime, redrawLimit);

    if( this.lastDrawTime === undefined ){ this.lastDrawTime = 0; }

    var nowTime = Date.now();
    var timeElapsed = nowTime - this.lastDrawTime;
    var callAfterLimit = timeElapsed >= redrawLimit;

    if( !forcedContext && !r.clearingMotionBlur ){
      if( !callAfterLimit || this.currentlyDrawing ){
        // console.log('-- skip', redrawLimit);

        // we have new things to draw but we're busy, so try again when possibly free
        this.redrawTimeout = setTimeout(function(){
          r.redraw();
        }, redrawLimit);
        return;
      }

      this.lastDrawTime = nowTime;
      this.currentlyDrawing = true;
    }

    if( motionBlur ){
      if( r.mbFrames == null ){
        r.mbFrames = 0;
      }

      if( !r.drawingImage ){ // image loading frames don't count towards motion blur blurry frames
        r.mbFrames++;
      }
      
      if( r.mbFrames < 3 ){ // need several frames before even high quality motionblur
        motionBlurFadeEffect = false;
      }

      // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
      if( r.mbFrames > r.minMbLowQualFrames ){
        //r.fullQualityMb = false;
        r.motionBlurPxRatio = r.mbPxRBlurry;
      }
    } 

    // console.log('mb: %s, N: %s, q: %s', motionBlur, r.mbFrames, r.motionBlurPxRatio);

    if( r.clearingMotionBlur ){
      //r.fullQualityMb = true; // TODO enable when doesn't cause scaled flashing issue

      r.motionBlurPxRatio = 1;
    }


    var startTime = Date.now();

    // console.log('-- redraw --')
    
    function drawToContext(){ 
      // startTime = Date.now();
      // console.profile('draw' + startTime)
      
      // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
      // because a rogue async texture frame would clear needDraw
      if( r.textureDrawLastFrame && !textureDraw ){
        needDraw[CR.NODE] = true;
        needDraw[CR.SELECT_BOX] = true;
      }
      
      // console.log('drawToContext()');
      // console.log( 'needDraw', needDraw[CR.NODE], needDraw[CR.DRAG], needDraw[CR.SELECT_BOX] );

      var edges = r.getCachedEdges();
      var coreStyle = cy.style()._private.coreStyle;
      
      var zoom = cy.zoom();
      var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
      var pan = cy.pan();
      var effectivePan = {
        x: pan.x,
        y: pan.y
      };

      var vp = {
        zoom: zoom,
        pan: {
          x: pan.x,
          y: pan.y
        }
      };
      var prevVp = r.prevViewport;
      var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

      // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
      if( !viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes) ){
        r.motionBlurPxRatio = 1;
      }

      if( forcedPan ){
        effectivePan = forcedPan;
      }

      // apply pixel ratio

      effectiveZoom *= pixelRatio;
      effectivePan.x *= pixelRatio;
      effectivePan.y *= pixelRatio;
      
      var eles = {
        drag: {
          nodes: [],
          edges: [],
          eles: []
        },
        nondrag: {
          nodes: [],
          edges: [],
          eles: []
        }
      };

      function mbclear( context, x, y, w, h ){
        var gco = context.globalCompositeOperation;

        context.globalCompositeOperation = 'destination-out';
        r.fillStyle( context, 255, 255, 255, r.motionBlurTransparency );
        context.fillRect(x, y, w, h);

        context.globalCompositeOperation = gco;
      }

      function setContextTransform(context, clear){
        var ePan, eZoom, w, h;

        if( /*!r.fullQualityMb &&*/ !r.clearingMotionBlur && (context === data.bufferContexts[CR.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[CR.MOTIONBLUR_BUFFER_DRAG]) ){
          ePan = {
            x: pan.x * mbPxRatio,
            y: pan.y * mbPxRatio
          };

          eZoom = zoom * mbPxRatio;

          w = r.canvasWidth * mbPxRatio;
          h = r.canvasHeight * mbPxRatio;
        } else {
          ePan = effectivePan;
          eZoom = effectiveZoom;

          w = r.canvasWidth;
          h = r.canvasHeight;
        }

        context.setTransform(1, 0, 0, 1, 0, 0);

        if( clear === 'motionBlur' ){ 
          mbclear(context, 0, 0, w, h);
        } else if( !forcedContext && (clear === undefined || clear) ){
          context.clearRect(0, 0, w, h);
        }
        
        if( !drawAllLayers ){
          context.translate( ePan.x, ePan.y );
          context.scale( eZoom, eZoom );
        }
        if( forcedPan ){
          context.translate( forcedPan.x, forcedPan.y );
        } 
        if( forcedZoom ){
          context.scale( forcedZoom, forcedZoom );
        }
      }

      if( !textureDraw ){
        r.textureDrawLastFrame = false;
      }

      if( textureDraw ){
        // console.log('textureDraw')
        
        r.textureDrawLastFrame = true;

        var bb;

        if( !r.textureCache ){
          r.textureCache = {};

          bb = r.textureCache.bb = cy.elements().boundingBox();

          r.textureCache.texture = r.data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];

          var cxt = r.data.bufferContexts[ CanvasRenderer.TEXTURE_BUFFER ];

          cxt.setTransform(1, 0, 0, 1, 0, 0);
          cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
          
          r.redraw({
            forcedContext: cxt,
            drawOnlyNodeLayer: true,
            forcedPxRatio: pixelRatio * r.textureMult
          });

          var vp = r.textureCache.viewport = {
            zoom: cy.zoom(),
            pan: cy.pan(),
            width: r.canvasWidth,
            height: r.canvasHeight
          };

          vp.mpan = {
            x: (0 - vp.pan.x)/vp.zoom,
            y: (0 - vp.pan.y)/vp.zoom
          };
        }

        needDraw[CR.DRAG] = false;
        needDraw[CR.NODE] = false;

        var context = data.contexts[CR.NODE];

        var texture = r.textureCache.texture;
        var vp = r.textureCache.viewport;
        bb = r.textureCache.bb;

        context.setTransform(1, 0, 0, 1, 0, 0);

        if( motionBlur ){
          mbclear(context, 0, 0, vp.width, vp.height);
        } else {
          context.clearRect(0, 0, vp.width, vp.height);
        }

        var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
        var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
        r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );
        context.fillRect( 0, 0, vp.width, vp.height );

        var zoom = cy.zoom();
        
        setContextTransform( context, false );

        context.clearRect( vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );
        context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );

      } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it
        r.textureCache = null;
      }

      var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);
      var hideEdges = r.hideEdgesOnViewport && vpManip;
      var hideLabels = r.hideLabelsOnViewport && vpManip;

      if (needDraw[CR.DRAG] || needDraw[CR.NODE] || drawAllLayers || drawOnlyNodeLayer) {
        //NB : VERY EXPENSIVE

        if( hideEdges ){ 
        } else {
          r.findEdgeControlPoints(edges);
        }

        var zEles = r.getCachedZSortedEles();
        var extent = cy.extent();

        for (var i = 0; i < zEles.length; i++) {
          var ele = zEles[i];
          var list;
          var bb = forcedContext ? null : ele.boundingBox();
          var insideExtent = forcedContext ? true : $$.math.boundingBoxesIntersect( extent, bb );

          if( !insideExtent ){ continue; } // no need to render

          if ( ele._private.rscratch.inDragLayer ) {
            list = eles.drag;
          } else {
            list = eles.nondrag;
          }

          list.eles.push( ele );
        }

      }
      
      
      function drawElements( list, context ){
        var eles = list.eles;

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          if( ele.isNode() ){
            r.drawNode(context, ele);

            if( !hideLabels ){
              r.drawNodeText(context, ele);
            }

            r.drawNode(context, ele, true);
          } else if( !hideEdges ) {
            r.drawEdge(context, ele);

            if( !hideLabels ){
              r.drawEdgeText(context, ele);
            }

            r.drawEdge(context, ele, true);
          }
          
          
        }

      }

      var needMbClear = [];

      needMbClear[CR.NODE] = !needDraw[CR.NODE] && motionBlur && !r.clearedForMotionBlur[CR.NODE] || r.clearingMotionBlur;
      if( needMbClear[CR.NODE] ){ r.clearedForMotionBlur[CR.NODE] = true; }

      needMbClear[CR.DRAG] = !needDraw[CR.DRAG] && motionBlur && !r.clearedForMotionBlur[CR.DRAG] || r.clearingMotionBlur;
      if( needMbClear[CR.DRAG] ){ r.clearedForMotionBlur[CR.DRAG] = true; }

      // console.log('--');

      // if( needDraw[CR.DRAG] && motionBlur && needDraw[CR.NODE] && inNodeDragGesture ){
      //   console.log('NODE blurclean');
      // 
      //   var context = data.contexts[CR.NODE];
      // 
      //   setContextTransform( context, true );
      //   drawElements(eles.nondrag, context);
      // 
      //   needDraw[CR.NODE] = false; 
      //   needMbClear[CR.NODE] = false;
      // 
      // } else 
      if( needDraw[CR.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[CR.NODE] ){
        // console.log('NODE', needDraw[CR.NODE], needMbClear[CR.NODE]);

        var useBuffer = motionBlur && !needMbClear[CR.NODE] && mbPxRatio !== 1;
        var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ CR.MOTIONBLUR_BUFFER_NODE ] : data.contexts[CR.NODE] );
        var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

        // if( needDraw[CR.DRAG] && needDraw[CR.NODE] ){
        //   clear = true;
        // }

        setContextTransform( context, clear );
        drawElements(eles.nondrag, context);
        
        if( !drawAllLayers && !motionBlur ){
          needDraw[CR.NODE] = false; 
        }
      }

      if ( !drawOnlyNodeLayer && (needDraw[CR.DRAG] || drawAllLayers || needMbClear[CR.DRAG]) ) {
        // console.log('DRAG');

        var useBuffer = motionBlur && !needMbClear[CR.DRAG] && mbPxRatio !== 1;
        var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ CR.MOTIONBLUR_BUFFER_DRAG ] : data.contexts[CR.DRAG] );
        
        setContextTransform( context, motionBlur && !useBuffer ? 'motionBlur' : undefined );
        drawElements(eles.drag, context);
        
        if( !drawAllLayers && !motionBlur ){
          needDraw[CR.DRAG] = false;
        }
      }
      
      if( r.showFps || (!drawOnlyNodeLayer && (needDraw[CR.SELECT_BOX] && !drawAllLayers)) ) {
        // console.log('redrawing selection box');
        
        var context = forcedContext || data.contexts[CR.SELECT_BOX];

        setContextTransform( context );

        if( data.select[4] == 1 && ( r.hoverData.selecting || r.touchData.selecting ) ){
          var zoom = data.cy.zoom();
          var borderWidth = coreStyle['selection-box-border-width'].value / zoom;
          
          context.lineWidth = borderWidth;
          context.fillStyle = "rgba(" 
            + coreStyle['selection-box-color'].value[0] + ","
            + coreStyle['selection-box-color'].value[1] + ","
            + coreStyle['selection-box-color'].value[2] + ","
            + coreStyle['selection-box-opacity'].value + ")";
          
          context.fillRect(
            data.select[0],
            data.select[1],
            data.select[2] - data.select[0],
            data.select[3] - data.select[1]);
          
          if (borderWidth > 0) {
            context.strokeStyle = "rgba(" 
              + coreStyle['selection-box-border-color'].value[0] + ","
              + coreStyle['selection-box-border-color'].value[1] + ","
              + coreStyle['selection-box-border-color'].value[2] + ","
              + coreStyle['selection-box-opacity'].value + ")";
            
            context.strokeRect(
              data.select[0],
              data.select[1],
              data.select[2] - data.select[0],
              data.select[3] - data.select[1]);
          }
        }

        if( data.bgActivePosistion && !r.hoverData.selecting ){
          var zoom = data.cy.zoom();
          var pos = data.bgActivePosistion;

          context.fillStyle = "rgba(" 
            + coreStyle['active-bg-color'].value[0] + ","
            + coreStyle['active-bg-color'].value[1] + ","
            + coreStyle['active-bg-color'].value[2] + ","
            + coreStyle['active-bg-opacity'].value + ")";

          context.beginPath();
          context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pxValue / zoom, 0, 2 * Math.PI); 
          context.fill();
        }
        
        var timeToRender = r.averageRedrawTime;
        if( r.showFps && timeToRender ){
          timeToRender = Math.round( timeToRender );
          var fps = Math.round(1000/timeToRender);

          context.setTransform(1, 0, 0, 1, 0, 0);

          //context.font = '20px helvetica';
          context.fillStyle = 'rgba(255, 0, 0, 0.75)';
          context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
          context.lineWidth = 1;
          context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);

          var maxFps = 60;
          context.strokeRect(0, 30, 250, 20);
          context.fillRect(0, 30, 250 * Math.min(fps/maxFps, 1), 20);
        }

        if( !drawAllLayers ){
          needDraw[CR.SELECT_BOX] = false; 
        }
      }

      // motionblur: blit rendered blurry frames
      if( motionBlur && mbPxRatio !== 1 ){
        var cxtNode = data.contexts[CR.NODE];
        var txtNode = r.data.bufferCanvases[ CR.MOTIONBLUR_BUFFER_NODE ];

        var cxtDrag = data.contexts[CR.DRAG];
        var txtDrag = r.data.bufferCanvases[ CR.MOTIONBLUR_BUFFER_DRAG ];

        var drawMotionBlur = function( cxt, txt, needClear ){
          cxt.setTransform(1, 0, 0, 1, 0, 0);

          if( needClear || !motionBlurFadeEffect ){
            cxt.clearRect( 0, 0, r.canvasWidth, r.canvasHeight );
          } else {
            mbclear( cxt, 0, 0, r.canvasWidth, r.canvasHeight );
          }
          
          var pxr = /*r.fullQualityMb ? 1 :*/ mbPxRatio;

          cxt.drawImage( 
            txt, // img
            0, 0, // sx, sy
            r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
            0, 0, // x, y
            r.canvasWidth, r.canvasHeight // w, h
          );
        };

        if( needDraw[CR.NODE] || needMbClear[CR.NODE] ){
          // console.log('mb NODE', needMbClear[CR.NODE]);

          drawMotionBlur( cxtNode, txtNode, needMbClear[CR.NODE] );
          needDraw[CR.NODE] = false;
        }

        if( needDraw[CR.DRAG] || needMbClear[CR.DRAG] ){
          // console.log('mb DRAG');

          drawMotionBlur( cxtDrag, txtDrag, needMbClear[CR.DRAG] );
          needDraw[CR.DRAG] = false;
          //needMbClear[CR.NODE] = true;
        }
      }


      var endTime = Date.now();

      if( r.averageRedrawTime === undefined ){
        r.averageRedrawTime = endTime - startTime;
      }

      if( r.redrawCount === undefined ){
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if( r.redrawTotalTime === undefined ){
        r.redrawTotalTime = 0;
      }

      r.redrawTotalTime += endTime - startTime;
      r.lastRedrawTime = endTime - startTime;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime/2 + (endTime - startTime)/2;
      //console.log('actual: %i, average: %i', endTime - startTime, this.averageRedrawTime);

      r.currentlyDrawing = false;

      r.prevViewport = vp;

      // console.profileEnd('draw' + startTime)

      if( r.clearingMotionBlur ){
        r.clearingMotionBlur = false;
        r.motionBlurCleared = true;
        r.motionBlur = true;
      }

      if( motionBlur ){ 
        r.motionBlurTimeout = setTimeout(function(){
          r.motionBlurTimeout = null;
          // console.log('mb CLEAR');

          r.clearedForMotionBlur[CR.NODE] = false;
          r.clearedForMotionBlur[CR.DRAG] = false;
          r.motionBlur = false;
          r.clearingMotionBlur = !textureDraw;
          r.mbFrames = 0;

          needDraw[CR.NODE] = true; 
          needDraw[CR.DRAG] = true; 

          r.redraw();
        }, CanvasRenderer.motionBlurDelay);
      }

      r.drawingImage = false;

    } // draw to context

    if( !forcedContext ){
      $$.util.requestAnimationFrame(drawToContext); // makes direct renders to screen a bit more responsive
    } else {
      drawToContext();
    }

    if( !forcedContext && !r.initrender ){
      r.initrender = true;
      cy.trigger('initrender');
    }

    if( !forcedContext ){
      cy.triggerOnRender();
    }
    
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // @O Polygon drawing
  CRp.drawPolygonPath = function(
    context, x, y, width, height, points) {

    var halfW = width / 2;
    var halfH = height / 2;

    if( context.beginPath ){ context.beginPath(); }

    context.moveTo( x + halfW * points[0], y + halfH * points[1] );

    for (var i = 1; i < points.length / 2; i++) {
      context.lineTo( x + halfW * points[i * 2], y + halfH * points[i * 2 + 1] );
    }
    
    context.closePath();
  };
  
  CRp.drawPolygon = function(
    context, x, y, width, height, points) {

    // Draw path
    this.drawPolygonPath(context, x, y, width, height, points);
    
    // Fill path
    context.fill();
  };
  
  // Round rectangle drawing
  CRp.drawRoundRectanglePath = function(
    context, x, y, width, height, radius) {
    
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var cornerRadius = $$.math.getRoundRectangleRadius(width, height);
    
    if( context.beginPath ){ context.beginPath(); }
    
    // Start at top middle
    context.moveTo(x, y - halfHeight);
    // Arc from middle top to right side
    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
    // Arc from right side to bottom
    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
    // Arc from bottom to left side
    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
    // Arc from left side to topBorder
    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
    // Join line
    context.lineTo(x, y - halfHeight);
    
    
    context.closePath();
  };
  
  CRp.drawRoundRectangle = function(
    context, x, y, width, height, radius) {
    
    this.drawRoundRectanglePath(context, x, y, width, height, radius);
    
    context.fill();
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  CRp.createBuffer = function(w, h) {
    var buffer = document.createElement('canvas');
    buffer.width = w;
    buffer.height = h;
    
    return [buffer, buffer.getContext('2d')];
  };

  CRp.bufferCanvasImage = function( options ){
    var data = this.data;
    var cy = data.cy;
    var bb = cy.elements().boundingBox();
    var width = options.full ? Math.ceil(bb.w) : this.data.container.clientWidth;
    var height = options.full ? Math.ceil(bb.h) : this.data.container.clientHeight;
    var scale = 1;

    if( options.scale !== undefined ){
      width *= options.scale;
      height *= options.scale;

      scale = options.scale;
    } else if( $$.is.number(options.maxWidth) || $$.is.number(options.maxHeight) ){
      var maxScaleW = Infinity;
      var maxScaleH = Infinity;

      if( $$.is.number(options.maxWidth) ){
        maxScaleW = scale * options.maxWidth / width;
      }

      if( $$.is.number(options.maxHeight) ){
        maxScaleH = scale * options.maxHeight / height;
      }

      scale = Math.min( maxScaleW, maxScaleH );

      width *= scale;
      height *= scale;
    }

    var buffCanvas = document.createElement('canvas');

    buffCanvas.width = width;
    buffCanvas.height = height;

    buffCanvas.style.width = width + 'px';
    buffCanvas.style.height = height + 'px';

    var buffCxt = buffCanvas.getContext('2d');

    // Rasterize the layers, but only if container has nonzero size
    if (width > 0 && height > 0) {

      buffCxt.clearRect( 0, 0, width, height );

      if( options.bg ){
        buffCxt.fillStyle = options.bg;
        buffCxt.rect( 0, 0, width, height );
        buffCxt.fill();
      }

      buffCxt.globalCompositeOperation = 'source-over';

      if( options.full ){ // draw the full bounds of the graph
        this.redraw({
          forcedContext: buffCxt,
          drawAllLayers: true,
          forcedZoom: scale,
          forcedPan: { x: -bb.x1*scale, y: -bb.y1*scale },
          forcedPxRatio: 1
        });
      } else { // draw the current view
        var cyPan = cy.pan();
        var pan = {
          x: cyPan.x * scale,
          y: cyPan.y * scale
        };
        var zoom = cy.zoom() * scale;

        this.redraw({
          forcedContext: buffCxt,
          drawAllLayers: true,
          forcedZoom: zoom,
          forcedPan: pan,
          forcedPxRatio: 1
        });
      }
    }

    return buffCanvas;
  }; 

  CRp.png = function( options ){
    return this.bufferCanvasImage( options ).toDataURL('image/png');
  };
  
  CRp.jpg = function( options ){
    return this.bufferCanvasImage( options ).toDataURL('image/jpeg');
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CR = CanvasRenderer;
  var CRp = CR.prototype;

  CRp.registerBinding = function(target, event, handler, useCapture){
    this.bindings.push({
      target: target,
      event: event,
      handler: handler,
      useCapture: useCapture
    });

    target.addEventListener(event, handler, useCapture);
  };

  CRp.nodeIsDraggable = function(node) {
    if (node._private.style['opacity'].value !== 0
      && node._private.style['visibility'].value == 'visible'
      && node._private.style['display'].value == 'element'
      && !node.locked()
      && node.grabbable() ) {

      return true;
    }

    return false;
  };

  CRp.load = function() {
    var r = this;

    var getDragListIds = function(opts){
      var listHasId;

      if( opts.addToList && r.data.cy.hasCompoundNodes() ){ // only needed for compound graphs
        if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist
          opts.addToList.hasId = {};

          for( var i = 0; i < opts.addToList.length; i++ ){
            var ele = opts.addToList[i];

            opts.addToList.hasId[ ele.id() ] = true;
          }
        }

        listHasId = opts.addToList.hasId;
      }

      return listHasId || {};
    };

    // helper function to determine which child nodes and inner edges
    // of a compound node to be dragged as well as the grabbed and selected nodes
    var addDescendantsToDrag = function(node, opts){
      if( !node._private.cy.hasCompoundNodes() ){
        return;
      }

      if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

      var listHasId = getDragListIds( opts );

      var innerNodes = node.descendants();

      // TODO do not drag hidden children & children of hidden children?
      for( var i = 0; i < innerNodes.size(); i++ ){
        var iNode = innerNodes[i];
        var _p = iNode._private;

        if( opts.inDragLayer ){
          _p.rscratch.inDragLayer = true;
        }

        if( opts.addToList && !listHasId[ iNode.id() ] ){
          opts.addToList.push( iNode );
          listHasId[ iNode.id() ] = true;

          _p.grabbed = true;
        }

        var edges = _p.edges;
        for( var j = 0; opts.inDragLayer && j < edges.length; j++ ){
          edges[j]._private.rscratch.inDragLayer = true;
        }
      }
    };

    // adds the given nodes, and its edges to the drag layer
    var addNodeToDrag = function(node, opts){

      var _p = node._private;
      var listHasId = getDragListIds( opts );

      if( opts.inDragLayer ){
        _p.rscratch.inDragLayer = true;
      }

      if( opts.addToList && !listHasId[ node.id() ] ){
        opts.addToList.push( node );
        listHasId[ node.id() ] = true;

        _p.grabbed = true;
      }

      var edges = _p.edges;
      for( var i = 0; opts.inDragLayer && i < edges.length; i++ ){
        edges[i]._private.rscratch.inDragLayer = true;
      }

      addDescendantsToDrag( node, opts ); // always add to drag

      // also add nodes and edges related to the topmost ancestor
      updateAncestorsInDragLayer( node, {
        inDragLayer: opts.inDragLayer
      } );
    };
    
    var freeDraggedElements = function( draggedElements ){
      if( !draggedElements ){ return; }
      
      for (var i=0; i < draggedElements.length; i++) {

        var dEi_p = draggedElements[i]._private;

        if(dEi_p.group === 'nodes') {
          dEi_p.rscratch.inDragLayer = false;
          dEi_p.grabbed = false;

          var sEdges = dEi_p.edges;
          for( var j = 0; j < sEdges.length; j++ ){ sEdges[j]._private.rscratch.inDragLayer = false; }

          // for compound nodes, also remove related nodes and edges from the drag layer
          updateAncestorsInDragLayer(draggedElements[i], { inDragLayer: false });

        } else if( dEi_p.group === 'edges' ){
          dEi_p.rscratch.inDragLayer = false;
        }

      }
    };

    // helper function to determine which ancestor nodes and edges should go
    // to the drag layer (or should be removed from drag layer).
    var updateAncestorsInDragLayer = function(node, opts) {

      if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

      // find top-level parent
      var parent = node;

      if( !node._private.cy.hasCompoundNodes() ){
        return;
      }

      while( parent.parent().nonempty() ){
        parent = parent.parent()[0];
      }

      // no parent node: no nodes to add to the drag layer
      if( parent == node ){
        return;
      }

      var nodes = parent.descendants()
        .merge( parent )
        .unmerge( node )
        .unmerge( node.descendants() )
      ;

      var edges = nodes.connectedEdges();

      var listHasId = getDragListIds( opts );

      for( var i = 0; i < nodes.size(); i++ ){
        if( opts.inDragLayer !== undefined ){
          nodes[i]._private.rscratch.inDragLayer = opts.inDragLayer;
        }

        if( opts.addToList && !listHasId[ nodes[i].id() ] ){
          opts.addToList.push( nodes[i] );
          listHasId[ nodes[i].id() ] = true;

          nodes[i]._private.grabbed = true;
        }
      }

      for( var j = 0; opts.inDragLayer !== undefined && j < edges.length; j++ ) {
        edges[j]._private.rscratch.inDragLayer = opts.inDragLayer;
      }
    };

    if( typeof MutationObserver !== 'undefined' ){
      r.removeObserver = new MutationObserver(function( mutns ){
        for( var i = 0; i < mutns.length; i++ ){
          var mutn = mutns[i];
          var rNodes = mutn.removedNodes;

          if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){
            var rNode = rNodes[j];

            if( rNode === r.data.container ){
              r.destroy();
              break;
            }
          } }
        }
      });

      r.removeObserver.observe( r.data.container.parentNode, { childList: true } );
    } else {
      r.registerBinding(r.data.container, 'DOMNodeRemoved', function(e){
        r.destroy();
      });
    }



    // auto resize
    r.registerBinding(window, 'resize', $$.util.debounce( function(e) {
      r.invalidateContainerClientCoordsCache();

      r.matchCanvasSize(r.data.container);
      r.data.canvasNeedsRedraw[CR.NODE] = true;
      r.redraw();
    }, 100 ) );

    var invalCtnrBBOnScroll = function(domEle){
      r.registerBinding(domEle, 'scroll', function(e){
        r.invalidateContainerClientCoordsCache();
      } );
    };

    var bbCtnr = r.data.cy.container();

    for( ;; ){

      invalCtnrBBOnScroll( bbCtnr );

      if( bbCtnr.parentNode ){
        bbCtnr = bbCtnr.parentNode;
      } else {
        break;
      }

    }

    // stop right click menu from appearing on cy
    r.registerBinding(r.data.container, 'contextmenu', function(e){
      e.preventDefault();
    });

    var inBoxSelection = function(){
      return r.data.select[4] !== 0;
    };

    // Primary key
    r.registerBinding(r.data.container, 'mousedown', function(e) {
      e.preventDefault();
      r.hoverData.capture = true;
      r.hoverData.which = e.which;

      var cy = r.data.cy;
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var select = r.data.select;
      var near = r.findNearestElement(pos[0], pos[1], true, false);
      var draggedElements = r.dragData.possibleDragElements;

      r.hoverData.mdownPos = pos;
      
      var needsRedraw = r.data.canvasNeedsRedraw;

      var checkForTaphold = function(){
        r.hoverData.tapholdCancelled = false;

        clearTimeout( r.hoverData.tapholdTimeout );

        r.hoverData.tapholdTimeout = setTimeout(function(){

          if( r.hoverData.tapholdCancelled ){
            return;
          } else {
            var ele = r.hoverData.down;

            if( ele ){
              ele.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: pos[0], y: pos[1] }
              }) );
            } else {
              cy.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: pos[0], y: pos[1] }
              }) );
            }
          }

        }, r.tapholdDuration);
      };

      // Right click button
      if( e.which == 3 ){

        r.hoverData.cxtStarted = true;

        var cxtEvt = new $$.Event(e, {
          type: 'cxttapstart',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( near ){
          near.activate();
          near.trigger( cxtEvt );

          r.hoverData.down = near;
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.downTime = (new Date()).getTime();
        r.hoverData.cxtDragged = false;

      // Primary button
      } else if (e.which == 1) {

        if( near ){
          near.activate();
        }

        // Element dragging
        {
          // If something is under the cursor and it is draggable, prepare to grab it
          if (near != null) {

            if( r.nodeIsDraggable(near) ){

              var grabEvent = new $$.Event(e, {
                type: 'grab',
                cyPosition: { x: pos[0], y: pos[1] }
              });

              if ( near.isNode() && !near.selected() ){

                draggedElements = r.dragData.possibleDragElements = [];
                addNodeToDrag( near, { addToList: draggedElements } );

                near.trigger(grabEvent);

              } else if ( near.isNode() && near.selected() ){
                draggedElements = r.dragData.possibleDragElements = [  ];

                var selectedNodes = cy.$(function(){ return this.isNode() && this.selected(); });

                for( var i = 0; i < selectedNodes.length; i++ ){

                  // Only add this selected node to drag if it is draggable, eg. has nonzero opacity
                  if( r.nodeIsDraggable( selectedNodes[i] ) ){
                    addNodeToDrag( selectedNodes[i], { addToList: draggedElements } );
                  }
                }

                near.trigger( grabEvent );
              }

              needsRedraw[CR.NODE] = true;
              needsRedraw[CR.DRAG] = true;

            }

            near
              .trigger(new $$.Event(e, {
                type: 'mousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapstart',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;

          } else if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'mousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapstart',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          }

          r.hoverData.down = near;
          r.hoverData.downTime = (new Date()).getTime();

        }

        // Selection box
        if ( near == null || near.isEdge() ) {
          select[4] = 1;
          var timeUntilActive = Math.max( 0, CR.panOrBoxSelectDelay - (+new Date() - r.hoverData.downTime) );

          clearTimeout( r.bgActiveTimeout );

          if( cy.boxSelectionEnabled() || ( near && near.isEdge() ) ){
            r.bgActiveTimeout = setTimeout(function(){
              if( near ){
                near.unactivate();
              }

              r.data.bgActivePosistion = {
                x: pos[0],
                y: pos[1]
              };

              r.hoverData.dragging = true;

              //checkForTaphold();

              needsRedraw[CR.SELECT_BOX] = true;

              r.redraw();
            }, timeUntilActive);
          } else {
            r.data.bgActivePosistion = {
              x: pos[0],
              y: pos[1]
            };

            //r.hoverData.dragging = true;

            //checkForTaphold();

            needsRedraw[CR.SELECT_BOX] = true;

            r.redraw();
          }

        }

        checkForTaphold();

      }

      // Initialize selection box coordinates
      select[0] = select[2] = pos[0];
      select[1] = select[3] = pos[1];

    }, false);

    r.registerBinding(window, 'mousemove', $$.util.throttle( function(e) {
      var preventDefault = false;
      var capture = r.hoverData.capture;

      // save cycles if mouse events aren't to be captured
      if ( !capture ){
        var containerPageCoords = r.findContainerClientCoords();

        if (e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth
          && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight
        ) {
          // inside container bounds so OK
        } else {
          return;
        }

        var cyContainer = r.data.container;
        var target = e.target;
        var tParent = target.parentNode;
        var containerIsTarget = false;

        while( tParent ){
          if( tParent === cyContainer ){
            containerIsTarget = true;
            break;
          }

          tParent = tParent.parentNode;
        }

        if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us
      }

      var cy = r.data.cy;
      var zoom = cy.zoom();
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var select = r.data.select;
      var needsRedraw = r.data.canvasNeedsRedraw;

      var near = null;
      if( !r.hoverData.draggingEles ){
        near = r.findNearestElement(pos[0], pos[1], true, false);
      }
      var last = r.hoverData.last;
      var down = r.hoverData.down;

      var disp = [pos[0] - select[2], pos[1] - select[3]];

      var draggedElements = r.dragData.possibleDragElements;

      var dx = select[2] - select[0];
      var dx2 = dx * dx;
      var dy = select[3] - select[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      r.hoverData.tapholdCancelled = true;

      var updateDragDelta = function(){
        var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

        if( dragDelta.length === 0 ){
          dragDelta.push( disp[0] );
          dragDelta.push( disp[1] );
        } else {
          dragDelta[0] += disp[0];
          dragDelta[1] += disp[1];
        }
      };


      preventDefault = true;

      // Mousemove event
      {
        if (near != null) {
          near
            .trigger(new $$.Event(e, {
              type: 'mousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
          ;

        } else if (near == null) {
          cy
            .trigger(new $$.Event(e, {
              type: 'mousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
          ;
        }

      }

      // trigger context drag if rmouse down
      if( r.hoverData.which === 3 ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxtdrag',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.cxtDragged = true;

        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){

          if( r.hoverData.cxtOver ){
            r.hoverData.cxtOver.trigger( new $$.Event(e, {
              type: 'cxtdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            // console.log('cxtdragout ' + r.hoverData.cxtOver.id());
          }

          r.hoverData.cxtOver = near;

          if( near ){
            near.trigger( new $$.Event(e, {
              type: 'cxtdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            // console.log('cxtdragover ' + near.id());
          }

        }

      // Check if we are drag panning the entire graph
      } else if (r.hoverData.dragging) {
        preventDefault = true;

        if( cy.panningEnabled() && cy.userPanningEnabled() ){
          var deltaP;

          if( r.hoverData.justStartedPan ){
            var mdPos = r.hoverData.mdownPos;

            deltaP = {
              x: ( pos[0] - mdPos[0] ) * zoom,
              y: ( pos[1] - mdPos[1] ) * zoom
            };

            r.hoverData.justStartedPan = false;

          } else {
            deltaP = {
              x: disp[0] * zoom,
              y: disp[1] * zoom
            };

          }

          cy.panBy( deltaP );

          r.hoverData.dragged = true;
        }

        // Needs reproject due to pan changing viewport
        pos = r.projectIntoViewport(e.clientX, e.clientY);

      // Checks primary button down & out of time & mouse not moved much
      } else if(
          select[4] == 1 && (down == null || down.isEdge())
          && ( !cy.boxSelectionEnabled() || (+new Date() - r.hoverData.downTime >= CR.panOrBoxSelectDelay) )
          //&& (Math.abs(select[3] - select[1]) + Math.abs(select[2] - select[0]) < 4)
          && !r.hoverData.selecting
          && rdist2 >= r.desktopTapThreshold2
          && cy.panningEnabled() && cy.userPanningEnabled()
      ){
        r.hoverData.dragging = true;
        r.hoverData.selecting = false;
        r.hoverData.justStartedPan = true;
        select[4] = 0;

      } else {
        // deactivate bg on box selection
        if (cy.boxSelectionEnabled() && !r.hoverData.dragging && Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]){
          clearTimeout( r.bgActiveTimeout );
          r.data.bgActivePosistion = undefined;
          r.hoverData.selecting = true;

          needsRedraw[CR.SELECT_BOX] = true;
          r.redraw();
        }

        if( down && down.isEdge() && down.active() ){ down.unactivate(); }

        if (near != last) {

          if (last) {
            last.trigger( new $$.Event(e, {
              type: 'mouseout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            last.trigger( new $$.Event(e, {
              type: 'tapdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );
          }

          if (near) {
            near.trigger( new $$.Event(e, {
              type: 'mouseover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            near.trigger( new $$.Event(e, {
              type: 'tapdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );
          }

          r.hoverData.last = near;
        }

        if( down && down.isNode() && r.nodeIsDraggable(down) ){

          if( rdist2 >= r.desktopTapThreshold2 ){ // then drag

            var justStartedDrag = !r.dragData.didDrag;

            if( justStartedDrag ) {
              needsRedraw[CR.NODE] = true;
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = [];

            for( var i = 0; i < draggedElements.length; i++ ){
              var dEle = draggedElements[i];

              // now, add the elements to the drag layer if not done already
              if( !r.hoverData.draggingEles ){
                addNodeToDrag( dEle, { inDragLayer: true } );
              }

              // Locked nodes not draggable, as well as non-visible nodes
              if( dEle.isNode() && r.nodeIsDraggable(dEle) && dEle.grabbed() ){
                var dPos = dEle._private.position;

                toTrigger.push( dEle );

                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];

                  if( justStartedDrag ){
                    var dragDelta = r.hoverData.dragDelta;

                    if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){
                      dPos.x += dragDelta[0];
                      dPos.y += dragDelta[1];
                    }
                  }
                }

              }
            }

            r.hoverData.draggingEles = true;

            var tcol = (new $$.Collection(cy, toTrigger));

            tcol.updateCompoundBounds();
            tcol.trigger('position drag');

            needsRedraw[CR.DRAG] = true;
            r.redraw();

          } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
            updateDragDelta();
          }
        }

        // prevent the dragging from triggering text selection on the page
        preventDefault = true;
      }

      select[2] = pos[0]; select[3] = pos[1];

      if( preventDefault ){
        if(e.stopPropagation) e.stopPropagation();
          if(e.preventDefault) e.preventDefault();
          return false;
        }
    }, 1000/30, { trailing: true }), false);

    r.registerBinding(window, 'mouseup', function(e) {
      // console.log('--\nmouseup', e)

      var capture = r.hoverData.capture;
      if (!capture) { return; }
      r.hoverData.capture = false;

      var cy = r.data.cy; var pos = r.projectIntoViewport(e.clientX, e.clientY); var select = r.data.select;
      var near = r.findNearestElement(pos[0], pos[1], true, false);
      var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;
      var shiftDown = e.shiftKey;
      var needsRedraw = r.data.canvasNeedsRedraw;

      if( r.data.bgActivePosistion ){
        needsRedraw[CR.SELECT_BOX] = true;
        r.redraw();
      }

      r.data.bgActivePosistion = undefined; // not active bg now
      clearTimeout( r.bgActiveTimeout );

      if( down ){
        down.unactivate();
      }

      if( r.hoverData.which === 3 ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxttapend',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        if( !r.hoverData.cxtDragged ){
          var cxtTap = new $$.Event(e, {
            type: 'cxttap',
            cyPosition: { x: pos[0], y: pos[1] }
          });

          if( down ){
            down.trigger( cxtTap );
          } else {
            cy.trigger( cxtTap );
          }
        }

        r.hoverData.cxtDragged = false;
        r.hoverData.which = null;

      // if not right mouse
      } else {

        // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
        if ( (down == null) // not mousedown on node
          && !r.dragData.didDrag // didn't move the node around
          //&& !(Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]) // not box selection
          && !r.hoverData.dragged // didn't pan
        ) {

          cy.$(function(){
            return this.selected();
          }).unselect();

          if (draggedElements.length > 0) {
            needsRedraw[CR.NODE] = true;
          }

          r.dragData.possibleDragElements = draggedElements = [];
        }


        // Mouseup event
        {
          // console.log('trigger mouseup et al');

          if (near != null) {
            near
              .trigger(new $$.Event(e, {
                type: 'mouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          } else if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'mouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          }
        }

        // Click event
        {
          // console.log('trigger click et al');

          if(
            //Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) === 0
            !r.dragData.didDrag // didn't move a node around
            && !r.hoverData.dragged // didn't pan
          ){
            if (near != null) {
              near
                .trigger( new $$.Event(e, {
                  type: 'click',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'tap',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'vclick',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
              ;
            } else if (near == null) {
              cy
                .trigger( new $$.Event(e, {
                  type: 'click',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'tap',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'vclick',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
              ;
            }
          }
        }

        // Single selection
        if (near == down && !r.dragData.didDrag) {
          if (near != null && near._private.selectable) {

            // console.log('single selection')

            if( r.hoverData.dragging ){
              // if panning, don't change selection state
            } else if( cy.selectionType() === 'additive' || shiftDown ){
              if( near.selected() ){
                near.unselect();
              } else {
                near.select();
              }
            } else {
              if( !shiftDown ){
                cy.$(':selected').unmerge( near ).unselect();
                near.select();
              }
            }

            needsRedraw[CR.NODE] = true;

          }

        }

        if ( r.hoverData.selecting && cy.boxSelectionEnabled() &&  Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4] ) {
          var newlySelected = [];
          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

          needsRedraw[CR.SELECT_BOX] = true;

          if( box.length > 0 ) {
            needsRedraw[CR.NODE] = true;
          }

          for( var i = 0; i < box.length; i++ ){
            if( box[i]._private.selectable ){
              newlySelected.push( box[i] );
            }
          }

          var newlySelCol = new $$.Collection( cy, newlySelected );

          if( cy.selectionType() === 'additive' ){
            newlySelCol.select();
          } else {
            if( !shiftDown ){
              cy.$(':selected').unmerge( newlySelCol ).unselect();
            }

            newlySelCol.select();
          }

          // always need redraw in case eles unselectable
          r.redraw();

        }

        // Cancel drag pan
        if( r.hoverData.dragging ){
          r.hoverData.dragging = false;
          
          needsRedraw[CR.SELECT_BOX] = true;
          needsRedraw[CR.NODE] = true;
          
          r.redraw();
        }

        if (!select[4]) {
          // console.log('free at end', draggedElements)

          needsRedraw[CR.DRAG] = true;
          needsRedraw[CR.NODE] = true;

          freeDraggedElements( draggedElements );

          if( down ){ down.trigger('free'); }

  //        draggedElements = r.dragData.possibleDragElements = [];

        }

      } // else not right mouse

      select[4] = 0; r.hoverData.down = null;

      //r.data.canvasNeedsRedraw[CR.SELECT_BOX] = true;

//      console.log('mu', pos[0], pos[1]);
//      console.log('ss', select);

      r.hoverData.cxtStarted = false;
      r.hoverData.draggingEles = false;
      r.hoverData.selecting = false;
      r.dragData.didDrag = false;
      r.hoverData.dragged = false;
      r.hoverData.dragDelta = [];

    }, false);

    var wheelHandler = function(e) {
      if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom

      var cy = r.data.cy;
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var rpos = [pos[0] * cy.zoom() + cy.pan().x,
                    pos[1] * cy.zoom() + cy.pan().y];

      if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom
        e.preventDefault();
        return;
      }

      if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){
        e.preventDefault();

        r.data.wheelZooming = true;
        clearTimeout( r.data.wheelTimeout );
        r.data.wheelTimeout = setTimeout(function(){
          r.data.wheelZooming = false;

          r.data.canvasNeedsRedraw[CR.NODE] = true;
          r.redraw();
        }, 150);

        var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;
        diff = diff * r.wheelSensitivity;

        var needsWheelFix = e.deltaMode === 1;
        if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows
          diff *= 33;
        }

        cy.zoom({
          level: cy.zoom() * Math.pow(10, diff),
          renderedPosition: { x: rpos[0], y: rpos[1] }
        });
      }

    };

    // Functions to help with whether mouse wheel should trigger zooming
    // --
    r.registerBinding(r.data.container, 'wheel', wheelHandler, true);

    // disable nonstandard wheel events
    // r.registerBinding(r.data.container, 'mousewheel', wheelHandler, true);
    // r.registerBinding(r.data.container, 'DOMMouseScroll', wheelHandler, true);
    // r.registerBinding(r.data.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

    r.registerBinding(window, 'scroll', function(e){
      r.scrollingPage = true;

      clearTimeout( r.scrollingPageTimeout );
      r.scrollingPageTimeout = setTimeout(function(){
        r.scrollingPage = false;
      }, 250);
    }, true);

    // Functions to help with handling mouseout/mouseover on the Cytoscape container
          // Handle mouseout on Cytoscape container
    r.registerBinding(r.data.container, 'mouseout', function(e) {
      var pos = r.projectIntoViewport(e.clientX, e.clientY);

      r.data.cy.trigger(new $$.Event(e, {
        type: 'mouseout',
        cyPosition: { x: pos[0], y: pos[1] }
      }));
    }, false);

    r.registerBinding(r.data.container, 'mouseover', function(e) {
      var pos = r.projectIntoViewport(e.clientX, e.clientY);

      r.data.cy.trigger(new $$.Event(e, {
        type: 'mouseover',
        cyPosition: { x: pos[0], y: pos[1] }
      }));
    }, false);

    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
    var center1, modelCenter1; // center point on start pinch to zoom
    var offsetLeft, offsetTop;
    var containerWidth, containerHeight;
    var twoFingersStartInside;

    var distance = function(x1, y1, x2, y2){
      return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
    };

    var distanceSq = function(x1, y1, x2, y2){
      return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
    };

    r.registerBinding(r.data.container, 'touchstart', function(e) {

      clearTimeout( this.threeFingerSelectTimeout );

      if( e.target !== r.data.link ){
        e.preventDefault();
      }

      r.touchData.capture = true;
      r.data.bgActivePosistion = undefined;

      var cy = r.data.cy;
      var nodes = r.getCachedNodes();
      var edges = r.getCachedEdges();
      var now = r.touchData.now;
      var earlier = r.touchData.earlier;
      var needsRedraw = r.data.canvasNeedsRedraw;

      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }


      // record starting points for pinch-to-zoom
      if( e.touches[1] ){

        // anything in the set of dragged eles should be released
        var release = function( eles ){
          for( var i = 0; i < eles.length; i++ ){
            eles[i]._private.grabbed = false;
            eles[i]._private.rscratch.inDragLayer = false;
            if( eles[i].active() ){ eles[i].unactivate(); }
          }
        };
        release(nodes);
        release(edges);

        var offsets = r.findContainerClientCoords();
        offsetLeft = offsets[0];
        offsetTop = offsets[1];
        containerWidth = offsets[2];
        containerHeight = offsets[3];

        f1x1 = e.touches[0].clientX - offsetLeft;
        f1y1 = e.touches[0].clientY - offsetTop;

        f2x1 = e.touches[1].clientX - offsetLeft;
        f2y1 = e.touches[1].clientY - offsetTop;

        twoFingersStartInside =
             0 <= f1x1 && f1x1 <= containerWidth
          && 0 <= f2x1 && f2x1 <= containerWidth
          && 0 <= f1y1 && f1y1 <= containerHeight
          && 0 <= f2y1 && f2y1 <= containerHeight
        ;

        var pan = cy.pan();
        var zoom = cy.zoom();

        distance1 = distance( f1x1, f1y1, f2x1, f2y1 );
        distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );
        center1 = [ (f1x1 + f2x1)/2, (f1y1 + f2y1)/2 ];
        modelCenter1 = [
          (center1[0] - pan.x) / zoom,
          (center1[1] - pan.y) / zoom
        ];

        // consider context tap
        var cxtDistThreshold = 200;
        var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
        if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){

          var near1 = r.findNearestElement(now[0], now[1], true, true);
          var near2 = r.findNearestElement(now[2], now[3], true, true);

          //console.log(distance1)

          if( near1 && near1.isNode() ){
            near1.activate().trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = near1;

          } else if( near2 && near2.isNode() ){
            near2.activate().trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = near2;

          } else {
            cy.trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = null;
          }

          if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
          r.touchData.cxt = true;
          r.touchData.cxtDragged = false;
          r.data.bgActivePosistion = undefined;

          //console.log('cxttapstart')

          r.redraw();
          return;

        }

        // console.log(center1);
        // console.log('touchstart ptz');
        // console.log(offsetLeft, offsetTop);
        // console.log(f1x1, f1y1);
        // console.log(f2x1, f2y1);
        // console.log(distance1);
        // console.log(center1);
      }

      // console.log('another tapstart')


      if (e.touches[2]) {

      } else if (e.touches[1]) {

      } else if (e.touches[0]) {
        var near = r.findNearestElement(now[0], now[1], true, true);

        if (near != null) {
          near.activate();

          r.touchData.start = near;

          if( near.isNode() && r.nodeIsDraggable(near) ){

            var draggedEles = r.dragData.touchDragEles = [];

            needsRedraw[CR.NODE] = true;
            needsRedraw[CR.DRAG] = true;

            if( near.selected() ){
              // reset drag elements, since near will be added again

              var selectedNodes = cy.$(function(){
                return this.isNode() && this.selected();
              });

              for( var k = 0; k < selectedNodes.length; k++ ){
                var selectedNode = selectedNodes[k];

                if( r.nodeIsDraggable(selectedNode) ){
                  addNodeToDrag( selectedNode, { addToList: draggedEles } );
                }
              }
            } else {
              addNodeToDrag( near, { addToList: draggedEles } );
            }

            near.trigger( new $$.Event(e, {
              type: 'grab',
              cyPosition: { x: now[0], y: now[1] }
            }) );
          }

          near
            .trigger(new $$.Event(e, {
              type: 'touchstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousdown',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;
        } if (near == null) {
          cy
            .trigger(new $$.Event(e, {
              type: 'touchstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousedown',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;

          r.data.bgActivePosistion = {
            x: pos[0],
            y: pos[1]
          };

          needsRedraw[CR.SELECT_BOX] = true;
          r.redraw();
        }


        // Tap, taphold
        // -----

        for (var i=0; i<now.length; i++) {
          earlier[i] = now[i];
          r.touchData.startPosition[i] = now[i];
        }

        r.touchData.singleTouchMoved = false;
        r.touchData.singleTouchStartTime = +new Date();

        clearTimeout( r.touchData.tapholdTimeout );
        r.touchData.tapholdTimeout = setTimeout(function() {
          if(
              r.touchData.singleTouchMoved === false
              && !r.pinching // if pinching, then taphold unselect shouldn't take effect

              // This time double constraint prevents multiple quick taps
              // followed by a taphold triggering multiple taphold events
              //&& Date.now() - r.touchData.singleTouchStartTime > 250
          ){
            if (r.touchData.start) {
              r.touchData.start.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            } else {
              r.data.cy.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              cy.$(':selected').unselect();
            }

//            console.log('taphold');
          }
        }, r.tapholdDuration);
      }

      //r.redraw();

    }, false);

// console.log = function(m){ $('#console').append('<div>'+m+'</div>'); };

    r.registerBinding(window, 'touchmove', $$.util.throttle(function(e) {

      var select = r.data.select;
      var capture = r.touchData.capture; //if (!capture) { return; };
      if( capture ){ e.preventDefault(); }

      var cy = r.data.cy;
      var now = r.touchData.now; var earlier = r.touchData.earlier;
      var zoom = cy.zoom();
      
      var needsRedraw = r.data.canvasNeedsRedraw;

      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }

      var startPos = r.touchData.startPosition;

      var dx = now[0] - startPos[0];
      var dx2 = dx * dx;
      var dy = now[1] - startPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      if( capture && r.touchData.cxt ){
        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
        // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
        var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
        var factorSq = distance2Sq / distance1Sq;

        var distThreshold = 150;
        var distThresholdSq = distThreshold * distThreshold;
        var factorThreshold = 1.5;
        var factorThresholdSq = factorThreshold * factorThreshold;

        //console.log(factor, distance2)

        // cancel ctx gestures if the distance b/t the fingers increases
        if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){
          r.touchData.cxt = false;
          if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }
          r.data.bgActivePosistion = undefined;
          needsRedraw[CR.SELECT_BOX] = true;

          var cxtEvt = new $$.Event(e, {
            type: 'cxttapend',
            cyPosition: { x: now[0], y: now[1] }
          });
          if( r.touchData.start ){
            r.touchData.start.trigger( cxtEvt );
          } else {
            cy.trigger( cxtEvt );
          }
        }

      }

      if( capture && r.touchData.cxt ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxtdrag',
          cyPosition: { x: now[0], y: now[1] }
        });
        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;

        if( r.touchData.start ){
          r.touchData.start.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxtDragged = true;

        //console.log('cxtdrag')

        var near = r.findNearestElement(now[0], now[1], true, true);

        if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){

          if( r.touchData.cxtOver ){
            r.touchData.cxtOver.trigger( new $$.Event(e, {
              type: 'cxtdragout',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            // console.log('cxtdragout');
          }

          r.touchData.cxtOver = near;

          if( near ){
            near.trigger( new $$.Event(e, {
              type: 'cxtdragover',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            // console.log('cxtdragover');
          }

        }

      } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){
        r.data.bgActivePosistion = undefined;
        clearTimeout( this.threeFingerSelectTimeout );
        this.lastThreeTouch = +new Date();
        r.touchData.selecting = true;

        needsRedraw[CR.SELECT_BOX] = true;

        if( !select || select.length === 0 || select[0] === undefined ){
          select[0] = (now[0] + now[2] + now[4])/3;
          select[1] = (now[1] + now[3] + now[5])/3;
          select[2] = (now[0] + now[2] + now[4])/3 + 1;
          select[3] = (now[1] + now[3] + now[5])/3 + 1;
        } else {
          select[2] = (now[0] + now[2] + now[4])/3;
          select[3] = (now[1] + now[3] + now[5])/3;
        }

        select[4] = 1;
        r.touchData.selecting = true;

        r.redraw();

      } else if ( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ) { // two fingers => pinch to zoom
        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;

        var draggedEles = r.dragData.touchDragEles;
        if( draggedEles ){
          needsRedraw[CR.DRAG] = true;

          for( var i = 0; i < draggedEles.length; i++ ){
            draggedEles[i]._private.grabbed = false;
            draggedEles[i]._private.rscratch.inDragLayer = false;
          }
        }

        // console.log('touchmove ptz');

        // (x2, y2) for fingers 1 and 2
        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;

        // console.log( f1x2, f1y2 )
        // console.log( f2x2, f2y2 )

        var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
        // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
        // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
        var factor = distance2 / distance1;

        // console.log(distance2)
        // console.log(factor)

        if( factor != 1 && twoFingersStartInside){

          // console.log(factor)
          // console.log(distance2 + ' / ' + distance1);
          // console.log('--');

          // delta finger1
          var df1x = f1x2 - f1x1;
          var df1y = f1y2 - f1y1;

          // delta finger 2
          var df2x = f2x2 - f2x1;
          var df2y = f2y2 - f2y1;

          // translation is the normalised vector of the two fingers movement
          // i.e. so pinching cancels out and moving together pans
          var tx = (df1x + df2x)/2;
          var ty = (df1y + df2y)/2;

          // adjust factor by the speed multiplier
          // var speed = 1.5;
          // if( factor > 1 ){
          //   factor = (factor - 1) * speed + 1;
          // } else {
          //   factor = 1 - (1 - factor) * speed;
          // }

          // now calculate the zoom
          var zoom1 = cy.zoom();
          var zoom2 = zoom1 * factor;
          var pan1 = cy.pan();

          // the model center point converted to the current rendered pos
          var ctrx = modelCenter1[0] * zoom1 + pan1.x;
          var ctry = modelCenter1[1] * zoom1 + pan1.y;

          var pan2 = {
            x: -zoom2/zoom1 * (ctrx - pan1.x - tx) + ctrx,
            y: -zoom2/zoom1 * (ctry - pan1.y - ty) + ctry
          };

          // console.log(pan2);
          // console.log(zoom2);

          // remove dragged eles
          if( r.touchData.start ){
            var draggedEles = r.dragData.touchDragEles;

            if( draggedEles ){ for( var i = 0; i < draggedEles.length; i++ ){
              var dEi_p = draggedEles[i]._private;
              
              dEi_p.grabbed = false;
              dEi_p.rscratch.inDragLayer = false;
            } }

            var start_p = r.touchData.start._private;
            start_p.active = false;
            start_p.grabbed = false;
            start_p.rscratch.inDragLayer = false;

            needsRedraw[CR.DRAG] = true;

            r.touchData.start
              .trigger('free')
              .trigger('unactivate')
            ;
          }

          cy.viewport({
            zoom: zoom2,
            pan: pan2,
            cancelOnFailedZoom: true
          });

          distance1 = distance2;
          f1x1 = f1x2;
          f1y1 = f1y2;
          f2x1 = f2x2;
          f2y1 = f2y2;

          r.pinching = true;
        }

        // Re-project
        if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
        if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
        if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

      } else if (e.touches[0]) {
        var start = r.touchData.start;
        var last = r.touchData.last;
        var near = near || r.findNearestElement(now[0], now[1], true, true);

        if( start != null && start._private.group == 'nodes' && r.nodeIsDraggable(start) ){

          if( rdist2 >= r.touchTapThreshold2 ){ // then dragging can happen
            var draggedEles = r.dragData.touchDragEles;

            for( var k = 0; k < draggedEles.length; k++ ){
              var draggedEle = draggedEles[k];

              if( r.nodeIsDraggable(draggedEle) && draggedEle.isNode() && draggedEle.grabbed() ){
                r.dragData.didDrag = true;
                var dPos = draggedEle._private.position;
                var justStartedDrag = !r.hoverData.draggingEles;

                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];
                }

                if( justStartedDrag ){
                  addNodeToDrag( draggedEle, { inDragLayer: true } );
                  
                  needsRedraw[CR.NODE] = true;

                  var dragDelta = r.touchData.dragDelta;

                  if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){
                    dPos.x += dragDelta[0];
                    dPos.y += dragDelta[1];
                  }

                }
              }
            }

            var tcol = new $$.Collection(cy, draggedEle);

            tcol.updateCompoundBounds();
            tcol.trigger('position drag');

            r.hoverData.draggingEles = true;

            needsRedraw[CR.DRAG] = true;

            if(
                 r.touchData.startPosition[0] == earlier[0]
              && r.touchData.startPosition[1] == earlier[1]
            ){

              needsRedraw[CR.NODE] = true;
            }

            r.redraw();
          } else { // otherise keep track of drag delta for later
            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

            if( dragDelta.length === 0 ){
              dragDelta.push( disp[0] );
              dragDelta.push( disp[1] );
            } else {
              dragDelta[0] += disp[0];
              dragDelta[1] += disp[1];
            }
          }
        }

        // Touchmove event
        {

          if (start != null) {
            start.trigger( new $$.Event(e, {
              type: 'touchmove',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            start.trigger( new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            start.trigger( new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: now[0], y: now[1] }
            }) );
          }

          if (start == null) {

            if (near != null) {
              near.trigger( new $$.Event(e, {
                type: 'touchmove',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              near.trigger( new $$.Event(e, {
                type: 'tapdrag',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              near.trigger( new $$.Event(e, {
                type: 'vmousemove',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            }

            if (near == null) {
              cy.trigger( new $$.Event(e, {
                type: 'touchmove',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              cy.trigger( new $$.Event(e, {
                type: 'tapdrag',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              cy.trigger( new $$.Event(e, {
                type: 'vmousemove',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            }
          }

          if (near != last) {
            if (last) { last.trigger(new $$.Event(e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } })); }
            if (near) { near.trigger(new $$.Event(e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } })); }
          }

          r.touchData.last = near;
        }

        // Check to cancel taphold
        for (var i=0;i<now.length;i++) {
          if (now[i]
            && r.touchData.startPosition[i]
            && Math.abs(now[i] - r.touchData.startPosition[i]) > 4) {

            r.touchData.singleTouchMoved = true;
          }
        }

        if(
            capture
            && ( start == null || start.isEdge() )
            && cy.panningEnabled() && cy.userPanningEnabled()
        ){

          if( r.swipePanning ){
            cy.panBy({
              x: disp[0] * zoom,
              y: disp[1] * zoom
            });

          } else if( rdist2 >= r.touchTapThreshold2 ){
            r.swipePanning = true;

            cy.panBy({
              x: dx * zoom,
              y: dy * zoom
            });
          }

          if( start ){
            start.unactivate();

            if( !r.data.bgActivePosistion ){
              r.data.bgActivePosistion = {
                x: now[0],
                y: now[1]
              };
            }

            needsRedraw[CR.SELECT_BOX] = true;

            r.touchData.start = null;
          }

          // Re-project
          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
          now[0] = pos[0]; now[1] = pos[1];
        }
      }

      for (var j=0; j<now.length; j++) { earlier[j] = now[j]; }
      //r.redraw();

    }, 1000/30, { trailing: true }), false);

    r.registerBinding(window, 'touchcancel', function(e) {
      var start = r.touchData.start;

      r.touchData.capture = false;

      if( start ){
        start.unactivate();
      }
    });

    r.registerBinding(window, 'touchend', function(e) {
      var start = r.touchData.start;

      var capture = r.touchData.capture;

      if( capture ){
        r.touchData.capture = false;
      } else {
        return;
      }

      e.preventDefault();
      var select = r.data.select;

      r.swipePanning = false;
      r.hoverData.draggingEles = false;

      var cy = r.data.cy;
      var zoom = cy.zoom();
      var now = r.touchData.now;
      var earlier = r.touchData.earlier;
      
      var needsRedraw = r.data.canvasNeedsRedraw;

      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

      if( start ){
        start.unactivate();
      }

      var ctxTapend;
      if( r.touchData.cxt ){
        ctxTapend = new $$.Event(e, {
          type: 'cxttapend',
          cyPosition: { x: now[0], y: now[1] }
        });

        if( start ){
          start.trigger( ctxTapend );
        } else {
          cy.trigger( ctxTapend );
        }

        //console.log('cxttapend')

        if( !r.touchData.cxtDragged ){
          var ctxTap = new $$.Event(e, {
            type: 'cxttap',
            cyPosition: { x: now[0], y: now[1] }
          });

          if( start ){
            start.trigger( ctxTap );
          } else {
            cy.trigger( ctxTap );
          }

          //console.log('cxttap')
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxt = false;
        r.touchData.start = null;

        r.redraw();
        return;
      }

      // no more box selection if we don't have three fingers
      if( !e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting ){
        r.touchData.selecting = false;
        clearTimeout( this.threeFingerSelectTimeout );
        //this.threeFingerSelectTimeout = setTimeout(function(){
          var newlySelected = [];
          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

          select[0] = undefined;
          select[1] = undefined;
          select[2] = undefined;
          select[3] = undefined;
          select[4] = 0;

          needsRedraw[CR.SELECT_BOX] = true;

          // console.log(box);
          for( var i = 0; i< box.length; i++ ) {
            if( box[i]._private.selectable ){
              newlySelected.push( box[i] );
            }
          }

          var newlySelCol = new $$.Collection( cy, newlySelected );

          if( cy.selectionType() === 'single' ){
            cy.$(':selected').unmerge( newlySelCol ).unselect();
          }

          newlySelCol.select();

          if( newlySelCol.length > 0 ) {
            needsRedraw[CR.NODE] = true;
          } else {
            r.redraw();
          }

        //}, 100);
      }

      var updateStartStyle = false;

      if( start != null ){
        start._private.active = false;
        updateStartStyle = true;
        start.unactivate();
      }

      if (e.touches[2]) {
        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;
      } else if (e.touches[1]) {

      } else if (e.touches[0]) {

      // Last touch released
      } else if (!e.touches[0]) {

        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;
        
        var draggedEles = r.dragData.touchDragEles;

        if (start != null ) {

          var startWasGrabbed = start._private.grabbed;
          
          freeDraggedElements( draggedEles );

          needsRedraw[CR.DRAG] = true;
          needsRedraw[CR.NODE] = true;
          
          if( startWasGrabbed ){
            start.trigger('free');
          }

          start
            .trigger(new $$.Event(e, {
              type: 'touchend',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapend',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmouseup',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;

          start.unactivate();

          r.touchData.start = null;

        } else {
          var near = r.findNearestElement(now[0], now[1], true, true);

          if (near != null) {
            near
              .trigger(new $$.Event(e, {
                type: 'touchend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }

          if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'touchend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }
        }

        var dx = r.touchData.startPosition[0] - now[0];
        var dx2 = dx * dx;
        var dy = r.touchData.startPosition[1] - now[1];
        var dy2 = dy * dy;
        var dist2 = dx2 + dy2;
        var rdist2 = dist2 * zoom * zoom;

        // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
        if (start != null
            && !r.dragData.didDrag // didn't drag nodes around
            && start._private.selectable
            && rdist2 < r.touchTapThreshold2
            && !r.pinching // pinch to zoom should not affect selection
        ) {

          if( cy.selectionType() === 'single' ){
            cy.$(':selected').unmerge( start ).unselect();
            start.select();
          } else {
            if( start.selected() ){
              start.unselect();
            } else {
              start.select();
            }
          }

          updateStartStyle = true;


          needsRedraw[CR.NODE] = true;
        }

        // Tap event, roughly same as mouse click event for touch
        if ( r.touchData.singleTouchMoved === false ) {

          if (start) {
            start
              .trigger(new $$.Event(e, {
                type: 'tap',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vclick',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          } else {
            cy
              .trigger(new $$.Event(e, {
                type: 'tap',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vclick',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }

//          console.log('tap');
        }

        r.touchData.singleTouchMoved = true;
      }

      for( var j = 0; j < now.length; j++ ){ earlier[j] = now[j]; }

      r.dragData.didDrag = false; // reset for next mousedown

      if( e.touches.length === 0 ){
        r.touchData.dragDelta = [];
      }

      if( updateStartStyle && start ){
        start.updateStyle(false);
      }

      if( e.touches.length < 2 ){
        r.pinching = false;
        needsRedraw[CR.NODE] = true;
        r.redraw();
      }

      //r.redraw();

    }, false);
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var renderer = CanvasRenderer.prototype;
  var usePaths = CanvasRenderer.usePaths();

  // Node shape contract:
  //
  // draw: draw
  // intersectLine: report intersection from x, y, to node center
  // checkPoint: check x, y in node

  var nodeShapes = CanvasRenderer.nodeShapes = {};

  var sin0 = Math.sin(0);
  var cos0 = Math.cos(0);

  var sin = {};
  var cos = {};

  var ellipseStepSize = 0.1;

  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
    sin[i] = Math.sin(i);
    cos[i] = Math.cos(i);
  }

  nodeShapes['ellipse'] = {
    draw: function(context, centerX, centerY, width, height) {
      nodeShapes['ellipse'].drawPath(context, centerX, centerY, width, height);
      context.fill();
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      
      if( usePaths ){
        if( context.beginPath ){ context.beginPath(); }

        var xPos, yPos;
        var rw = width/2;
        var rh = height/2;
        for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
            xPos = centerX - (rw * sin[i]) * sin0 + (rw * cos[i]) * cos0;
            yPos = centerY + (rh * cos[i]) * sin0 + (rh * sin[i]) * cos0;

            if (i === 0) {
                context.moveTo(xPos, yPos);
            } else {
                context.lineTo(xPos, yPos);
            }
        }
        context.closePath();

      } else {

        if( context.beginPath ){ context.beginPath(); }
        context.translate(centerX, centerY);
        context.scale(width / 2, height / 2);
        // At origin, radius 1, 0 to 2pi
        context.arc(0, 0, 1, 0, Math.PI * 2 * 0.999, false); // *0.999 b/c chrome rendering bug on full circle
        context.closePath();

        context.scale(2/width, 2/height);
        context.translate(-centerX, -centerY);

      }
      
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      var intersect = $$.math.intersectLineEllipse(
        x, y,
        nodeX,
        nodeY,
        width / 2 + padding,
        height / 2 + padding);
      
      return intersect;
    },
    
    intersectBox: function(
      x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      return $$.math.boxIntersectEllipse(
        x1, y1, x2, y2, padding, width, height, centerX, centerY);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
//      console.log(arguments);
      
      x -= centerX;
      y -= centerY;
      
      x /= (width / 2 + padding);
      y /= (height / 2 + padding);
      
      return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);
    }
  };
  
  function generatePolygon( name, points ){
    nodeShapes[name] = {
      points: points,
      
      draw: function(context, centerX, centerY, width, height) {
        renderer.drawPolygon(context,
          centerX, centerY,
          width, height,
          nodeShapes[name].points);
      },
      
      drawPath: function(context, centerX, centerY, width, height) {
        renderer.drawPolygonPath(context,
          centerX, centerY,
          width, height,
          nodeShapes[name].points);
      },
      
      intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
        return $$.math.polygonIntersectLine(
            x, y,
            nodeShapes[name].points,
            nodeX,
            nodeY,
            width / 2, height / 2,
            padding);
      },
      
      intersectBox: function(
        x1, y1, x2, y2,
        width, height, centerX, 
        centerY, padding) {
        
        var points = nodeShapes[name].points;
        
        return $$.math.boxIntersectPolygon(
          x1, y1, x2, y2,
          points, width, height, centerX, 
          centerY, [0, -1], padding);
      },
      
      checkPoint: function(
        x, y, padding, width, height, centerX, centerY) {
        
        return $$.math.pointInsidePolygon(x, y, nodeShapes[name].points,
          centerX, centerY, width, height, [0, -1], padding);
      }
    };
  }
  
  generatePolygon( 'triangle', $$.math.generateUnitNgonPointsFitToSquare(3, 0) );
  
  generatePolygon( 'square', $$.math.generateUnitNgonPointsFitToSquare(4, 0) );
  nodeShapes['rectangle'] = nodeShapes['square'];
  
  nodeShapes['roundrectangle'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(4, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawRoundRectangle(context,
        centerX, centerY,
        width, height,
        10);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawRoundRectanglePath(context,
        centerX, centerY,
        width, height,
        10);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return $$.math.roundRectangleIntersectLine(
          x, y,
          nodeX,
          nodeY,
          width, height,
          padding);
    },
    
    intersectBox: function(
      x1, y1, x2, y2,
      width, height, centerX, 
      centerY, padding) {

      return $$.math.roundRectangleIntersectBox(
        x1, y1, x2, y2, 
        width, height, centerX, centerY, padding);
    },
    
    // Looks like the width passed into this function is actually the total width / 2
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      var cornerRadius = $$.math.getRoundRectangleRadius(width, height);
      
      // Check hBox
      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,
        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding)) {
        return true;
      }
      
      // Check vBox
      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,
        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding)) {
        return true;
      }
      
      var checkInEllipse = function(x, y, centerX, centerY, width, height, padding) {
        x -= centerX;
        y -= centerY;
        
        x /= (width / 2 + padding);
        y /= (height / 2 + padding);
        
        return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);
      };
      
      
      // Check top left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      /*
      if (renderer.boxIntersectEllipse(x, y, x, y, padding, 
        cornerRadius * 2, cornerRadius * 2,
        centerX - width + cornerRadius,
        centerY - height + cornerRadius)) {
        return true;
      }
      */
      
      // Check top right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      // Check bottom right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      // Check bottom left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      return false;
    }
  };
  
  generatePolygon( 'diamond', [
    0, 1,
    1, 0,
    0, -1,
    -1, 0
  ] );
  
  generatePolygon( 'pentagon', $$.math.generateUnitNgonPointsFitToSquare(5, 0) );
  
  generatePolygon( 'hexagon', $$.math.generateUnitNgonPointsFitToSquare(6, 0) );
  
  generatePolygon( 'heptagon', $$.math.generateUnitNgonPointsFitToSquare(7, 0) );
  
  generatePolygon( 'octagon', $$.math.generateUnitNgonPointsFitToSquare(8, 0) );
    
  var star5Points = new Array(20);
  {
    var outerPoints = $$.math.generateUnitNgonPoints(5, 0);
    var innerPoints = $$.math.generateUnitNgonPoints(5, Math.PI / 5);
    
  //  console.log(outerPoints);
  //  console.log(innerPoints);
    
    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;
    
    for (var i=0;i<innerPoints.length/2;i++) {
      innerPoints[i*2] *= innerRadius;
      innerPoints[i*2+1] *= innerRadius;
    }
    
    for (var i=0;i<20/4;i++) {
      star5Points[i*4] = outerPoints[i*2];
      star5Points[i*4+1] = outerPoints[i*2+1];
      
      star5Points[i*4+2] = innerPoints[i*2];
      star5Points[i*4+3] = innerPoints[i*2+1];
    }
    
  //  console.log(star5Points);
  }

  star5Points = $$.math.fitPolygonToSquare( star5Points );
  
  generatePolygon( 'star', star5Points );
  
  generatePolygon( 'vee', [
    -1, -1,
    0, -0.333,
    1, -1,
    0, 1
  ] );
  
  generatePolygon( 'rhomboid', [
    -1, -1,
    0.333, -1,
    1, 1,
    -0.333, 1
  ] );

})( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    animate: true, // whether to show the layout as it's running
    maxSimulationTime: 4000, // max length in ms to run the layout
    fit: true, // on every layout reposition of nodes, fit the viewport
    padding: 30, // padding around the simulation
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout

    // callbacks on layout events
    ready: undefined, // callback on layoutready 
    stop: undefined, // callback on layoutstop

    // forces used by arbor (use arbor default on undefined)
    repulsion: undefined,
    stiffness: undefined,
    friction: undefined,
    gravity: true,
    fps: undefined,
    precision: undefined,

    // static numbers or functions that dynamically return what these
    // values should be for each element
    // e.g. nodeMass: function(n){ return n.data('weight') }
    nodeMass: undefined, 
    edgeLength: undefined,

    stepSize: 0.1, // smoothing of arbor bounding box

    // function that returns true if the system is stable to indicate
    // that the layout can be stopped
    stableEnergy: function( energy ){
      var e = energy; 
      return (e.max <= 0.5) || (e.mean <= 0.3);
    },

    // infinite layout options
    infinite: false // overrides all other options for a forces-all-the-time mode
  };
  
  function ArborLayout(options){
    this._private = {};

    this._private.options = $$.util.extend({}, defaults, options);
  }
    
  ArborLayout.prototype.run = function(){
    var layout = this;
    var options = this._private.options;

    $$.util.require('arbor', function(arbor){

      var cy = options.cy;
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var edges = eles.edges();
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );
      var simUpdatingPos = false;

      layout.trigger({ type: 'layoutstart', layout: layout });

      // backward compatibility for old animation option
      if( options.liveUpdate !== undefined ){
        options.animate = options.liveUpdate;
      }

      // arbor doesn't work with just 1 node 
      if( eles.nodes().size() <= 1 ){
        if( options.fit ){
          cy.reset();
        }

        eles.nodes().position({
          x: Math.round( (bb.x1 + bb.x2)/2 ),
          y: Math.round( (bb.y1 + bb.y2)/2 )
        });

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });

        return;
      }

      var sys = layout._private.system = arbor.ParticleSystem();

      sys.parameters({
        repulsion: options.repulsion,
        stiffness: options.stiffness, 
        friction: options.friction, 
        gravity: options.gravity, 
        fps: options.fps, 
        dt: options.dt, 
        precision: options.precision
      });

      if( options.animate && options.fit ){
        cy.fit( bb, options.padding );
      }
      
      var doneTime = 250;
      var doneTimeout;
      
      var ready = false;
      
      var lastDraw = +new Date();
      var sysRenderer = {
        init: function(system){
        },
        redraw: function(){
          var energy = sys.energy();

          // if we're stable (according to the client), we're done
          if( !options.infinite && options.stableEnergy != null && energy != null && energy.n > 0 && options.stableEnergy(energy) ){
            layout.stop();
            return;
          }

          if( !options.infinite && doneTime != Infinity ){
            clearTimeout(doneTimeout);
            doneTimeout = setTimeout(doneHandler, doneTime);
          }
          
          var movedNodes = cy.collection();
          
          sys.eachNode(function(n, point){ 
            var data = n.data;
            var node = data.element;
            
            if( node == null ){
              return;
            }

            if( !node.locked() && !node.grabbed() ){
              node.silentPosition({
                x: bb.x1 + point.x,
                y: bb.y1 + point.y
              });

              movedNodes.merge( node );
            }
          });
          

          if( options.animate && movedNodes.length > 0 ){
            simUpdatingPos = true;

            movedNodes.rtrigger('position');

            if( options.fit ){
              cy.fit( options.padding );
            }

            lastDraw = +new Date();
            simUpdatingPos = false;
          }

          
          if( !ready ){
            ready = true;
            layout.one('layoutready', options.ready);
            layout.trigger({ type: 'layoutready', layout: layout });
          }
        }
        
      };
      sys.renderer = sysRenderer;
      sys.screenSize( bb.w, bb.h );
      sys.screenPadding( options.padding, options.padding, options.padding, options.padding );
      sys.screenStep( options.stepSize );

      function calculateValueForElement(element, value){
        if( value == null ){
          return undefined;
        } else if( typeof value == typeof function(){} ){
          return value.apply(element, [element._private.data, {
            nodes: nodes.length,
            edges: edges.length,
            element: element
          }]); 
        } else {
          return value;
        }
      }

      var grabHandler;
      nodes.on('grab free position', grabHandler = function(e){
        if( simUpdatingPos ){ return; }

        var pos = this.position();
        var apos = sys.fromScreen( pos );
        if( !apos ){ return; }

        var p = arbor.Point(apos.x, apos.y);
        var padding = options.padding;

        if(
          bb.x1 + padding <= pos.x && pos.x <= bb.x2 - padding &&
          bb.y1 + padding <= pos.y && pos.y <= bb.y2 - padding
        ){
          this.scratch().arbor.p = p;
        }
        
        switch( e.type ){
        case 'grab':
          this.scratch().arbor.fixed = true;
          break;
        case 'free':
          this.scratch().arbor.fixed = false;
          //this.scratch().arbor.tempMass = 1000;
          break;
        }
      });

      var lockHandler;
      nodes.on('lock unlock', lockHandler = function(e){
        node.scratch().arbor.fixed = node.locked();
      });
            
      var removeHandler;
      eles.on('remove', removeHandler = function(e){ return; // TODO enable when layout add/remove api added
        // var ele = this;
        // var arborEle = ele.scratch().arbor;

        // if( !arborEle ){ return; }

        // if( ele.isNode() ){
        //   sys.pruneNode( arborEle );
        // } else {
        //   sys.pruneEdge( arborEle );
        // }
      });

      var addHandler;
      cy.on('add', '*', addHandler = function(){ return; // TODO enable when layout add/remove api added
        // var ele = this;

        // if( ele.isNode() ){
        //   addNode( ele );
        // } else {
        //   addEdge( ele );
        // }
      });

      var resizeHandler;
      cy.on('resize', resizeHandler = function(){
        if( options.boundingBox == null && layout._private.system != null ){
          var w = cy.width();
          var h = cy.height();

          sys.screenSize( w, h );
        }
      });

      function addNode( node ){
        if( node.isFullAutoParent() ){ return; } // they don't exist in the sim

        var id = node._private.data.id;
        var mass = calculateValueForElement(node, options.nodeMass);
        var locked = node._private.locked;
        var nPos = node.position();
        
        var pos = sys.fromScreen({
          x: nPos.x,
          y: nPos.y
        });

        node.scratch().arbor = sys.addNode(id, {
          element: node,
          mass: mass,
          fixed: locked,
          x: locked ? pos.x : undefined,
          y: locked ? pos.y : undefined
        });
      }

      function addEdge( edge ){
        var src = edge.source().id();
        var tgt = edge.target().id();
        var length = calculateValueForElement(edge, options.edgeLength);
        
        edge.scratch().arbor = sys.addEdge(src, tgt, {
          length: length
        }); 
      }

      nodes.each(function(i, node){
        addNode( node );
      });
      
      edges.each(function(i, edge){
        addEdge( edge );
      });
      
      var grabbableNodes = nodes.filter(":grabbable");
      // disable grabbing if so set
      if( options.ungrabifyWhileSimulating ){
        grabbableNodes.ungrabify();
      }
      
      var doneHandler = layout._private.doneHandler = function(){
        layout._private.doneHandler = null;

        if( !options.animate ){
          if( options.fit ){
            cy.reset();
          }

          nodes.rtrigger('position');
        }

        // unbind handlers
        nodes.off('grab free position', grabHandler);
        nodes.off('lock unlock', lockHandler);
        eles.off('remove', removeHandler);
        cy.off('add', '*', addHandler);
        cy.off('resize', resizeHandler);
        
        // enable back grabbing if so set
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      };
      
      sys.start();
      if( !options.infinite && options.maxSimulationTime != null && options.maxSimulationTime > 0 && options.maxSimulationTime !== Infinity ){
        setTimeout(function(){
          layout.stop();
        }, options.maxSimulationTime);
      }
    
    }); // require

    return this; // chaining
  };


  ArborLayout.prototype.stop = function(){
    if( this._private.system != null ){
      this._private.system.stop();
    }

    if( this._private.doneHandler ){
      this._private.doneHandler();
    }

    return this; // chaining
  };
  
  $$('layout', 'arbor', ArborLayout);
  
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
    padding: 30, // padding on fit
    circle: false, // put depths in concentric circles if true, put depths top down if false
    spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    roots: undefined, // the roots of the trees
    maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function BreadthFirstLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  BreadthFirstLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    var graph = eles;
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var roots;
    if( $$.is.elementOrCollection(options.roots) ){
      roots = options.roots;
    } else if( $$.is.array(options.roots) ){
      var rootsArray = [];

      for( var i = 0; i < options.roots.length; i++ ){
        var id = options.roots[i];
        var ele = cy.getElementById( id );
        rootsArray.push( ele );
      }

      roots = new $$.Collection( cy, rootsArray );
    } else if( $$.is.string(options.roots) ){
      roots = cy.$( options.roots );

    } else {
      if( options.directed ){
        roots = nodes.roots();
      } else {
        var components = [];
        var unhandledNodes = nodes;

        while( unhandledNodes.length > 0 ){
          var currComp = cy.collection();

          eles.bfs({
            roots: unhandledNodes[0],
            visit: function(i, depth, node, edge, pNode){
              currComp = currComp.add( node );
            },
            directed: false
          });

          unhandledNodes = unhandledNodes.not( currComp );
          components.push( currComp );
        }

        roots = cy.collection();
        for( var i = 0; i < components.length; i++ ){
          var comp = components[i];
          var maxDegree = comp.maxDegree( false );
          var compRoots = comp.filter(function(){
            return this.degree(false) === maxDegree;
          });

          roots = roots.add( compRoots );
        }
        
      }
    }


    var depths = [];
    var foundByBfs = {};
    var id2depth = {};
    var prevNode = {};
    var prevEdge = {};
    var successors = {};

    // find the depths of the nodes
    graph.bfs({
      roots: roots,
      directed: options.directed,
      visit: function(i, depth, node, edge, pNode){
        var ele = this[0];
        var id = ele.id();

        if( !depths[depth] ){
          depths[depth] = [];
        }

        depths[depth].push( ele );
        foundByBfs[ id ] = true;
        id2depth[ id ] = depth;
        prevNode[ id ] = pNode;
        prevEdge[ id ] = edge;

        if( pNode ){
          var prevId = pNode.id();
          var succ = successors[ prevId ] = successors[ prevId ] || [];
          
          succ.push( node );
        }
      }
    });

    // check for nodes not found by bfs
    var orphanNodes = [];
    for( var i = 0; i < nodes.length; i++ ){
      var ele = nodes[i];

      if( foundByBfs[ ele.id() ] ){
        continue;
      } else {
        orphanNodes.push( ele );
      }
    }

    // assign orphan nodes a depth from their neighborhood
    var maxChecks = orphanNodes.length * 3;
    var checks = 0;
    while( orphanNodes.length !== 0 && checks < maxChecks ){
      var node = orphanNodes.shift();
      var neighbors = node.neighborhood().nodes();
      var assignedDepth = false;

      for( var i = 0; i < neighbors.length; i++ ){
        var depth = id2depth[ neighbors[i].id() ];

        if( depth !== undefined ){
          depths[depth].push( node );
          assignedDepth = true;
          break;
        }
      }

      if( !assignedDepth ){
        orphanNodes.push( node );
      }

      checks++;
    }

    // assign orphan nodes that are still left to the depth of their subgraph
    while( orphanNodes.length !== 0 ){
      var node = orphanNodes.shift();
      //var subgraph = graph.bfs( node ).path;
      var assignedDepth = false;

      // for( var i = 0; i < subgraph.length; i++ ){
      //   var depth = id2depth[ subgraph[i].id() ];

      //   if( depth !== undefined ){
      //     depths[depth].push( node );
      //     assignedDepth = true;
      //     break;
      //   }
      // }

      if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
        if( depths.length === 0 ){
          depths.push([]);
        }
        
        depths[0].push( node );
      }
    }

    // assign the nodes a depth and index
    var assignDepthsToEles = function(){
      for( var i = 0; i < depths.length; i++ ){
        var eles = depths[i];

        for( var j = 0; j < eles.length; j++ ){
          var ele = eles[j];

          ele._private.scratch.breadthfirst = {
            depth: i,
            index: j
          };
        }
      }
    };
    assignDepthsToEles();


    var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
      var edges = node.connectedEdges(function(){
        return this.data('target') === node.id();
      });
      var thisInfo = node._private.scratch.breadthfirst;
      var highestDepthOfOther = 0;
      var highestOther;
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];
        var otherNode = edge.source()[0];
        var otherInfo = otherNode._private.scratch.breadthfirst;

        if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
          highestDepthOfOther = otherInfo.depth;
          highestOther = otherNode;
        }
      }

      return highestOther;
    };

     // make maximal if so set by adjusting depths
    for( var adj = 0; adj < options.maximalAdjustments; adj++ ){

      var nDepths = depths.length;
      var elesToMove = [];
      for( var i = 0; i < nDepths; i++ ){
        var depth = depths[i];

        var nDepth = depth.length;
        for( var j = 0; j < nDepth; j++ ){
          var ele = depth[j];
          var info = ele._private.scratch.breadthfirst;
          var intEle = intersectsDepth(ele);

          if( intEle ){
            info.intEle = intEle;
            elesToMove.push( ele );
          }
        }
      }

      for( var i = 0; i < elesToMove.length; i++ ){ 
        var ele = elesToMove[i];
        var info = ele._private.scratch.breadthfirst;
        var intEle = info.intEle;
        var intInfo = intEle._private.scratch.breadthfirst;

        depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index

        // add to end of new depth
        var newDepth = intInfo.depth + 1;
        while( newDepth > depths.length - 1 ){
          depths.push([]);
        }
        depths[ newDepth ].push( ele );

        info.depth = newDepth;
        info.index = depths[newDepth].length - 1;
      }

      assignDepthsToEles();
    }

    // find min distance we need to leave between nodes
    var minDistance = 0;
    if( options.avoidOverlap ){
      for( var i = 0; i < nodes.length; i++ ){
        var w = nodes[i].outerWidth();
        var h = nodes[i].outerHeight();
        
        minDistance = Math.max(minDistance, w, h);
      }
      minDistance *= options.spacingFactor; // just to have some nice spacing
    }

    // get the weighted percent for an element based on its connectivity to other levels
    var cachedWeightedPercent = {};
    var getWeightedPercent = function( ele ){
      if( cachedWeightedPercent[ ele.id() ] ){
        return cachedWeightedPercent[ ele.id() ];
      }

      var eleDepth = ele._private.scratch.breadthfirst.depth;
      var neighbors = ele.neighborhood().nodes().not(':parent');
      var percent = 0;
      var samples = 0;

      for( var i = 0; i < neighbors.length; i++ ){
        var neighbor = neighbors[i];
        var bf = neighbor._private.scratch.breadthfirst;
        var index = bf.index;
        var depth = bf.depth;
        var nDepth = depths[depth].length;

        if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
          percent += index / nDepth;
          samples++;
        }
      }

      samples = Math.max(1, samples);
      percent = percent / samples;

      if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
        percent = undefined;
      }

      cachedWeightedPercent[ ele.id() ] = percent;
      return percent;
    };


    // rearrange the indices in each depth level based on connectivity

    var sortFn = function(a, b){
      var apct = getWeightedPercent( a );
      var bpct = getWeightedPercent( b );

      return apct - bpct;
    };

    for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result

      for( var i = 0; i < depths.length; i++ ){
        depths[i] = depths[i].sort( sortFn );
      }
      assignDepthsToEles(); // and update

    }

    var biggestDepthSize = 0;
    for( var i = 0; i < depths.length; i++ ){
      biggestDepthSize = Math.max( depths[i].length, biggestDepthSize );
    }

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.x1 + bb.h/2
    };
   
    var getPosition = function( ele, isBottomDepth ){
      var info = ele._private.scratch.breadthfirst;
      var depth = info.depth;
      var index = info.index;
      var depthSize = depths[depth].length;

      var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );
      var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );
      var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );
      radiusStepSize = Math.max( radiusStepSize, minDistance );

      if( !options.circle ){
        
        var epos = {
          x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
          y: (depth + 1) * distanceY
        };

        if( isBottomDepth ){
          return epos;
        }

        // var succs = successors[ ele.id() ];
        // if( succs ){
        //   epos.x = 0;
        // 
        //   for( var i = 0 ; i < succs.length; i++ ){
        //     var spos = pos[ succs[i].id() ];
        //     
        //     epos.x += spos.x;
        //   }
        // 
        //   epos.x /= succs.length;
        // } else {
        //   //debugger;
        // }

        return epos;

      } else {
        if( options.circle ){
          var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize/2 : 0);
          var theta = 2 * Math.PI / depths[depth].length * index;

          if( depth === 0 && depths[0].length === 1 ){
            radius = 1;
          }

          return {
            x: center.x + radius * Math.cos(theta),
            y: center.y + radius * Math.sin(theta)
          };

        } else {
          return {
            x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
            y: (depth + 1) * distanceY
          };
        }
      }
      
    };

    // get positions in reverse depth order
    var pos = {};
    for( var i = depths.length - 1; i >=0; i-- ){
      var depth = depths[i];

      for( var j = 0; j < depth.length; j++ ){
        var node = depth[j];

        pos[ node.id() ] = getPosition( node, i === depths.length - 1 );
      }
    }

    nodes.layoutPositions(this, options, function(){
      return pos[ this.id() ];
    });
    
    return this; // chaining
  };
  
  $$('layout', 'breadthfirst', BreadthFirstLayout);
  
})( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // the padding on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
    radius: undefined, // the radius of the circle
    startAngle: 3/2 * Math.PI, // the position of the first node
    counterclockwise: false, // whether the layout should go counterclockwise (true) or clockwise (false)
    sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function CircleLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  CircleLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
      
    var nodes = eles.nodes().not(':parent');

    if( options.sort ){
      nodes = nodes.sort( options.sort );
    }
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.y1 + bb.h/2
    };
    
    var theta = options.startAngle;
    var dTheta = 2 * Math.PI / nodes.length;
    var r;

    var minDistance = 0;
    for( var i = 0; i < nodes.length; i++ ){
      var w = nodes[i].outerWidth();
      var h = nodes[i].outerHeight();
      
      minDistance = Math.max(minDistance, w, h);
    }

    if( $$.is.number(options.radius) ){
      r = options.radius;
    } else if( nodes.length <= 1 ){
      r = 0;
    } else {
      r = Math.min( bb.h, bb.w )/2 - minDistance;
    }

    // calculate the radius
    if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
      minDistance *= 1.75; // just to have some nice spacing

      var dTheta = 2 * Math.PI / nodes.length;
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt( minDistance * minDistance / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
      r = Math.max( rMin, r );
    }

    var getPos = function( i, ele ){
      var rx = r * Math.cos( theta );
      var ry = r * Math.sin( theta );
      var pos = {
        x: center.x + rx,
        y: center.y + ry
      };

      theta = options.counterclockwise ? theta - dTheta : theta + dTheta;
      return pos;
    };
    
    nodes.layoutPositions( this, options, getPos );

    return this; // chaining
  };
  
  $$('layout', 'circle', CircleLayout);
  
})( cytoscape );

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    animate: true, // whether to show the layout as it's running
    refresh: 1, // number of ticks per frame; higher is faster but more jerky
    maxSimulationTime: 4000, // max length in ms to run the layout
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout
    fit: true, // on every layout reposition of nodes, fit the viewport
    padding: 30, // padding around the simulation
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }

    // layout event callbacks
    ready: function(){}, // on layoutready
    stop: function(){}, // on layoutstop

    // positioning options
    randomize: false, // use random node positions at beginning of layout
    avoidOverlap: true, // if true, prevents overlap of node bounding boxes
    handleDisconnected: true, // if true, avoids disconnected components from overlapping
    nodeSpacing: function( node ){ return 10; }, // extra spacing around nodes
    flow: undefined, // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }
    alignment: undefined, // relative alignment constraints on nodes, e.g. function( node ){ return { x: 0, y: 1 } }

    // different methods of specifying edge length
    // each can be a constant numerical value or a function like `function( edge ){ return 2; }`
    edgeLength: undefined, // sets edge length directly in simulation
    edgeSymDiffLength: undefined, // symmetric diff edge length in simulation
    edgeJaccardLength: undefined, // jaccard edge length in simulation

    // iterations of cola algorithm; uses default values on undefined
    unconstrIter: undefined, // unconstrained initial layout iterations
    userConstIter: undefined, // initial layout iterations with user-specified constraints
    allConstIter: undefined, // initial layout iterations with all constraints including non-overlap

    // infinite layout options
    infinite: false // overrides all other options for a forces-all-the-time mode
  };

  // constructor
  // options : object containing layout options
  function ColaLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  ColaLayout.prototype.run = function(){
    var layout = this;
    var options = this.options;
    
    layout.manuallyStopped = false;

    $$.util.require('cola', function(cola){

      var cy = options.cy; // cy is automatically populated for us in the constructor
      var eles = options.eles;
      var nodes = eles.nodes();
      var edges = eles.edges();
      var ready = false;
      
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );

      var getOptVal = function( val, ele ){
        if( $$.is.fn(val) ){
          var fn = val;
          return fn.apply( ele, [ ele ] );
        } else {
          return val;
        }
      };

      var updateNodePositions = function(){
        var x = { min: Infinity, max: -Infinity };
        var y = { min: Infinity, max: -Infinity };

        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var scratch = node._private.scratch.cola;

          x.min = Math.min( x.min, scratch.x || 0 );
          x.max = Math.max( x.max, scratch.x || 0 );

          y.min = Math.min( y.min, scratch.y || 0 );
          y.max = Math.max( y.max, scratch.y || 0 );
        }

        nodes.positions(function(i, node){
          var scratch = node._private.scratch.cola;
          var retPos;

          if( !node.grabbed() && !node.isParent() ){
            retPos = {
              x: bb.x1 + scratch.x - x.min,
              y: bb.y1 + scratch.y - y.min
            };

            if( !$$.is.number(retPos.x) || !$$.is.number(retPos.y) ){
              retPos = undefined;
            }
          }

          return retPos;
        });

        nodes.updateCompoundBounds(); // because the way this layout sets positions is buggy for some reason; ref #878

        if( !ready ){
          onReady();
          ready = true;
        }

        if( options.fit ){
          cy.fit( options.padding );
        }
      };

      var onDone = function(){
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        nodes.off('grab free position', grabHandler);
        nodes.off('lock unlock', lockHandler);

        // trigger layoutstop when the layout stops (e.g. finishes)
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      };

      var onReady = function(){
        // trigger layoutready when each node has had its position set at least once
        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
      };

      var ticksPerFrame = options.refresh;
      var tickSkip = 1; // frames until a tick; used to slow down sim for debugging

      if( options.refresh < 0 ){
        tickSkip = Math.abs( options.refresh );
        ticksPerFrame = 1;
      } else {
        ticksPerFrame = Math.max( 1, ticksPerFrame ); // at least 1
      }

      var adaptor = layout.adaptor = cola.adaptor({
        trigger: function( e ){ // on sim event      
          var TICK = cola.EventType ? cola.EventType.tick : null;
          var END = cola.EventType ? cola.EventType.end : null;
          
          switch( e.type ){
            case 'tick':
            case TICK:
              if( options.animate ){
                updateNodePositions();
              }
              break;

            case 'end':
            case END:
              updateNodePositions();
              if( !options.infinite ){ onDone(); }           
              break;
          }
        },

        kick: function(){ // kick off the simulation
          var skip = 0;

          var inftick = function(){
            if( layout.manuallyStopped ){
              onDone();
              
              return true;
            }
            
            var ret = adaptor.tick();

            if( ret && options.infinite ){ // resume layout if done
              adaptor.resume(); // resume => new kick
            }
            
            return ret; // allow regular finish b/c of new kick
          };

          var multitick = function(){ // multiple ticks in a row
            var ret;

            // skip ticks to slow down layout for debugging
            // var thisSkip = skip;
            // skip = (skip + 1) % tickSkip;
            // if( thisSkip !== 0 ){
            //   return false;
            // }

            for( var i = 0; i < ticksPerFrame && !ret; i++ ){
              ret = ret || inftick(); // pick up true ret vals => sim done
            }

            return ret;
          };

          if( options.animate ){
            var frame = function(){
              if( multitick() ){ return; }

              $$.util.requestAnimationFrame( frame );
            };

            $$.util.requestAnimationFrame( frame );
          } else {
            while( !inftick() ){}
          }
        },

        on: function( type, listener ){}, // dummy; not needed

        drag: function(){} // not needed for our case
      });
      layout.adaptor = adaptor;

      // if set no grabbing during layout
      var grabbableNodes = nodes.filter(':grabbable');
      if( options.ungrabifyWhileSimulating ){
        grabbableNodes.ungrabify();
      }

      // handle node dragging
      var grabHandler;
      nodes.on('grab free position', grabHandler = function(e){
        var node = this;
        var scrCola = node._private.scratch.cola;
        var pos = node._private.position;

        if( node.grabbed() ){
          scrCola.x = pos.x - bb.x1;
          scrCola.y = pos.y - bb.y1;

          adaptor.dragstart( scrCola );
        } else if( $$.is.number(scrCola.x) && $$.is.number(scrCola.y) ){
          pos.x = scrCola.x + bb.x1;
          pos.y = scrCola.y + bb.y1;
        }

        switch( e.type ){
          case 'grab':
            adaptor.dragstart( scrCola );
            adaptor.resume();
            break;
          case 'free':
            adaptor.dragend( scrCola );
            break;
        }
        
      });

      var lockHandler;
      nodes.on('lock unlock', lockHandler = function(e){
        var node = this;
        var scrCola = node._private.scratch.cola;
      
        if( node.locked() ){
          adaptor.dragstart( scrCola );
        } else {
          adaptor.dragend( scrCola );
        }
      });

      var nonparentNodes = nodes.stdFilter(function( node ){
        return !node.isParent();
      });

      // add nodes to cola
      adaptor.nodes( nonparentNodes.map(function( node, i ){
        var padding = getOptVal( options.nodeSpacing, node );
        var pos = node.position();

        var struct = node._private.scratch.cola = {
          x: options.randomize ? Math.round( Math.random() * bb.w ) : pos.x,
          y: options.randomize ? Math.round( Math.random() * bb.h ) : pos.y,
          width: node.outerWidth() + 2*padding,
          height: node.outerHeight() + 2*padding,
          index: i
        };

        return struct;
      }) );

      if( options.alignment ){ // then set alignment constraints

        var offsetsX = [];
        var offsetsY = [];

        nonparentNodes.forEach(function( node ){
          var align = getOptVal( options.alignment, node );
          var scrCola = node._private.scratch.cola;
          var index = scrCola.index;

          if( !align ){ return; }

          if( align.x != null ){
            offsetsX.push({
              node: index,
              offset: align.x
            });
          }

          if( align.y != null ){
            offsetsY.push({
              node: index,
              offset: align.y
            });
          }
        });

        // add alignment constraints on nodes
        var constraints = [];

        if( offsetsX.length > 0 ){
          constraints.push({
            type: 'alignment',
            axis: 'x',
            offsets: offsetsX
          });
        }

        if( offsetsY.length > 0 ){
          constraints.push({
            type: 'alignment',
            axis: 'y',
            offsets: offsetsY
          });
        }
        
        adaptor.constraints( constraints );

      }

      // add compound nodes to cola
      adaptor.groups( nodes.stdFilter(function( node ){
        return node.isParent();
      }).map(function( node, i ){ // add basic group incl leaf nodes
        node._private.scratch.cola = {
          index: i,

          leaves: node.descendants().stdFilter(function( child ){
            return !child.isParent();
          }).map(function( child ){
            return child[0]._private.scratch.cola.index;
          })
        };

        return node;
      }).map(function( node ){ // add subgroups
        node._private.scratch.cola.groups = node.descendants().stdFilter(function( child ){
          return child.isParent();
        }).map(function( child ){
          return child._private.scratch.cola.index;
        });

        return node._private.scratch.cola;
      }) );

      // get the edge length setting mechanism
      var length;
      var lengthFnName;
      if( options.edgeLength != null ){
        length = options.edgeLength;
        lengthFnName = 'linkDistance';
      } else if( options.edgeSymDiffLength != null ){
        length = options.edgeSymDiffLength;
        lengthFnName = 'symmetricDiffLinkLengths';
      } else if( options.edgeJaccardLength != null ){
        length = options.edgeJaccardLength;
        lengthFnName = 'jaccardLinkLengths';
      } else {
        length = 100;
        lengthFnName = 'linkDistance';
      }

      var lengthGetter = function( link ){
        return link.calcLength;
      };

      // add the edges to cola
      adaptor.links( edges.stdFilter(function( edge ){
        return !edge.source().isParent() && !edge.target().isParent();
      }).map(function( edge, i ){
        var c = edge._private.scratch.cola = {
          source: edge.source()[0]._private.scratch.cola.index,
          target: edge.target()[0]._private.scratch.cola.index
        };

        if( length != null ){
          c.calcLength = getOptVal( length, edge );
        }

        return c;
      }) );

      adaptor.size([ bb.w, bb.h ]);

      if( length != null ){
        adaptor[ lengthFnName ]( lengthGetter );
      }

      // set the flow of cola
      if( options.flow ){
        var flow;
        var defAxis = 'y';
        var defMinSep = 50;

        if( $$.is.string(options.flow) ){
          flow = {
            axis: options.flow,
            minSeparation: defMinSep
          };
        } else if( $$.is.number(options.flow) ){
          flow = {
            axis: defAxis,
            minSeparation: options.flow
          };
        } else if( $$.is.plainObject(options.flow) ){
          flow = options.flow;

          flow.axis = flow.axis || defAxis;
          flow.minSeparation = flow.minSeparation != null ? flow.minSeparation : defMinSep;
        } else { // e.g. options.flow: true
          flow = {
            axis: defAxis,
            minSeparation: defMinSep
          };
        }

        adaptor.flowLayout( flow.axis , flow.minSeparation );
      }

      layout.trigger({ type: 'layoutstart', layout: layout });

      adaptor
        .avoidOverlaps( options.avoidOverlap )
        .handleDisconnected( options.handleDisconnected )
        .start( options.unconstrIter, options.userConstIter, options.allConstIter)
      ;

      if( !options.infinite ){
        setTimeout(function(){
          if( !layout.manuallyStopped ){
            adaptor.stop();
          }
        }, options.maxSimulationTime);
      }

    }); // require

    return this; // chaining
  };

  // called on continuous layouts to stop them before they finish
  ColaLayout.prototype.stop = function(){
    if( this.adaptor ){
      this.manuallyStopped = true;
      this.adaptor.stop();
    }

    return this; // chaining
  };

  // register the layout
  $$('layout', 'cola', ColaLayout);

})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // the padding on fit
    startAngle: 3/2 * Math.PI, // the position of the first node
    counterclockwise: false, // whether the layout should go counterclockwise/anticlockwise (true) or clockwise (false)
    minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    height: undefined, // height of layout area (overrides container height)
    width: undefined, // width of layout area (overrides container width)
    concentric: function(node){ // returns numeric value for each node, placing higher nodes in levels towards the centre
      return node.degree();
    },
    levelWidth: function(nodes){ // the variation of concentric values in each level
      return nodes.maxDegree() / 4;
    },
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function ConcentricLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  ConcentricLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.y1 + bb.h/2
    };
    
    var nodeValues = []; // { node, value }
    var theta = options.startAngle;
    var maxNodeSize = 0;

    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];
      var value;
      
      // calculate the node value
      value = options.concentric.apply(node, [ node ]);
      nodeValues.push({
        value: value,
        node: node
      });

      // for style mapping
      node._private.scratch.concentric = value;
    }

    // in case we used the `concentric` in style
    nodes.updateStyle();

    // calculate max size now based on potentially updated mappers
    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];

      maxNodeSize = Math.max( maxNodeSize, node.outerWidth(), node.outerHeight() );
    }

    // sort node values in descreasing order
    nodeValues.sort(function(a, b){
      return b.value - a.value;
    });

    var levelWidth = options.levelWidth( nodes );

    // put the values into levels
    var levels = [ [] ];
    var currentLevel = levels[0];
    for( var i = 0; i < nodeValues.length; i++ ){
      var val = nodeValues[i];

      if( currentLevel.length > 0 ){
        var diff = Math.abs( currentLevel[0].value - val.value );

        if( diff >= levelWidth ){
          currentLevel = [];
          levels.push( currentLevel );
        }
      }

      currentLevel.push( val );
    }

    // create positions from levels

    var pos = {}; // id => position
    var r = 0;
    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

    if( !options.avoidOverlap ){ // then strictly constrain to bb
      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
      var maxR = ( Math.min(bb.w, bb.h) / 2 - minDist );
      var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );

      minDist = Math.min( minDist, rStep );
    }

    for( var i = 0; i < levels.length; i++ ){
      var level = levels[i];
      var dTheta = 2 * Math.PI / level.length;

      // calculate the radius
      if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
        var dcos = Math.cos(dTheta) - Math.cos(0);
        var dsin = Math.sin(dTheta) - Math.sin(0);
        var rMin = Math.sqrt( minDist * minDist / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
        r = Math.max( rMin, r );
      }

      for( var j = 0; j < level.length; j++ ){
        var val = level[j];
        var theta = options.startAngle + (options.counterclockwise ? -1 : 1) * dTheta * j;

        var p = {
          x: center.x + r * Math.cos(theta),
          y: center.y + r * Math.sin(theta)
        };

        pos[ val.node.id() ] = p;
      }

      r += minDist;
      
    } 

    // position the nodes
    nodes.layoutPositions(this, options, function(){
      var id = this.id();

      return pos[id];
    });
  
    return this; // chaining
  };
  
  $$('layout', 'concentric', ConcentricLayout);
  
})( cytoscape );

/*
  The CoSE layout was written by Gerardo Huck.

  Modifications tracked on Github.
*/

;(function($$) { 'use strict';

  var DEBUG;

  /**
   * @brief :  default layout options
   */
  var defaults = {
    // Called on `layoutready`
    ready               : function() {},

    // Called on `layoutstop`
    stop                : function() {},

    // Whether to animate while running the layout
    animate             : true,

    // Number of iterations between consecutive screen positions update (0 -> only updated on the end)
    refresh             : 4,
    
    // Whether to fit the network view after when done
    fit                 : true, 

    // Padding on fit
    padding             : 30, 

    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    boundingBox         : undefined,

    // Whether to randomize node positions on the beginning
    randomize           : true,
    
    // Whether to use the JS console to print debug messages
    debug               : false,

    // Node repulsion (non overlapping) multiplier
    nodeRepulsion       : 400000,
    
    // Node repulsion (overlapping) multiplier
    nodeOverlap         : 10,
    
    // Ideal edge (non nested) length
    idealEdgeLength     : 10,
    
    // Divisor to compute edge forces
    edgeElasticity      : 100,
    
    // Nesting factor (multiplier) to compute ideal edge length for nested edges
    nestingFactor       : 5, 
    
    // Gravity force (constant)
    gravity             : 250, 
    
    // Maximum number of iterations to perform
    numIter             : 100,
    
    // Initial temperature (maximum node displacement)
    initialTemp         : 200,
    
    // Cooling factor (how the temperature is reduced between consecutive iterations
    coolingFactor       : 0.95, 
    
    // Lower temperature threshold (below this point the layout will end)
    minTemp             : 1.0
  };


  /**
   * @brief       : constructor
   * @arg options : object containing layout options
   */
  function CoseLayout(options) {
    this.options = $$.util.extend({}, defaults, options); 
  }


  /**
   * @brief : runs the layout
   */
  CoseLayout.prototype.run = function() {
    var options = this.options;
    var cy      = options.cy;
    var layout  = this;

    layout.stopped = false;

    layout.trigger({ type: 'layoutstart', layout: layout });

    // Set DEBUG - Global variable
    if (true === options.debug) {
      DEBUG = true;
    } else {
      DEBUG = false;
    }

    // Get start time
    var startTime = new Date();

    // Initialize layout info
    var layoutInfo = createLayoutInfo(cy, layout, options);
    
    // Show LayoutInfo contents if debugging
    if (DEBUG) {
      printLayoutInfo(layoutInfo);
    }

    // If required, randomize node positions
    if (true === options.randomize) {
      randomizePositions(layoutInfo, cy);
    }

    updatePositions(layoutInfo, cy, options);

    var mainLoop = function(i){
      if( layout.stopped ){
        // logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step(layoutInfo, cy, options, i);
      
      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      // logDebug("New temperature: " + layoutInfo.temperature);

      if (layoutInfo.temperature < options.minTemp) {
        // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var done = function(){
      refreshPositions(layoutInfo, cy, options);

      // Fit the graph if necessary
      if (true === options.fit) {
        cy.fit( options.padding );
      }
      
      // Get end time
      var endTime = new Date();

      console.info('Layout took ' + (endTime - startTime) + ' ms');

      // Layout has finished
      layout.one('layoutstop', options.stop);
      layout.trigger({ type: 'layoutstop', layout: layout });
    };

    if( options.animate ){
      var i = 0;
      var frame = function(){

        var f = 0;
        var loopRet;
        while( f < options.refresh && i < options.numIter ){
          var loopRet = mainLoop(i);
          if( loopRet === false ){ break; }

          f++;
          i++;
        }

        refreshPositions(layoutInfo, cy, options);
        if( options.fit ){
          cy.fit( options.padding );
        }

        if ( loopRet !== false && i + 1 < options.numIter ) {
          $$.util.requestAnimationFrame( frame );
        } else {
          done();
        }
      };

      $$.util.requestAnimationFrame( frame );
    } else {
      for (var i = 0; i < options.numIter; i++) {
        if( mainLoop(i) === false ){ break; }
      }

      done();
    }
   
    return this; // chaining
  };


  /**
   * @brief : called on continuous layouts to stop them before they finish
   */
  CoseLayout.prototype.stop = function(){
    this.stopped = true;

    return this; // chaining
  };


  /**
   * @brief     : Creates an object which is contains all the data
   *              used in the layout process
   * @arg cy    : cytoscape.js object
   * @return    : layoutInfo object initialized
   */
  var createLayoutInfo = function(cy, layout, options) {
    // Shortcut
    var edges = options.eles.edges();
    var nodes = options.eles.nodes();

    var layoutInfo   = {
      layout       : layout,
      layoutNodes  : [], 
      idToIndex    : {},
      nodeSize     : nodes.size(),
      graphSet     : [],
      indexToGraph : [], 
      layoutEdges  : [],
      edgeSize     : edges.size(),
      temperature  : options.initialTemp,
      clientWidth  : cy.width(),
      clientHeight : cy.width(),
      boundingBox  : $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
                       x1: 0, y1: 0, w: cy.width(), h: cy.height()
                     } )
    }; 
    
    // Iterate over all nodes, creating layout nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var tempNode        = {};
      tempNode.id         = nodes[i].data('id');
      tempNode.parentId   = nodes[i].data('parent');      
      tempNode.children   = [];
      tempNode.positionX  = nodes[i].position('x');
      tempNode.positionY  = nodes[i].position('y');
      tempNode.offsetX    = 0;      
      tempNode.offsetY    = 0;
      tempNode.height     = nodes[i].height();
      tempNode.width      = nodes[i].width();
      tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;
      tempNode.minX       = tempNode.positionX - tempNode.width  / 2;
      tempNode.maxY       = tempNode.positionY + tempNode.height / 2;
      tempNode.minY       = tempNode.positionY - tempNode.height / 2;
      tempNode.padLeft    = nodes[i]._private.style['padding-left'].pxValue;
      tempNode.padRight   = nodes[i]._private.style['padding-right'].pxValue;
      tempNode.padTop     = nodes[i]._private.style['padding-top'].pxValue;
      tempNode.padBottom  = nodes[i]._private.style['padding-bottom'].pxValue;
      
      // Add new node
      layoutInfo.layoutNodes.push(tempNode);
      // Add entry to id-index map
      layoutInfo.idToIndex[tempNode.id] = i;
    }

    // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0;   // Points to the start the queue
    var end   = -1;  // Points to the end of the queue

    var tempGraph = [];

    // Second pass to add child information and 
    // initialize queue for hierarchical traversal
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      var p_id = n.parentId;
      // Check if node n has a parent node
      if (null != p_id) {
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
      } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[++end] = n.id;
      tempGraph.push(n.id);    
      }
    }
    
    // Add root graph to graphSet
    layoutInfo.graphSet.push(tempGraph);

    // Traverse the graph, level by level, 
    while (start <= end) {
      // Get the node to visit and remove it from queue
      var node_id  = queue[start++];
      var node_ix  = layoutInfo.idToIndex[node_id];
      var node     = layoutInfo.layoutNodes[node_ix];
      var children = node.children;
      if (children.length > 0) {
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push(children);
      // Add children to que queue to be visited
      for (var i = 0; i < children.length; i++) {
        queue[++end] = children[i];
      }
      }
    }

    // Create indexToGraph map
    for (var i = 0; i < layoutInfo.graphSet.length; i++) {      
      var graph = layoutInfo.graphSet[i];
      for (var j = 0; j < graph.length; j++) {
      var index = layoutInfo.idToIndex[graph[j]];
      layoutInfo.indexToGraph[index] = i;
      }
    }
    
    // Iterate over all edges, creating Layout Edges
    for (var i = 0; i < layoutInfo.edgeSize; i++) {
      var e = edges[i];
      var tempEdge = {};      
      tempEdge.id       = e.data('id');
      tempEdge.sourceId = e.data('source');
      tempEdge.targetId = e.data('target');

      // Compute ideal length
      var idealLength = options.idealEdgeLength;

      // Check if it's an inter graph edge
      var sourceIx    = layoutInfo.idToIndex[tempEdge.sourceId];
      var targetIx    = layoutInfo.idToIndex[tempEdge.targetId];
      var sourceGraph = layoutInfo.indexToGraph[sourceIx];
      var targetGraph = layoutInfo.indexToGraph[targetIx];

      if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[lca];
      var depth    = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[sourceIx];
      while (-1 === $.inArray(tempNode.id, lcaGraph)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[targetIx];
      while (-1 === $.inArray(tempNode.id, lcaGraph)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +  
        //  ". Index: " + lca + " Contents: " + lcaGraph.toString() + 
        //  ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
      }

      tempEdge.idealLength = idealLength;

      layoutInfo.layoutEdges.push(tempEdge);
    }

    // Finally, return layoutInfo object
    return layoutInfo;
  };

  
  /**
   * @brief : This function finds the index of the lowest common 
   *          graph ancestor between 2 nodes in the subtree 
   *          (from the graph hierarchy induced tree) whose
   *          root is graphIx
   *
   * @arg node1: node1's ID
   * @arg node2: node2's ID
   * @arg layoutInfo: layoutInfo object
   *
   */
  var findLCA = function(node1, node2, layoutInfo) {
    // Find their common ancester, starting from the root graph
    var res = findLCA_aux(node1, node2, 0, layoutInfo);
    if (2 > res.count) {
      // If aux function couldn't find the common ancester, 
      // then it is the root graph
      return 0;
    } else {
      return res.graph;
    }
  };


  /**
   * @brief          : Auxiliary function used for LCA computation
   * 
   * @arg node1      : node1's ID
   * @arg node2      : node2's ID
   * @arg graphIx    : subgraph index
   * @arg layoutInfo : layoutInfo object
   *
   * @return         : object of the form {count: X, graph: Y}, where:
   *                   X is the number of ancesters (max: 2) found in 
   *                   graphIx (and it's subgraphs),
   *                   Y is the graph index of the lowest graph containing 
   *                   all X nodes
   */
  var findLCA_aux = function(node1, node2, graphIx, layoutInfo) {
    var graph = layoutInfo.graphSet[graphIx];
    // If both nodes belongs to graphIx
    if (-1 < $.inArray(node1, graph) && -1 < $.inArray(node2, graph)) {
      return {count:2, graph:graphIx};
    }

    // Make recursive calls for all subgraphs
    var c = 0;
    for (var i = 0; i < graph.length; i++) {
      var nodeId   = graph[i];
      var nodeIx   = layoutInfo.idToIndex[nodeId];
      var children = layoutInfo.layoutNodes[nodeIx].children;

      // If the node has no child, skip it
      if (0 === children.length) {
      continue;
      }

      var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
      var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
      if (0 === result.count) {
      // Neither node1 nor node2 are present in this subgraph
      continue;
      } else if (1 === result.count) {
      // One of (node1, node2) is present in this subgraph
      c++;
      if (2 === c) {
        // We've already found both nodes, no need to keep searching
        break;
      }
      } else {
      // Both nodes are present in this subgraph
      return result;
      }      
    }
    
    return {count:c, graph:graphIx};
  };


  /**
   * @brief: printsLayoutInfo into js console
   *         Only used for debbuging 
   */
  var printLayoutInfo = function(layoutInfo) {
    if (!DEBUG) {
      return;
    }
    console.debug("layoutNodes:");
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      var s = 
      "\nindex: "     + i + 
      "\nId: "        + n.id + 
      "\nChildren: "  + n.children.toString() +  
      "\nparentId: "  + n.parentId  + 
      "\npositionX: " + n.positionX + 
      "\npositionY: " + n.positionY +
      "\nOffsetX: " + n.offsetX + 
      "\nOffsetY: " + n.offsetY + 
      "\npadLeft: " + n.padLeft + 
      "\npadRight: " + n.padRight + 
      "\npadTop: " + n.padTop + 
      "\npadBottom: " + n.padBottom;

      console.debug(s);    
    }  
    
    console.debug('idToIndex');
    for (var i in layoutInfo.idToIndex) {
      console.debug("Id: " + i + "\nIndex: " + layoutInfo.idToIndex[i]);
    }

    console.debug('Graph Set');
    var set = layoutInfo.graphSet;
    for (var i = 0; i < set.length; i ++) {
      console.debug("Set : " + i + ": " + set[i].toString());
    } 

    var s = 'IndexToGraph';
    for (var i = 0; i < layoutInfo.indexToGraph.length; i ++) {
      s += "\nIndex : " + i + " Graph: "+ layoutInfo.indexToGraph[i];
    }
    console.debug(s);

    s = 'Layout Edges';
    for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
      var e = layoutInfo.layoutEdges[i];
      s += "\nEdge Index: " + i + " ID: " + e.id + 
      " SouceID: " + e.sourceId + " TargetId: " + e.targetId + 
      " Ideal Length: " + e.idealLength;
    }
    console.debug(s);

    s =  "nodeSize: " + layoutInfo.nodeSize;
    s += "\nedgeSize: " + layoutInfo.edgeSize;
    s += "\ntemperature: " + layoutInfo.temperature;
    console.debug(s);

    return;
  };


  /**
   * @brief : Randomizes the position of all nodes
   */
  var randomizePositions = function(layoutInfo, cy) {
    var width     = layoutInfo.clientWidth;
    var height    = layoutInfo.clientHeight;

    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      // No need to randomize compound nodes
      if (true || 0 === n.children.length) {
        n.positionX = Math.random() * width;
        n.positionY = Math.random() * height;
      }
    }
  };

  
  /**
   * @brief          : Updates the positions of nodes in the network
   * @arg layoutInfo : LayoutInfo object
   * @arg cy         : Cytoscape object
   * @arg options    : Layout options
   */
  var refreshPositions = function(layoutInfo, cy, options) {  
    // var s = 'Refreshing positions';
    // logDebug(s);

    var layout = layoutInfo.layout;
    var nodes = options.eles.nodes();
    var bb = layoutInfo.boundingBox;
    var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
    
    if( options.boundingBox ){
      nodes.forEach(function( node ){
        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

        coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );
        coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );

        coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );
        coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );
      });

      coseBB.w = coseBB.x2 - coseBB.x1;
      coseBB.h = coseBB.y2 - coseBB.y1;
    }

    nodes.positions(function(i, ele) {
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
      // s = "Node: " + lnode.id + ". Refreshed position: (" + 
      // lnode.positionX + ", " + lnode.positionY + ").";
      // logDebug(s);

      if( options.boundingBox ){ // then add extra bounding box constraint
        var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
        var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

        return {
          x: bb.x1 + pctX * bb.w,
          y: bb.y1 + pctY * bb.h
        };
      } else {
        return {
          x: lnode.positionX,
          y: lnode.positionY
        };
      }
    });

    // Trigger layoutReady only on first call
    if (true !== layoutInfo.ready) {
      // s = 'Triggering layoutready';
      // logDebug(s);
      layoutInfo.ready = true;
      layout.one('layoutready', options.ready);
      layout.trigger({ type: 'layoutready', layout: this });
    }
  };


  /**
   * @brief          : Performs one iteration of the physical simulation
   * @arg layoutInfo : LayoutInfo object already initialized
   * @arg cy         : Cytoscape object
   * @arg options    : Layout options
   */
  var step = function(layoutInfo, cy, options, step) {  
    // var s = "\n\n###############################";
    // s += "\nSTEP: " + step;
    // s += "\n###############################\n";
    // logDebug(s);

    // Calculate node repulsions
    calculateNodeForces(layoutInfo, cy, options);
    // Calculate edge forces
    calculateEdgeForces(layoutInfo, cy, options);
    // Calculate gravity forces
    calculateGravityForces(layoutInfo, cy, options);
    // Propagate forces from parent to child
    propagateForces(layoutInfo, cy, options);
    // Update positions based on calculated forces
    updatePositions(layoutInfo, cy, options);
  };

  
  /**
   * @brief : Computes the node repulsion forces
   */
  var calculateNodeForces = function(layoutInfo, cy, options) {
    // Go through each of the graphs in graphSet
    // Nodes only repel each other if they belong to the same graph
    // var s = 'calculateNodeForces';
    // logDebug(s);
    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
      var graph    = layoutInfo.graphSet[i];
      var numNodes = graph.length;

      // s = "Set: " + graph.toString();
      // logDebug(s);

      // Now get all the pairs of nodes 
      // Only get each pair once, (A, B) = (B, A)
      for (var j = 0; j < numNodes; j++) {
      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
      for (var k = j + 1; k < numNodes; k++) {
        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
        nodeRepulsion(node1, node2, layoutInfo, cy, options);
      } 
      }
    } 
  };


  /**
   * @brief : Compute the node repulsion forces between a pair of nodes
   */
  var nodeRepulsion = function(node1, node2, layoutInfo, cy, options) {
    // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

    // Get direction of line connecting both node centers
    var directionX = node2.positionX - node1.positionX;
    var directionY = node2.positionY - node1.positionY;
    // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

    // If both centers are the same, apply a random force
    if (0 === directionX && 0 === directionY) {
      // s += "\nNodes have the same position.";
      return; // TODO
    }

    var overlap = nodesOverlap(node1, node2, directionX, directionY);
    
    if (overlap > 0) {
      // s += "\nNodes DO overlap.";
      // s += "\nOverlap: " + overlap;
      // If nodes overlap, repulsion force is proportional 
      // to the overlap
      var force    = options.nodeOverlap * overlap;

      // Compute the module and components of the force vector
      var distance = Math.sqrt(directionX * directionX + directionY * directionY);
      // s += "\nDistance: " + distance;
      var forceX   = force * directionX / distance;
      var forceY   = force * directionY / distance;

    } else {
      // s += "\nNodes do NOT overlap.";
      // If there's no overlap, force is inversely proportional 
      // to squared distance

      // Get clipping points for both nodes
      var point1 = findClippingPoint(node1, directionX, directionY);
      var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);

      // Use clipping points to compute distance
      var distanceX   = point2.x - point1.x;
      var distanceY   = point2.y - point1.y;
      var distanceSqr = distanceX * distanceX + distanceY * distanceY;
      var distance    = Math.sqrt(distanceSqr);
      // s += "\nDistance: " + distance;

      // Compute the module and components of the force vector
      var force  = options.nodeRepulsion / distanceSqr;
      var forceX = force * distanceX / distance;
      var forceY = force * distanceY / distance;
    }

    // Apply force
    node1.offsetX -= forceX;
    node1.offsetY -= forceY;
    node2.offsetX += forceX;
    node2.offsetY += forceY;

    // s += "\nForceX: " + forceX + " ForceY: " + forceY;
    // logDebug(s);

    return;
  };


  /**
   * @brief : Finds the point in which an edge (direction dX, dY) intersects 
   *          the rectangular bounding box of it's source/target node 
   */
  var findClippingPoint = function(node, dX, dY) {

    // Shorcuts
    var X = node.positionX;
    var Y = node.positionY;
    var H = node.height;
    var W = node.width;
    var dirSlope     = dY / dX;
    var nodeSlope    = H / W;

    // var s = 'Computing clipping point of node ' + node.id + 
    //   " . Height:  " + H + ", Width: " + W + 
    //   "\nDirection " + dX + ", " + dY; 
    // 
    // Compute intersection
    var res = {};
    do {
      // Case: Vertical direction (up)
      if (0 === dX && 0 < dY) {
        res.x = X;
        // s += "\nUp direction";
        res.y = Y + H / 2;
        break;
      }

      // Case: Vertical direction (down)
      if (0 === dX && 0 > dY) {
        res.x = X;
        res.y = Y + H / 2;
        // s += "\nDown direction";
        break;
      }      

      // Case: Intersects the right border
      if (0 < dX && 
      -1 * nodeSlope <= dirSlope && 
      dirSlope <= nodeSlope) {
        res.x = X + W / 2;
        res.y = Y + (W * dY / 2 / dX);
        // s += "\nRightborder";
        break;
      }

      // Case: Intersects the left border
      if (0 > dX && 
      -1 * nodeSlope <= dirSlope && 
      dirSlope <= nodeSlope) {
        res.x = X - W / 2;
        res.y = Y - (W * dY / 2 / dX);
        // s += "\nLeftborder";
        break;
      }

      // Case: Intersects the top border
      if (0 < dY && 
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope )) {
        res.x = X + (H * dX / 2 / dY);
        res.y = Y + H / 2;
        // s += "\nTop border";
        break;
      }

      // Case: Intersects the bottom border
      if (0 > dY && 
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope )) {
        res.x = X - (H * dX / 2 / dY);
        res.y = Y - H / 2;
        // s += "\nBottom border";
        break;
      }

    } while (false);

    // s += "\nClipping point found at " + res.x + ", " + res.y;
    // logDebug(s);
    return res;
  };


  /**
   * @brief  : Determines whether two nodes overlap or not
   * @return : Amount of overlapping (0 => no overlap)
   */
  var nodesOverlap = function(node1, node2, dX, dY) {

    if (dX > 0) {
      var overlapX = node1.maxX - node2.minX;
    } else {
      var overlapX = node2.maxX - node1.minX;
    }

    if (dY > 0) {
      var overlapY = node1.maxY - node2.minY;
    } else {
      var overlapY = node2.maxY - node1.minY;
    }

    if (overlapX >= 0 && overlapY >= 0) {
      return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
    } else {
      return 0;
    }
  };
    
  
  /**
   * @brief : Calculates all edge forces
   */
  var calculateEdgeForces = function(layoutInfo, cy, options) {
    // Iterate over all edges
    for (var i = 0; i < layoutInfo.edgeSize; i++) {
      // Get edge, source & target nodes
      var edge     = layoutInfo.layoutEdges[i];
      var sourceIx = layoutInfo.idToIndex[edge.sourceId];
      var source   = layoutInfo.layoutNodes[sourceIx];
      var targetIx = layoutInfo.idToIndex[edge.targetId];
      var target   = layoutInfo.layoutNodes[targetIx];

      // Get direction of line connecting both node centers
      var directionX = target.positionX - source.positionX;
      var directionY = target.positionY - source.positionY;
      
      // If both centers are the same, do nothing.
      // A random force has already been applied as node repulsion
      if (0 === directionX && 0 === directionY) {
      return;
      }

      // Get clipping points for both nodes
      var point1 = findClippingPoint(source, directionX, directionY);
      var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);


      var lx = point2.x - point1.x;
      var ly = point2.y - point1.y;
      var l  = Math.sqrt(lx * lx + ly * ly);

      var force  = Math.pow(edge.idealLength - l, 2) / options.edgeElasticity; 

      if (0 !== l) {
        var forceX = force * lx / l;
        var forceY = force * ly / l;
      } else {
        var forceX = 0;
        var forceY = 0;
      }

      // Add this force to target and source nodes
      source.offsetX += forceX;
      source.offsetY += forceY;
      target.offsetX -= forceX;
      target.offsetY -= forceY;

      // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
      // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
      // logDebug(s);
    }
  };


  /**
   * @brief : Computes gravity forces for all nodes
   */
  var calculateGravityForces = function(layoutInfo, cy, options) {
    // var s = 'calculateGravityForces';
    // logDebug(s);
    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
      var graph    = layoutInfo.graphSet[i];
      var numNodes = graph.length;

      // s = "Set: " + graph.toString();
      // logDebug(s);
          
      // Compute graph center
      if (0 === i) {
        var centerX   = layoutInfo.clientHeight / 2;
        var centerY   = layoutInfo.clientWidth  / 2;    
      } else {
        // Get Parent node for this graph, and use its position as center
        var temp    = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
        var parent  = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
        var centerX = parent.positionX;
        var centerY = parent.positionY;
      }
      // s = "Center found at: " + centerX + ", " + centerY;
      // logDebug(s);

      // Apply force to all nodes in graph
      for (var j = 0; j < numNodes; j++) {
        var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
        // s = "Node: " + node.id;
        var dx = centerX - node.positionX;
        var dy = centerY - node.positionY;
        var d  = Math.sqrt(dx * dx + dy * dy);
        if (d > 1.0) { // TODO: Use global variable for distance threshold
          var fx = options.gravity * dx / d;
          var fy = options.gravity * dy / d;
          node.offsetX += fx;
          node.offsetY += fy;
          // s += ": Applied force: " + fx + ", " + fy;
        } else {
          // s += ": skypped since it's too close to center";
        }
        // logDebug(s);
      }
    }
  };


  /**
   * @brief          : This function propagates the existing offsets from 
   *                   parent nodes to its descendents.
   * @arg layoutInfo : layoutInfo Object
   * @arg cy         : cytoscape Object
   * @arg options    : Layout options
   */
  var propagateForces = function(layoutInfo, cy, options) {  
    // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0;   // Points to the start the queue
    var end   = -1;  // Points to the end of the queue

    // logDebug('propagateForces');

    // Start by visiting the nodes in the root graph
    queue.push.apply(queue, layoutInfo.graphSet[0]);
    end += layoutInfo.graphSet[0].length;

    // Traverse the graph, level by level, 
    while (start <= end) {
      // Get the node to visit and remove it from queue
      var nodeId    = queue[start++];
      var nodeIndex = layoutInfo.idToIndex[nodeId];
      var node      = layoutInfo.layoutNodes[nodeIndex];
      var children  = node.children;

      // We only need to process the node if it's compound
      if (0 < children.length) {    
      var offX = node.offsetX;
      var offY = node.offsetY;

      // var s = "Propagating offset from parent node : " + node.id + 
      //   ". OffsetX: " + offX + ". OffsetY: " + offY;
      // s += "\n Children: " + children.toString();
      // logDebug(s);
      
      for (var i = 0; i < children.length; i++) {
        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
        // Propagate offset
        childNode.offsetX += offX;
        childNode.offsetY += offY;
        // Add children to queue to be visited
        queue[++end] = children[i];
      }
      
      // Reset parent offsets
      node.offsetX = 0;
      node.offsetY = 0;
      }
      
    }
  };


  /**
   * @brief : Updates the layout model positions, based on 
   *          the accumulated forces
   */
  var updatePositions = function(layoutInfo, cy, options) {
    // var s = 'Updating positions';
    // logDebug(s);

    // Reset boundaries for compound nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        // logDebug("Resetting boundaries of compound node: " + n.id);
        n.maxX = undefined;
        n.minX = undefined;
        n.maxY = undefined;
        n.minY = undefined;
      }
    }

    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        // No need to set compound node position
        // logDebug("Skipping position update of node: " + n.id);
        continue;
      }
      // s = "Node: " + n.id + " Previous position: (" + 
      // n.positionX + ", " + n.positionY + ")."; 

      // Limit displacement in order to improve stability
      var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
      n.positionX += tempForce.x; 
      n.positionY += tempForce.y;
      n.offsetX = 0;
      n.offsetY = 0;
      n.minX    = n.positionX - n.width; 
      n.maxX    = n.positionX + n.width; 
      n.minY    = n.positionY - n.height; 
      n.maxY    = n.positionY + n.height; 
      // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
      // logDebug(s);

      // Update ancestry boudaries
      updateAncestryBoundaries(n, layoutInfo);
    }

    // Update size, position of compund nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        n.positionX = (n.maxX + n.minX) / 2;
        n.positionY = (n.maxY + n.minY) / 2;
        n.width     = n.maxX - n.minX;
        n.height    = n.maxY - n.minY;
        // s = "Updating position, size of compound node " + n.id;
        // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
        // s += "\nWidth: " + n.width + ", Height: " + n.height;
        // logDebug(s);
      }
    }  
  };


  /**
   * @brief : Limits a force (forceX, forceY) to be not 
   *          greater (in modulo) than max. 
   8          Preserves force direction. 
   */
  var limitForce = function(forceX, forceY, max) {
    // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
    var force = Math.sqrt(forceX * forceX + forceY * forceY);

    if (force > max) {
      var res = {
      x : max * forceX / force,
      y : max * forceY / force
      };      

    } else {
      var res = {
      x : forceX,
      y : forceY
      };
    }

    // s += ".\nResult: (" + res.x + ", " + res.y + ")";
    // logDebug(s);

    return res;
  };


  /**
   * @brief : Function used for keeping track of compound node 
   *          sizes, since they should bound all their subnodes.
   */
  var updateAncestryBoundaries = function(node, layoutInfo) {
    // var s = "Propagating new position/size of node " + node.id;
    var parentId = node.parentId;
    if (null == parentId) {
      // If there's no parent, we are done
      // s += ". No parent node.";
      // logDebug(s);
      return;
    }

    // Get Parent Node
    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
    var flag = false;

    // MaxX
    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
      p.maxX = node.maxX + p.padRight;
      flag = true;
      // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
    }

    // MinX
    if (null == p.minX || node.minX - p.padLeft < p.minX) {
      p.minX = node.minX - p.padLeft;
      flag = true;
      // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
    }

    // MaxY
    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
      p.maxY = node.maxY + p.padBottom;
      flag = true;
      // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
    }

    // MinY
    if (null == p.minY || node.minY - p.padTop < p.minY) {
      p.minY = node.minY - p.padTop;
      flag = true;
      // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
    }

    // If updated boundaries, propagate changes upward
    if (flag) {
      // logDebug(s);
      return updateAncestryBoundaries(p, layoutInfo);
    } 

    // s += ". No changes in boundaries/position of parent node " + p.id;  
    // logDebug(s);
    return;
  };


  /**
   * @brief : Logs a debug message in JS console, if DEBUG is ON
   */
  // var logDebug = function(text) {
  //   if (DEBUG) {
  //     console.debug(text);
  //   }
  // };


  // register the layout
  $$('layout', 'cose', CoseLayout);

})(cytoscape);

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    // dagre algo options, uses default value on undefined
    nodeSep: undefined, // the separation between adjacent nodes in the same rank
    edgeSep: undefined, // the separation between adjacent edges in the same rank
    rankSep: undefined, // the separation between adjacent nodes in the same rank
    rankDir: undefined, // 'TB' for top to bottom flow, 'LR' for left to right
    minLen: function( edge ){ return 1; }, // number of ranks to keep between the source and target of the edge
    edgeWeight: function( edge ){ return 1; }, // higher weight edges are generally made shorter and straighter than lower weight edges
    
    // general layout options
    fit: true, // whether to fit to viewport
    padding: 30, // fit padding
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    ready: function(){}, // on layoutready
    stop: function(){} // on layoutstop
  };

  // constructor
  // options : object containing layout options
  function DagreLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  DagreLayout.prototype.run = function(){
    var options = this.options;
    var layout = this;

    $$.util.require('dagre', function(dagre){

      var cy = options.cy; // cy is automatically populated for us in the constructor
      var eles = options.eles;

      var getVal = function( ele, val ){
        return $$.is.fn(val) ? val.apply( ele, [ ele ] ) : val;
      };

      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );

      var g = new dagre.graphlib.Graph({
        multigraph: true,
        compound: true
      });

      var gObj = {};
      var setGObj = function( name, val ){
        if( val != null ){
          gObj[ name ] = val;
        }
      };
      
      setGObj( 'nodesep', options.nodeSep );
      setGObj( 'edgesep', options.edgeSep );
      setGObj( 'ranksep', options.rankSep );
      setGObj( 'rankdir', options.rankDir );

      g.setGraph( gObj );

      g.setDefaultEdgeLabel(function() { return {}; });
      g.setDefaultNodeLabel(function() { return {}; });

      // add nodes to dagre
      var nodes = eles.nodes();
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];

        g.setNode( node.id(), {
          width: node.width(),
          height: node.height(),
          name: node.id()
        } );

        // console.log( g.node(node.id()) );
      }

      // set compound parents
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];

        if( node.isChild() ){
          g.setParent( node.id(), node.parent().id() );
        }
      }

      // add edges to dagre
      var edges = eles.edges().stdFilter(function( edge ){
        return !edge.source().isParent() && !edge.target().isParent(); // dagre can't handle edges on compound nodes
      });
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];

        g.setEdge( edge.source().id(), edge.target().id(), {
          minlen: getVal( edge, options.minLen ),
          weight: getVal( edge, options.edgeWeight ),
          name: edge.id()
        }, edge.id() );

        // console.log( g.edge(edge.source().id(), edge.target().id(), edge.id()) );
      }

      dagre.layout( g );

      var gNodeIds = g.nodes();
      for( var i = 0; i < gNodeIds.length; i++ ){
        var id = gNodeIds[i];
        var n = g.node( id );

        cy.getElementById(id).scratch().dagre = n;
      }

      var dagreBB;

      if( options.boundingBox ){
        dagreBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
        nodes.forEach(function( node ){
          var dModel = node.scratch().dagre;

          dagreBB.x1 = Math.min( dagreBB.x1, dModel.x );
          dagreBB.x2 = Math.max( dagreBB.x2, dModel.x );

          dagreBB.y1 = Math.min( dagreBB.y1, dModel.y );
          dagreBB.y2 = Math.max( dagreBB.y2, dModel.y );
        });

        dagreBB.w = dagreBB.x2 - dagreBB.x1;
        dagreBB.h = dagreBB.y2 - dagreBB.y1;
      } else {
        dagreBB = bb;
      }

      var constrainPos = function( p ){
        if( options.boundingBox ){
          var xPct = (p.x - dagreBB.x1) / dagreBB.w;
          var yPct = (p.y - dagreBB.y1) / dagreBB.h;

          return {
            x: bb.x1 + xPct * bb.w,
            y: bb.y1 + yPct * bb.h
          };
        } else {
          return p;
        }
      };

      nodes.layoutPositions(layout, options, function(){
        var dModel = this.scratch().dagre;

        return constrainPos({
          x: dModel.x,
          y: dModel.y
        });
      });

    }); // require

    return this; // chaining
  };

  // register the layout
  $$('layout', 'dagre', DagreLayout);

})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // padding used on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    rows: undefined, // force num of rows in the grid
    columns: undefined, // force num of cols in the grid
    position: function( node ){}, // returns { row, col } for element
    sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function GridLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  GridLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');

    if( options.sort ){
      nodes = nodes.sort( options.sort );
    }
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    if( bb.h === 0 || bb.w === 0){
      nodes.layoutPositions(this, options, function(){
        return { x: bb.x1, y: bb.y1 };
      });
      
    } else {
      
      // width/height * splits^2 = cells where splits is number of times to split width
      var cells = nodes.size();
      var splits = Math.sqrt( cells * bb.h/bb.w );
      var rows = Math.round( splits );
      var cols = Math.round( bb.w/bb.h * splits );

      var small = function(val){
        if( val == null ){
          return Math.min(rows, cols);
        } else {
          var min = Math.min(rows, cols);
          if( min == rows ){
            rows = val;
          } else {
            cols = val;
          }
        }
      };
      
      var large = function(val){
        if( val == null ){
          return Math.max(rows, cols);
        } else {
          var max = Math.max(rows, cols);
          if( max == rows ){
            rows = val;
          } else {
            cols = val;
          }
        }
      };
      
      // if rows or columns were set in options, use those values
      if( options.rows != null && options.columns != null ){
        rows = options.rows;
        cols = options.columns;
      } else if( options.rows != null && options.columns == null ){
        rows = options.rows;
        cols = Math.ceil( cells / rows );
      } else if( options.rows == null && options.columns != null ){
        cols = options.columns;
        rows = Math.ceil( cells / cols );
      }
      
      // otherwise use the automatic values and adjust accordingly
      
      // if rounding was up, see if we can reduce rows or columns
      else if( cols * rows > cells ){
        var sm = small();
        var lg = large();
        
        // reducing the small side takes away the most cells, so try it first
        if( (sm - 1) * lg >= cells ){
          small(sm - 1);
        } else if( (lg - 1) * sm >= cells ){
          large(lg - 1);
        } 
      } else {
        
        // if rounding was too low, add rows or columns
        while( cols * rows < cells ){
          var sm = small();
          var lg = large();
          
          // try to add to larger side first (adds less in multiplication)
          if( (lg + 1) * sm >= cells ){
            large(lg + 1);
          } else {
            small(sm + 1);
          }
        }
      }
      
      var cellWidth = bb.w / cols;
      var cellHeight = bb.h / rows;

      if( options.avoidOverlap ){
        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var w = node.outerWidth();
          var h = node.outerHeight();

          cellWidth = Math.max( cellWidth, w );
          cellHeight = Math.max( cellHeight, h );
        }
      }
      
      var cellUsed = {}; // e.g. 'c-0-2' => true
      
      var used = function(row, col){
        return cellUsed['c-' + row + '-' + col] ? true : false;
      };
      
      var use = function(row, col){
        cellUsed['c-' + row + '-' + col] = true;
      };

      // to keep track of current cell position
      var row = 0;
      var col = 0;
      var moveToNextCell = function(){
        col++;
        if( col >= cols ){
          col = 0;
          row++;
        }
      };

      // get a cache of all the manual positions
      var id2manPos = {};
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var rcPos = options.position( node );

        if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
          var pos = {
            row: rcPos.row,
            col: rcPos.col
          };

          if( pos.col === undefined ){ // find unused col
            pos.col = 0;

            while( used(pos.row, pos.col) ){
              pos.col++;
            }
          } else if( pos.row === undefined ){ // find unused row
            pos.row = 0;

            while( used(pos.row, pos.col) ){
              pos.row++;
            }
          }

          id2manPos[ node.id() ] = pos;
          use( pos.row, pos.col );
        }
      }

      var getPos = function(i, element){
        var x, y;

        if( element.locked() || element.isFullAutoParent() ){
          return false;
        }

        // see if we have a manual position set
        var rcPos = id2manPos[ element.id() ];
        if( rcPos ){
          x = rcPos.col * cellWidth + cellWidth/2 + bb.x1;
          y = rcPos.row * cellHeight + cellHeight/2 + bb.y1;
        
        } else { // otherwise set automatically
        
          while( used(row, col) ){
            moveToNextCell();
          }

          x = col * cellWidth + cellWidth/2 + bb.x1;
          y = row * cellHeight + cellHeight/2 + bb.y1;
          use( row, col );
          
          moveToNextCell();
        }
        
        return { x: x, y: y };
        
      };

      nodes.layoutPositions( this, options, getPos );
    }

    return this; // chaining
    
  };
  
  $$('layout', 'grid', GridLayout);
  
})( cytoscape );

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    ready: function(){}, // on layoutready
    stop: function(){} // on layoutstop
  };

  // constructor
  // options : object containing layout options
  function NullLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  NullLayout.prototype.run = function(){
    var options = this.options;
    var eles = options.eles; // elements to consider in the layout
    var layout = this;

    // cy is automatically populated for us in the constructor
    var cy = options.cy; // jshint ignore:line

    layout.trigger('layoutstart');

    // puts all nodes at (0, 0)
    eles.nodes().positions(function(){
      return {
        x: 0,
        y: 0
      };
    });

    // trigger layoutready when each node has had its position set at least once
    layout.one('layoutready', options.ready);
    layout.trigger('layoutready');

    // trigger layoutstop when the layout stops (e.g. finishes)
    layout.one('layoutstop', options.stop);
    layout.trigger('layoutstop');

    return this; // chaining
  };

  // called on continuous layouts to stop them before they finish
  NullLayout.prototype.stop = function(){
    return this; // chaining
  };

  // register the layout
  $$('layout', 'null', NullLayout);

})(cytoscape);
;(function($$){ 'use strict';
  
  var defaults = {
    positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
    zoom: undefined, // the zoom level to set (prob want fit = false if set)
    pan: undefined, // the pan level to set (prob want fit = false if set)
    fit: true, // whether to fit to viewport
    padding: 30, // padding on fit
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function PresetLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  PresetLayout.prototype.run = function(){
    var options = this.options;
    var eles = options.eles;

    var nodes = eles.nodes();
    var posIsFn = $$.is.fn( options.positions );

    function getPosition(node){
      if( options.positions == null ){
        return null;
      }

      if( posIsFn ){
        return options.positions.apply( node, [ node ] );
      }
      
      var pos = options.positions[node._private.data.id];

      if( pos == null ){
        return null;
      }
      
      return pos;
    }
    
    nodes.layoutPositions(this, options, function(i, node){
      var position = getPosition(node);
      
      if( node.locked() || position == null ){
        return false;
      }
      
      return position;
    });
        
    return this; // chaining
  };
  
  $$('layout', 'preset', PresetLayout);
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit to viewport
    padding: 30, // fit padding
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function RandomLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  RandomLayout.prototype.run = function(){
    var options = this.options;
    var cy = options.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var getPos = function( i, node ){
      return {
        x: bb.x1 + Math.round( Math.random() * bb.w ),
        y: bb.y1 + Math.round( Math.random() * bb.h )
      };
    };

    nodes.layoutPositions( this, options, getPos );

    return this; // chaining
  };
  
  // register the layout
  $$(
    'layout', // we're registering a layout
    'random', // the layout name
    RandomLayout // the layout prototype
  );
  
})(cytoscape);

;( function( $$ ){ 'use strict';

  /*
   * This layout combines several algorithms:
   *
   * - It generates an initial position of the nodes by using the
   *   Fruchterman-Reingold algorithm (doi:10.1002/spe.4380211102)
   *
   * - Finally it eliminates overlaps by using the method described by
   *   Gansner and North (doi:10.1007/3-540-37623-2_28)
   */

  var defaults = {
    animate: true, // whether to show the layout as it's running
    ready: undefined, // Callback on layoutready
    stop: undefined, // Callback on layoutstop
    fit: true, // Reset viewport to fit default simulationBounds
    minDist: 20, // Minimum distance between nodes
    padding: 20, // Padding
    expandingFactor: -1.0, // If the network does not satisfy the minDist
    // criterium then it expands the network of this amount
    // If it is set to -1.0 the amount of expansion is automatically
    // calculated based on the minDist, the aspect ratio and the
    // number of nodes
    maxFruchtermanReingoldIterations: 50, // Maximum number of initial force-directed iterations
    maxExpandIterations: 4, // Maximum number of expanding iterations
    boundingBox: undefined // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  };

  function SpreadLayout( options ) {
    this.options = $$.util.extend( {}, defaults, options );
  }

  function cellCentroid( cell ) {
    var hes = cell.halfedges;
    var area = 0,
      x = 0,
      y = 0;
    var p1, p2, f;

    for( var i = 0; i < hes.length; ++i ) {
      p1 = hes[ i ].getEndpoint();
      p2 = hes[ i ].getStartpoint();

      area += p1.x * p2.y;
      area -= p1.y * p2.x;

      f = p1.x * p2.y - p2.x * p1.y;
      x += ( p1.x + p2.x ) * f;
      y += ( p1.y + p2.y ) * f;
    }

    area /= 2;
    f = area * 6;
    return {
      x: x / f,
      y: y / f
    };
  }

  function sitesDistance( ls, rs ) {
    var dx = ls.x - rs.x;
    var dy = ls.y - rs.y;
    return Math.sqrt( dx * dx + dy * dy );
  }

  SpreadLayout.prototype.run = function() {

    var layout = this;
    // var self = this;
    var options = this.options;

    $$.util.requires(['foograph', 'Voronoi'], function(foograph, Voronoi){

      var cy = options.cy;
      // var allNodes = cy.nodes();
      var nodes = cy.nodes();
      //var allEdges = cy.edges();
      var edges = cy.edges();
      var cWidth = cy.width();
      var cHeight = cy.height();
      var simulationBounds = options.boundingBox ? $$.util.makeBoundingBox( options.boundingBox ) : null;
      var padding = options.padding;
      var simBBFactor = Math.max( 1, Math.log(nodes.length) * 0.8 );
      
      if( nodes.length < 100 ){
        simBBFactor /= 2;
      }

      layout.trigger( {
        type: 'layoutstart',
        layout: layout
      } );

      var simBB = {
        x1: 0,
        y1: 0,
        x2: cWidth * simBBFactor,
        y2: cHeight * simBBFactor
      };

      if( simulationBounds ) {
        simBB.x1 = simulationBounds.x1;
        simBB.y1 = simulationBounds.y1;
        simBB.x2 = simulationBounds.x2;
        simBB.y2 = simulationBounds.y2;
      }

      simBB.x1 += padding;
      simBB.y1 += padding;
      simBB.x2 -= padding;
      simBB.y2 -= padding;

      var width = simBB.x2 - simBB.x1;
      var height = simBB.y2 - simBB.y1;

      // Get start time
      var startTime = Date.now();

      // layout doesn't work with just 1 node
      if( nodes.size() <= 1 ) {
        nodes.positions( {
          x: Math.round( ( simBB.x1 + simBB.x2 ) / 2 ),
          y: Math.round( ( simBB.y1 + simBB.y2 ) / 2 )
        } );

        if( options.fit ) {
          cy.fit( options.padding );
        }

        // Get end time
        var endTime = Date.now();
        console.info( "Layout on " + nodes.size() + " nodes took " + ( endTime - startTime ) + " ms" );

        layout.one( "layoutready", options.ready );
        layout.trigger( "layoutready" );

        layout.one( "layoutstop", options.stop );
        layout.trigger( "layoutstop" );

        return;
      }

      // First I need to create the data structure to pass to the worker
      var pData = {
        'width': width,
        'height': height,
        'minDist': options.minDist,
        'expFact': options.expandingFactor,
        'expIt': 0,
        'maxExpIt': options.maxExpandIterations,
        'vertices': [],
        'edges': [],
        'startTime': startTime,
        'maxFruchtermanReingoldIterations': options.maxFruchtermanReingoldIterations
      };

      nodes.each(
        function( i, node ) {
          var nodeId = this._private.data.id;
          pData[ 'vertices' ].push( {
            id: nodeId,
            x: 0,
            y: 0
          } );
        } );

      edges.each(
        function() {
          var srcNodeId = this.source().id();
          var tgtNodeId = this.target().id();
          pData[ 'edges' ].push( {
            src: srcNodeId,
            tgt: tgtNodeId
          } );
        } );

      //Decleration
      var t1 = $$.Thread();
      // And to add the required scripts
      //EXTERNAL 1
      t1.require( foograph, 'foograph' );
      //EXTERNAL 2
      t1.require( Voronoi );

      //Local function
      t1.require( sitesDistance );
      t1.require( cellCentroid );

      function setPositions( pData ){ //console.log('set posns')
        // First we retrieve the important data
        // var expandIteration = pData[ 'expIt' ];
        var dataVertices = pData[ 'vertices' ];
        var vertices = [];
        for( var i = 0; i < dataVertices.length; ++i ) {
          var dv = dataVertices[ i ];
          vertices[ dv.id ] = {
            x: dv.x,
            y: dv.y
          };
        }
        /*
         * FINALLY:
         *
         * We position the nodes based on the calculation
         */
        nodes.positions(
          function( i, node ) {
            var id = node._private.data.id;
            // var pos = node._private.position;
            var vertex = vertices[ id ];

            return {
              x: Math.round( simBB.x1 + vertex.x ),
              y: Math.round( simBB.y1 + vertex.y )
            };
          } );

        if( options.fit ) {
          cy.fit( options.padding );
        }

        cy.nodes().rtrigger( "position" );
      }

      var didLayoutReady = false;
      t1.on('message', function(e){
        var pData = e.message; //console.log('message', e)

        if( !options.animate ){
          return;
        }

        setPositions( pData );

        if( !didLayoutReady ){
          layout.trigger( "layoutready" );

          didLayoutReady = true;
        }
      });

      layout.one( "layoutready", options.ready );

      t1.pass( pData ).run( function( pData ) {
        
        foograph = eval('foograph');
        Voronoi = eval('Voronoi');
        
        // I need to retrieve the important data
        var lWidth = pData[ 'width' ];
        var lHeight = pData[ 'height' ];
        var lMinDist = pData[ 'minDist' ];
        var lExpFact = pData[ 'expFact' ];
        var lMaxExpIt = pData[ 'maxExpIt' ];
        var lMaxFruchtermanReingoldIterations = pData[ 'maxFruchtermanReingoldIterations' ];

        // Prepare the data to output
        var savePositions = function(){
          pData[ 'width' ] = lWidth;
          pData[ 'height' ] = lHeight;
          pData[ 'expIt' ] = expandIteration;
          pData[ 'expFact' ] = lExpFact;

          pData[ 'vertices' ] = [];
          for( var i = 0; i < fv.length; ++i ) {
            pData[ 'vertices' ].push( {
              id: fv[ i ].label,
              x: fv[ i ].x,
              y: fv[ i ].y
            } );
          }
        };

        var messagePositions = function(){
          broadcast( pData );
        };

        /*
         * FIRST STEP: Application of the Fruchterman-Reingold algorithm
         *
         * We use the version implemented by the foograph library
         *
         * Ref.: https://code.google.com/p/foograph/
         */

        // We need to create an instance of a graph compatible with the library
        var frg = new foograph.Graph( "FRgraph", false );

        var frgNodes = {};

        // Then we have to add the vertices
        var dataVertices = pData[ 'vertices' ];
        for( var ni = 0; ni < dataVertices.length; ++ni ) {
          var id = dataVertices[ ni ][ 'id' ];
          var v = new foograph.Vertex( id, Math.round( Math.random() * lHeight ), Math.round( Math.random() * lHeight ) );
          frgNodes[ id ] = v;
          frg.insertVertex( v );
        }

        var dataEdges = pData[ 'edges' ];
        for( var ei = 0; ei < dataEdges.length; ++ei ) {
          var srcNodeId = dataEdges[ ei ][ 'src' ];
          var tgtNodeId = dataEdges[ ei ][ 'tgt' ];
          frg.insertEdge( "", 1, frgNodes[ srcNodeId ], frgNodes[ tgtNodeId ] );
        }

        var fv = frg.vertices;

        // Then we apply the layout
        var iterations = lMaxFruchtermanReingoldIterations;
        var frLayoutManager = new foograph.ForceDirectedVertexLayout( lWidth, lHeight, iterations, false, lMinDist );

        frLayoutManager.callback = function(){
          savePositions();
          messagePositions();
        };

        frLayoutManager.layout( frg );

        savePositions();
        messagePositions();

        /*
         * SECOND STEP: Tiding up of the graph.
         *
         * We use the method described by Gansner and North, based on Voronoi
         * diagrams.
         *
         * Ref: doi:10.1007/3-540-37623-2_28
         */

        // We calculate the Voronoi diagram dor the position of the nodes
        var voronoi = new Voronoi();
        var bbox = {
          xl: 0,
          xr: lWidth,
          yt: 0,
          yb: lHeight
        };
        var vSites = [];
        for( var i = 0; i < fv.length; ++i ) {
          vSites[ fv[ i ].label ] = fv[ i ];
        }

        function checkMinDist( ee ) {
          var infractions = 0;
          // Then we check if the minimum distance is satisfied
          for( var eei = 0; eei < ee.length; ++eei ) {
            var e = ee[ eei ];
            if( ( e.lSite != null ) && ( e.rSite != null ) && sitesDistance( e.lSite, e.rSite ) < lMinDist ) {
              ++infractions;
            }
          }
          return infractions;
        }

        var diagram = voronoi.compute( fv, bbox );

        // Then we reposition the nodes at the centroid of their Voronoi cells
        var cells = diagram.cells;
        for( var i = 0; i < cells.length; ++i ) {
          var cell = cells[ i ];
          var site = cell.site;
          var centroid = cellCentroid( cell );
          var currv = vSites[ site.label ];
          currv.x = centroid.x;
          currv.y = centroid.y;
        }

        if( lExpFact < 0.0 ) {
          // Calculates the expanding factor
          lExpFact = Math.max( 0.05, Math.min( 0.10, lMinDist / Math.sqrt( ( lWidth * lHeight ) / fv.length ) * 0.5 ) );
          //console.info("Expanding factor is " + (options.expandingFactor * 100.0) + "%");
        }

        var prevInfractions = checkMinDist( diagram.edges );
        //console.info("Initial infractions " + prevInfractions);

        var bStop = ( prevInfractions <= 0 );

        var voronoiIteration = 0;
        var expandIteration = 0;

        // var initWidth = lWidth;

        while( !bStop ) {
          ++voronoiIteration;
          for( var it = 0; it <= 4; ++it ) {
            voronoi.recycle( diagram );
            diagram = voronoi.compute( fv, bbox );

            // Then we reposition the nodes at the centroid of their Voronoi cells
            cells = diagram.cells;
            for( var i = 0; i < cells.length; ++i ) {
              var cell = cells[ i ];
              var site = cell.site;
              var centroid = cellCentroid( cell );
              var currv = vSites[ site.label ];
              currv.x = centroid.x;
              currv.y = centroid.y;
            }
          }

          var currInfractions = checkMinDist( diagram.edges );
          //console.info("Current infractions " + currInfractions);

          if( currInfractions <= 0 ) {
            bStop = true;
          } else {
            if( currInfractions >= prevInfractions || voronoiIteration >= 4 ) {
              if( expandIteration >= lMaxExpIt ) {
                bStop = true;
              } else {
                lWidth += lWidth * lExpFact;
                lHeight += lHeight * lExpFact;
                bbox = {
                  xl: 0,
                  xr: lWidth,
                  yt: 0,
                  yb: lHeight
                };
                ++expandIteration;
                voronoiIteration = 0;
                //console.info("Expanded to ("+width+","+height+")");
              }
            }
          }
          prevInfractions = currInfractions;

          savePositions();
          messagePositions();
        }

        savePositions();
        return pData;

      } ).then( function( pData ) {
        // var expandIteration = pData[ 'expIt' ];
        var dataVertices = pData[ 'vertices' ];

        setPositions( pData );

        // Get end time
        var startTime = pData[ 'startTime' ];
        var endTime = new Date();
        console.info( "Layout on " + dataVertices.length + " nodes took " + ( endTime - startTime ) + " ms" );

        layout.one( "layoutstop", options.stop );

        if( !options.animate ){
          layout.trigger( "layoutready" );
        }

        layout.trigger( "layoutstop" );

        t1.stop();
      } );

    });

    return this;
  }; // run

  SpreadLayout.prototype.stop = function() {};

  $$( 'layout', 'spread', SpreadLayout );


} )( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    animate: true, // whether to show the layout as it's running
    maxSimulationTime: 4000, // max length in ms to run the layout
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // padding on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    random: false, // whether to use random initial positions
    infinite: false, // overrides all other options for a forces-all-the-time mode
    ready: undefined, // callback on layoutready
    stop: undefined, // callback on layoutstop

    // springy forces
    stiffness: 400,
    repulsion: 400,
    damping: 0.5
  };

  function SpringyLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  SpringyLayout.prototype.run = function(){
    var layout = this;
    var self = this;
    var options = this.options;

    $$.util.require('Springy', function(Springy){

      var simUpdatingPos = false;

      var cy = options.cy;
      layout.trigger({ type: 'layoutstart', layout: layout });
      
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var edges = eles.edges();
   
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );
      
      // make a new graph
      var graph = new Springy.Graph();

      // make some nodes
      nodes.each(function(i, node){
        node.scratch('springy', {
          model: graph.newNode({
            element: node
          })
        });
      });

      // connect them with edges
      edges.each(function(i, edge){
        var fdSrc = edge.source().scratch('springy').model;
        var fdTgt = edge.target().scratch('springy').model;
        
        edge.scratch('springy', {
          model: graph.newEdge(fdSrc, fdTgt, {
            element: edge
          })
        });
      });
      
      var sim = window.sim = new Springy.Layout.ForceDirected(graph, options.stiffness, options.repulsion, options.damping);

      if( options.infinite ){
        sim.minEnergyThreshold = -Infinity;
      }

      var currentBB = sim.getBoundingBox();
      // var targetBB = {bottomleft: new Springy.Vector(-2, -2), topright: new Springy.Vector(2, 2)};
      
      // convert to/from screen coordinates
      var toScreen = function(p) {
        currentBB = sim.getBoundingBox();

        var size = currentBB.topright.subtract(currentBB.bottomleft);
        var sx = p.subtract(currentBB.bottomleft).divide(size.x).x * bb.w + bb.x1;
        var sy = p.subtract(currentBB.bottomleft).divide(size.y).y * bb.h + bb.x1;

        return new Springy.Vector(sx, sy);
      };

      var fromScreen = function(s) {
        currentBB = sim.getBoundingBox();

        var size = currentBB.topright.subtract(currentBB.bottomleft);
        var px = ((s.x - bb.x1) / bb.w) * size.x + currentBB.bottomleft.x;
        var py = ((s.y - bb.y1) / bb.h) * size.y + currentBB.bottomleft.y;

        return new Springy.Vector(px, py);
      };
      
      var movedNodes = cy.collection();
      
      var numNodes = cy.nodes().size();
      var drawnNodes = 1;
      var fdRenderer = new Springy.Renderer(sim,
        function clear() {
          if( self.stopped ){ return; } // because springy is a buggy layout
          
          if( movedNodes.length > 0 && options.animate ){
            simUpdatingPos = true;

            movedNodes.rtrigger('position');

            if( options.fit ){
              cy.fit( options.padding );
            }

            movedNodes = cy.collection();

            simUpdatingPos = false;
          }
        },

        function drawEdge(edge, p1, p2) {
          // draw an edge
        },

        function drawNode(node, p) {
          if( self.stopped ){ return; } // because springy is a buggy layout

          var v = toScreen(p);
          var element = node.data.element;
          
          if( !element.locked() && !element.grabbed() ){
              element._private.position = {
                x: v.x,
                y: v.y
              };
              movedNodes.merge(element);
          } else {
            //setLayoutPositionForElement(element);
          }
          
          if( drawnNodes == numNodes ){
            layout.one('layoutready', options.ready);
            layout.trigger({ type: 'layoutready', layout: layout });
          } 
          
          drawnNodes++;
        
        }
      );
      
      // set initial node points
      nodes.each(function(i, ele){
        if( !options.random ){
          setLayoutPositionForElement(ele);
        }
      });
      
      // update node positions when dragging
      var dragHandler;
      nodes.on('position', dragHandler = function(){
        if( simUpdatingPos ){ return; }

        setLayoutPositionForElement(this);
      });
      
      function setLayoutPositionForElement(element){
        var fdId = element.scratch('springy').model.id;
        var fdP = fdRenderer.layout.nodePoints[fdId].p;
        var pos = element.position();
        var positionInFd = (pos.x != null && pos.y != null) ? fromScreen(element.position()) : {
          x: Math.random() * 4 - 2,
          y: Math.random() * 4 - 2
        };
        
        fdP.x = positionInFd.x;
        fdP.y = positionInFd.y;
      }
      
      var grabbableNodes = nodes.filter(":grabbable");
      
      function start(){
        self.stopped = false;

        // disable grabbing if so set
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.ungrabify();
        }
        
        fdRenderer.start();
      }
      
      self.stopSystem = function(){
        self.stopped = true;

        graph.filterNodes(function(){
          return false; // remove all nodes
        });
        
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        if( options.fit ){
          cy.fit( options.padding );
        }
        
        nodes.off('drag position', dragHandler);

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });

        self.stopSystem = null;
      };
      
      start();
      if( !options.infinite ){
        setTimeout(function(){
          self.stop();
        }, options.maxSimulationTime);
      }

    }); // require

    return this; // chaining
  };

  SpringyLayout.prototype.stop = function(){
    if( this.stopSystem != null ){
      this.stopSystem();
    }

    return this; // chaining
  };
  
  $$('layout', 'springy', SpringyLayout);

  
})(cytoscape);

;(function($$){ 'use strict';
    
  function NullRenderer(options){
    this.options = options;
  }
  
  NullRenderer.prototype.recalculateRenderedStyle = function(){
  };

  NullRenderer.prototype.notify = function(){
    // the null renderer does nothing
  };
  
  $$('renderer', 'null', NullRenderer);
  
})( cytoscape );

}).call(this,require('_process'),"/../bower_components/cytoscape/dist")

},{"_process":4,"child_process":1,"os":2,"path":3}],6:[function(require,module,exports){
(function (global){
/*! imjs - v3.13.0 - 2015-05-08 */

// This library is open source software according to the definition of the
// GNU Lesser General Public Licence, Version 3, (LGPLv3) a copy of which is
// included with this software. All use of this software is covered according to
// the terms of the LGPLv3.
// 
// The copyright is held by InterMine (www.intermine.org) and Alex Kalderimis (alex@intermine.org).

(function (intermine) {
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.imjs=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function() {
  exports.ACCEPT_HEADER = {
    'xml': 'application/xml',
    'json': 'application/json',
    'tsv': 'text/tab-separated-values',
    'tab': 'text/tab-separated-values',
    'csv': 'text/comma-separated-values',
    'fasta': 'text/x-fasta',
    'gff3': 'text/x-gff3',
    'bed': 'text/x-bed',
    'objects': 'application/json;type=objects',
    'jsonobjects': 'application/json;type=objects',
    'jsontable': 'application/json;type=table',
    'jsonrows': 'application/json;type=rows',
    'jsoncount': 'application/json;type=count',
    'jsonp': 'application/javascript',
    'jsonpobjects': 'application/javascript;type=objects',
    'jsonptable': 'application/javascript;type=table',
    'jsonprows': 'application/javascript;type=rows',
    'jsonpcount': 'application/javascript;type=count'
  };

}).call(this);

},{}],2:[function(_dereq_,module,exports){
(function (global){
(function() {
  var expose, imjs, merge;

  _dereq_('./shiv');

  module.exports = imjs = _dereq_('./service');

  merge = imjs.utils.merge;

  expose = function(name, thing) {
    if ('function' === typeof define && define.amd) {
      return define(name, [], thing);
    } else {
      return global[name] = thing;
    }
  };

  expose('imjs', imjs);

  if (typeof intermine === 'undefined') {
    expose('intermine', imjs);
  } else {
    expose('intermine', merge(intermine, imjs));
  }

}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./service":10,"./shiv":12}],3:[function(_dereq_,module,exports){
(function() {
  var ACCEPT_HEADER, JSONStream, PESKY_COMMA, URL, URLENC, USER_AGENT, VERSION, blocking, defer, error, getMsg, http, invoke, merge, parseOptions, rejectAfter, streaming, utils, _ref;

  URL = _dereq_('url');

  JSONStream = _dereq_('JSONStream');

  http = _dereq_('http');

  ACCEPT_HEADER = _dereq_('./constants').ACCEPT_HEADER;

  VERSION = _dereq_('./version').VERSION;

  _ref = utils = _dereq_('./util'), error = _ref.error, defer = _ref.defer, merge = _ref.merge, invoke = _ref.invoke;

  USER_AGENT = "node-http/imjs-" + VERSION;

  PESKY_COMMA = /,\s*$/;

  URLENC = "application/x-www-form-urlencoded";

  exports.supports = function() {
    return true;
  };

  streaming = function(opts, resolve, reject) {
    return function(resp) {
      var errors, results;
      if (resp.pipe == null) {
        return reject(new Error('response is not a stream'));
      }
      resp.on('error', reject);
      if ((resp.statusCode != null) && resp.statusCode !== 200) {
        errors = JSONStream.parse('error');
        errors.pause();
        resp.pipe(errors);
        return reject([resp.statusCode, errors]);
      } else {
        results = JSONStream.parse('results.*');
        results.pause();
        resp.pipe(results);
        return resolve(results);
      }
    };
  };

  getMsg = function(_arg, text, e, code) {
    var type, url;
    type = _arg.type, url = _arg.url;
    return "Could not parse response to " + type + " " + url + ": \"" + text + "\" (" + code + ": " + e + ")";
  };

  blocking = function(opts, resolve, reject) {
    return function(resp) {
      var containerBuffer;
      containerBuffer = '';
      resp.on('data', function(chunk) {
        return containerBuffer += chunk;
      });
      resp.on('error', reject);
      return resp.on('end', function() {
        var ct, e, err, f, match, parsed, _ref1;
        ct = resp.headers['content-type'];
        if ('application/json' === ct || /json/.test(opts.dataType) || /json/.test(opts.data.format)) {
          if ('' === containerBuffer && resp.statusCode === 200) {
            return resolve();
          } else {
            try {
              parsed = JSON.parse(containerBuffer);
              if (err = parsed.error) {
                return reject(new Error(err));
              } else {
                return resolve(parsed);
              }
            } catch (_error) {
              e = _error;
              if (resp.statusCode >= 400) {
                return reject(new Error(resp.statusCode));
              } else {
                return reject(new Error(getMsg(opts, containerBuffer, e, resp.statusCode)));
              }
            }
          }
        } else {
          if (match = containerBuffer.match(/\[ERROR\] (\d+)([\s\S]*)/)) {
            return reject(new Error(match[2]));
          } else {
            f = (200 <= (_ref1 = resp.statusCode) && _ref1 < 400) ? resolve : reject;
            return f(containerBuffer);
          }
        }
      });
    };
  };

  exports.iterReq = function(method, path, format) {
    return function(q, page, cb, eb, onEnd) {
      var attach, promise, readErrors, req, _ref1;
      if (page == null) {
        page = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (eb == null) {
        eb = (function() {});
      }
      if (onEnd == null) {
        onEnd = (function() {});
      }
      if (utils.isFunction(page)) {
        _ref1 = [{}, page, cb, eb], page = _ref1[0], cb = _ref1[1], eb = _ref1[2], onEnd = _ref1[3];
      }
      req = merge({
        format: format
      }, page, {
        query: q.toXML()
      });
      attach = function(stream) {
        stream.on('data', cb);
        stream.on('error', eb);
        stream.on('end', onEnd);
        setTimeout((function() {
          if (stream.resume != null) {
            return stream.resume();
          }
        }), 3);
        return stream;
      };
      readErrors = function(_arg) {
        var errors, sc;
        sc = _arg[0], errors = _arg[1];
        errors.on('data', eb);
        errors.on('error', eb);
        errors.on('end', onEnd);
        if (errors.resume != null) {
          errors.resume();
        }
        return error(sc);
      };
      promise = this.makeRequest(method, path, req, null, true);
      promise.then(attach, readErrors);
      return promise;
    };
  };

  rejectAfter = function(timeout, reject, promise) {
    var to;
    to = setTimeout((function() {
      return reject("Request timed out.");
    }), timeout);
    return promise.then(function() {
      return cancelTimeout(to);
    });
  };

  parseOptions = function(opts) {
    var k, parsed, postdata, sep, v, _ref1, _ref2, _ref3;
    if (!opts.url) {
      throw new Error("No url provided in " + (JSON.stringify(opts)));
    }
    if (typeof opts.data === 'string') {
      postdata = opts.data;
      if ((_ref1 = opts.type) === 'GET' || _ref1 === 'DELETE') {
        throw new Error("Invalid request. " + opts.type + " requests must not have bodies");
      }
    } else {
      postdata = utils.querystring(opts.data);
    }
    parsed = URL.parse(opts.url, true);
    parsed.withCredentials = false;
    parsed.method = opts.type || 'GET';
    if (opts.port != null) {
      parsed.port = opts.port;
    }
    parsed.headers = {
      'User-Agent': USER_AGENT,
      'Accept': ACCEPT_HEADER[opts.dataType]
    };
    if (((_ref2 = parsed.method) === 'GET' || _ref2 === 'DELETE') && (postdata != null ? postdata.length : void 0)) {
      sep = /\?/.test(parsed.path) ? '&' : '?';
      parsed.path += sep + postdata;
      postdata = null;
    } else {
      parsed.headers['Content-Type'] = (opts.contentType || URLENC) + '; charset=UTF-8';
      parsed.headers['Content-Length'] = postdata.length;
    }
    if (opts.headers != null) {
      _ref3 = opts.headers;
      for (k in _ref3) {
        v = _ref3[k];
        parsed.headers[k] = v;
      }
    }
    if (opts.auth != null) {
      parsed.auth = opts.auth;
    }
    return [parsed, postdata];
  };

  exports.doReq = function(opts, iter) {
    var e, handler, postdata, promise, reject, req, resolve, timeout, url, _ref1, _ref2;
    _ref1 = defer(), promise = _ref1.promise, resolve = _ref1.resolve, reject = _ref1.reject;
    promise.then(null, opts.error);
    try {
      _ref2 = parseOptions(opts), url = _ref2[0], postdata = _ref2[1];
      handler = (iter ? streaming : blocking)(opts, resolve, reject);
      req = http.request(url, handler);
      req.on('error', function(err) {
        return reject(new Error("Error: " + url.method + " " + opts.url + ": " + err));
      });
      if (postdata != null) {
        req.write(postdata);
      }
      req.end();
      timeout = opts.timeout;
      if (timeout > 0) {
        rejectAfter(timeout, reject, promise);
      }
    } catch (_error) {
      e = _error;
      reject(e);
    }
    return promise;
  };

}).call(this);

},{"./constants":1,"./util":15,"./version":16,"JSONStream":18,"http":50,"url":47}],4:[function(_dereq_,module,exports){
(function() {
  var CategoryResults, IDResolutionJob, IdResults, ONE_MINUTE, concatMap, defer, difference, fold, funcutils, get, id, intermine, uniqBy, withCB,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  funcutils = _dereq_('./util');

  intermine = exports;

  uniqBy = funcutils.uniqBy, difference = funcutils.difference, defer = funcutils.defer, withCB = funcutils.withCB, id = funcutils.id, get = funcutils.get, fold = funcutils.fold, concatMap = funcutils.concatMap;

  ONE_MINUTE = 60 * 1000;

  CategoryResults = (function() {
    var getIssueMatches;

    function CategoryResults(results) {
      var k, v;
      for (k in results) {
        if (!__hasProp.call(results, k)) continue;
        v = results[k];
        this[k] = v;
      }
    }

    CategoryResults.prototype.getStats = function(type) {
      if (type != null) {
        return this.stats[type];
      } else {
        return this.stats;
      }
    };

    getIssueMatches = concatMap(get('matches'));

    CategoryResults.prototype.getMatches = function(k) {
      var _ref;
      if (k === 'MATCH') {
        return this.matches[k];
      } else {
        return (_ref = getIssueMatches(this.matches[k])) != null ? _ref : [];
      }
    };

    CategoryResults.prototype.getMatchIds = function(k) {
      if (k != null) {
        return this.getMatches(k).map(get('id'));
      } else {
        return this.allMatchIds();
      }
    };

    CategoryResults.prototype.goodMatchIds = function() {
      return this.getMatchIds('MATCH');
    };

    CategoryResults.prototype.allMatchIds = function() {
      var combineIds;
      combineIds = fold((function(_this) {
        return function(res, issueSet) {
          return res.concat(_this.getMatchIds(issueSet));
        };
      })(this));
      return combineIds(this.goodMatchIds(), ['DUPLICATE', 'WILDCARD', 'TYPE_CONVERTED', 'OTHER']);
    };

    return CategoryResults;

  })();

  IdResults = (function() {
    var flatten, getReasons, isGood, unique;

    unique = uniqBy(id);

    flatten = concatMap(id);

    getReasons = function(match) {
      var k, vals;
      return flatten((function() {
        var _ref, _results;
        _ref = match.identifiers;
        _results = [];
        for (k in _ref) {
          vals = _ref[k];
          _results.push(vals);
        }
        return _results;
      })());
    };

    isGood = function(match, k) {
      return (k == null) || __indexOf.call(getReasons(match), k) >= 0;
    };

    function IdResults(results) {
      var k, v;
      for (k in results) {
        if (!__hasProp.call(results, k)) continue;
        v = results[k];
        this[k] = v;
      }
    }

    IdResults.prototype.getStats = function(type) {
      switch (type) {
        case 'objects':
          return this.getObjectStats();
        case 'identifiers':
          return this.getIdentifierStats();
        default:
          return {
            objects: this.getObjectStats(),
            identifiers: this.getIdentifierStats()
          };
      }
    };

    IdResults.prototype.getIdentifierStats = function() {
      var all, allIdents, issues, matchIdents, matches, toIdents;
      toIdents = function(ms) {
        var ident, match;
        return unique(flatten((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = ms.length; _i < _len; _i++) {
            match = ms[_i];
            _results.push((function() {
              var _results1;
              _results1 = [];
              for (ident in match != null ? match.identifiers : void 0) {
                _results1.push(ident);
              }
              return _results1;
            })());
          }
          return _results;
        })()));
      };
      matchIdents = toIdents(this.getMatches('MATCH'));
      allIdents = toIdents(this.getMatches());
      matches = matchIdents.length;
      all = allIdents.length;
      issues = (difference(allIdents, matchIdents)).length;
      return {
        matches: matches,
        all: all,
        issues: issues
      };
    };

    IdResults.prototype.getObjectStats = function() {
      var all, issues, match, matches;
      matches = this.goodMatchIds().length;
      all = this.allMatchIds().length;
      issues = ((function() {
        var _results;
        _results = [];
        for (id in this) {
          if (!__hasProp.call(this, id)) continue;
          match = this[id];
          if (__indexOf.call(getReasons(match), 'MATCH') < 0) {
            _results.push(id);
          }
        }
        return _results;
      }).call(this)).length;
      return {
        matches: matches,
        all: all,
        issues: issues
      };
    };

    IdResults.prototype.getMatches = function(k) {
      var match, _results;
      _results = [];
      for (id in this) {
        if (!__hasProp.call(this, id)) continue;
        match = this[id];
        if (isGood(match, k)) {
          _results.push(match);
        }
      }
      return _results;
    };

    IdResults.prototype.getMatchIds = function(k) {
      var match, _results;
      _results = [];
      for (id in this) {
        if (!__hasProp.call(this, id)) continue;
        match = this[id];
        if (isGood(match, k)) {
          _results.push(id);
        }
      }
      return _results;
    };

    IdResults.prototype.goodMatchIds = function() {
      return this.getMatchIds('MATCH');
    };

    IdResults.prototype.allMatchIds = function() {
      return this.getMatchIds();
    };

    return IdResults;

  })();

  IDResolutionJob = (function() {
    function IDResolutionJob(uid, service) {
      this.uid = uid;
      this.service = service;
      this.del = __bind(this.del, this);
      this.fetchResults = __bind(this.fetchResults, this);
      this.fetchErrorMessage = __bind(this.fetchErrorMessage, this);
      this.fetchStatus = __bind(this.fetchStatus, this);
    }

    IDResolutionJob.prototype.fetchStatus = function(cb) {
      return withCB(cb, this.service.get("ids/" + this.uid + "/status").then(get('status')));
    };

    IDResolutionJob.prototype.fetchErrorMessage = function(cb) {
      return withCB(cb, this.service.get("ids/" + this.uid + "/status").then(get('message')));
    };

    IDResolutionJob.prototype.fetchResults = function(cb) {
      var gettingRes, gettingVer;
      gettingRes = this.service.get("ids/" + this.uid + "/result").then(get('results'));
      gettingVer = this.service.fetchVersion();
      return gettingVer.then(function(v) {
        return gettingRes.then(function(results) {
          if (v >= 16) {
            return new CategoryResults(results);
          } else {
            return new IdResults(results);
          }
        });
      });
    };

    IDResolutionJob.prototype.del = function(cb) {
      return withCB(cb, this.service.makeRequest('DELETE', "ids/" + this.uid));
    };

    IDResolutionJob.prototype.decay = 50;

    IDResolutionJob.prototype.poll = function(onSuccess, onError, onProgress) {
      var backOff, notify, promise, reject, resolve, resp, _ref;
      _ref = defer(), promise = _ref.promise, resolve = _ref.resolve, reject = _ref.reject;
      promise.then(onSuccess, onError);
      notify = onProgress != null ? onProgress : (function() {});
      resp = this.fetchStatus();
      resp.then(null, reject);
      backOff = this.decay;
      this.decay = Math.min(ONE_MINUTE, backOff * 1.25);
      resp.then((function(_this) {
        return function(status) {
          notify(status);
          switch (status) {
            case 'SUCCESS':
              return _this.fetchResults().then(resolve, reject);
            case 'ERROR':
              return _this.fetchErrorMessage().then(reject, reject);
            default:
              return setTimeout((function() {
                return _this.poll(resolve, reject, notify);
              }), backOff);
          }
        };
      })(this));
      return promise;
    };

    return IDResolutionJob;

  })();

  IDResolutionJob.prototype.wait = IDResolutionJob.prototype.poll;

  IDResolutionJob.create = function(service) {
    return function(uid) {
      return new IDResolutionJob(uid, service);
    };
  };

  intermine.IDResolutionJob = IDResolutionJob;

  intermine.CategoryResults = CategoryResults;

  intermine.IdResults = IdResults;

}).call(this);

},{"./util":15}],5:[function(_dereq_,module,exports){
(function() {
  var INVITES, List, REQUIRES_VERSION, SHARES, TAGS_PATH, dejoin, get, getFolderName, intermine, invoke, isFolder, merge, set, utils, withCB,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  utils = _dereq_('./util');

  intermine = exports;

  merge = utils.merge, withCB = utils.withCB, get = utils.get, invoke = utils.invoke, REQUIRES_VERSION = utils.REQUIRES_VERSION, set = utils.set, dejoin = utils.dejoin;

  TAGS_PATH = "list/tags";

  SHARES = "lists/shares";

  INVITES = 'lists/invitations';

  isFolder = function(t) {
    return t.substr(0, t.indexOf(':')) === '__folder__';
  };

  getFolderName = function(t) {
    return t.substr(t.indexOf(':') + 1);
  };

  List = (function() {
    var getTags;

    function List(properties, service) {
      var k, v;
      this.service = service;
      this._updateTags = __bind(this._updateTags, this);
      this.hasTag = __bind(this.hasTag, this);
      for (k in properties) {
        if (!__hasProp.call(properties, k)) continue;
        v = properties[k];
        this[k] = v;
      }
      this.dateCreated = (this.dateCreated != null) ? new Date(this.dateCreated) : null;
      this.folders = this.tags.filter(isFolder).map(getFolderName);
    }

    List.prototype.hasTag = function(t) {
      return __indexOf.call(this.tags, t) >= 0;
    };

    List.prototype.query = function(view) {
      if (view == null) {
        view = ['*'];
      }
      return this.service.query({
        select: view,
        from: this.type,
        where: [[this.type, 'IN', this.name]]
      });
    };

    List.prototype.del = function(cb) {
      return this.service.makeRequest('DELETE', 'lists', {
        name: this.name
      }, cb);
    };

    getTags = function(_arg) {
      var tags;
      tags = _arg.tags;
      return tags;
    };

    List.prototype._updateTags = function(err, tags) {
      if (err != null) {
        return;
      }
      this.tags = tags.slice();
      return this.folders = this.tags.filter(isFolder).map(getFolderName);
    };

    List.prototype.fetchTags = function(cb) {
      return withCB(this._updateTags, cb, this.service.makeRequest('GET', 'list/tags', {
        name: this.name
      }).then(getTags));
    };

    List.prototype.addTags = function(tags, cb) {
      var req;
      req = {
        name: this.name,
        tags: tags
      };
      return withCB(this._updateTags, cb, this.service.makeRequest('POST', 'list/tags', req).then(getTags));
    };

    List.prototype.removeTags = function(tags, cb) {
      var req;
      req = {
        name: this.name,
        tags: tags
      };
      return withCB(this._updateTags, cb, this.service.makeRequest('DELETE', 'list/tags', req).then(getTags));
    };

    List.prototype.contents = function(cb) {
      return withCB(cb, this.query().then(dejoin).then(invoke('records')));
    };

    List.prototype.rename = function(newName, cb) {
      var promise;
      promise = this.service.post('lists/rename', {
        oldname: this.name,
        newname: newName
      }).then(get('listName')).then((function(_this) {
        return function(n) {
          return _this.name = n;
        };
      })(this)).then(this.service.fetchList);
      return withCB(cb, promise);
    };

    List.prototype.copy = function(opts, cb) {
      var baseName, name, query, tags, _ref, _ref1, _ref2;
      if (opts == null) {
        opts = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (arguments.length === 1 && utils.isFunction(opts)) {
        _ref = [{}, opts], opts = _ref[0], cb = _ref[1];
      }
      if (typeof opts === 'string') {
        opts = {
          name: opts
        };
      }
      name = baseName = (_ref1 = opts.name) != null ? _ref1 : "" + this.name + "_copy";
      tags = this.tags.concat((_ref2 = opts.tags) != null ? _ref2 : []);
      query = this.query(['id']);
      return withCB(cb, this.service.fetchLists().then(invoke('map', get('name'))).then((function(_this) {
        return function(names) {
          var c;
          c = 1;
          while (__indexOf.call(names, name) >= 0) {
            name = "" + baseName + "-" + (c++);
          }
          return query.then(invoke('saveAsList', {
            name: name,
            tags: tags,
            description: _this.description
          }));
        };
      })(this)));
    };

    List.prototype.enrichment = function(opts, cb) {
      return this.service.enrichment(merge({
        list: this.name
      }, opts), cb);
    };

    List.prototype.shareWithUser = function(recipient, cb) {
      return withCB(cb, this.service.post(SHARES, {
        'list': this.name,
        'with': recipient
      }));
    };

    List.prototype.inviteUserToShare = function(recipient, notify, cb) {
      if (notify == null) {
        notify = true;
      }
      if (cb == null) {
        cb = (function() {});
      }
      return withCB(cb, this.service.post(INVITES, {
        list: this.name,
        to: recipient,
        notify: !!notify
      }));
    };

    return List;

  })();

  intermine.List = List;

}).call(this);

},{"./util":15}],6:[function(_dereq_,module,exports){
(function() {
  var JAVA_LANG_OBJ, Model, PathInfo, Table, error, find, flatten, intermine, omap, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Table = _dereq_('./table').Table;

  PathInfo = _dereq_('./path').PathInfo;

  _ref = _dereq_('./util'), flatten = _ref.flatten, find = _ref.find, error = _ref.error, omap = _ref.omap;

  intermine = exports;

  JAVA_LANG_OBJ = new Table({
    name: 'Object',
    tags: [],
    displayName: 'Object',
    attributes: {},
    references: {},
    collections: {}
  });

  Model = (function() {
    function Model(_arg) {
      var classes, liftToTable;
      this.name = _arg.name, classes = _arg.classes;
      this.findCommonType = __bind(this.findCommonType, this);
      this.findSharedAncestor = __bind(this.findSharedAncestor, this);
      this.getAncestorsOf = __bind(this.getAncestorsOf, this);
      this.getSubclassesOf = __bind(this.getSubclassesOf, this);
      this.getPathInfo = __bind(this.getPathInfo, this);
      liftToTable = omap((function(_this) {
        return function(k, v) {
          return [k, new Table(v, _this)];
        };
      })(this));
      this.classes = liftToTable(classes);
      this.classes['java.lang.Object'] = JAVA_LANG_OBJ;
    }

    Model.prototype.getPathInfo = function(path, subcls) {
      return PathInfo.parse(this, path, subcls);
    };

    Model.prototype.getSubclassesOf = function(cls) {
      var cd, clazz, ret, _, _ref1, _ref2;
      clazz = cls && cls.name ? cls : this.classes[cls];
      if (clazz == null) {
        throw new Error("" + cls + " is not a table");
      }
      ret = [clazz.name];
      _ref1 = this.classes;
      for (_ in _ref1) {
        cd = _ref1[_];
        if (_ref2 = clazz.name, __indexOf.call(cd.parents(), _ref2) >= 0) {
          ret = ret.concat(this.getSubclassesOf(cd));
        }
      }
      return ret;
    };

    Model.prototype.getAncestorsOf = function(cls) {
      var clazz, parents;
      clazz = cls && cls.name ? cls : this.classes[cls];
      if (clazz == null) {
        throw new Error("" + cls + " is not a table");
      }
      parents = clazz.parents();
      return parents.filter((function(_this) {
        return function(p) {
          return _this.classes[p];
        };
      })(this)).reduce(((function(_this) {
        return function(as, p) {
          return as.concat(_this.getAncestorsOf(p));
        };
      })(this)), parents);
    };

    Model.prototype.findSharedAncestor = function(classA, classB) {
      var a_ancestry, b_ancestry, firstCommon;
      if (classB === null || classA === null) {
        return null;
      }
      if (classA === classB) {
        return classA;
      }
      a_ancestry = this.getAncestorsOf(classA);
      if (__indexOf.call(a_ancestry, classB) >= 0) {
        return classB;
      }
      b_ancestry = this.getAncestorsOf(classB);
      if (__indexOf.call(b_ancestry, classA) >= 0) {
        return classA;
      }
      firstCommon = find(a_ancestry, function(a) {
        return __indexOf.call(b_ancestry, a) >= 0;
      });
      return firstCommon;
    };

    Model.prototype.findCommonType = function(xs) {
      if (xs == null) {
        xs = [];
      }
      return xs.reduce(this.findSharedAncestor);
    };

    return Model;

  })();

  Model.prototype.makePath = Model.prototype.getPathInfo;

  Model.prototype.findCommonTypeOfMultipleClasses = Model.prototype.findCommonType;

  Model.load = function(data) {
    var e;
    try {
      return new Model(data);
    } catch (_error) {
      e = _error;
      throw new Error("Error loading model: " + e);
    }
  };

  Model.INTEGRAL_TYPES = ["int", "Integer", "long", "Long"];

  Model.FRACTIONAL_TYPES = ["double", "Double", "float", "Float"];

  Model.NUMERIC_TYPES = Model.INTEGRAL_TYPES.concat(Model.FRACTIONAL_TYPES);

  Model.BOOLEAN_TYPES = ["boolean", "Boolean"];

  intermine.Model = Model;

}).call(this);

},{"./path":7,"./table":13,"./util":15}],7:[function(_dereq_,module,exports){
(function() {
  var NAMES, PARSED, PathInfo, any, concatMap, copy, error, get, intermine, makeKey, set, success, utils, withCB,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  intermine = exports;

  utils = _dereq_('./util');

  withCB = utils.withCB, concatMap = utils.concatMap, get = utils.get, any = utils.any, set = utils.set, copy = utils.copy, success = utils.success, error = utils.error;

  NAMES = {};

  PARSED = {};

  makeKey = function(model, path, subclasses) {
    var k, v, _ref;
    return "" + (model != null ? model.name : void 0) + "|" + (model != null ? (_ref = model.service) != null ? _ref.root : void 0 : void 0) + "|" + path + ":" + ((function() {
      var _results;
      _results = [];
      for (k in subclasses) {
        v = subclasses[k];
        _results.push("" + k + "=" + v);
      }
      return _results;
    })());
  };

  PathInfo = (function() {
    function PathInfo(_arg) {
      var _i, _ref;
      this.root = _arg.root, this.model = _arg.model, this.descriptors = _arg.descriptors, this.subclasses = _arg.subclasses, this.displayName = _arg.displayName, this.ident = _arg.ident;
      this.allDescriptors = __bind(this.allDescriptors, this);
      this.getChildNodes = __bind(this.getChildNodes, this);
      this.getDisplayName = __bind(this.getDisplayName, this);
      this.isa = __bind(this.isa, this);
      this.append = __bind(this.append, this);
      this.getParent = __bind(this.getParent, this);
      this.getEndClass = __bind(this.getEndClass, this);
      this.containsCollection = __bind(this.containsCollection, this);
      this.isCollection = __bind(this.isCollection, this);
      this.isReverseReference = __bind(this.isReverseReference, this);
      this.isReference = __bind(this.isReference, this);
      this.isClass = __bind(this.isClass, this);
      this.isAttribute = __bind(this.isAttribute, this);
      this.isRoot = __bind(this.isRoot, this);
      _ref = this.descriptors, this.mid = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), this.end = _ref[_i++];
      if (this.ident == null) {
        this.ident = makeKey(this.model, this, this.subclasses);
      }
    }

    PathInfo.prototype.isRoot = function() {
      return this.descriptors.length === 0;
    };

    PathInfo.prototype.isAttribute = function() {
      return (this.end != null) && !this.isReference();
    };

    PathInfo.prototype.isClass = function() {
      return this.isRoot() || this.isReference();
    };

    PathInfo.prototype.isReference = function() {
      var _ref;
      return ((_ref = this.end) != null ? _ref.referencedType : void 0) != null;
    };

    PathInfo.prototype.isReverseReference = function() {
      var gp, p, referencedType, reverseReference, _ref;
      if (this.isReference() && (this.mid.length > 0)) {
        _ref = this.end, reverseReference = _ref.reverseReference, referencedType = _ref.referencedType;
        p = this.getParent();
        gp = p.getParent();
        return (referencedType != null) && (gp.isa(referencedType)) && (p.end.name === reverseReference);
      }
      return false;
    };

    PathInfo.prototype.isCollection = function() {
      var _ref, _ref1;
      return (_ref = (_ref1 = this.end) != null ? _ref1.isCollection : void 0) != null ? _ref : false;
    };

    PathInfo.prototype.containsCollection = function() {
      return any(this.descriptors, function(x) {
        return x.isCollection;
      });
    };

    PathInfo.prototype.getEndClass = function() {
      var _ref;
      return this.model.classes[this.subclasses[this.toString()] || ((_ref = this.end) != null ? _ref.referencedType : void 0)] || this.root;
    };

    PathInfo.prototype.getParent = function() {
      var data;
      if (this.isRoot()) {
        throw new Error("Root paths do not have parents");
      }
      data = {
        root: this.root,
        model: this.model,
        descriptors: this.mid.slice(),
        subclasses: this.subclasses
      };
      return new PathInfo(data);
    };

    PathInfo.prototype.append = function(attr) {
      var data, fld;
      if (this.isAttribute()) {
        throw new Error("" + this + " is an attribute.");
      }
      fld = typeof attr === 'string' ? this.getType().fields[attr] : attr;
      if (fld == null) {
        throw new Error("" + attr + " is not a field of " + (this.getType()));
      }
      data = {
        root: this.root,
        model: this.model,
        descriptors: this.descriptors.concat([fld]),
        subclasses: this.subclasses
      };
      return new PathInfo(data);
    };

    PathInfo.prototype.isa = function(clazz) {
      var name, type;
      if (clazz == null) {
        return false;
      }
      if (this.isAttribute()) {
        return this.getType() === clazz;
      } else {
        name = clazz.name ? clazz.name : '' + clazz;
        type = this.getType();
        return (name === type.name) || (__indexOf.call(this.model.getAncestorsOf(type), name) >= 0);
      }
    };

    PathInfo.prototype.getDisplayName = function(cb) {
      var cached, custom, params, path;
      if (custom = this.displayName) {
        return success(custom);
      }
      if (this.namePromise == null) {
        this.namePromise = (cached = NAMES[this.ident]) ? success(cached) : this.isRoot() && this.root.displayName ? success(this.root.displayName) : this.model.service == null ? error("No service") : (path = 'model' + (concatMap(function(d) {
          return '/' + d.name;
        }))(this.allDescriptors()), params = (set({
          format: 'json'
        }))(copy(this.subclasses)), this.model.service.get(path, params).then(get('display')).then((function(_this) {
          return function(n) {
            var _name;
            return NAMES[_name = _this.ident] != null ? NAMES[_name] : NAMES[_name] = n;
          };
        })(this)));
      }
      return withCB(cb, this.namePromise);
    };

    PathInfo.prototype.getChildNodes = function() {
      var fld, name, _ref, _ref1, _results;
      _ref1 = ((_ref = this.getEndClass()) != null ? _ref.fields : void 0) || {};
      _results = [];
      for (name in _ref1) {
        fld = _ref1[name];
        _results.push(this.append(fld));
      }
      return _results;
    };

    PathInfo.prototype.allDescriptors = function() {
      return [this.root].concat(this.descriptors);
    };

    PathInfo.prototype.toString = function() {
      return this.allDescriptors().map(get('name')).join('.');
    };

    PathInfo.prototype.equals = function(other) {
      return this === other || (this.ident && (other != null ? other.ident : void 0) === this.ident);
    };

    PathInfo.prototype.getType = function() {
      var _ref, _ref1;
      return ((_ref = this.end) != null ? (_ref1 = _ref.type) != null ? _ref1.replace(/java\.lang\./, '') : void 0 : void 0) || this.getEndClass();
    };

    return PathInfo;

  })();

  PathInfo.prototype.toPathString = PathInfo.prototype.toString;

  PathInfo.parse = function(model, path, subclasses) {
    var cached, cd, descriptors, fld, ident, keyPath, part, parts, root;
    if (subclasses == null) {
      subclasses = {};
    }
    ident = makeKey(model, path, subclasses);
    if (cached = PARSED[ident]) {
      return cached;
    }
    parts = (path + '').split('.');
    root = cd = model.classes[parts.shift()];
    keyPath = root.name;
    descriptors = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = parts.length; _i < _len; _i++) {
        part = parts[_i];
        fld = (cd != null ? cd.fields[part] : void 0) || ((_ref = (cd = model.classes[subclasses[keyPath]])) != null ? _ref.fields[part] : void 0);
        if (!fld) {
          throw new Error("Could not find " + part + " in " + cd + " when parsing " + path);
        }
        keyPath += "." + part;
        cd = model.classes[fld.type || fld.referencedType];
        _results.push(fld);
      }
      return _results;
    })();
    return PARSED[ident] = new PathInfo({
      root: root,
      model: model,
      descriptors: descriptors,
      subclasses: subclasses,
      ident: ident
    });
  };

  PathInfo.flushCache = function() {
    PARSED = {};
    return NAMES = {};
  };

  intermine.PathInfo = PathInfo;

}).call(this);

},{"./util":15}],8:[function(_dereq_,module,exports){
(function() {
  var Promise;

  Promise = _dereq_('es6-promise').Promise;

  module.exports = Promise;

}).call(this);

},{"es6-promise":22}],9:[function(_dereq_,module,exports){
(function() {
  var BASIC_ATTRS, CODES, Events, LIST_PIPE, Query, REQUIRES_VERSION, RESULTS_METHODS, SIMPLE_ATTRS, bioUriArgs, conAttrs, conStr, conToJSON, conValStr, concatMap, copyCon, decapitate, didntRemove, f, filter, fold, get, get_canonical_op, headLess, id, idConStr, intermine, interpretConArray, interpretConstraint, invoke, merge, mth, multiConStr, noUndefVals, noValueConStr, partition, removeIrrelevantSortOrders, simpleConStr, stringToSortOrder, stringifySortOrder, toQueryString, typeConStr, union, utils, withCB, _fn, _get_data_fetcher, _i, _j, _len, _len1, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  Events = _dereq_('backbone-events-standalone');

  intermine = exports;

  intermine.xml = _dereq_('./xml');

  utils = _dereq_('./util');

  REQUIRES_VERSION = utils.REQUIRES_VERSION, withCB = utils.withCB, merge = utils.merge, filter = utils.filter, partition = utils.partition, fold = utils.fold, concatMap = utils.concatMap, id = utils.id, get = utils.get, invoke = utils.invoke;

  toQueryString = utils.querystring;

  get_canonical_op = function(orig) {
    var canonical;
    canonical = (orig != null ? orig.toLowerCase : void 0) != null ? Query.OP_DICT[orig.toLowerCase()] : null;
    if (!canonical) {
      throw new Error("Illegal constraint operator: " + orig);
    }
    return canonical;
  };

  BASIC_ATTRS = ['path', 'op', 'code'];

  SIMPLE_ATTRS = BASIC_ATTRS.concat(['value', 'extraValue']);

  RESULTS_METHODS = ['rowByRow', 'eachRow', 'recordByRecord', 'eachRecord', 'records', 'rows', 'table', 'tableRows', 'values'];

  LIST_PIPE = function(service) {
    return utils.compose(service.fetchList, get('listName'));
  };

  CODES = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];

  decapitate = function(x) {
    if (x == null) {
      x = '';
    }
    return x.substr(x.indexOf('.'));
  };

  conValStr = function(v) {
    if (v != null) {
      return "<value>" + (utils.escape(v)) + "</value>";
    } else {
      return "<nullValue/>";
    }
  };

  conAttrs = function(c, names) {
    var k, v;
    return ((function() {
      var _results;
      _results = [];
      for (k in c) {
        v = c[k];
        if ((__indexOf.call(names, k) >= 0)) {
          _results.push("" + k + "=\"" + (utils.escape(v)) + "\" ");
        }
      }
      return _results;
    })()).join('');
  };

  noValueConStr = function(c) {
    return "<constraint " + (conAttrs(c, BASIC_ATTRS)) + "/>";
  };

  typeConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'type'])) + "/>";
  };

  simpleConStr = function(c) {
    return "<constraint " + (conAttrs(c, SIMPLE_ATTRS)) + "/>";
  };

  multiConStr = function(c) {
    return "<constraint " + (conAttrs(c, BASIC_ATTRS)) + ">" + (concatMap(conValStr)(c.values)) + "</constraint>";
  };

  idConStr = function(c) {
    return "<constraint " + (conAttrs(c, BASIC_ATTRS)) + "ids=\"" + (c.ids.join(',')) + "\"/>";
  };

  conStr = function(c) {
    var _ref;
    if (c.values != null) {
      return multiConStr(c);
    } else if (c.ids != null) {
      return idConStr(c);
    } else if (c.op == null) {
      return typeConStr(c);
    } else if (_ref = c.op, __indexOf.call(Query.NULL_OPS, _ref) >= 0) {
      return noValueConStr(c);
    } else {
      return simpleConStr(c);
    }
  };

  headLess = function(path) {
    return path.replace(/^[^\.]+\./, '');
  };

  copyCon = function(con) {
    var code, editable, extraValue, ids, op, path, switchable, switched, type, value, values;
    path = con.path, type = con.type, op = con.op, value = con.value, values = con.values, extraValue = con.extraValue, ids = con.ids, code = con.code, editable = con.editable, switched = con.switched, switchable = con.switchable;
    ids = ids != null ? ids.slice() : void 0;
    values = values != null ? values.slice() : void 0;
    return noUndefVals({
      path: path,
      type: type,
      op: op,
      value: value,
      values: values,
      extraValue: extraValue,
      ids: ids,
      code: code,
      editable: editable,
      switched: switched,
      switchable: switchable
    });
  };

  conToJSON = function(con) {
    var copy;
    copy = copyCon(con);
    copy.path = headLess(copy.path);
    return copy;
  };

  noUndefVals = function(x) {
    var k, v;
    for (k in x) {
      v = x[k];
      if (v == null) {
        delete x[k];
      }
    }
    return x;
  };

  didntRemove = function(orig, reduced) {
    return "Did not remove a single constraint. original = " + orig + ", reduced = " + reduced;
  };

  interpretConstraint = function(path, con) {
    var constraint, k, keys, v, x, _ref, _ref1;
    constraint = {
      path: path
    };
    if (con === null) {
      constraint.op = 'IS NULL';
    } else if (utils.isArray(con)) {
      constraint.op = 'ONE OF';
      constraint.values = con;
    } else if ((_ref = typeof con) === 'string' || _ref === 'number' || _ref === 'boolean') {
      if (_ref1 = typeof con.toUpperCase === "function" ? con.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref1) >= 0) {
        constraint.op = con;
      } else {
        constraint.op = '=';
        constraint.value = con;
      }
    } else {
      keys = (function() {
        var _results;
        _results = [];
        for (k in con) {
          x = con[k];
          _results.push(k);
        }
        return _results;
      })();
      if (__indexOf.call(keys, 'isa') >= 0) {
        if (utils.isArray(con.isa)) {
          constraint.op = k;
          constraint.values = con.isa;
        } else {
          constraint.type = con.isa;
        }
      } else {
        if (__indexOf.call(keys, 'extraValue') >= 0) {
          constraint.extraValue = con.extraValue;
        }
        for (k in con) {
          v = con[k];
          if (!(k !== 'extraValue')) {
            continue;
          }
          constraint.op = k;
          if (utils.isArray(v)) {
            constraint.values = v;
          } else {
            constraint.value = v;
          }
        }
      }
    }
    return constraint;
  };

  interpretConArray = function(conArgs) {
    var a0, constraint, v, _ref;
    conArgs = conArgs.slice();
    constraint = {
      path: conArgs.shift()
    };
    if (conArgs.length === 1) {
      a0 = conArgs[0];
      if (_ref = typeof a0.toUpperCase === "function" ? a0.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref) >= 0) {
        constraint.op = a0;
      } else {
        constraint.type = a0;
      }
    } else if (conArgs.length >= 2) {
      constraint.op = conArgs[0];
      v = conArgs[1];
      if (utils.isArray(v)) {
        constraint.values = v;
      } else {
        constraint.value = v;
      }
      if (conArgs.length === 3) {
        constraint.extraValue = conArgs[2];
      }
    }
    return constraint;
  };

  stringifySortOrder = function(sortOrder) {
    var oe;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sortOrder.length; _i < _len; _i++) {
        oe = sortOrder[_i];
        _results.push("" + oe.path + " " + oe.direction);
      }
      return _results;
    })()).join(' ');
  };

  stringToSortOrder = function(str) {
    var i, parts, pathIndices, x, _i, _len, _results;
    if (str == null) {
      return [];
    }
    parts = str.split(/\s+/);
    pathIndices = (function() {
      var _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = parts.length / 2; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        _results.push(x * 2);
      }
      return _results;
    })();
    _results = [];
    for (_i = 0, _len = pathIndices.length; _i < _len; _i++) {
      i = pathIndices[_i];
      _results.push([parts[i], parts[i + 1]]);
    }
    return _results;
  };

  removeIrrelevantSortOrders = function() {
    var oe, oldOrder;
    oldOrder = this.sortOrder;
    this.sortOrder = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = oldOrder.length; _i < _len; _i++) {
        oe = oldOrder[_i];
        if (this.isRelevant(oe.path)) {
          _results.push(oe);
        }
      }
      return _results;
    }).call(this);
    if (oldOrder.length !== this.sortOrder.length) {
      return this.trigger('change:sortorder change:orderby', this.sortOrder.slice());
    }
  };

  Query = (function() {
    var addPI, cAttrs, kids, parseSummary, qAttrs, scFold, toAttrPairs, toPathAndType, xmlAttr;

    Query.JOIN_STYLES = ['INNER', 'OUTER'];

    Query.BIO_FORMATS = ['gff3', 'fasta', 'bed'];

    Query.NULL_OPS = ['IS NULL', 'IS NOT NULL'];

    Query.ATTRIBUTE_VALUE_OPS = ["=", "!=", ">", ">=", "<", "<=", "CONTAINS", "LIKE", "NOT LIKE"];

    Query.MULTIVALUE_OPS = ['ONE OF', 'NONE OF'];

    Query.RANGE_OPS = ['OVERLAPS', 'DOES NOT OVERLAP', 'OUTSIDE', 'WITHIN', 'CONTAINS', 'DOES NOT CONTAIN'];

    Query.TERNARY_OPS = ['LOOKUP'];

    Query.LOOP_OPS = ['=', '!='];

    Query.LIST_OPS = ['IN', 'NOT IN'];

    Query.OP_DICT = {
      '=': '=',
      '==': '==',
      'eq': '=',
      'eqq': '==',
      '!=': '!=',
      'ne': '!=',
      '>': '>',
      'gt': '>',
      '>=': '>=',
      'ge': '>=',
      '<': '<',
      'lt': '<',
      '<=': '<=',
      'le': '<=',
      'contains': 'CONTAINS',
      'CONTAINS': 'CONTAINS',
      'does not contain': 'DOES NOT CONTAIN',
      'DOES NOT CONTAIN': 'DOES NOT CONTAIN',
      'like': 'LIKE',
      'LIKE': 'LIKE',
      'not like': 'NOT LIKE',
      'NOT LIKE': 'NOT LIKE',
      'lookup': 'LOOKUP',
      'IS NULL': 'IS NULL',
      'is null': 'IS NULL',
      'IS NOT NULL': 'IS NOT NULL',
      'is not null': 'IS NOT NULL',
      'ONE OF': 'ONE OF',
      'one of': 'ONE OF',
      'NONE OF': 'NONE OF',
      'none of': 'NONE OF',
      'in': 'IN',
      'not in': 'NOT IN',
      'IN': 'IN',
      'NOT IN': 'NOT IN',
      'WITHIN': 'WITHIN',
      'within': 'WITHIN',
      'OVERLAPS': 'OVERLAPS',
      'overlaps': 'OVERLAPS',
      'DOES NOT OVERLAP': 'DOES NOT OVERLAP',
      'does not overlap': 'DOES NOT OVERLAP',
      'OUTSIDE': 'OUTSIDE',
      'outside': 'OUTSIDE',
      'ISA': 'ISA',
      'isa': 'ISA'
    };

    qAttrs = ['name', 'view', 'sortOrder', 'constraintLogic', 'title', 'description', 'comment'];

    cAttrs = ['path', 'type', 'op', 'code', 'value', 'ids'];

    toAttrPairs = function(el, attrs) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = attrs.length; _i < _len; _i++) {
        x = attrs[_i];
        if (el.hasAttribute(x)) {
          _results.push([x, el.getAttribute(x)]);
        }
      }
      return _results;
    };

    kids = function(el, name) {
      var kid, _i, _len, _ref, _results;
      _ref = el.getElementsByTagName(name);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        kid = _ref[_i];
        _results.push(kid);
      }
      return _results;
    };

    xmlAttr = function(name) {
      return function(el) {
        return el.getAttribute(name);
      };
    };

    Query.fromXML = function(xml) {
      var con, dom, j, pathOf, q, query, styleOf;
      dom = intermine.xml.parse(xml);
      query = kids(dom, 'query')[0] || kids(dom, 'template')[0];
      if (!query) {
        throw new Error("no query in xml");
      }
      pathOf = xmlAttr('path');
      styleOf = xmlAttr('style');
      q = utils.pairsToObj(toAttrPairs(query, qAttrs));
      q.view = q.view.split(/\s+/);
      q.sortOrder = stringToSortOrder(q.sortOrder);
      q.joins = (function() {
        var _i, _len, _ref, _results;
        _ref = kids(query, 'join');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          j = _ref[_i];
          if (styleOf(j) === 'OUTER') {
            _results.push(pathOf(j));
          }
        }
        return _results;
      })();
      q.constraints = (function() {
        var _i, _len, _ref, _results;
        _ref = kids(query, 'constraint');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          con = _ref[_i];
          _results.push((function(con) {
            var c, tn, v, values, x;
            c = utils.pairsToObj(toAttrPairs(con, cAttrs));
            if (c.ids != null) {
              c.ids = (function() {
                var _j, _len1, _ref1, _results1;
                _ref1 = c.ids.split(',');
                _results1 = [];
                for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                  x = _ref1[_j];
                  _results1.push(parseInt(x, 10));
                }
                return _results1;
              })();
            }
            values = kids(con, 'value');
            if (values.length) {
              c.values = (function() {
                var _j, _len1, _results1;
                _results1 = [];
                for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
                  v = values[_j];
                  _results1.push(((function() {
                    var _k, _len2, _ref1, _results2;
                    _ref1 = v.childNodes;
                    _results2 = [];
                    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                      tn = _ref1[_k];
                      _results2.push(tn.data);
                    }
                    return _results2;
                  })()).join(''));
                }
                return _results1;
              })();
            }
            return c;
          })(con));
        }
        return _results;
      })();
      return q;
    };

    Query.prototype.constraints = [];

    Query.prototype.views = [];

    Query.prototype.joins = {};

    Query.prototype.constraintLogic = '';

    Query.prototype.sortOrder = '';

    Query.prototype.name = null;

    Query.prototype.title = null;

    Query.prototype.comment = null;

    Query.prototype.description = null;

    function Query(properties, service, _arg) {
      var model, prop, summaryFields, _i, _len, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      _ref = _arg != null ? _arg : {}, model = _ref.model, summaryFields = _ref.summaryFields;
      this.addConstraint = __bind(this.addConstraint, this);
      this.expandStar = __bind(this.expandStar, this);
      this.adjustPath = __bind(this.adjustPath, this);
      this.select = __bind(this.select, this);
      if (properties == null) {
        properties = {};
      }
      this.constraints = [];
      this.views = [];
      this.joins = {};
      this.displayNames = utils.copy((_ref1 = (_ref2 = properties.displayNames) != null ? _ref2 : properties.aliases) != null ? _ref1 : {});
      _ref3 = ['name', 'title', 'comment', 'description', 'type'];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        prop = _ref3[_i];
        if (properties[prop] != null) {
          this[prop] = properties[prop];
        }
      }
      this.service = service != null ? service : {};
      this.model = (_ref4 = model != null ? model : properties.model) != null ? _ref4 : {};
      this.summaryFields = (_ref5 = summaryFields != null ? summaryFields : properties.summaryFields) != null ? _ref5 : {};
      this.root = (_ref6 = properties.root) != null ? _ref6 : properties.from;
      this.maxRows = (_ref7 = (_ref8 = properties.size) != null ? _ref8 : properties.limit) != null ? _ref7 : properties.maxRows;
      this.start = (_ref9 = (_ref10 = properties.start) != null ? _ref10 : properties.offset) != null ? _ref9 : 0;
      this.select(properties.views || properties.view || properties.select || []);
      this.addConstraints(properties.constraints || properties.where || []);
      this.addJoins(properties.joins || properties.join || []);
      this.orderBy(properties.sortOrder || properties.orderBy || []);
      if (properties.constraintLogic != null) {
        this.constraintLogic = properties.constraintLogic;
      }
      this.on('change:views', removeIrrelevantSortOrders, this);
    }

    Query.prototype.removeFromSelect = function(unwanted) {
      var mapFn, so, uw, v;
      if (unwanted == null) {
        unwanted = [];
      }
      unwanted = utils.stringList(unwanted);
      mapFn = utils.compose(this.expandStar, this.adjustPath);
      unwanted = utils.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = unwanted.length; _i < _len; _i++) {
          uw = unwanted[_i];
          _results.push(mapFn(uw));
        }
        return _results;
      })());
      this.sortOrder = (function() {
        var _i, _len, _ref, _ref1, _results;
        _ref = this.sortOrder;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          so = _ref[_i];
          if (!(_ref1 = so.path, __indexOf.call(unwanted, _ref1) >= 0)) {
            _results.push(so);
          }
        }
        return _results;
      }).call(this);
      this.views = (function() {
        var _i, _len, _ref, _results;
        _ref = this.views;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          if (!(__indexOf.call(unwanted, v) >= 0)) {
            _results.push(v);
          }
        }
        return _results;
      }).call(this);
      this.trigger('remove:view', unwanted);
      this.trigger('change:views', this.views);
      return this.trigger('change', this.views);
    };

    Query.prototype.removeConstraint = function(con, silent) {
      var c, iscon, orig, reduced;
      if (silent == null) {
        silent = false;
      }
      orig = this.constraints;
      iscon = typeof con === 'string' ? (function(c) {
        return c.code === con;
      }) : (function(c) {
        var _ref, _ref1;
        return (c.path === con.path) && (c.op === con.op) && (c.value === con.value) && (c.extraValue === con.extraValue) && (con.type === c.type) && (((_ref = c.values) != null ? _ref.join('%%') : void 0) === ((_ref1 = con.values) != null ? _ref1.join('%%') : void 0));
      });
      reduced = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = orig.length; _i < _len; _i++) {
          c = orig[_i];
          if (!iscon(c)) {
            _results.push(c);
          }
        }
        return _results;
      })();
      if (reduced.length !== orig.length - 1) {
        throw new Error(didntRemove(orig, reduced));
      }
      this.constraints = reduced;
      if (!silent) {
        this.trigger('change:constraints');
        this.trigger('change');
        return this.trigger('removed:constraint', utils.find(orig, iscon));
      }
    };

    Query.prototype.addToSelect = function(views, opts) {
      var dups, mapFn, p, toAdd, v, x, _ref, _ref1;
      if (views == null) {
        views = [];
      }
      if (opts == null) {
        opts = {};
      }
      views = utils.stringList(views);
      mapFn = utils.compose(this.expandStar, this.adjustPath);
      toAdd = utils.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = views.length; _i < _len; _i++) {
          v = views[_i];
          _results.push(mapFn(v));
        }
        return _results;
      })());
      dups = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = toAdd.length; _i < _len; _i++) {
          p = toAdd[_i];
          if (__indexOf.call(this.views, p) >= 0) {
            _results.push(p);
          }
        }
        return _results;
      }).call(this);
      if (dups.length) {
        throw new Error("" + dups + " already in the select list");
      }
      dups = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = toAdd.length; _i < _len; _i++) {
          p = toAdd[_i];
          if (((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = toAdd.length; _j < _len1; _j++) {
              x = toAdd[_j];
              if (x === p) {
                _results1.push(x);
              }
            }
            return _results1;
          })()).length > 1) {
            _results.push(p);
          }
        }
        return _results;
      })();
      if (dups.length) {
        throw new Error("" + dups + " specified multiple times as arguments to addToSelect");
      }
      (_ref = this.views).push.apply(_ref, toAdd);
      if (opts.silent) {
        opts.events = ((_ref1 = opts.events) != null ? _ref1 : []).concat(['change', 'add:view', 'change:views']);
      } else {
        this.trigger('add:view change:views', toAdd);
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.select = function(views, opts) {
      var e, oldViews;
      oldViews = this.views.slice();
      try {
        this.views = [];
        this.addToSelect(views, opts);
      } catch (_error) {
        e = _error;
        this.views = oldViews;
        utils.error(e);
      }
      return this;
    };

    Query.prototype.adjustPath = function(path) {
      path = path && path.name ? path.name : "" + path;
      if (this.root != null) {
        if (!path.match("^" + this.root)) {
          path = this.root + "." + path;
        }
      } else {
        this.root = path.split('.')[0];
      }
      return path;
    };

    Query.prototype.getPossiblePaths = function(depth, allowReverseReferences, predicate) {
      var getPaths, key, ret, test, _base;
      if (depth == null) {
        depth = 3;
      }
      if (allowReverseReferences == null) {
        allowReverseReferences = true;
      }
      if (predicate == null) {
        predicate = null;
      }
      test = typeof predicate === 'string' ? function(p) {
        return p[predicate]();
      } : predicate;
      getPaths = (function(_this) {
        return function(root, d) {
          var cd, field, name, others, path, subPaths;
          path = _this.getPathInfo(root);
          if ((!allowReverseReferences) && path.isReverseReference()) {
            return [];
          } else if (path.isAttribute()) {
            return [path];
          } else {
            cd = path.getType();
            subPaths = concatMap(function(ref) {
              return getPaths("" + root + "." + ref.name, d - 1);
            });
            others = cd && (d > 0) ? subPaths((function() {
              var _ref, _results;
              _ref = cd.fields;
              _results = [];
              for (name in _ref) {
                field = _ref[name];
                _results.push(field);
              }
              return _results;
            })()) : [];
            return [path].concat(others);
          }
        };
      })(this);
      key = "" + depth + "-" + allowReverseReferences;
      if (this._possiblePaths == null) {
        this._possiblePaths = {};
      }
      ret = ((_base = this._possiblePaths)[key] != null ? _base[key] : _base[key] = getPaths(this.root, depth)).slice();
      if (test != null) {
        return ret.filter(test);
      } else {
        return ret;
      }
    };

    Query.prototype.getPathInfo = function(path) {
      var adjusted, pi, _ref;
      adjusted = this.adjustPath(path);
      pi = (_ref = this.model) != null ? typeof _ref.getPathInfo === "function" ? _ref.getPathInfo(adjusted, this.getSubclasses()) : void 0 : void 0;
      if (pi && adjusted in this.displayNames) {
        pi.displayName = this.displayNames[adjusted];
      }
      return pi;
    };

    Query.prototype.makePath = Query.prototype.getPathInfo;

    toPathAndType = function(c) {
      return [c.path, c.type];
    };

    scFold = utils.compose(utils.pairsToObj, utils.map(toPathAndType), filter(get('type')));

    Query.prototype.getSubclasses = function() {
      return scFold(this.constraints);
    };

    Query.prototype.getType = function(path) {
      return this.getPathInfo(path).getType();
    };

    Query.prototype.getViewNodes = function() {
      var p, toParentNode;
      toParentNode = (function(_this) {
        return function(v) {
          return _this.getPathInfo(v).getParent();
        };
      })(this);
      return utils.uniqBy(String, (function() {
        var _i, _len, _ref, _results;
        _ref = this.views;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(toParentNode(p));
        }
        return _results;
      }).call(this));
    };

    Query.prototype.isInView = function(path) {
      var pi, pstr, _ref;
      pi = this.getPathInfo(path);
      if (!pi) {
        throw new Error("Invalid path: " + path);
      }
      if (pi.isAttribute()) {
        return _ref = pi.toString(), __indexOf.call(this.views, _ref) >= 0;
      } else {
        pstr = pi.toString();
        return utils.any(this.getViewNodes(), function(n) {
          return n.toString() === pstr;
        });
      }
    };

    Query.prototype.isConstrained = function(path, includeAttrs) {
      var pi, test;
      if (includeAttrs == null) {
        includeAttrs = false;
      }
      pi = this.getPathInfo(path);
      if (!pi) {
        throw new Error("Invalid path: " + path);
      }
      test = function(c) {
        return (c.op != null) && c.path === pi.toString();
      };
      if ((!pi.isAttribute()) && includeAttrs) {
        test = (function(_this) {
          return function(c) {
            return (c.op != null) && (c.path === pi.toString() || pi.equals(_this.getPathInfo(c.path).getParent()));
          };
        })(this);
      }
      return utils.any(this.constraints, test);
    };

    Query.prototype.canHaveMultipleValues = function(path) {
      return this.getPathInfo(path).containsCollection();
    };

    Query.prototype.getQueryNodes = function() {
      var c, constrainedNodes, pi, viewNodes;
      viewNodes = this.getViewNodes();
      constrainedNodes = (function() {
        var _i, _len, _ref, _results;
        _ref = this.constraints;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if (!(c.type == null)) {
            continue;
          }
          pi = this.getPathInfo(c.path);
          if (pi.isAttribute()) {
            _results.push(pi.getParent());
          } else {
            _results.push(pi);
          }
        }
        return _results;
      }).call(this);
      return utils.uniqBy(String, viewNodes.concat(constrainedNodes));
    };

    Query.prototype.isInQuery = function(p) {
      var c, pi, pstr, _i, _len, _ref;
      pi = this.getPathInfo(p);
      if (pi) {
        pstr = pi.toPathString();
        _ref = this.views.concat((function() {
          var _j, _len, _ref, _results;
          _ref = this.constraints;
          _results = [];
          for (_j = 0, _len = _ref.length; _j < _len; _j++) {
            c = _ref[_j];
            if (c.type == null) {
              _results.push(c.path);
            }
          }
          return _results;
        }).call(this));
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          if (0 === p.indexOf(pstr)) {
            return true;
          }
        }
        return false;
      }
      return true;
    };

    Query.prototype.isRelevant = function(path) {
      var nodes, pi, sought;
      pi = this.getPathInfo(path);
      if (pi.isAttribute()) {
        pi = pi.getParent();
      }
      sought = pi.toString();
      nodes = this.getViewNodes();
      return utils.any(nodes, function(n) {
        return n.toPathString() === sought;
      });
    };

    Query.prototype.expandStar = function(path) {
      var attrViews, cd, expand, fn, n, name, pathStem, starViews;
      if (/\*$/.test(path)) {
        pathStem = path.substr(0, path.lastIndexOf('.'));
        expand = function(x) {
          return pathStem + x;
        };
        cd = this.getType(pathStem);
        if (/\.\*$/.test(path)) {
          if (cd && this.summaryFields[cd.name]) {
            fn = utils.compose(expand, decapitate);
            return (function() {
              var _i, _len, _ref, _results;
              _ref = this.summaryFields[cd.name];
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                n = _ref[_i];
                if (!this.hasView(n)) {
                  _results.push(fn(n));
                }
              }
              return _results;
            }).call(this);
          }
        } else if (/\.\*\*$/.test(path)) {
          starViews = this.expandStar(pathStem + '.*');
          attrViews = (function() {
            var _results;
            _results = [];
            for (name in cd.attributes) {
              _results.push(expand("." + name));
            }
            return _results;
          })();
          return utils.uniqBy(id, starViews.concat(attrViews));
        }
      }
      return path;
    };

    Query.prototype.isOuterJoin = function(p) {
      return this.joins[this.adjustPath(p)] === 'OUTER';
    };

    Query.prototype.hasView = function(v) {
      var _ref;
      return this.views && (_ref = this.adjustPath(v), __indexOf.call(this.views, _ref) >= 0);
    };

    Query.prototype.count = function(cont) {
      if (this.service.count) {
        return this.service.count(this, cont);
      } else {
        throw new Error("This query has no service with count functionality attached.");
      }
    };

    Query.prototype.appendToList = function(target, cb) {
      var name, processor, req, toRun, updateTarget;
      if (target != null ? target.name : void 0) {
        name = target.name;
        updateTarget = function(err, list) {
          if (err == null) {
            return target.size = list.size;
          }
        };
      } else {
        name = String(target);
        updateTarget = null;
      }
      toRun = this.makeListQuery();
      req = {
        listName: name,
        query: toRun.toXML()
      };
      processor = LIST_PIPE(this.service);
      return withCB(updateTarget, cb, this.service.post('query/append/tolist', req).then(processor));
    };

    Query.prototype.selectPreservingImpliedConstraints = function(paths) {
      var n, toRun, _i, _len, _ref;
      if (paths == null) {
        paths = [];
      }
      toRun = this.clone();
      toRun.select(paths);
      _ref = this.getViewNodes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (!this.isOuterJoined(n)) {
          if (!(toRun.isInView(n || toRun.isConstrained(n))) && (n.getEndClass().fields.id != null)) {
            toRun.addConstraint([n.append('id'), 'IS NOT NULL']);
          }
        }
      }
      return toRun;
    };

    Query.prototype.makeListQuery = function() {
      var paths, _ref;
      paths = this.views.slice();
      if (paths.length !== 1 || !((_ref = paths[0]) != null ? _ref.match(/\.id$/) : void 0)) {
        paths = ['id'];
      }
      return this.selectPreservingImpliedConstraints(paths);
    };

    Query.prototype.saveAsList = function(options, cb) {
      var req, toRun;
      toRun = this.makeListQuery();
      req = utils.copy(options);
      req.listName = req.listName || req.name;
      req.query = toRun.toXML();
      if (options.tags) {
        req.tags = options.tags.join(';');
      }
      return withCB(cb, this.service.post('query/tolist', req).then(LIST_PIPE(this.service)));
    };

    Query.prototype.summarise = function(path, limit, cont) {
      return this.filterSummary(path, '', limit, cont);
    };

    Query.prototype.summarize = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.summarise.apply(this, args);
    };

    parseSummary = function(data) {
      var isNumeric, r, stats, _i, _len, _ref, _ref1;
      isNumeric = ((_ref = data.results[0]) != null ? _ref.max : void 0) != null;
      _ref1 = data.results;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        r = _ref1[_i];
        r.count = parseInt(r.count, 10);
      }
      stats = {
        uniqueValues: data.uniqueValues,
        filteredCount: data.filteredCount
      };
      if (isNumeric) {
        stats = merge(stats, data.results[0]);
      }
      data.stats = stats;
      return data;
    };

    Query.prototype.filterSummary = function(path, term, limit, cont) {
      var req, toRun, _ref;
      if (cont == null) {
        cont = (function() {});
      }
      if (utils.isFunction(limit)) {
        _ref = [limit, null], cont = _ref[0], limit = _ref[1];
      }
      path = this.adjustPath(path);
      toRun = this.clone();
      if (__indexOf.call(toRun.views, path) < 0) {
        toRun.views.push(path);
      }
      req = {
        query: toRun.toXML(),
        summaryPath: path,
        format: 'jsonrows'
      };
      if (limit) {
        req.size = limit;
      }
      if (term) {
        req.filterTerm = term;
      }
      return withCB(cont, this.service.post('query/results', req).then(parseSummary));
    };

    Query.prototype.clone = function(cloneEvents) {
      var cloned, k, v, _ref;
      cloned = new Query(this, this.service);
      if (cloned._callbacks == null) {
        cloned._callbacks = {};
      }
      if (cloneEvents) {
        _ref = this._callbacks;
        for (k in _ref) {
          if (!__hasProp.call(_ref, k)) continue;
          v = _ref[k];
          cloned._callbacks[k] = v;
        }
        cloned.off('change:views', removeIrrelevantSortOrders, this);
      }
      return cloned;
    };

    Query.prototype.next = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start + this.maxRows;
      }
      return clone;
    };

    Query.prototype.previous = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start - this.maxRows;
      } else {
        clone.start = 0;
      }
      return clone;
    };

    Query.prototype.getSortDirection = function(sorted) {
      var a, so;
      a = this.adjustPath(sorted);
      if (!(this.isInQuery(a) || this.isRelevant(a))) {
        throw new Error("" + sorted + " is not in the query");
      }
      so = utils.find(this.sortOrder, function(_arg) {
        var path;
        path = _arg.path;
        return a === path;
      });
      return so != null ? so.direction : void 0;
    };

    Query.prototype.isOuterJoined = function(path) {
      var dir, jp, _ref;
      path = this.adjustPath(path);
      _ref = this.joins;
      for (jp in _ref) {
        dir = _ref[jp];
        if (dir === 'OUTER' && path.indexOf(jp) === 0) {
          return true;
        }
      }
      return false;
    };

    Query.prototype.getOuterJoin = function(path) {
      var joinPaths, k;
      path = this.adjustPath(path);
      joinPaths = ((function() {
        var _results;
        _results = [];
        for (k in this.joins) {
          _results.push(k);
        }
        return _results;
      }).call(this)).sort(function(a, b) {
        return b.length - a.length;
      });
      return utils.find(joinPaths, (function(_this) {
        return function(p) {
          return _this.joins[p] === 'OUTER' && path.indexOf(p) === 0;
        };
      })(this));
    };

    Query.prototype._parse_sort_order = function(input) {
      var direction, k, path, so, v, _ref;
      if (input == null) {
        throw new Error('No input');
      }
      if (typeof input === 'string') {
        so = {
          path: input,
          direction: 'ASC'
        };
      } else if (utils.isArray(input)) {
        path = input[0], direction = input[1];
        so = {
          path: path,
          direction: direction
        };
      } else if (input.path == null) {
        for (k in input) {
          v = input[k];
          _ref = [k, v], path = _ref[0], direction = _ref[1];
        }
        so = {
          path: path,
          direction: direction
        };
      } else {
        path = input.path, direction = input.direction;
        so = {
          path: path,
          direction: direction
        };
      }
      so.path = this.adjustPath(so.path);
      if (so.direction == null) {
        so.direction = 'ASC';
      }
      so.direction = so.direction.toUpperCase();
      return so;
    };

    Query.prototype.addOrSetSortOrder = function(so) {
      var currentDirection, oe;
      so = this._parse_sort_order(so);
      currentDirection = this.getSortDirection(so.path);
      if (currentDirection == null) {
        this.addSortOrder(so);
      } else if (currentDirection !== so.direction) {
        oe = utils.find(this.sortOrder, function(_arg) {
          var path;
          path = _arg.path;
          return path === so.path;
        });
        oe.direction = so.direction;
        this.trigger('change:sortorder', this.sortOrder);
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.addSortOrder = function(so, _arg) {
      var silent;
      silent = (_arg != null ? _arg : {}).silent;
      this.sortOrder.push(this._parse_sort_order(so));
      if (!silent) {
        this.trigger('add:sortorder', so);
        this.trigger('change:sortorder', this.sortOrder);
        return this.trigger('change');
      }
    };

    Query.prototype.orderBy = function(oes, opts) {
      var copy, direction, oe, oldSO, path, _i, _len, _ref;
      if (opts == null) {
        opts = {};
      }
      oldSO = this.sortOrder.slice();
      this.sortOrder = [];
      for (_i = 0, _len = oes.length; _i < _len; _i++) {
        oe = oes[_i];
        this.addSortOrder(this._parse_sort_order(oe), {
          silent: true
        });
      }
      copy = (function() {
        var _j, _len1, _ref, _ref1, _results;
        _ref = this.sortOrder;
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          _ref1 = _ref[_j], path = _ref1.path, direction = _ref1.direction;
          _results.push({
            path: path,
            direction: direction
          });
        }
        return _results;
      }).call(this);
      this.trigger('set:sortorder', copy);
      if ((stringifySortOrder(oldSO)) !== this.getSorting()) {
        if (opts.silent) {
          opts.events = ((_ref = opts.events) != null ? _ref : []).concat(['change', 'change:sortorder']);
        } else {
          this.trigger('change:sortorder', copy);
          this.trigger('change');
        }
      }
      return this;
    };

    Query.prototype.addJoins = function(joins) {
      var j, k, v, _i, _len, _results, _results1;
      if (utils.isArray(joins)) {
        _results = [];
        for (_i = 0, _len = joins.length; _i < _len; _i++) {
          j = joins[_i];
          _results.push(this.addJoin(j));
        }
        return _results;
      } else {
        _results1 = [];
        for (k in joins) {
          v = joins[k];
          _results1.push(this.addJoin({
            path: k,
            style: v
          }));
        }
        return _results1;
      }
    };

    Query.prototype.addJoin = function(join) {
      if (typeof join === 'string') {
        join = {
          path: join,
          style: 'OUTER'
        };
      }
      return this.setJoinStyle(join.path, join.style);
    };

    Query.prototype.setJoinStyle = function(path, style) {
      if (style == null) {
        style = 'OUTER';
      }
      path = this.adjustPath(path);
      style = style.toUpperCase();
      if (__indexOf.call(Query.JOIN_STYLES, style) < 0) {
        throw new Error("Invalid join style: " + style);
      }
      if (this.joins[path] !== style) {
        this.joins[path] = style;
        this.trigger('change:joins', {
          path: path,
          style: style
        });
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.addConstraints = function(constraints, conj) {
      var c, con, oldLogic, path, _fn, _i, _len;
      if (conj == null) {
        conj = 'and';
      }
      this.__silent__ = true;
      oldLogic = this.constraintLogic;
      if (utils.isArray(constraints)) {
        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          c = constraints[_i];
          this.addConstraint(c, conj);
        }
      } else {
        _fn = (function(_this) {
          return function(path, con) {
            return _this.addConstraint(interpretConstraint(path, con), conj);
          };
        })(this);
        for (path in constraints) {
          con = constraints[path];
          _fn(path, con);
        }
      }
      this.__silent__ = false;
      this.trigger('add:constraint');
      this.trigger('change:constraints');
      if (oldLogic !== this.constraintLogic) {
        this.trigger('change:logic', this.constraintLogic);
      }
      return this.trigger('change');
    };

    Query.prototype.addConstraint = function(constraint, conj) {
      var i, logic, needsLogicClause, newConLen, newLogic, oldLogic, _ref;
      if (conj == null) {
        conj = 'and';
      }
      if (conj !== 'and' && conj !== 'or') {
        throw new Error('Unknown logical conjunction: ' + conj);
      }
      if (utils.isArray(constraint)) {
        constraint = interpretConArray(constraint);
      } else {
        constraint = copyCon(constraint);
      }
      if (constraint.switched === 'OFF') {
        return this;
      }
      constraint.path = this.adjustPath(constraint.path);
      if (constraint.type == null) {
        constraint.op = get_canonical_op(constraint.op);
      }
      this.constraints.push(constraint);
      needsLogicClause = (conj === 'or') || (((_ref = this.constraintLogic) != null ? _ref.length : void 0) > 0);
      newConLen = this.constraints.length;
      oldLogic = this.constraintLogic;
      if (needsLogicClause) {
        newLogic = newConLen === 2 ? "" + CODES[0] + " " + conj + " " + CODES[1] : (logic = this.constraintLogic, logic || (logic = ((function() {
          var _i, _ref1, _results;
          _results = [];
          for (i = _i = 0, _ref1 = newConLen - 2; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
            _results.push(CODES[i]);
          }
          return _results;
        })()).join(' and ')), "(" + logic + ") " + conj + " " + CODES[newConLen - 1]);
        this.constraintLogic = newLogic;
      }
      if (!this.__silent__) {
        this.trigger('add:constraint', constraint);
        this.trigger('change:constraints');
        if (oldLogic !== this.constraintLogic) {
          this.trigger('change:logic', this.constraintLogic);
        }
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.getSorting = function() {
      return stringifySortOrder(this.sortOrder);
    };

    Query.prototype.getConstraintXML = function() {
      var c, toSerialise;
      toSerialise = (function() {
        var _i, _len, _ref, _results;
        _ref = this.constraints;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if ((c.type == null) || this.isInQuery(c.path)) {
            _results.push(c);
          }
        }
        return _results;
      }).call(this);
      if (toSerialise.length) {
        return concatMap(conStr)(concatMap(id)(partition(function(c) {
          return c.type != null;
        })(toSerialise)));
      } else {
        return '';
      }
    };

    Query.prototype.getJoinXML = function() {
      var p, s, strs;
      strs = (function() {
        var _ref, _results;
        _ref = this.joins;
        _results = [];
        for (p in _ref) {
          s = _ref[p];
          if (this.isInQuery(p) && s === 'OUTER') {
            _results.push("<join path=\"" + p + "\" style=\"OUTER\"/>");
          }
        }
        return _results;
      }).call(this);
      return strs.join('');
    };

    Query.prototype.toXML = function() {
      var attrs, headAttrs, k, v;
      attrs = {
        model: this.model.name,
        view: this.views.join(' '),
        sortOrder: this.getSorting(),
        constraintLogic: this.constraintLogic
      };
      if (this.name != null) {
        attrs.name = this.name;
      }
      headAttrs = ((function() {
        var _results;
        _results = [];
        for (k in attrs) {
          v = attrs[k];
          if (v) {
            _results.push(k + '="' + v + '"');
          }
        }
        return _results;
      })()).join(' ');
      return "<query " + headAttrs + " >" + (this.getJoinXML()) + (this.getConstraintXML()) + "</query>";
    };

    Query.prototype.toJSON = function() {
      var c, direction, path, style, v;
      return noUndefVals({
        name: this.name,
        title: this.title,
        comment: this.comment,
        description: this.description,
        constraintLogic: this.constraintLogic,
        from: this.root,
        select: (function() {
          var _i, _len, _ref, _results;
          _ref = this.views;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            _results.push(headLess(v));
          }
          return _results;
        }).call(this),
        orderBy: (function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = this.sortOrder;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], path = _ref1.path, direction = _ref1.direction;
            _results.push({
              path: headLess(path),
              direction: direction
            });
          }
          return _results;
        }).call(this),
        joins: (function() {
          var _ref, _results;
          _ref = this.joins;
          _results = [];
          for (path in _ref) {
            style = _ref[path];
            if (style === 'OUTER') {
              _results.push(headLess(path));
            }
          }
          return _results;
        }).call(this),
        where: (function() {
          var _i, _len, _ref, _results;
          _ref = this.constraints;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(conToJSON(c));
          }
          return _results;
        }).call(this)
      });
    };

    Query.prototype.fetchCode = function(lang, cb) {
      var req;
      req = {
        query: this.toXML(),
        lang: lang
      };
      return withCB(cb, this.service.post('query/code', req).then(this.service.VERIFIER).then(get('code')));
    };

    Query.prototype.setName = function(name) {
      this.name = name;
    };

    Query.prototype.save = function(name, cb) {
      return REQUIRES_VERSION(this.service, 16, (function(_this) {
        return function() {
          var req, _ref;
          if (utils.isFunction(name)) {
            _ref = [null, name], name = _ref[0], cb = _ref[1];
          }
          if (name != null) {
            _this.setName(name);
          }
          req = {
            type: 'PUT',
            path: 'user/queries',
            data: _this.toXML(),
            contentType: 'application/xml',
            dataType: 'json'
          };
          return withCB(cb, _this.service.authorise(req)).then(function(authed) {
            return _this.service.doReq(authed);
          }).then(function(resp) {
            return resp.queries;
          });
        };
      })(this));
    };

    Query.prototype.store = function(name, cb) {
      return REQUIRES_VERSION(this.service, 16, (function(_this) {
        return function() {
          var getName, req, updateName, _ref;
          if (utils.isFunction(name)) {
            _ref = [null, name], name = _ref[0], cb = _ref[1];
          }
          if (name != null) {
            _this.setName(name);
          }
          updateName = function(err, name) {
            if (err == null) {
              return _this.setName(name);
            }
          };
          getName = utils.compose(get(_this.name), get('queries'));
          req = {
            type: 'POST',
            path: 'user/queries',
            data: _this.toXML(),
            contentType: 'application/xml',
            dataType: 'json'
          };
          return withCB(cb, updateName, _this.service.authorise(req)).then(function(authed) {
            return _this.service.doReq(authed);
          }).then(getName);
        };
      })(this));
    };

    Query.prototype.saveAsTemplate = function(name, cb) {
      return REQUIRES_VERSION(this.service, 16, (function(_this) {
        return function() {
          var req, _ref;
          if (utils.isFunction(name)) {
            _ref = [null, name], name = _ref[0], cb = _ref[1];
          }
          if (name != null) {
            _this.setName(name);
          }
          if (!_this.name) {
            throw new Error("Templates must have a name");
          }
          req = {
            type: 'POST',
            path: 'templates',
            data: "<template " + (conAttrs(_this, ['name', 'title', 'comment'])) + ">" + (_this.toXML()) + "</template>",
            contentType: 'application/xml',
            dataType: 'json'
          };
          return withCB(cb, _this.service.authorise(req).then(function(authed) {
            return _this.service.doReq(authed);
          }));
        };
      })(this));
    };

    Query.prototype.getCodeURI = function(lang) {
      var req, _ref;
      req = {
        query: this.toXML(),
        lang: lang,
        format: 'text'
      };
      if (((_ref = this.service) != null ? _ref.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/code?" + (toQueryString(req));
    };

    Query.prototype.getExportURI = function(format, options) {
      var req, _ref;
      if (format == null) {
        format = 'tab';
      }
      if (options == null) {
        options = {};
      }
      if (__indexOf.call(Query.BIO_FORMATS, format) >= 0) {
        return this["get" + (format.toUpperCase()) + "URI"](options);
      }
      req = merge(options, {
        query: this.toXML(),
        format: format
      });
      if (((_ref = this.service) != null ? _ref.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results?" + (toQueryString(req));
    };

    Query.prototype.needsAuthentication = function() {
      return utils.any(this.constraints, function(c) {
        var _ref;
        return (_ref = c.op) === 'NOT IN' || _ref === 'IN';
      });
    };

    Query.prototype.fetchQID = function(cb) {
      return withCB(cb, this.service.post('queries', {
        query: this.toXML()
      }).then(get('id')));
    };

    addPI = function(p) {
      return p.append('primaryIdentifier').toString();
    };

    Query.prototype.__bio_req = function(types, n) {
      var isSuitable, toRun;
      toRun = this.makeListQuery();
      isSuitable = function(p) {
        return utils.any(types, function(t) {
          return p.isa(t);
        });
      };
      toRun.views = utils.take(n)((function() {
        var _i, _len, _ref, _results;
        _ref = this.getViewNodes();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          if (isSuitable(n)) {
            _results.push(addPI(n));
          }
        }
        return _results;
      }).call(this));
      return {
        query: toRun.toXML(),
        format: 'text'
      };
    };

    Query.prototype._fasta_req = function() {
      return this.__bio_req(["SequenceFeature", 'Protein'], 1);
    };

    Query.prototype._gff3_req = function() {
      return this.__bio_req(['SequenceFeature']);
    };

    Query.prototype._bed_req = Query.prototype._gff3_req;

    return Query;

  })();

  union = fold(function(xs, ys) {
    return xs.concat(ys);
  });

  Query.prototype.toString = Query.prototype.toXML;

  Query.ATTRIBUTE_OPS = union([Query.ATTRIBUTE_VALUE_OPS, Query.MULTIVALUE_OPS, Query.NULL_OPS]);

  Query.REFERENCE_OPS = union([Query.TERNARY_OPS, Query.LOOP_OPS, Query.LIST_OPS]);

  bioUriArgs = function(reqMeth, f) {
    return function(opts, cb) {
      var ensureAttr, obj, req, v, _ref;
      if (opts == null) {
        opts = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      if (utils.isFunction(opts)) {
        _ref = [{}, opts], opts = _ref[0], cb = _ref[1];
      }
      ensureAttr = (function(_this) {
        return function(p) {
          var path;
          path = _this.getPathInfo(p);
          if (path.isAttribute()) {
            return path;
          } else {
            return path.append('id');
          }
        };
      })(this);
      if ((opts != null ? opts.view : void 0) != null) {
        opts.view = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = opts.view;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            v = _ref1[_i];
            _results.push(this.getPathInfo(v).toString());
          }
          return _results;
        }).call(this);
      }
      obj = opts["export"] != null ? this.selectPreservingImpliedConstraints(opts["export"].map(ensureAttr)) : this;
      req = merge(obj[reqMeth](), opts);
      return f.call(obj, req, cb);
    };
  };

  _ref = Query.BIO_FORMATS;
  _fn = function(f) {
    var getMeth, reqMeth, uriMeth;
    reqMeth = "_" + f + "_req";
    getMeth = "get" + (f.toUpperCase());
    uriMeth = getMeth + "URI";
    Query.prototype[getMeth] = bioUriArgs(reqMeth, function(req, cb) {
      return withCB(cb, this.service.post('query/results/' + f, req));
    });
    return Query.prototype[uriMeth] = bioUriArgs(reqMeth, function(req, cb) {
      if (this.service.token != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results/" + f + "?" + (toQueryString(req));
    });
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    f = _ref[_i];
    _fn(f);
  }

  _get_data_fetcher = function(server_fn) {
    return function() {
      var cbs, page, x, _ref1;
      page = arguments[0], cbs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this.service[server_fn]) {
        if (page == null) {
          page = {};
        } else if (utils.isFunction(page)) {
          page = {};
          cbs = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = arguments.length; _j < _len1; _j++) {
              x = arguments[_j];
              _results.push(x);
            }
            return _results;
          }).apply(this, arguments);
        }
        page = noUndefVals(merge({
          start: this.start,
          size: this.maxRows
        }, page));
        return (_ref1 = this.service)[server_fn].apply(_ref1, [this, page].concat(__slice.call(cbs)));
      } else {
        throw new Error("Service does not provide '" + server_fn + "'.");
      }
    };
  };

  for (_j = 0, _len1 = RESULTS_METHODS.length; _j < _len1; _j++) {
    mth = RESULTS_METHODS[_j];
    Query.prototype[mth] = _get_data_fetcher(mth);
  }

  Events.mixin(Query.prototype);

  Query.prototype.emit = Query.prototype.trigger;

  Query.prototype.bind = Query.prototype.on;

  intermine.Query = Query;

}).call(this);

},{"./util":15,"./xml":17,"backbone-events-standalone":21}],10:[function(_dereq_,module,exports){
(function() {
  var ALWAYS_AUTH, CLASSKEYS, CLASSKEY_PATH, DEFAULT_ERROR_HANDLER, DEFAULT_PROTOCOL, ENRICHMENT_PATH, HAS_PROTOCOL, HAS_SUFFIX, IDResolutionJob, ID_RESOLUTION_PATH, LISTS_PATH, LIST_OPERATION_PATHS, LIST_PIPE, List, MODELS, MODEL_PATH, Model, NEEDS_AUTH, NO_AUTH, PATH_VALUES_PATH, PREF_PATH, Promise, QUERY_RESULTS_PATH, QUICKSEARCH_PATH, Query, RELEASES, RELEASE_PATH, REQUIRES_VERSION, SUBTRACT_PATH, SUFFIX, SUMMARYFIELDS_PATH, SUMMARY_FIELDS, Service, TABLE_ROW_PATH, TEMPLATES_PATH, TO_NAMES, USER_TOKENS, User, VERSIONS, VERSION_PATH, WHOAMI_PATH, WIDGETS, WIDGETS_PATH, WITH_OBJ_PATH, dejoin, error, get, getListFinder, http, invoke, map, merge, p, set, success, to_query_string, utils, version, withCB, _get_or_fetch, _i, _j, _len, _len1, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  Promise = _dereq_('./promise');

  Model = _dereq_('./model').Model;

  Query = _dereq_('./query').Query;

  List = _dereq_('./lists').List;

  User = _dereq_('./user').User;

  IDResolutionJob = _dereq_('./id-resolution-job').IDResolutionJob;

  version = _dereq_('./version');

  utils = _dereq_('./util');

  http = _dereq_('./http');

  to_query_string = utils.querystring;

  withCB = utils.withCB, map = utils.map, merge = utils.merge, get = utils.get, set = utils.set, invoke = utils.invoke, success = utils.success, error = utils.error, REQUIRES_VERSION = utils.REQUIRES_VERSION, dejoin = utils.dejoin;

  VERSIONS = {};

  CLASSKEYS = {};

  RELEASES = {};

  MODELS = {};

  SUMMARY_FIELDS = {};

  WIDGETS = {};

  DEFAULT_PROTOCOL = "http://";

  VERSION_PATH = "version";

  TEMPLATES_PATH = "templates";

  RELEASE_PATH = "version/release";

  CLASSKEY_PATH = "classkeys";

  LISTS_PATH = "lists";

  MODEL_PATH = "model";

  SUMMARYFIELDS_PATH = "summaryfields";

  QUERY_RESULTS_PATH = "query/results";

  QUICKSEARCH_PATH = "search";

  WIDGETS_PATH = "widgets";

  ENRICHMENT_PATH = "list/enrichment";

  WITH_OBJ_PATH = "listswithobject";

  LIST_OPERATION_PATHS = {
    union: "lists/union",
    intersection: "lists/intersect",
    difference: "lists/diff"
  };

  SUBTRACT_PATH = 'lists/subtract';

  WHOAMI_PATH = "user/whoami";

  TABLE_ROW_PATH = QUERY_RESULTS_PATH + '/tablerows';

  PREF_PATH = 'user/preferences';

  PATH_VALUES_PATH = 'path/values';

  USER_TOKENS = 'user/tokens';

  ID_RESOLUTION_PATH = 'ids';

  NO_AUTH = {};

  _ref = [VERSION_PATH, RELEASE_PATH, CLASSKEY_PATH, WIDGETS_PATH, MODEL_PATH, SUMMARYFIELDS_PATH, QUICKSEARCH_PATH, PATH_VALUES_PATH];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    p = _ref[_i];
    NO_AUTH[p] = true;
  }

  ALWAYS_AUTH = {};

  _ref1 = [WHOAMI_PATH, PREF_PATH, LIST_OPERATION_PATHS, SUBTRACT_PATH, WITH_OBJ_PATH, ENRICHMENT_PATH, TEMPLATES_PATH, USER_TOKENS];
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    p = _ref1[_j];
    ALWAYS_AUTH[p] = true;
  }

  NEEDS_AUTH = function(path, q) {
    if (NO_AUTH[path]) {
      return false;
    } else if (ALWAYS_AUTH[path]) {
      return true;
    } else if (!(q != null ? q.needsAuthentication : void 0)) {
      return true;
    } else {
      return q.needsAuthentication();
    }
  };

  HAS_PROTOCOL = /^https?:\/\//i;

  HAS_SUFFIX = /service\/?$/i;

  SUFFIX = "/service/";

  DEFAULT_ERROR_HANDLER = function(e) {
    var f, _ref2;
    f = (_ref2 = console.error) != null ? _ref2 : console.log;
    return f(e);
  };

  _get_or_fetch = function(propName, store, path, key, cb) {
    var opts, promise, root, useCache, value;
    root = this.root, useCache = this.useCache;
    promise = this[propName] != null ? this[propName] : this[propName] = useCache && (value = store[root]) ? success(value) : (opts = {
      type: 'GET',
      dataType: 'json',
      data: {
        format: 'json'
      }
    }, this.doReq(merge(opts, {
      url: this.root + path
    })).then(function(x) {
      return store[root] = x[key];
    }));
    return withCB(cb, promise);
  };

  getListFinder = function(name) {
    return function(lists) {
      return new Promise(function(resolve, reject) {
        var list;
        if (list = utils.find(lists, function(l) {
          return l.name === name;
        })) {
          return resolve(list);
        } else {
          return reject("List \"" + name + "\" not found among: " + (lists.map(get('name'))));
        }
      });
    };
  };

  LIST_PIPE = function(service, prop) {
    if (prop == null) {
      prop = 'listName';
    }
    return utils.compose(service.fetchList, get(prop));
  };

  TO_NAMES = function(xs) {
    var x, _k, _len2, _ref2, _ref3, _results;
    if (xs == null) {
      xs = [];
    }
    _ref2 = (utils.isArray(xs) ? xs : [xs]);
    _results = [];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      x = _ref2[_k];
      _results.push((_ref3 = x.name) != null ? _ref3 : x);
    }
    return _results;
  };

  Service = (function() {
    var FIVE_MIN, checkNameParam, getNewUserToken, loadQ, pathValuesReq, toMapByName;

    Service.prototype.doReq = http.doReq;

    function Service(_arg) {
      var noCache;
      this.root = _arg.root, this.token = _arg.token, this.errorHandler = _arg.errorHandler, this.DEBUG = _arg.DEBUG, this.help = _arg.help, noCache = _arg.noCache;
      this.connectAs = __bind(this.connectAs, this);
      this.createList = __bind(this.createList, this);
      this.resolveIds = __bind(this.resolveIds, this);
      this.templateQuery = __bind(this.templateQuery, this);
      this.savedQuery = __bind(this.savedQuery, this);
      this.query = __bind(this.query, this);
      this.fetchRelease = __bind(this.fetchRelease, this);
      this.fetchClassKeys = __bind(this.fetchClassKeys, this);
      this.fetchVersion = __bind(this.fetchVersion, this);
      this.fetchSummaryFields = __bind(this.fetchSummaryFields, this);
      this.fetchModel = __bind(this.fetchModel, this);
      this.fetchWidgetMap = __bind(this.fetchWidgetMap, this);
      this.fetchWidgets = __bind(this.fetchWidgets, this);
      this.complement = __bind(this.complement, this);
      this.fetchListsContaining = __bind(this.fetchListsContaining, this);
      this.fetchList = __bind(this.fetchList, this);
      this.findLists = __bind(this.findLists, this);
      this.fetchLists = __bind(this.fetchLists, this);
      this.fetchTemplates = __bind(this.fetchTemplates, this);
      this.tableRows = __bind(this.tableRows, this);
      this.values = __bind(this.values, this);
      this.rows = __bind(this.rows, this);
      this.records = __bind(this.records, this);
      this.table = __bind(this.table, this);
      this.pathValues = __bind(this.pathValues, this);
      this.fetchUser = __bind(this.fetchUser, this);
      this.whoami = __bind(this.whoami, this);
      this.findById = __bind(this.findById, this);
      this.count = __bind(this.count, this);
      this.enrichment = __bind(this.enrichment, this);
      if (this.root == null) {
        throw new Error("No service root provided. This is required");
      }
      if (!HAS_PROTOCOL.test(this.root)) {
        this.root = DEFAULT_PROTOCOL + this.root;
      }
      if (!HAS_SUFFIX.test(this.root)) {
        this.root = this.root + SUFFIX;
      }
      this.root = this.root.replace(/ice$/, "ice/");
      if (this.errorHandler == null) {
        this.errorHandler = DEFAULT_ERROR_HANDLER;
      }
      if (this.help == null) {
        this.help = 'no.help.available@dev.null';
      }
      this.useCache = !noCache;
      this.getFormat = (function(_this) {
        return function(intended) {
          if (intended == null) {
            intended = 'json';
          }
          return intended;
        };
      })(this);
    }

    Service.prototype.post = function(path, data) {
      return this.makeRequest('POST', path, data);
    };

    Service.prototype.get = function(path, data) {
      return this.makeRequest('GET', path, data);
    };

    Service.prototype.makeRequest = function(method, path, data, cb, indiv) {
      var dataType, errBack, opts, timeout, _ref2, _ref3, _ref4;
      if (method == null) {
        method = 'GET';
      }
      if (path == null) {
        path = '';
      }
      if (data == null) {
        data = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (indiv == null) {
        indiv = false;
      }
      if (utils.isArray(cb)) {
        _ref2 = cb, cb = _ref2[0], errBack = _ref2[1];
      }
      if (utils.isArray(data)) {
        data = utils.pairsToObj(data);
      }
      if (errBack == null) {
        errBack = this.errorHandler;
      }
      data = utils.copy(data);
      dataType = this.getFormat(data.format);
      if (!http.supports(method)) {
        _ref3 = [method, http.getMethod(method)], data.method = _ref3[0], method = _ref3[1];
      }
      opts = {
        data: data,
        dataType: dataType,
        success: cb,
        error: errBack,
        path: path,
        type: method
      };
      if (data.auth != null) {
        opts.auth = data.auth;
        delete opts.data.auth;
      }
      if (data.headers != null) {
        opts.headers = utils.copy(data.headers);
        delete opts.data.headers;
      }
      if (timeout = (_ref4 = data.timeout) != null ? _ref4 : this.timeout) {
        opts.timeout = timeout;
        delete data.timeout;
      }
      return this.authorise(opts).then((function(_this) {
        return function(authed) {
          return _this.doReq(authed, indiv);
        };
      })(this));
    };

    Service.prototype.authorise = function(req) {
      return this.fetchVersion().then((function(_this) {
        return function(version) {
          var opts, pathAdditions, _ref2;
          opts = utils.copy(req);
          if (opts.headers == null) {
            opts.headers = {};
          }
          opts.url = _this.root + opts.path;
          pathAdditions = [];
          if (version < 14) {
            if ('string' === typeof opts.data) {
              pathAdditions.push(['format', opts.dataType]);
            } else {
              opts.data.format = opts.dataType;
            }
          }
          if ((_this.token != null) && NEEDS_AUTH(req.path, (_ref2 = opts.data) != null ? _ref2.query : void 0)) {
            if (version >= 14) {
              opts.headers.Authorization = "Token " + _this.token;
            } else if ('string' === typeof opts.data) {
              pathAdditions.push(['token', _this.token]);
            } else {
              opts.data.token = _this.token;
            }
          }
          if (pathAdditions.length) {
            opts.url += '?' + to_query_string(pathAdditions);
          }
          return opts;
        };
      })(this));
    };

    Service.prototype.enrichment = function(opts, cb) {
      return REQUIRES_VERSION(this, 8, (function(_this) {
        return function() {
          var req;
          req = merge({
            maxp: 0.05,
            correction: 'Holm-Bonferroni'
          }, opts);
          return withCB(cb, _this.get(ENRICHMENT_PATH, req).then(get('results')));
        };
      })(this));
    };

    Service.prototype.search = function(options, cb) {
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          var k, req, v, _ref2;
          if (utils.isFunction(options)) {
            _ref2 = [options, {}], cb = _ref2[0], options = _ref2[1];
          }
          if (typeof options === 'string') {
            req = {
              q: options
            };
          } else {
            req = {
              q: options.q
            };
            for (k in options) {
              if (!__hasProp.call(options, k)) continue;
              v = options[k];
              if (k !== 'q') {
                req["facet_" + k] = v;
              }
            }
          }
          return withCB(cb, _this.post(QUICKSEARCH_PATH, req));
        };
      })(this));
    };

    Service.prototype.makePath = function(path, subclasses, cb) {
      if (subclasses == null) {
        subclasses = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      return withCB(cb, this.fetchModel().then(function(m) {
        return m.makePath(path, subclasses);
      }));
    };

    Service.prototype.count = function(q, cb) {
      var promise, req;
      if (cb == null) {
        cb = (function() {});
      }
      promise = !q ? error("Not enough arguments") : q.toPathString != null ? (p = q.isClass() ? q.append('id') : q, this.pathValues(p, 'count')) : q.toXML != null ? (req = {
        query: q,
        format: 'jsoncount'
      }, this.post(QUERY_RESULTS_PATH, req).then(get('count'))) : typeof q === 'string' ? this.fetchModel().then((function(_this) {
        return function(m) {
          var e;
          try {
            return _this.count(m.makePath(q));
          } catch (_error) {
            e = _error;
            return _this.query({
              select: [q]
            }).then(_this.count);
          }
        };
      })(this)) : this.query(q).then(this.count);
      return withCB(cb, promise);
    };

    Service.prototype.findById = function(type, id, fields, cb) {
      var promise, _ref2;
      if (fields == null) {
        fields = ['**'];
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (utils.isFunction(fields)) {
        _ref2 = [['**'], fields], fields = _ref2[0], cb = _ref2[1];
      }
      promise = this.query({
        from: type,
        select: fields,
        where: {
          id: id
        }
      }).then(dejoin).then(invoke('records')).then(get(0));
      return withCB(cb, promise);
    };

    Service.prototype.lookup = function(type, term, context, cb) {
      var promise, _ref2;
      if (utils.isFunction(context)) {
        _ref2 = [null, context], context = _ref2[0], cb = _ref2[1];
      }
      promise = this.query({
        from: type,
        select: ['**'],
        where: [[type, 'LOOKUP', term, context]]
      }).then(dejoin).then(invoke('records'));
      return withCB(cb, promise);
    };

    Service.prototype.find = function(type, term, context, cb) {
      var _ref2;
      if (utils.isFunction(context)) {
        _ref2 = [null, context], context = _ref2[0], cb = _ref2[1];
      }
      return withCB(cb, this.lookup(type, term, context).then(function(found) {
        if ((found == null) || found.length === 0) {
          return error("Nothing found");
        } else if (found.length > 1) {
          return error("Multiple items found: " + (found.slice(0, 3)) + "...");
        } else {
          return success(found[0]);
        }
      }));
    };

    Service.prototype.whoami = function(cb) {
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          return withCB(cb, _this.get(WHOAMI_PATH).then(get('user')).then(function(x) {
            return new User(_this, x);
          }));
        };
      })(this));
    };

    Service.prototype.fetchUser = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.whoami.apply(this, args);
    };

    pathValuesReq = function(format, path) {
      return {
        format: format,
        path: String(path),
        typeConstraints: JSON.stringify(path.subclasses)
      };
    };

    Service.prototype.pathValues = function(path, typeConstraints, cb) {
      if (typeConstraints == null) {
        typeConstraints = {};
      }
      return REQUIRES_VERSION(this, 6, (function(_this) {
        return function() {
          var e, format, promise, wanted, _ref2;
          if (typeof typeConstraints === 'string') {
            wanted = typeConstraints;
            typeConstraints = {};
          }
          if (utils.isFunction(typeConstraints)) {
            _ref2 = [cb, typeConstraints], typeConstraints = _ref2[0], cb = _ref2[1];
          }
          if (wanted !== 'count') {
            wanted = 'results';
          }
          format = wanted === 'count' ? 'jsoncount' : 'json';
          promise = (function() {
            var _ref3;
            try {
              return this.fetchModel().then(invoke('makePath', path, (_ref3 = path.subclasses) != null ? _ref3 : typeConstraints)).then(function(path) {
                return pathValuesReq(format, path);
              }).then((function(_this) {
                return function(req) {
                  return _this.post(PATH_VALUES_PATH, req);
                };
              })(this)).then(get(wanted));
            } catch (_error) {
              e = _error;
              return error(e);
            }
          }).call(_this);
          return withCB(cb, promise);
        };
      })(this));
    };

    Service.prototype.doPagedRequest = function(q, path, page, format, cb) {
      var req, _ref2;
      if (page == null) {
        page = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (q.toXML != null) {
        if (utils.isFunction(page)) {
          _ref2 = [page, {}], cb = _ref2[0], page = _ref2[1];
        }
        req = merge(page, {
          query: q,
          format: format
        });
        return withCB(cb, this.post(path, req).then(get('results')));
      } else {
        return this.query(q).then((function(_this) {
          return function(query) {
            return _this.doPagedRequest(query, path, page, format, cb);
          };
        })(this));
      }
    };

    Service.prototype.table = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsontable', cb);
    };

    Service.prototype.records = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsonobjects', cb);
    };

    Service.prototype.rows = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'json', cb);
    };

    Service.prototype.values = function(q, opts, cb) {
      var resp, _ref2;
      if (utils.isFunction(opts)) {
        _ref2 = [opts, cb], cb = _ref2[0], opts = _ref2[1];
      }
      resp = q == null ? error("No query term supplied") : (q.descriptors != null) || typeof q === 'string' ? this.pathValues(q, opts).then(map(get('value'))) : q.toXML != null ? q.views.length !== 1 ? error("Expected one column, got " + q.views.length) : this.rows(q, opts).then(map(get(0))) : this.query(q).then((function(_this) {
        return function(query) {
          return _this.values(query, opts);
        };
      })(this));
      return withCB(cb, resp);
    };

    Service.prototype.tableRows = function(q, page, cb) {
      return this.doPagedRequest(q, TABLE_ROW_PATH, page, 'json', cb);
    };

    Service.prototype.fetchTemplates = function(cb) {
      return withCB(cb, this.get(TEMPLATES_PATH).then(get('templates')));
    };

    Service.prototype.fetchLists = function(cb) {
      return this.findLists('', cb);
    };

    Service.prototype.findLists = function(name, cb) {
      if (name == null) {
        name = '';
      }
      if (cb == null) {
        cb = (function() {});
      }
      return this.fetchVersion().then((function(_this) {
        return function(v) {
          var fn;
          return withCB(cb, name && v < 13 ? error("Finding lists by name on the server requires version 13. This is only " + v) : (fn = function(ls) {
            var data, _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = ls.length; _k < _len2; _k++) {
              data = ls[_k];
              _results.push(new List(data, _this));
            }
            return _results;
          }, _this.get(LISTS_PATH, {
            name: name
          }).then(get('lists')).then(fn)));
        };
      })(this));
    };

    Service.prototype.fetchList = function(name, cb) {
      return this.fetchVersion().then((function(_this) {
        return function(v) {
          return withCB(cb, v < 13 ? _this.findLists().then(getListFinder(name)) : _this.findLists(name).then(get(0)));
        };
      })(this));
    };

    Service.prototype.fetchListsContaining = function(opts, cb) {
      var fn;
      fn = (function(_this) {
        return function(xs) {
          var x, _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = xs.length; _k < _len2; _k++) {
            x = xs[_k];
            _results.push(new List(x, _this));
          }
          return _results;
        };
      })(this);
      return withCB(cb, this.get(WITH_OBJ_PATH, opts).then(get('lists')).then(fn));
    };

    Service.prototype.combineLists = function(operation, options, cb) {
      var description, lists, name, req, tags, _ref2;
      _ref2 = merge({
        lists: [],
        tags: []
      }, options), name = _ref2.name, lists = _ref2.lists, tags = _ref2.tags, description = _ref2.description;
      req = {
        name: name,
        description: description
      };
      if (req.description == null) {
        req.description = "" + operation + " of " + (lists.join(', '));
      }
      req.tags = tags.join(';');
      req.lists = lists.join(';');
      return withCB(cb, this.get(LIST_OPERATION_PATHS[operation], req).then(LIST_PIPE(this)));
    };

    Service.prototype.merge = function() {
      return this.combineLists.apply(this, ['union'].concat(__slice.call(arguments)));
    };

    Service.prototype.intersect = function() {
      return this.combineLists.apply(this, ['intersection'].concat(__slice.call(arguments)));
    };

    Service.prototype.diff = function() {
      return this.combineLists.apply(this, ['difference'].concat(__slice.call(arguments)));
    };

    Service.prototype.complement = function(options, cb) {
      var defaultDesc, description, exclude, from, lists, name, references, req, tags;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      from = options.from, exclude = options.exclude, name = options.name, description = options.description, tags = options.tags;
      defaultDesc = function() {
        return "Relative complement of " + (lists.join(' and ')) + " in " + (references.join(' and '));
      };
      references = TO_NAMES(from);
      lists = TO_NAMES(exclude);
      if (name == null) {
        name = defaultDesc();
      }
      if (description == null) {
        description = defaultDesc();
      }
      if (tags == null) {
        tags = [];
      }
      req = {
        name: name,
        description: description,
        tags: tags,
        lists: lists,
        references: references
      };
      return withCB(cb, this.post(SUBTRACT_PATH, req).then(LIST_PIPE(this)));
    };

    Service.prototype.fetchWidgets = function(cb) {
      return REQUIRES_VERSION(this, 8, (function(_this) {
        return function() {
          return _get_or_fetch.call(_this, 'widgets', WIDGETS, WIDGETS_PATH, 'widgets', cb);
        };
      })(this));
    };

    toMapByName = utils.omap(function(w) {
      return [w.name, w];
    });

    Service.prototype.fetchWidgetMap = function(cb) {
      return REQUIRES_VERSION(this, 8, (function(_this) {
        return function() {
          return withCB(cb, (_this.__wmap__ != null ? _this.__wmap__ : _this.__wmap__ = _this.fetchWidgets().then(toMapByName)));
        };
      })(this));
    };

    Service.prototype.fetchModel = function(cb) {
      var ret;
      ret = _get_or_fetch.call(this, 'model', MODELS, MODEL_PATH, 'model').then(Model.load).then(set({
        service: this
      }));
      return withCB(cb, ret);
    };

    Service.prototype.fetchSummaryFields = function(cb) {
      return _get_or_fetch.call(this, 'summaryFields', SUMMARY_FIELDS, SUMMARYFIELDS_PATH, 'classes', cb);
    };

    Service.prototype.fetchVersion = function(cb) {
      return _get_or_fetch.call(this, 'version', VERSIONS, VERSION_PATH, 'version', cb);
    };

    Service.prototype.fetchClassKeys = function(cb) {
      return _get_or_fetch.call(this, 'classkeys', CLASSKEYS, CLASSKEY_PATH, 'classes', cb);
    };

    Service.prototype.fetchRelease = function(cb) {
      return _get_or_fetch.call(this, 'release', RELEASES, RELEASE_PATH, 'version', cb);
    };

    Service.prototype.query = function(options, cb) {
      var buildQuery;
      buildQuery = (function(_this) {
        return function(_arg) {
          var model, summaryFields;
          model = _arg[0], summaryFields = _arg[1];
          return new Query(options, _this, {
            model: model,
            summaryFields: summaryFields
          });
        };
      })(this);
      return withCB(cb, utils.parallel(this.fetchModel(), this.fetchSummaryFields()).then(buildQuery));
    };

    loadQ = function(service, name) {
      return function(q) {
        if (!q) {
          return error("No query found called " + name);
        }
        return service.query(q);
      };
    };

    checkNameParam = function(name) {
      if (name) {
        if ('string' === typeof name) {
          return success();
        } else {
          return error("Name must be a string");
        }
      } else {
        return error("Name not provided");
      }
    };

    Service.prototype.savedQuery = function(name, cb) {
      return REQUIRES_VERSION(this, 16, (function(_this) {
        return function() {
          return checkNameParam(name).then(function() {
            return withCB(cb, _this.get('user/queries', {
              filter: name
            }).then(function(r) {
              return r.queries[name];
            }).then(loadQ(_this, name)));
          });
        };
      })(this));
    };

    Service.prototype.templateQuery = function(name, cb) {
      return checkNameParam(name).then((function(_this) {
        return function() {
          return withCB(cb, _this.fetchTemplates().then(get(name)).then(set('type', 'TEMPLATE')).then(loadQ(_this, name)));
        };
      })(this));
    };

    Service.prototype.manageUserPreferences = function(method, data, cb) {
      return REQUIRES_VERSION(this, 11, (function(_this) {
        return function() {
          return withCB(cb, _this.makeRequest(method, PREF_PATH, data).then(get('preferences')));
        };
      })(this));
    };

    Service.prototype.resolveIds = function(opts, cb) {
      return REQUIRES_VERSION(this, 10, (function(_this) {
        return function() {
          var req;
          req = {
            type: 'POST',
            url: _this.root + ID_RESOLUTION_PATH,
            contentType: 'application/json',
            data: JSON.stringify(opts),
            dataType: 'json'
          };
          return withCB(cb, _this.doReq(req).then(get('uid')).then(IDResolutionJob.create(_this)));
        };
      })(this));
    };

    Service.prototype.resolutionJob = function(id) {
      return IDResolutionJob.create(this)(id);
    };

    Service.prototype.createList = function(opts, ids, cb) {
      var adjust, req;
      if (opts == null) {
        opts = {};
      }
      if (ids == null) {
        ids = '';
      }
      if (cb == null) {
        cb = function() {};
      }
      adjust = (function(_this) {
        return function(x) {
          return merge(x, {
            token: _this.token,
            tags: opts.tags || []
          });
        };
      })(this);
      req = {
        data: utils.isArray(ids) ? ids.map(function(x) {
          return "\"" + x + "\"";
        }).join("\n") : ids,
        dataType: 'json',
        url: "" + this.root + "lists?" + (to_query_string(adjust(opts))),
        type: 'POST',
        contentType: 'text/plain'
      };
      return withCB(cb, this.doReq(req).then(LIST_PIPE(this)));
    };

    getNewUserToken = function(resp) {
      return resp.user.temporaryToken;
    };

    Service.prototype.connectAs = function(token) {
      return Service.connect(merge(this, {
        token: token,
        noCache: !this.useCache
      }));
    };

    Service.prototype.register = function(name, password, cb) {
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          return withCB(cb, _this.post('users', {
            name: name,
            password: password
          }).then(getNewUserToken).then(_this.connectAs));
        };
      })(this));
    };

    FIVE_MIN = 5 * 60;

    Service.prototype.getDeregistrationToken = function(validity, cb) {
      if (validity == null) {
        validity = FIVE_MIN;
      }
      return REQUIRES_VERSION(this, 16, (function(_this) {
        return function() {
          var promise;
          promise = _this.token != null ? _this.post('user/deregistration', {
            validity: validity
          }).then(get('token')) : error("Not registered");
          return withCB(cb, promise);
        };
      })(this));
    };

    Service.prototype.deregister = function(token, cb) {
      return REQUIRES_VERSION(this, 16, (function(_this) {
        return function() {
          return withCB(cb, _this.makeRequest('DELETE', 'user', {
            deregistrationToken: token,
            format: 'xml'
          }));
        };
      })(this));
    };

    Service.prototype.login = function(name, password, cb) {
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          var auth;
          auth = "" + name + ":" + password;
          return withCB(cb, _this.logout().then(function(service) {
            return service.get('user/token', {
              auth: auth
            });
          })).then(get('token')).then(_this.connectAs);
        };
      })(this));
    };

    Service.prototype.logout = function(cb) {
      return withCB(cb, success(this.connectAs()));
    };

    return Service;

  })();

  Service.prototype.rowByRow = function() {
    var args, f, q;
    q = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    f = http.iterReq('POST', QUERY_RESULTS_PATH, 'json');
    if (q.toXML != null) {
      return f.apply(this, arguments);
    } else {
      return this.query(q).then((function(_this) {
        return function(query) {
          return _this.rowByRow.apply(_this, [query].concat(__slice.call(args)));
        };
      })(this));
    }
  };

  Service.prototype.eachRow = Service.prototype.rowByRow;

  Service.prototype.recordByRecord = function() {
    var args, f, q;
    q = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    f = http.iterReq('POST', QUERY_RESULTS_PATH, 'jsonobjects');
    if (q.toXML != null) {
      return f.apply(this, arguments);
    } else {
      return this.query(q).then((function(_this) {
        return function(query) {
          return _this.recordByRecord.apply(_this, [query].concat(__slice.call(args)));
        };
      })(this));
    }
  };

  Service.prototype.eachRecord = Service.prototype.recordByRecord;

  Service.prototype.union = Service.prototype.merge;

  Service.prototype.difference = Service.prototype.diff;

  Service.prototype.symmetricDifference = Service.prototype.diff;

  Service.prototype.relativeComplement = Service.prototype.complement;

  Service.prototype.subtract = Service.prototype.complement;

  Service.flushCaches = function() {
    MODELS = {};
    VERSIONS = {};
    RELEASES = {};
    CLASSKEYS = {};
    SUMMARY_FIELDS = {};
    return WIDGETS = {};
  };

  Service.connect = function(opts) {
    if ((opts != null ? opts.root : void 0) == null) {
      throw new Error("Invalid options provided: " + (JSON.stringify(opts)));
    }
    return new Service(opts);
  };

  exports.Service = Service;

  exports.Model = Model;

  exports.Query = Query;

  exports.utils = utils;

  exports.VERSION = version.VERSION;

  exports.imjs = version;

}).call(this);

},{"./http":3,"./id-resolution-job":4,"./lists":5,"./model":6,"./promise":8,"./query":9,"./user":14,"./util":15,"./version":16}],11:[function(_dereq_,module,exports){
(function (global){
(function() {
  var FakeDomParser;

  exports.DOMParser = global.DOMParser != null ? global.DOMParser : FakeDomParser = (function() {
    function FakeDomParser() {
      throw new Error("DOMParser is not available");
    }

    return FakeDomParser;

  })();

}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],12:[function(_dereq_,module,exports){
(function() {
  var HAS_CONSOLE, HAS_JSON, NOT_ENUM, hasDontEnumBug, hasOwnProperty, head, m, script, _fn, _i, _len, _ref;

  HAS_CONSOLE = typeof console !== 'undefined';

  HAS_JSON = typeof JSON !== 'undefined';

  NOT_ENUM = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];

  if (!HAS_JSON) {
    script = document.createElement('script');
    script.src = 'http://cdn.intermine.org/js/json3/3.2.2/json3.min.js';
    script.type = 'text/javascript';
    head = document.getElementsByTagName('head')[0];
    head.appendChild(script);
  }

  if (Object.keys == null) {
    hasOwnProperty = Object.prototype.hasOwnProperty;
    hasDontEnumBug = !{
      toString: null
    }.propertyIsEnumerable("toString");
    Object.keys = function(o) {
      var keys, name, nonEnum, _i, _len;
      if (typeof o !== "object" && typeof o !== "" || o === null) {
        throw new TypeError("Object.keys called on a non-object");
      }
      keys = (function() {
        var _results;
        _results = [];
        for (name in o) {
          if (hasOwnProperty.call(o, name)) {
            _results.push(name);
          }
        }
        return _results;
      })();
      if (hasDontEnumBug) {
        for (_i = 0, _len = NOT_ENUM.length; _i < _len; _i++) {
          nonEnum = NOT_ENUM[_i];
          if (hasOwnProperty.call(o, nonEnum)) {
            keys.push(nonEnum);
          }
        }
      }
      return keys;
    };
  }

  if (Array.prototype.map == null) {
    Array.prototype.map = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        _results.push(f(x));
      }
      return _results;
    };
  }

  if (Array.prototype.filter == null) {
    Array.prototype.filter = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        if (f(x)) {
          _results.push(x);
        }
      }
      return _results;
    };
  }

  if (Array.prototype.reduce == null) {
    Array.prototype.reduce = function(f, initValue) {
      var ret, x, xs, _i, _len;
      xs = this.slice();
      ret = arguments.length < 2 ? xs.pop() : initValue;
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        ret = f(ret, x);
      }
      return ret;
    };
  }

  if (Array.prototype.forEach == null) {
    Array.prototype.forEach = function(f, ctx) {
      var i, x, _i, _len, _results;
      if (!f) {
        throw new Error("No function provided");
      }
      _results = [];
      for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
        x = this[i];
        _results.push(f.call(ctx != null ? ctx : this, x, i, this));
      }
      return _results;
    };
  }

  if (!HAS_CONSOLE) {
    this.console = {
      log: (function() {}),
      error: (function() {}),
      debug: (function() {})
    };
    if (typeof window !== "undefined" && window !== null) {
      window.console = this.console;
    }
  }

  if (console.log == null) {
    console.log = function() {};
  }

  if (console.error == null) {
    console.error = function() {};
  }

  if (console.debug == null) {
    console.debug = function() {};
  }

  if (console.log.apply == null) {
    console.log("Your console needs patching.");
    _ref = ['log', 'error', 'debug'];
    _fn = function(m) {
      var oldM;
      oldM = console[m];
      return console[m] = function(args) {
        return oldM(args);
      };
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      _fn(m);
    }
  }

}).call(this);

},{}],13:[function(_dereq_,module,exports){
(function() {
  var Promise, merge, properties,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  merge = function(src, dest) {
    var k, v, _results;
    _results = [];
    for (k in src) {
      v = src[k];
      _results.push(dest[k] = v);
    }
    return _results;
  };

  Promise = _dereq_('./promise');

  properties = ['attributes', 'references', 'collections'];

  exports.Table = (function() {
    function Table(opts, model) {
      var c, prop, _, _i, _len, _ref, _ref1;
      this.model = model;
      this.getDisplayName = __bind(this.getDisplayName, this);
      this.name = opts.name, this.tags = opts.tags, this.displayName = opts.displayName, this.attributes = opts.attributes, this.references = opts.references, this.collections = opts.collections;
      this.fields = {};
      this.__parents__ = (_ref = opts['extends']) != null ? _ref : [];
      for (_i = 0, _len = properties.length; _i < _len; _i++) {
        prop = properties[_i];
        if (this[prop] == null) {
          throw new Error("Bad model data: missing " + prop);
        }
        merge(this[prop], this.fields);
      }
      _ref1 = this.collections;
      for (_ in _ref1) {
        c = _ref1[_];
        c.isCollection = true;
      }
    }

    Table.prototype.toString = function() {
      var n, _;
      return "[Table name=" + this.name + ", fields=[" + ((function() {
        var _ref, _results;
        _ref = this.fields;
        _results = [];
        for (n in _ref) {
          _ = _ref[n];
          _results.push(n);
        }
        return _results;
      }).call(this)) + "]]";
    };

    Table.prototype.parents = function() {
      var _ref;
      return ((_ref = this.__parents__) != null ? _ref : []).slice();
    };

    Table.prototype.getDisplayName = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this.model != null) {
            return resolve(_this.model.makePath(_this.name).getDisplayName());
          } else {
            return reject(new Error('model not set - cannot make path'));
          }
        };
      })(this));
    };

    return Table;

  })();

}).call(this);

},{"./promise":8}],14:[function(_dereq_,module,exports){
(function() {
  var any, do_pref_req, error, get, isFunction, withCB, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = _dereq_('./util'), withCB = _ref.withCB, get = _ref.get, isFunction = _ref.isFunction, any = _ref.any, error = _ref.error;

  do_pref_req = function(user, data, method, cb) {
    return user.service.manageUserPreferences(method, data, cb).then(function(prefs) {
      return user.preferences = prefs;
    });
  };

  exports.User = (function() {
    function User(service, _arg) {
      this.service = service;
      this.username = _arg.username, this.preferences = _arg.preferences;
      this.refresh = __bind(this.refresh, this);
      this.clearPreferences = __bind(this.clearPreferences, this);
      this.clearPreference = __bind(this.clearPreference, this);
      this.setPreferences = __bind(this.setPreferences, this);
      this.setPreference = __bind(this.setPreference, this);
      this.hasPreferences = this.preferences != null;
      if (this.preferences == null) {
        this.preferences = {};
      }
    }

    User.prototype.setPreference = function(key, value, cb) {
      var data, _ref1;
      if (isFunction(value)) {
        _ref1 = [null, value], value = _ref1[0], cb = _ref1[1];
      }
      if (typeof key === 'string') {
        data = {};
        data[key] = value;
      } else if (value == null) {
        data = key;
      } else {
        return withCB(cb, error("Incorrect arguments to setPreference"));
      }
      return this.setPreferences(data, cb);
    };

    User.prototype.setPreferences = function(prefs, cb) {
      return do_pref_req(this, prefs, 'POST', cb);
    };

    User.prototype.clearPreference = function(key, cb) {
      return do_pref_req(this, {
        key: key
      }, 'DELETE', cb);
    };

    User.prototype.clearPreferences = function(cb) {
      return do_pref_req(this, {}, 'DELETE', cb);
    };

    User.prototype.refresh = function(cb) {
      return do_pref_req(this, {}, 'GET', cb);
    };

    User.prototype.createToken = function(type, message, cb) {
      var _ref1, _ref2;
      if (type == null) {
        type = 'day';
      }
      if ((cb == null) && any([type, message], isFunction)) {
        if (isFunction(type)) {
          _ref1 = [null, null, type], type = _ref1[0], message = _ref1[1], cb = _ref1[2];
        } else if (isFunction(message)) {
          _ref2 = [null, message], message = _ref2[0], cb = _ref2[1];
        }
      }
      return withCB(cb, this.service.post('user/tokens', {
        type: type,
        message: message
      }).then(get('token')));
    };

    User.prototype.fetchCurrentTokens = function(cb) {
      return withCB(cb, this.service.get('user/tokens').then(get('tokens')));
    };

    User.prototype.revokeAllTokens = function(cb) {
      return withCB(cb, this.service.makeRequest('DELETE', 'user/tokens'));
    };

    User.prototype.revokeToken = function(token, cb) {
      return withCB(cb, this.service.makeRequest('DELETE', "user/tokens/" + token));
    };

    return User;

  })();

}).call(this);

},{"./util":15}],15:[function(_dereq_,module,exports){
(function() {
  var Promise, REQUIRES, comp, curry, encode, entities, error, flatten, fold, id, invoke, invokeWith, isArray, merge, pairFold, qsFromList, root, success, thenFold, _ref,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  Promise = _dereq_('./promise');

  root = exports;

  root.defer = function() {
    var deferred;
    deferred = {};
    deferred.promise = new Promise(function(resolve, reject) {
      deferred.resolve = resolve;
      return deferred.reject = reject;
    });
    return deferred;
  };

  encode = function(x) {
    return encodeURIComponent(String(x));
  };

  qsFromList = function(pairs) {
    var pair;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = pairs.length; _i < _len; _i++) {
        pair = pairs[_i];
        _results.push(pair.map(encode).join('='));
      }
      return _results;
    })()).join('&');
  };

  root.querystring = function(obj) {
    var k, p, pairs, subList, sv, v;
    if (!obj) {
      return '';
    }
    if (isArray(obj)) {
      pairs = obj.slice();
    } else {
      pairs = [];
      for (k in obj) {
        v = obj[k];
        if (isArray(v)) {
          subList = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = v.length; _i < _len; _i++) {
              sv = v[_i];
              _results.push([k, sv]);
            }
            return _results;
          })();
          pairs = pairs.concat(subList);
        } else {
          pairs.push([k, v]);
        }
      }
    }
    return qsFromList((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = pairs.length; _i < _len; _i++) {
        p = pairs[_i];
        if (p[1] != null) {
          _results.push(p);
        }
      }
      return _results;
    })());
  };

  root.curry = curry = function() {
    var args, f;
    f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return f.apply(null, args.concat(rest));
    };
  };

  root.error = error = function(e) {
    return new Promise(function(_, reject) {
      return reject(new Error(e));
    });
  };

  root.success = success = function(x) {
    return new Promise(function(resolve, _) {
      return resolve(x);
    });
  };

  root.parallel = function() {
    var promises;
    promises = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (promises.length === 1 && (!promises[0].then) && promises[0].length) {
      return Promise.all(promises[0]);
    } else {
      return Promise.all(promises);
    }
  };

  root.withCB = function() {
    var f, fs, onErr, onSucc, p, _i, _j, _len;
    fs = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), p = arguments[_i++];
    for (_j = 0, _len = fs.length; _j < _len; _j++) {
      f = fs[_j];
      if (!(f != null)) {
        continue;
      }
      onSucc = curry(f, null);
      onErr = f;
      p.then(onSucc, onErr);
    }
    return p;
  };

  root.fold = fold = function(f) {
    return function(init, xs) {
      var k, ret, v;
      if (arguments.length === 1) {
        xs = (init != null ? init.slice() : void 0) || init;
        init = (xs != null ? xs.shift() : void 0) || {};
      }
      if (xs == null) {
        throw new Error("xs is null");
      }
      if (xs.reduce != null) {
        return xs.reduce(f, init);
      } else {
        ret = init;
        for (k in xs) {
          v = xs[k];
          ret = ret != null ? f(ret, k, v) : {
            k: v
          };
        }
        return ret;
      }
    };
  };

  root.take = function(n) {
    return function(xs) {
      if (n != null) {
        return xs.slice(0, +(n - 1) + 1 || 9e9);
      } else {
        return xs.slice();
      }
    };
  };

  root.filter = function(f) {
    return function(xs) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        if (f(x)) {
          _results.push(x);
        }
      }
      return _results;
    };
  };

  root.uniqBy = function(f, xs) {
    var k, keys, values, x, _i, _len;
    if (arguments.length === 1) {
      return curry(root.uniqBy, f);
    }
    keys = [];
    values = [];
    if (xs == null) {
      return values;
    }
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      k = f(x);
      if (__indexOf.call(keys, k) < 0) {
        keys.push(k);
        values.push(x);
      }
    }
    return values;
  };

  root.find = function(xs, f) {
    var x, _i, _len;
    if (arguments.length === 1) {
      f = xs;
      return function(xs) {
        return root.find(xs, f);
      };
    }
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (f(x)) {
        return x;
      }
    }
    return null;
  };

  isArray = (_ref = Array.isArray) != null ? _ref : function(xs) {
    return ((xs != null ? xs.splice : void 0) != null) && ((xs != null ? xs.push : void 0) != null) && ((xs != null ? xs.pop : void 0) != null) && ((xs != null ? xs.slice : void 0) != null);
  };

  root.isArray = isArray;

  root.isFunction = typeof /./ !== 'function' ? function(f) {
    return typeof f === 'function';
  } : function(f) {
    return (f != null) && (f.call != null) && (f.apply != null) && f.toString() === '[object Function]';
  };

  entities = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&apos;'
  };

  root.escape = function(str) {
    var code, i, ret, withEntities, _i, _ref1;
    if (str == null) {
      return '';
    }
    withEntities = String(str).replace(/[&<>"']/g, function(entity) {
      return entities[entity];
    });
    ret = [];
    for (i = _i = 0, _ref1 = withEntities.length; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
      code = withEntities.charCodeAt(i);
      if (code > 256) {
        ret.push("&#" + code + ";");
      } else {
        ret.push(withEntities.charAt(i));
      }
    }
    return ret.join('');
  };

  root.omap = function(f) {
    var merger;
    merger = fold(function(a, oldk, oldv) {
      var newk, newv, _ref1;
      _ref1 = f(oldk, oldv), newk = _ref1[0], newv = _ref1[1];
      if (isArray(newv)) {
        newv = newv.slice();
      }
      a[newk] = newv;
      return a;
    });
    return function(xs) {
      return merger({}, xs);
    };
  };

  root.copy = root.omap(function(k, v) {
    return [k, v];
  });

  root.partition = function(f) {
    return function(xs) {
      var divide;
      divide = fold(function(_arg, x) {
        var falses, trues;
        trues = _arg[0], falses = _arg[1];
        if (f(x)) {
          return [trues.concat([x]), falses];
        } else {
          return [trues, falses.concat([x])];
        }
      });
      return divide([[], []], xs);
    };
  };

  root.id = id = function(x) {
    return x;
  };

  root.concatMap = function(f) {
    return function(xs) {
      var fx, ret, x, _i, _len;
      ret = void 0;
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        fx = f(x);
        ret = ret === void 0 ? fx : typeof ret === 'number' ? ret + fx : ret.concat != null ? ret.concat(fx) : merge(ret, fx);
      }
      return ret;
    };
  };

  root.map = function(f) {
    return invoke('map', f);
  };

  comp = fold(function(f, g) {
    return function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return f(g.apply(null, args));
    };
  });

  root.compose = function() {
    var fs;
    fs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return comp(fs);
  };

  root.flatMap = root.concatMap;

  root.difference = function(xs, remove) {
    var x, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (__indexOf.call(remove, x) < 0) {
        _results.push(x);
      }
    }
    return _results;
  };

  root.stringList = function(x) {
    if (typeof x === 'string') {
      return [x];
    } else {
      return x;
    }
  };

  root.flatten = flatten = function() {
    var ret, x, xs, xx, _i, _j, _len, _len1, _ref1;
    xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    ret = [];
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (isArray(x)) {
        _ref1 = flatten.apply(null, x);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          xx = _ref1[_j];
          ret.push(xx);
        }
      } else {
        ret.push(x);
      }
    }
    return ret;
  };

  root.sum = root.concatMap(id);

  root.merge = merge = function() {
    var k, newObj, o, objs, v, _i, _len;
    objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    newObj = {};
    for (_i = 0, _len = objs.length; _i < _len; _i++) {
      o = objs[_i];
      for (k in o) {
        if (!__hasProp.call(o, k)) continue;
        v = o[k];
        newObj[k] = v;
      }
    }
    return newObj;
  };

  root.any = function(xs, f) {
    var x, _i, _len;
    if (f == null) {
      f = id;
    }
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (f(x)) {
        return true;
      }
    }
    return false;
  };

  root.invoke = invoke = function() {
    var args, name;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return invokeWith(name, args);
  };

  root.invokeWith = invokeWith = function(name, args, ctx) {
    if (args == null) {
      args = [];
    }
    if (ctx == null) {
      ctx = null;
    }
    return function(o) {
      if (o == null) {
        throw new Error("Cannot call method \"" + name + "\" of null");
      }
      if (!o[name]) {
        throw new Error("Cannot call undefined method \"" + name + " of " + o);
      } else {
        return o[name].apply(ctx || o, args);
      }
    };
  };

  root.get = function(name) {
    return function(obj) {
      return obj[name];
    };
  };

  root.set = function(name, value) {
    return function(obj) {
      var k, v;
      if (arguments.length === 2) {
        obj[name] = value;
      } else {
        for (k in name) {
          if (!__hasProp.call(name, k)) continue;
          v = name[k];
          obj[k] = v;
        }
      }
      return obj;
    };
  };

  REQUIRES = function(required, got) {
    return "This service requires a service at version " + required + " or above. This one is at " + got;
  };

  root.REQUIRES_VERSION = function(s, n, f) {
    return s.fetchVersion().then(function(v) {
      if (v >= n) {
        return f();
      } else {
        return error(REQUIRES(n, v));
      }
    });
  };

  root.dejoin = function(q) {
    var parts, view, _i, _len, _ref1;
    _ref1 = q.views;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      view = _ref1[_i];
      parts = view.split('.');
      if (parts.length > 2) {
        q.addJoin(parts.slice(1, -1).join('.'));
      }
    }
    return q;
  };

  thenFold = fold(function(p, f) {
    return p.then(f);
  });

  root.sequence = function() {
    var fns;
    fns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return thenFold(success(), fns);
  };

  pairFold = fold(function(o, _arg) {
    var k, v;
    k = _arg[0], v = _arg[1];
    if (o[k] != null) {
      throw new Error("Duplicate key: " + k);
    }
    o[k] = v;
    return o;
  });

  root.pairsToObj = function(pairs) {
    return pairFold({}, pairs);
  };

}).call(this);

},{"./promise":8}],16:[function(_dereq_,module,exports){
(function() {
  exports.VERSION = '3.13.0';

}).call(this);

},{}],17:[function(_dereq_,module,exports){
(function() {
  var DOMParser, sanitize;

  DOMParser = _dereq_('xmldom').DOMParser;

  sanitize = function(xml) {
    xml = xml.replace(/^\s*/g, '');
    xml = xml.replace(/\s$/g, '');
    if (xml.length === 0) {
      return xml;
    } else if (xml[xml.length - 1] !== '>') {
      return xml + '>';
    } else {
      return xml;
    }
  };

  exports.parse = function(xml) {
    var dom, parser;
    if (typeof xml !== 'string') {
      throw new Error("Expected a string - got " + xml);
    }
    xml = sanitize(xml);
    if (!xml) {
      throw new Error("Expected content - got empty string");
    }
    dom = (function() {
      try {
        parser = new DOMParser();
        return parser.parseFromString(xml, 'text/xml');
      } catch (_error) {}
    })();
    if ((!dom) || (!dom.documentElement) || dom.getElementsByTagName('parsererror').length) {
      throw new Error("Invalid XML: " + xml);
    }
    return dom;
  };

}).call(this);

},{"xmldom":11}],18:[function(_dereq_,module,exports){
(function (process,Buffer){


var Parser = _dereq_('jsonparse')
  , through = _dereq_('through')

/*

  the value of this.stack that creationix's jsonparse has is weird.

  it makes this code ugly, but his problem is way harder that mine,
  so i'll forgive him.

*/

exports.parse = function (path, map) {

  var parser = new Parser()
  var stream = through(function (chunk) {
    if('string' === typeof chunk)
      chunk = new Buffer(chunk)
    parser.write(chunk)
  },
  function (data) {
    if(data)
      stream.write(data)
    stream.queue(null)
  })

  if('string' === typeof path)
    path = path.split('.').map(function (e) {
      if (e === '*')
        return true
      else if (e === '') // '..'.split('.') returns an empty string
        return {recurse: true}
      else
        return e
    })


  var count = 0, _key
  if(!path || !path.length)
    path = null

  parser.onValue = function (value) {
    if (!this.root)
      stream.root = value

    if(! path) return

    var i = 0 // iterates on path
    var j  = 0 // iterates on stack
    while (i < path.length) {
      var key = path[i]
      var c
      j++

      if (key && !key.recurse) {
        c = (j === this.stack.length) ? this : this.stack[j]
        if (!c) return
        if (! check(key, c.key)) return
        i++
      } else {
        i++
        var nextKey = path[i]
        if (! nextKey) return
        while (true) {
          c = (j === this.stack.length) ? this : this.stack[j]
          if (!c) return
          if (check(nextKey, c.key)) { i++; break}
          j++
        }
      }
    }
    if (j !== this.stack.length) return

    count ++
    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])
    var data = this.value[this.key]
    if(null != data)
      if(null != (data = map ? map(data, actualPath) : data))
        stream.queue(data)
    delete this.value[this.key]
  }
  parser._onToken = parser.onToken;

  parser.onToken = function (token, value) {
    parser._onToken(token, value);
    if (this.stack.length === 0) {
      if (stream.root) {
        if(!path)
          stream.queue(stream.root)
        stream.emit('root', stream.root, count)
        count = 0;
        stream.root = null;
      }
    }
  }

  parser.onError = function (err) {
    stream.emit('error', err)
  }


  return stream
}

function check (x, y) {
  if ('string' === typeof x)
    return y == x
  else if (x && 'function' === typeof x.exec)
    return x.exec(y)
  else if ('boolean' === typeof x)
    return x
  else if ('function' === typeof x)
    return x(y)
  return false
}

exports.stringify = function (op, sep, cl, indent) {
  indent = indent || 0
  if (op === false){
    op = ''
    sep = '\n'
    cl = ''
  } else if (op == null) {

    op = '[\n'
    sep = '\n,\n'
    cl = '\n]\n'

  }

  //else, what ever you like

  var stream
    , first = true
    , anyData = false
  stream = through(function (data) {
    anyData = true
    var json = JSON.stringify(data, null, indent)
    if(first) { first = false ; stream.queue(op + json)}
    else stream.queue(sep + json)
  },
  function (data) {
    if(!anyData)
      stream.queue(op)
    stream.queue(cl)
    stream.queue(null)
  })

  return stream
}

exports.stringifyObject = function (op, sep, cl, indent) {
  indent = indent || 0
  if (op === false){
    op = ''
    sep = '\n'
    cl = ''
  } else if (op == null) {

    op = '{\n'
    sep = '\n,\n'
    cl = '\n}\n'

  }

  //else, what ever you like

  var first = true
    , anyData = false
  stream = through(function (data) {
    anyData = true
    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)
    if(first) { first = false ; this.queue(op + json)}
    else this.queue(sep + json)
  },
  function (data) {
    if(!anyData) this.queue(op)
    this.queue(cl)

    this.queue(null)
  })

  return stream
}

if(!module.parent && process.title !== 'browser') {
  process.stdin
    .pipe(exports.parse(process.argv[2]))
    .pipe(exports.stringify('[', ',\n', ']\n', 2))
    .pipe(process.stdout)
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"),_dereq_("buffer").Buffer)
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"buffer":23,"jsonparse":19,"through":56}],19:[function(_dereq_,module,exports){
(function (Buffer){
/*global Buffer*/
// Named constants with unique integer values
var C = {};
// Tokens
var LEFT_BRACE    = C.LEFT_BRACE    = 0x1;
var RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;
var LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;
var RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;
var COLON         = C.COLON         = 0x5;
var COMMA         = C.COMMA         = 0x6;
var TRUE          = C.TRUE          = 0x7;
var FALSE         = C.FALSE         = 0x8;
var NULL          = C.NULL          = 0x9;
var STRING        = C.STRING        = 0xa;
var NUMBER        = C.NUMBER        = 0xb;
// Tokenizer States
var START   = C.START   = 0x11;
var TRUE1   = C.TRUE1   = 0x21;
var TRUE2   = C.TRUE2   = 0x22;
var TRUE3   = C.TRUE3   = 0x23;
var FALSE1  = C.FALSE1  = 0x31;
var FALSE2  = C.FALSE2  = 0x32;
var FALSE3  = C.FALSE3  = 0x33;
var FALSE4  = C.FALSE4  = 0x34;
var NULL1   = C.NULL1   = 0x41;
var NULL2   = C.NULL3   = 0x42;
var NULL3   = C.NULL2   = 0x43;
var NUMBER1 = C.NUMBER1 = 0x51;
var NUMBER2 = C.NUMBER2 = 0x52;
var NUMBER3 = C.NUMBER3 = 0x53;
var NUMBER4 = C.NUMBER4 = 0x54;
var NUMBER5 = C.NUMBER5 = 0x55;
var NUMBER6 = C.NUMBER6 = 0x56;
var NUMBER7 = C.NUMBER7 = 0x57;
var NUMBER8 = C.NUMBER8 = 0x58;
var STRING1 = C.STRING1 = 0x61;
var STRING2 = C.STRING2 = 0x62;
var STRING3 = C.STRING3 = 0x63;
var STRING4 = C.STRING4 = 0x64;
var STRING5 = C.STRING5 = 0x65;
var STRING6 = C.STRING6 = 0x66;
// Parser States
var VALUE   = C.VALUE   = 0x71;
var KEY     = C.KEY     = 0x72;
// Parser Modes
var OBJECT  = C.OBJECT  = 0x81;
var ARRAY   = C.ARRAY   = 0x82;

// Slow code to string converter (only used when throwing syntax errors)
function toknam(code) {
  var keys = Object.keys(C);
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    if (C[key] === code) { return key; }
  }
  return code && ("0x" + code.toString(16));
}


function Parser() {
  this.tState = START;
  this.value = undefined;

  this.string = undefined; // string data
  this.unicode = undefined; // unicode escapes

  // For number parsing
  this.negative = undefined;
  this.magnatude = undefined;
  this.position = undefined;
  this.exponent = undefined;
  this.negativeExponent = undefined;
  
  this.key = undefined;
  this.mode = undefined;
  this.stack = [];
  this.state = VALUE;
  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary
  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read
  this.temp_buffs = { "2": new Buffer(2), "3": new Buffer(3), "4": new Buffer(4) }; // for rebuilding chars split before boundary is reached
}
var proto = Parser.prototype;
proto.charError = function (buffer, i) {
  this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + toknam(this.tState)));
};
proto.onError = function (err) { throw err; };
proto.write = function (buffer) {
  if (typeof buffer === "string") buffer = new Buffer(buffer);
  //process.stdout.write("Input: ");
  //console.dir(buffer.toString());
  var n;
  for (var i = 0, l = buffer.length; i < l; i++) {
    if (this.tState === START){
      n = buffer[i];
      if(n === 0x7b){ this.onToken(LEFT_BRACE, "{"); // {
      }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, "}"); // }
      }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, "["); // [
      }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, "]"); // ]
      }else if(n === 0x3a){ this.onToken(COLON, ":");  // :
      }else if(n === 0x2c){ this.onToken(COMMA, ","); // ,
      }else if(n === 0x74){ this.tState = TRUE1;  // t
      }else if(n === 0x66){ this.tState = FALSE1;  // f
      }else if(n === 0x6e){ this.tState = NULL1; // n
      }else if(n === 0x22){ this.string = ""; this.tState = STRING1; // "
      }else if(n === 0x2d){ this.negative = true; this.tState = NUMBER1; // -
      }else if(n === 0x30){ this.magnatude = 0; this.tState = NUMBER2; // 0
      }else{
        if (n > 0x30 && n < 0x40) { // 1-9
          this.magnatude = n - 0x30; this.tState = NUMBER3;
        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {
          // whitespace
        } else { this.charError(buffer, i); }
      }
    }else if (this.tState === STRING1){ // After open quote
      n = buffer[i]; // get current byte from buffer
      // check for carry over of a multi byte char split between data chunks
      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration
      if (this.bytes_remaining > 0) {
        for (var j = 0; j < this.bytes_remaining; j++) {
          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
        }
        this.string += this.temp_buffs[this.bytes_in_sequence].toString();
        this.bytes_in_sequence = this.bytes_remaining = 0;
        i = i + j - 1;
      } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time
        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;
        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;
        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;
        if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split
          for (var k = 0; k <= (buffer.length - 1 - i); k++) {
            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk
          }
          this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;
          i = buffer.length - 1;
        } else {
          this.string += buffer.slice(i, (i + this.bytes_in_sequence)).toString();
          i = i + this.bytes_in_sequence - 1;
        }
      } else if (n === 0x22) { this.tState = START; this.onToken(STRING, this.string); this.string = undefined; }
      else if (n === 0x5c) { this.tState = STRING2; }
      else if (n >= 0x20) { this.string += String.fromCharCode(n); }
      else { this.charError(buffer, i); }
    }else if (this.tState === STRING2){ // After backslash
      n = buffer[i];
      if(n === 0x22){ this.string += "\""; this.tState = STRING1;
      }else if(n === 0x5c){ this.string += "\\"; this.tState = STRING1; 
      }else if(n === 0x2f){ this.string += "\/"; this.tState = STRING1; 
      }else if(n === 0x62){ this.string += "\b"; this.tState = STRING1; 
      }else if(n === 0x66){ this.string += "\f"; this.tState = STRING1; 
      }else if(n === 0x6e){ this.string += "\n"; this.tState = STRING1; 
      }else if(n === 0x72){ this.string += "\r"; this.tState = STRING1; 
      }else if(n === 0x74){ this.string += "\t"; this.tState = STRING1; 
      }else if(n === 0x75){ this.unicode = ""; this.tState = STRING3;
      }else{ 
        this.charError(buffer, i); 
      }
    }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes
      n = buffer[i];
      // 0-9 A-F a-f
      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {
        this.unicode += String.fromCharCode(n);
        if (this.tState++ === STRING6) {
          this.string += String.fromCharCode(parseInt(this.unicode, 16));
          this.unicode = undefined;
          this.tState = STRING1; 
        }
      } else {
        this.charError(buffer, i);
      }
    }else if (this.tState === NUMBER1){ // after minus
      n = buffer[i];
      if (n === 0x30) { this.magnatude = 0; this.tState = NUMBER2; }
      else if (n > 0x30 && n < 0x40) { this.magnatude = n - 0x30; this.tState = NUMBER3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === NUMBER2){ // * After initial zero
      n = buffer[i];
      if(n === 0x2e){ // .
        this.position = 0.1; this.tState = NUMBER4;
      }else if(n === 0x65 ||  n === 0x45){ // e/E
        this.exponent = 0; this.tState = NUMBER6;
      }else{
        this.tState = START;
        this.onToken(NUMBER, 0);
        this.magnatude = undefined;
        this.negative = undefined;
        i--;
      }
    }else if (this.tState === NUMBER3){ // * After digit (before period)
      n = buffer[i];
      if(n === 0x2e){ // .
        this.position = 0.1; this.tState = NUMBER4;
      }else if(n === 0x65 || n === 0x45){ // e/E
        this.exponent = 0; this.tState = NUMBER6;
      }else{
        if (n >= 0x30 && n < 0x40) { this.magnatude = this.magnatude * 10 + n - 0x30; }
        else {
          this.tState = START; 
          if (this.negative) {
            this.magnatude = -this.magnatude;
            this.negative = undefined;
          }
          this.onToken(NUMBER, this.magnatude); 
          this.magnatude = undefined;
          i--;
        }
      }
    }else if (this.tState === NUMBER4){ // After period
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.magnatude += this.position * (n - 0x30);
        this.position /= 10;
        this.tState = NUMBER5; 
      } else { this.charError(buffer, i); }
    }else if (this.tState === NUMBER5){ // * After digit (after period)
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.magnatude += this.position * (n - 0x30);
        this.position /= 10;
      }
      else if (n === 0x65 || n === 0x45) { this.exponent = 0; this.tState = NUMBER6; } // E/e
      else {
        this.tState = START; 
        if (this.negative) {
          this.magnatude = -this.magnatude;
          this.negative = undefined;
        }
        this.onToken(NUMBER, this.negative ? -this.magnatude : this.magnatude); 
        this.magnatude = undefined;
        this.position = undefined;
        i--; 
      }
    }else if (this.tState === NUMBER6){ // After E
      n = buffer[i];
      if (n === 0x2b || n === 0x2d) { // +/-
        if (n === 0x2d) { this.negativeExponent = true; }
        this.tState = NUMBER7;
      }
      else if (n >= 0x30 && n < 0x40) {
        this.exponent = this.exponent * 10 + (n - 0x30);
        this.tState = NUMBER8;
      }
      else { this.charError(buffer, i); }  
    }else if (this.tState === NUMBER7){ // After +/-
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.exponent = this.exponent * 10 + (n - 0x30);
        this.tState = NUMBER8;
      }
      else { this.charError(buffer, i); }  
    }else if (this.tState === NUMBER8){ // * After digit (after +/-)
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.exponent = this.exponent * 10 + (n - 0x30);
      }
      else {
        if (this.negativeExponent) {
          this.exponent = -this.exponent;
          this.negativeExponent = undefined;
        }
        this.magnatude *= Math.pow(10, this.exponent);
        this.exponent = undefined;
        if (this.negative) { 
          this.magnatude = -this.magnatude;
          this.negative = undefined;
        }
        this.tState = START;
        this.onToken(NUMBER, this.magnatude);
        this.magnatude = undefined;
        i--; 
      } 
    }else if (this.tState === TRUE1){ // r
      if (buffer[i] === 0x72) { this.tState = TRUE2; }
      else { this.charError(buffer, i); }
    }else if (this.tState === TRUE2){ // u
      if (buffer[i] === 0x75) { this.tState = TRUE3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === TRUE3){ // e
      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE1){ // a
      if (buffer[i] === 0x61) { this.tState = FALSE2; }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE2){ // l
      if (buffer[i] === 0x6c) { this.tState = FALSE3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE3){ // s
      if (buffer[i] === 0x73) { this.tState = FALSE4; }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE4){ // e
      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); }
      else { this.charError(buffer, i); }
    }else if (this.tState === NULL1){ // u
      if (buffer[i] === 0x75) { this.tState = NULL2; }
      else { this.charError(buffer, i); }
    }else if (this.tState === NULL2){ // l
      if (buffer[i] === 0x6c) { this.tState = NULL3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === NULL3){ // l
      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); }
      else { this.charError(buffer, i); }
    }
  }
};
proto.onToken = function (token, value) {
  // Override this to get events
};

proto.parseError = function (token, value) {
  this.onError(new Error("Unexpected " + toknam(token) + (value ? ("(" + JSON.stringify(value) + ")") : "") + " in state " + toknam(this.state)));
};
proto.onError = function (err) { throw err; };
proto.push = function () {
  this.stack.push({value: this.value, key: this.key, mode: this.mode});
};
proto.pop = function () {
  var value = this.value;
  var parent = this.stack.pop();
  this.value = parent.value;
  this.key = parent.key;
  this.mode = parent.mode;
  this.emit(value);
  if (!this.mode) { this.state = VALUE; }
};
proto.emit = function (value) {
  if (this.mode) { this.state = COMMA; }
  this.onValue(value);
};
proto.onValue = function (value) {
  // Override me
};  
proto.onToken = function (token, value) {
  //console.log("OnToken: state=%s token=%s %s", toknam(this.state), toknam(token), value?JSON.stringify(value):"");
  if(this.state === VALUE){
    if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){
      if (this.value) {
        this.value[this.key] = value;
      }
      this.emit(value);  
    }else if(token === LEFT_BRACE){
      this.push();
      if (this.value) {
        this.value = this.value[this.key] = {};
      } else {
        this.value = {};
      }
      this.key = undefined;
      this.state = KEY;
      this.mode = OBJECT;
    }else if(token === LEFT_BRACKET){
      this.push();
      if (this.value) {
        this.value = this.value[this.key] = [];
      } else {
        this.value = [];
      }
      this.key = 0;
      this.mode = ARRAY;
      this.state = VALUE;
    }else if(token === RIGHT_BRACE){
      if (this.mode === OBJECT) {
        this.pop();
      } else {
        this.parseError(token, value);
      }
    }else if(token === RIGHT_BRACKET){
      if (this.mode === ARRAY) {
        this.pop();
      } else {
        this.parseError(token, value);
      }
    }else{
      this.parseError(token, value);
    }
  }else if(this.state === KEY){
    if (token === STRING) {
      this.key = value;
      this.state = COLON;
    } else if (token === RIGHT_BRACE) {
      this.pop();
    } else {
      this.parseError(token, value);
    }
  }else if(this.state === COLON){
    if (token === COLON) { this.state = VALUE; }
    else { this.parseError(token, value); }
  }else if(this.state === COMMA){
    if (token === COMMA) { 
      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }
      else if (this.mode === OBJECT) { this.state = KEY; }

    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
      this.pop();
    } else {
      this.parseError(token, value);
    }
  }else{
    this.parseError(token, value);
  }
};

module.exports = Parser;

}).call(this,_dereq_("buffer").Buffer)
},{"buffer":23}],20:[function(_dereq_,module,exports){
/**
 * Standalone extraction of Backbone.Events, no external dependency required.
 * Degrades nicely when Backone/underscore are already available in the current
 * global context.
 *
 * Note that docs suggest to use underscore's `_.extend()` method to add Events
 * support to some given object. A `mixin()` method has been added to the Events
 * prototype to avoid using underscore for that sole purpose:
 *
 *     var myEventEmitter = BackboneEvents.mixin({});
 *
 * Or for a function constructor:
 *
 *     function MyConstructor(){}
 *     MyConstructor.prototype.foo = function(){}
 *     BackboneEvents.mixin(MyConstructor.prototype);
 *
 * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * (c) 2013 Nicolas Perriault
 */
/* global exports:true, define, module */
(function() {
  var root = this,
      breaker = {},
      nativeForEach = Array.prototype.forEach,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      slice = Array.prototype.slice,
      idCounter = 0;

  // Returns a partial implementation matching the minimal API subset required
  // by Backbone.Events
  function miniscore() {
    return {
      keys: Object.keys || function (obj) {
        if (typeof obj !== "object" && typeof obj !== "function" || obj === null) {
          throw new TypeError("keys() called on a non-object");
        }
        var key, keys = [];
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            keys[keys.length] = key;
          }
        }
        return keys;
      },

      uniqueId: function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      },

      has: function(obj, key) {
        return hasOwnProperty.call(obj, key);
      },

      each: function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, l = obj.length; i < l; i++) {
            if (iterator.call(context, obj[i], i, obj) === breaker) return;
          }
        } else {
          for (var key in obj) {
            if (this.has(obj, key)) {
              if (iterator.call(context, obj[key], key, obj) === breaker) return;
            }
          }
        }
      },

      once: function(func) {
        var ran = false, memo;
        return function() {
          if (ran) return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      }
    };
  }

  var _ = miniscore(), Events;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Mixin utility
  Events.mixin = function(proto) {
    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo',
                   'listenToOnce', 'bind', 'unbind'];
    _.each(exports, function(name) {
      proto[name] = this[name];
    }, this);
    return proto;
  };

  // Export Events as BackboneEvents depending on current context
  if (typeof define === "function") {
    define(function() {
      return Events;
    });
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Events;
    }
    exports.BackboneEvents = Events;
  } else {
    root.BackboneEvents = Events;
  }
})(this);

},{}],21:[function(_dereq_,module,exports){
module.exports = _dereq_('./backbone-events-standalone');

},{"./backbone-events-standalone":20}],22:[function(_dereq_,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   2.0.1
 */

(function() {
    "use strict";

    function $$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function $$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function $$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var $$utils$$_isArray;

    if (!Array.isArray) {
      $$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      $$utils$$_isArray = Array.isArray;
    }

    var $$utils$$isArray = $$utils$$_isArray;
    var $$utils$$now = Date.now || function() { return new Date().getTime(); };
    function $$utils$$F() { }

    var $$utils$$o_create = (Object.create || function (o) {
      if (arguments.length > 1) {
        throw new Error('Second argument not supported');
      }
      if (typeof o !== 'object') {
        throw new TypeError('Argument must be an object');
      }
      $$utils$$F.prototype = o;
      return new $$utils$$F();
    });

    var $$asap$$len = 0;

    var $$asap$$default = function asap(callback, arg) {
      $$asap$$queue[$$asap$$len] = callback;
      $$asap$$queue[$$asap$$len + 1] = arg;
      $$asap$$len += 2;
      if ($$asap$$len === 2) {
        // If len is 1, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        $$asap$$scheduleFlush();
      }
    };

    var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};
    var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;

    // test for web worker but not in IE10
    var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function $$asap$$useNextTick() {
      return function() {
        process.nextTick($$asap$$flush);
      };
    }

    function $$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function $$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = $$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function $$asap$$useSetTimeout() {
      return function() {
        setTimeout($$asap$$flush, 1);
      };
    }

    var $$asap$$queue = new Array(1000);

    function $$asap$$flush() {
      for (var i = 0; i < $$asap$$len; i+=2) {
        var callback = $$asap$$queue[i];
        var arg = $$asap$$queue[i+1];

        callback(arg);

        $$asap$$queue[i] = undefined;
        $$asap$$queue[i+1] = undefined;
      }

      $$asap$$len = 0;
    }

    var $$asap$$scheduleFlush;

    // Decide what async method to use to triggering processing of queued callbacks:
    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
      $$asap$$scheduleFlush = $$asap$$useNextTick();
    } else if ($$asap$$BrowserMutationObserver) {
      $$asap$$scheduleFlush = $$asap$$useMutationObserver();
    } else if ($$asap$$isWorker) {
      $$asap$$scheduleFlush = $$asap$$useMessageChannel();
    } else {
      $$asap$$scheduleFlush = $$asap$$useSetTimeout();
    }

    function $$$internal$$noop() {}
    var $$$internal$$PENDING   = void 0;
    var $$$internal$$FULFILLED = 1;
    var $$$internal$$REJECTED  = 2;
    var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();

    function $$$internal$$selfFullfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function $$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.')
    }

    function $$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        $$$internal$$GET_THEN_ERROR.error = error;
        return $$$internal$$GET_THEN_ERROR;
      }
    }

    function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function $$$internal$$handleForeignThenable(promise, thenable, then) {
       $$asap$$default(function(promise) {
        var sealed = false;
        var error = $$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            $$$internal$$resolve(promise, value);
          } else {
            $$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          $$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          $$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function $$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === $$$internal$$FULFILLED) {
        $$$internal$$fulfill(promise, thenable._result);
      } else if (promise._state === $$$internal$$REJECTED) {
        $$$internal$$reject(promise, thenable._result);
      } else {
        $$$internal$$subscribe(thenable, undefined, function(value) {
          $$$internal$$resolve(promise, value);
        }, function(reason) {
          $$$internal$$reject(promise, reason);
        });
      }
    }

    function $$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        $$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = $$$internal$$getThen(maybeThenable);

        if (then === $$$internal$$GET_THEN_ERROR) {
          $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          $$$internal$$fulfill(promise, maybeThenable);
        } else if ($$utils$$isFunction(then)) {
          $$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          $$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function $$$internal$$resolve(promise, value) {
      if (promise === value) {
        $$$internal$$reject(promise, $$$internal$$selfFullfillment());
      } else if ($$utils$$objectOrFunction(value)) {
        $$$internal$$handleMaybeThenable(promise, value);
      } else {
        $$$internal$$fulfill(promise, value);
      }
    }

    function $$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      $$$internal$$publish(promise);
    }

    function $$$internal$$fulfill(promise, value) {
      if (promise._state !== $$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = $$$internal$$FULFILLED;

      if (promise._subscribers.length === 0) {
      } else {
        $$asap$$default($$$internal$$publish, promise);
      }
    }

    function $$$internal$$reject(promise, reason) {
      if (promise._state !== $$$internal$$PENDING) { return; }
      promise._state = $$$internal$$REJECTED;
      promise._result = reason;

      $$asap$$default($$$internal$$publishRejection, promise);
    }

    function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + $$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + $$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        $$asap$$default($$$internal$$publish, parent);
      }
    }

    function $$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          $$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function $$$internal$$ErrorObject() {
      this.error = null;
    }

    var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();

    function $$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        $$$internal$$TRY_CATCH_ERROR.error = e;
        return $$$internal$$TRY_CATCH_ERROR;
      }
    }

    function $$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = $$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = $$$internal$$tryCatch(callback, detail);

        if (value === $$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== $$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        $$$internal$$resolve(promise, value);
      } else if (failed) {
        $$$internal$$reject(promise, error);
      } else if (settled === $$$internal$$FULFILLED) {
        $$$internal$$fulfill(promise, value);
      } else if (settled === $$$internal$$REJECTED) {
        $$$internal$$reject(promise, value);
      }
    }

    function $$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          $$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          $$$internal$$reject(promise, reason);
        });
      } catch(e) {
        $$$internal$$reject(promise, e);
      }
    }

    function $$$enumerator$$makeSettledResult(state, position, value) {
      if (state === $$$internal$$FULFILLED) {
        return {
          state: 'fulfilled',
          value: value
        };
      } else {
        return {
          state: 'rejected',
          reason: value
        };
      }
    }

    function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor($$$internal$$noop, label);
      this._abortOnReject = abortOnReject;

      if (this._validateInput(input)) {
        this._input     = input;
        this.length     = input.length;
        this._remaining = input.length;

        this._init();

        if (this.length === 0) {
          $$$internal$$fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate();
          if (this._remaining === 0) {
            $$$internal$$fulfill(this.promise, this._result);
          }
        }
      } else {
        $$$internal$$reject(this.promise, this._validationError());
      }
    }

    $$$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return $$utils$$isArray(input);
    };

    $$$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    $$$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var $$$enumerator$$default = $$$enumerator$$Enumerator;

    $$$enumerator$$Enumerator.prototype._enumerate = function() {
      var length  = this.length;
      var promise = this.promise;
      var input   = this._input;

      for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {
        this._eachEntry(input[i], i);
      }
    };

    $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var c = this._instanceConstructor;
      if ($$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {
          entry._onerror = null;
          this._settledAt(entry._state, i, entry._result);
        } else {
          this._willSettleAt(c.resolve(entry), i);
        }
      } else {
        this._remaining--;
        this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);
      }
    };

    $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var promise = this.promise;

      if (promise._state === $$$internal$$PENDING) {
        this._remaining--;

        if (this._abortOnReject && state === $$$internal$$REJECTED) {
          $$$internal$$reject(promise, value);
        } else {
          this._result[i] = this._makeResult(state, i, value);
        }
      }

      if (this._remaining === 0) {
        $$$internal$$fulfill(promise, this._result);
      }
    };

    $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
      return value;
    };

    $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      $$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt($$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt($$$internal$$REJECTED, i, reason);
      });
    };

    var $$promise$all$$default = function all(entries, label) {
      return new $$$enumerator$$default(this, entries, true /* abort on reject */, label).promise;
    };

    var $$promise$race$$default = function race(entries, label) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor($$$internal$$noop, label);

      if (!$$utils$$isArray(entries)) {
        $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        $$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        $$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {
        $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    };

    var $$promise$resolve$$default = function resolve(object, label) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor($$$internal$$noop, label);
      $$$internal$$resolve(promise, object);
      return promise;
    };

    var $$promise$reject$$default = function reject(reason, label) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor($$$internal$$noop, label);
      $$$internal$$reject(promise, reason);
      return promise;
    };

    var $$es6$promise$promise$$counter = 0;

    function $$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function $$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;

    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promises eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function $$es6$promise$promise$$Promise(resolver) {
      this._id = $$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if ($$$internal$$noop !== resolver) {
        if (!$$utils$$isFunction(resolver)) {
          $$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof $$es6$promise$promise$$Promise)) {
          $$es6$promise$promise$$needsNew();
        }

        $$$internal$$initializePromise(this, resolver);
      }
    }

    $$es6$promise$promise$$Promise.all = $$promise$all$$default;
    $$es6$promise$promise$$Promise.race = $$promise$race$$default;
    $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;
    $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;

    $$es6$promise$promise$$Promise.prototype = {
      constructor: $$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor($$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          $$asap$$default(function(){
            $$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          $$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };

    var $$es6$promise$polyfill$$default = function polyfill() {
      var local;

      if (typeof global !== 'undefined') {
        local = global;
      } else if (typeof window !== 'undefined' && window.document) {
        local = window;
      } else {
        local = self;
      }

      var es6PromiseSupport =
        "Promise" in local &&
        // Some of these methods are missing from
        // Firefox/Chrome experimental implementations
        "resolve" in local.Promise &&
        "reject" in local.Promise &&
        "all" in local.Promise &&
        "race" in local.Promise &&
        // Older version of the spec had a resolver object
        // as the arg rather than a function
        (function() {
          var resolve;
          new local.Promise(function(r) { resolve = r; });
          return $$utils$$isFunction(resolve);
        }());

      if (!es6PromiseSupport) {
        local.Promise = $$es6$promise$promise$$default;
      }
    };

    var es6$promise$umd$$ES6Promise = {
      'Promise': $$es6$promise$promise$$default,
      'polyfill': $$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = es6$promise$umd$$ES6Promise;
    }
}).call(this);
}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55}],23:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')
var isArray = _dereq_('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":24,"ieee754":25,"is-array":26}],24:[function(_dereq_,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],25:[function(_dereq_,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],26:[function(_dereq_,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],27:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],28:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],29:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],30:[function(_dereq_,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],31:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],32:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],33:[function(_dereq_,module,exports){
'use strict';

exports.decode = exports.parse = _dereq_('./decode');
exports.encode = exports.stringify = _dereq_('./encode');

},{"./decode":31,"./encode":32}],34:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":35}],35:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Readable = _dereq_('./_stream_readable');
var Writable = _dereq_('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./_stream_readable":37,"./_stream_writable":39,"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"core-util-is":40,"inherits":28}],36:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = _dereq_('./_stream_transform');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":38,"core-util-is":40,"inherits":28}],37:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = _dereq_('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = _dereq_('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = _dereq_('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = _dereq_('stream');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = _dereq_('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = _dereq_('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"buffer":23,"core-util-is":40,"events":27,"inherits":28,"isarray":29,"stream":45,"string_decoder/":46}],38:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = _dereq_('./_stream_duplex');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":35,"core-util-is":40,"inherits":28}],39:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = _dereq_('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Stream = _dereq_('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = _dereq_('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./_stream_duplex":35,"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"buffer":23,"core-util-is":40,"inherits":28,"stream":45}],40:[function(_dereq_,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,_dereq_("buffer").Buffer)
},{"buffer":23}],41:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":36}],42:[function(_dereq_,module,exports){
var Stream = _dereq_('stream'); // hack to fix a circular dependency issue when used with browserify
exports = module.exports = _dereq_('./lib/_stream_readable.js');
exports.Stream = Stream;
exports.Readable = exports;
exports.Writable = _dereq_('./lib/_stream_writable.js');
exports.Duplex = _dereq_('./lib/_stream_duplex.js');
exports.Transform = _dereq_('./lib/_stream_transform.js');
exports.PassThrough = _dereq_('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":35,"./lib/_stream_passthrough.js":36,"./lib/_stream_readable.js":37,"./lib/_stream_transform.js":38,"./lib/_stream_writable.js":39,"stream":45}],43:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":38}],44:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":39}],45:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = _dereq_('events').EventEmitter;
var inherits = _dereq_('inherits');

inherits(Stream, EE);
Stream.Readable = _dereq_('readable-stream/readable.js');
Stream.Writable = _dereq_('readable-stream/writable.js');
Stream.Duplex = _dereq_('readable-stream/duplex.js');
Stream.Transform = _dereq_('readable-stream/transform.js');
Stream.PassThrough = _dereq_('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":27,"inherits":28,"readable-stream/duplex.js":34,"readable-stream/passthrough.js":41,"readable-stream/readable.js":42,"readable-stream/transform.js":43,"readable-stream/writable.js":44}],46:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = _dereq_('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":23}],47:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = _dereq_('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = _dereq_('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":30,"querystring":33}],48:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],49:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":48,"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"inherits":28}],50:[function(_dereq_,module,exports){
var http = module.exports;
var EventEmitter = _dereq_('events').EventEmitter;
var Request = _dereq_('./lib/request');
var url = _dereq_('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }

    if (!params.protocol) {
        if (params.scheme) {
            params.protocol = params.scheme + ':';
        } else {
            params.protocol = window.location.protocol;
        }
    }

    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

http.STATUS_CODES = {
    100 : 'Continue',
    101 : 'Switching Protocols',
    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
    200 : 'OK',
    201 : 'Created',
    202 : 'Accepted',
    203 : 'Non-Authoritative Information',
    204 : 'No Content',
    205 : 'Reset Content',
    206 : 'Partial Content',
    207 : 'Multi-Status',               // RFC 4918
    300 : 'Multiple Choices',
    301 : 'Moved Permanently',
    302 : 'Moved Temporarily',
    303 : 'See Other',
    304 : 'Not Modified',
    305 : 'Use Proxy',
    307 : 'Temporary Redirect',
    400 : 'Bad Request',
    401 : 'Unauthorized',
    402 : 'Payment Required',
    403 : 'Forbidden',
    404 : 'Not Found',
    405 : 'Method Not Allowed',
    406 : 'Not Acceptable',
    407 : 'Proxy Authentication Required',
    408 : 'Request Time-out',
    409 : 'Conflict',
    410 : 'Gone',
    411 : 'Length Required',
    412 : 'Precondition Failed',
    413 : 'Request Entity Too Large',
    414 : 'Request-URI Too Large',
    415 : 'Unsupported Media Type',
    416 : 'Requested Range Not Satisfiable',
    417 : 'Expectation Failed',
    418 : 'I\'m a teapot',              // RFC 2324
    422 : 'Unprocessable Entity',       // RFC 4918
    423 : 'Locked',                     // RFC 4918
    424 : 'Failed Dependency',          // RFC 4918
    425 : 'Unordered Collection',       // RFC 4918
    426 : 'Upgrade Required',           // RFC 2817
    428 : 'Precondition Required',      // RFC 6585
    429 : 'Too Many Requests',          // RFC 6585
    431 : 'Request Header Fields Too Large',// RFC 6585
    500 : 'Internal Server Error',
    501 : 'Not Implemented',
    502 : 'Bad Gateway',
    503 : 'Service Unavailable',
    504 : 'Gateway Time-out',
    505 : 'HTTP Version Not Supported',
    506 : 'Variant Also Negotiates',    // RFC 2295
    507 : 'Insufficient Storage',       // RFC 4918
    509 : 'Bandwidth Limit Exceeded',
    510 : 'Not Extended',               // RFC 2774
    511 : 'Network Authentication Required' // RFC 6585
};
},{"./lib/request":51,"events":27,"url":47}],51:[function(_dereq_,module,exports){
var Stream = _dereq_('stream');
var Response = _dereq_('./response');
var Base64 = _dereq_('Base64');
var inherits = _dereq_('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.protocol || 'http:') + '//'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    if (typeof params.withCredentials === 'undefined') {
        params.withCredentials = true;
    }

    try { xhr.withCredentials = params.withCredentials }
    catch (e) {}
    
    if (params.responseType) try { xhr.responseType = params.responseType }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );

    xhr.onerror = function(event) {
        self.emit('error', new Error('Network error'));
    };

    self._headers = {};
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            self.setHeader(key, value);
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });

    res.on('error', function (err) {
        self.emit('error', err);
    });
    
    xhr.onreadystatechange = function () {
        // Fix for IE9 bug
        // SCRIPT575: Could not complete the operation due to error c00c023f
        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
        if (xhr.__aborted) return;
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    this._headers[key.toLowerCase()] = value
};

Request.prototype.getHeader = function (key) {
    return this._headers[key.toLowerCase()]
};

Request.prototype.removeHeader = function (key) {
    delete this._headers[key.toLowerCase()]
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);

    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = this._headers[key];
        if (isArray(value)) {
            for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
            }
        }
        else this.xhr.setRequestHeader(key, value)
    }

    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else if (isXHR2Compatible(this.body[0])) {
        this.xhr.send(this.body[0]);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

var isXHR2Compatible = function (obj) {
    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
};

},{"./response":52,"Base64":53,"inherits":54,"stream":45}],52:[function(_dereq_,module,exports){
var Stream = _dereq_('stream');
var util = _dereq_('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":45,"util":49}],53:[function(_dereq_,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],54:[function(_dereq_,module,exports){
module.exports=_dereq_(28)
},{"/home/alex/projects/javascript/imjs/node_modules/grunt-browserify/node_modules/browserify/node_modules/inherits/inherits_browser.js":28}],55:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.once = noop;
process.off = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],56:[function(_dereq_,module,exports){
(function (process){
var Stream = _dereq_('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data == null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"stream":45}]},{},[2])(2)
});
})(window.intermine);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],7:[function(require,module,exports){
var cymine = {
  toNodesAndEdges : function(records, parentNode){
    var d = {
      nodes : [],
      edges : []
    };

    for (var i in records) {
      var thisNode, row = records[i];
      thisNode = this.recordToNode(row);

      if(row.interactions) {
        //recursively make the interactions into nodes,
        //because node entities are nested at two levels.
        d = this.mergeObjects(d, this.toNodesAndEdges(row.interactions, thisNode));
      } else {
        //if it doesn't have an interaction list, it probably *is* an interaction
        //and thus needs to be an edge
        d.edges.push(this.interactionToEdge(parentNode, thisNode));

      }
      d.nodes.push(thisNode);

    }

    return d;
  },
  recordToNode : function (obj) {
    var ret;
    ret = obj.gene2 ? obj.gene2 : obj;
    return {
      data : {
        class : ret.class,
        label : this.nameNode(obj),
        symbol : ret.symbol,
        id : ret.objectId.toString() //cytoscape needs strings
      }
    }
  },
  nameNode : function(obj) {
    if (obj.gene2 && obj.gene2.symbol) {
      return obj.gene2.symbol;
    } else if (obj.symbol) {
      return obj.symbol;
    } else if (obj.details) {
      return obj.details[0].name;
    } else {
      return "NAME MISSING"
    }
  },
  interactionToEdge : function(node, node2) {
    //todo: we almost certainly want to add more complexity to the return object
    return {
      data : {
        source : node.data.id,
        target : node2.data.id
      }
    };
  },
  /**
  * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
  * @param obj1
  * @param obj2
  * @returns obj3 a new object based on obj1 and obj2
  */

  //TODO: make sure we handle edge cases better, e.g. duplicate values.
  mergeObjects : function(obj1,obj2){
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }
    return obj3;
  }

};

module.exports = cymine;

},{}],8:[function(require,module,exports){
var cymine = require('./cymine'),
cytoscape = require('./../bower_components/cytoscape/dist/cytoscape'),
imjs = require('./../bower_components/imjs/js/im.js');

//Todo: generify query.
var cy, humanmine = new imjs.Service({root: 'www.humanmine.org/humanmine'}),
query = {
  "name": "Gene_Interactions",
  "title": "Gene --> Interactions",
  "description": "Show all interactions for a given gene.",
  "constraintLogic": "A and B",
  "from": "Gene",
  "select": [
    "symbol",
    "interactions.gene2.symbol",
    "interactions.details.name",
    "interactions.details.role1",
    "interactions.details.role2",
    "interactions.details.type",
    "interactions.details.experiment.interactionDetectionMethods.name",
    "interactions.details.experiment.publication.pubMedId",
    "interactions.details.relationshipType.name",
    "interactions.details.dataSets.name"
  ],
  "orderBy": [
    {
      "path": "symbol",
      "direction": "ASC"
    }
  ],
  "where": [
    {
      "path": "Gene",
      "op": "LOOKUP",
      "value": "PPARG",
      "extraValue": "H. sapiens",
      "code": "A",
      "editable": true,
      "switched": "LOCKED",
      "switchable": false
    }
  ]
};

humanmine.records(query).then(function(response) {
  if (response) {
    try {

      var graph = {};
        graph.data = cymine.toNodesAndEdges(response),
        graph.targetElem = document.getElementById('cy'),
        graph.statusBar = graph.targetElem.querySelector('.status');

      console.debug('response:', response, 'graph data', graph.data);

      cy = cytoscape({
        container: graph.targetElem,
        layout: { name: 'cose'},
        style: [
          {
            selector: 'node',
            style: {
              'content': 'data(label)',
            }
          }
        ],
        elements: graph.data,
        ready: function(){
          window.cy = this;
          graph.statusBar.remove();
          }
      });

    } catch(e) {console.error(e);}
  } else {
    graph.statusBar.class = "status no-results";
  }
});

},{"./../bower_components/cytoscape/dist/cytoscape":5,"./../bower_components/imjs/js/im.js":6,"./cymine":7}]},{},[8])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy5udm0vdmVyc2lvbnMvbm9kZS92MC4xMi43L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uLy4uLy4uLy5udm0vdmVyc2lvbnMvbm9kZS92MC4xMi43L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIi4uLy4uLy4uLy5udm0vdmVyc2lvbnMvbm9kZS92MC4xMi43L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL29zLWJyb3dzZXJpZnkvYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy5udm0vdmVyc2lvbnMvbm9kZS92MC4xMi43L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLy4uLy5udm0vdmVyc2lvbnMvbm9kZS92MC4xMi43L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uL2Jvd2VyX2NvbXBvbmVudHMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLmpzIiwiLi4vYm93ZXJfY29tcG9uZW50cy9pbWpzL2pzL2ltLmpzIiwiY3ltaW5lLmpzIiwibWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeGt6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1L1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIixudWxsLCJleHBvcnRzLmVuZGlhbm5lc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnTEUnIH07XG5cbmV4cG9ydHMuaG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lXG4gICAgfVxuICAgIGVsc2UgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5sb2FkYXZnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy51cHRpbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbmV4cG9ydHMuZnJlZW1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMudG90YWxtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLmNwdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnQnJvd3NlcicgfTtcblxuZXhwb3J0cy5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXNcbj0gZXhwb3J0cy5nZXROZXR3b3JrSW50ZXJmYWNlc1xuPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7fSB9O1xuXG5leHBvcnRzLmFyY2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnamF2YXNjcmlwdCcgfTtcblxuZXhwb3J0cy5wbGF0Zm9ybSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdicm93c2VyJyB9O1xuXG5leHBvcnRzLnRtcGRpciA9IGV4cG9ydHMudG1wRGlyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnL3RtcCc7XG59O1xuXG5leHBvcnRzLkVPTCA9ICdcXG4nO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qIVxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgQ3l0b3NjYXBlLmpzIDIuNC40LlxuICogXG4gKiBDeXRvc2NhcGUuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlXG4gKiBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueVxuICogbGF0ZXIgdmVyc2lvbi5cbiAqIFxuICogQ3l0b3NjYXBlLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTU1xuICogRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZVxuICogZGV0YWlscy5cbiAqIFxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAqIEN5dG9zY2FwZS5qcy4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4gXG5cbi8vIHRoaXMgaXMgcHV0IGFzIGEgZ2xvYmFsIHZhciBpbiB0aGUgYnJvd3NlclxuLy8gb3IgaXQncyBqdXN0IGEgZ2xvYmFsIHRvIHRoaXMgbW9kdWxlIGlmIGNvbW1vbmpzXG5cbnZhciBjeXRvc2NhcGU7XG5cbihmdW5jdGlvbih3aW5kb3cpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gdGhlIG9iamVjdCBpdGVzZWxmIGlzIGEgZnVuY3Rpb24gdGhhdCBpbml0J3MgYW4gaW5zdGFuY2Ugb2YgY3l0b3NjYXBlXG5cbiAgdmFyICQkID0gY3l0b3NjYXBlID0gZnVuY3Rpb24oKXsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgcmV0dXJuIGN5dG9zY2FwZS5pbml0LmFwcGx5KGN5dG9zY2FwZSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAkJC52ZXJzaW9uID0gJzIuNC40JztcbiAgXG4gIC8vIGFsbG93IGZ1bmN0aW9uYWwgYWNjZXNzIHRvIGN5dG9zY2FwZS5qc1xuICAvLyBlLmcuIHZhciBjeXRvID0gJC5jeXRvc2NhcGUoeyBzZWxlY3RvcjogXCIjZm9vXCIsIC4uLiB9KTtcbiAgLy8gICAgICB2YXIgbm9kZXMgPSBjeXRvLm5vZGVzKCk7XG4gICQkLmluaXQgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIFxuICAgIC8vIGlmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxuICAgIGlmKCBvcHRpb25zID09PSB1bmRlZmluZWQgKXtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgaW5zdGFuY2VcbiAgICBpZiggJCQuaXMucGxhaW5PYmplY3QoIG9wdGlvbnMgKSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5Db3JlKCBvcHRpb25zICk7XG4gICAgfSBcbiAgICBcbiAgICAvLyBhbGxvdyBmb3IgcmVnaXN0cmF0aW9uIG9mIGV4dGVuc2lvbnNcbiAgICAvLyBlLmcuICQuY3l0b3NjYXBlKCdyZW5kZXJlcicsICdzdmcnLCBTdmdSZW5kZXJlcik7XG4gICAgLy8gZS5nLiAkLmN5dG9zY2FwZSgncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVzaGFwZScsICdlbGxpcHNlJywgU3ZnRWxsaXBzZU5vZGVTaGFwZSk7XG4gICAgLy8gZS5nLiAkLmN5dG9zY2FwZSgnY29yZScsICdkb1NvbWV0aGluZycsIGZ1bmN0aW9uKCl7IC8qIGRvU29tZXRoaW5nIGNvZGUgKi8gfSk7XG4gICAgLy8gZS5nLiAkLmN5dG9zY2FwZSgnY29sbGVjdGlvbicsICdkb1NvbWV0aGluZycsIGZ1bmN0aW9uKCl7IC8qIGRvU29tZXRoaW5nIGNvZGUgKi8gfSk7XG4gICAgZWxzZSBpZiggJCQuaXMuc3RyaW5nKCBvcHRpb25zICkgKSB7XG4gICAgICByZXR1cm4gJCQuZXh0ZW5zaW9uLmFwcGx5KCQkLmV4dGVuc2lvbiwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZGVmaW5lIHRoZSBmdW5jdGlvbiBuYW1lc3BhY2UgaGVyZSwgc2luY2UgaXQgaGFzIG1lbWJlcnMgaW4gbWFueSBwbGFjZXNcbiAgJCQuZm4gPSB7fTtcblxuICBpZiggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKXsgLy8gZXhwb3NlIGFzIGEgY29tbW9uanMgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjeXRvc2NhcGU7XG4gIH1cblxuICBpZiggdHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCApeyAvLyBleHBvc2UgYXMgYW4gYW1kL3JlcXVpcmVqcyBtb2R1bGVcbiAgICBkZWZpbmUoJ2N5dG9zY2FwZScsIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gY3l0b3NjYXBlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIGFsd2F5cyByZWdpc3RlciBpbiB0aGUgd2luZG93IGp1c3QgaW4gY2FzZSAoZS5nLiB3LyBkZXJieWpzKVxuICBpZiggd2luZG93ICl7XG4gICAgd2luZG93LmN5dG9zY2FwZSA9IGN5dG9zY2FwZTtcbiAgfVxuICBcbn0pKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuLy8gZXh0cmEgc2V0IHRvIGB0aGlzYCBpcyBuZWNlc3NhcnkgZm9yIG1ldGVvclxudGhpcy5jeXRvc2NhcGUgPSBjeXRvc2NhcGU7XG5cbi8vIGludGVybmFsLCBtaW5pbWFsIFByb21pc2UgaW1wbCBzLnQuIGFwaXMgY2FuIHJldHVybiBwcm9taXNlcyBpbiBvbGQgZW52c1xuLy8gYmFzZWQgb24gdGhlbmFibGUgKGh0dHA6Ly9naXRodWIuY29tL3JzZS90aGVuYWJsZSlcblxuLy8gTkI6IHlvdSBtdXN0IHVzZSBgbmV3ICQkLlByb21pc2VgLCBiZWNhdXNlIHlvdSBtYXkgaGF2ZSBuYXRpdmUgcHJvbWlzZXMgdGhhdCBkb24ndCBhdXRvbmV3IGZvciB5b3VcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8qICBwcm9taXNlIHN0YXRlcyBbUHJvbWlzZXMvQSsgMi4xXSAgKi9cbiAgdmFyIFNUQVRFX1BFTkRJTkcgICA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4xXSAgKi9cbiAgdmFyIFNUQVRFX0ZVTEZJTExFRCA9IDE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yXSAgKi9cbiAgdmFyIFNUQVRFX1JFSkVDVEVEICA9IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4zXSAgKi9cblxuICAvKiAgcHJvbWlzZSBvYmplY3QgY29uc3RydWN0b3IgICovXG4gIHZhciBhcGkgPSBmdW5jdGlvbiAoZXhlY3V0b3IpIHtcbiAgICAvKiAgb3B0aW9uYWxseSBzdXBwb3J0IG5vbi1jb25zdHJ1Y3Rvci9wbGFpbi1mdW5jdGlvbiBjYWxsICAqL1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBhcGkpKVxuICAgICAgcmV0dXJuIG5ldyBhcGkoZXhlY3V0b3IpO1xuXG4gICAgLyogIGluaXRpYWxpemUgb2JqZWN0ICAqL1xuICAgIHRoaXMuaWQgICAgICAgICAgID0gXCJUaGVuYWJsZS8xLjAuN1wiO1xuICAgIHRoaXMuc3RhdGUgICAgICAgID0gU1RBVEVfUEVORElORzsgLyogIGluaXRpYWwgc3RhdGUgICovXG4gICAgdGhpcy5mdWxmaWxsVmFsdWUgPSB1bmRlZmluZWQ7ICAgICAvKiAgaW5pdGlhbCB2YWx1ZSAgKi8gICAgIC8qICBbUHJvbWlzZXMvQSsgMS4zLCAyLjEuMi4yXSAgKi9cbiAgICB0aGlzLnJlamVjdFJlYXNvbiA9IHVuZGVmaW5lZDsgICAgIC8qICBpbml0aWFsIHJlYXNvbiAqLyAgICAgLyogIFtQcm9taXNlcy9BKyAxLjUsIDIuMS4zLjJdICAqL1xuICAgIHRoaXMub25GdWxmaWxsZWQgID0gW107ICAgICAgICAgICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG4gICAgdGhpcy5vblJlamVjdGVkICAgPSBbXTsgICAgICAgICAgICAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cblxuICAgIC8qICBwcm92aWRlIG9wdGlvbmFsIGluZm9ybWF0aW9uLWhpZGluZyBwcm94eSAgKi9cbiAgICB0aGlzLnByb3h5ID0ge1xuICAgICAgdGhlbjogdGhpcy50aGVuLmJpbmQodGhpcylcbiAgICB9O1xuXG4gICAgLyogIHN1cHBvcnQgb3B0aW9uYWwgZXhlY3V0b3IgZnVuY3Rpb24gICovXG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZXhlY3V0b3IuY2FsbCh0aGlzLCB0aGlzLmZ1bGZpbGwuYmluZCh0aGlzKSwgdGhpcy5yZWplY3QuYmluZCh0aGlzKSk7XG4gIH07XG5cbiAgLyogIHByb21pc2UgQVBJIG1ldGhvZHMgICovXG4gIGFwaS5wcm90b3R5cGUgPSB7XG4gICAgLyogIHByb21pc2UgcmVzb2x2aW5nIG1ldGhvZHMgICovXG4gICAgZnVsZmlsbDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX0ZVTEZJTExFRCwgXCJmdWxmaWxsVmFsdWVcIiwgdmFsdWUpOyB9LFxuICAgIHJlamVjdDogIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9SRUpFQ1RFRCwgIFwicmVqZWN0UmVhc29uXCIsIHZhbHVlKTsgfSxcblxuICAgIC8qICBcIlRoZSB0aGVuIE1ldGhvZFwiIFtQcm9taXNlcy9BKyAxLjEsIDEuMiwgMi4yXSAgKi9cbiAgICB0aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciBjdXJyID0gdGhpcztcbiAgICAgIHZhciBuZXh0ID0gbmV3IGFwaSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjddICAqL1xuICAgICAgY3Vyci5vbkZ1bGZpbGxlZC5wdXNoKFxuICAgICAgICByZXNvbHZlcihvbkZ1bGZpbGxlZCwgbmV4dCwgXCJmdWxmaWxsXCIpKTsgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi8yLjIuNl0gICovXG4gICAgICBjdXJyLm9uUmVqZWN0ZWQucHVzaChcbiAgICAgICAgcmVzb2x2ZXIob25SZWplY3RlZCwgIG5leHQsIFwicmVqZWN0XCIgKSk7ICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjMvMi4yLjZdICAqL1xuICAgICAgZXhlY3V0ZShjdXJyKTtcbiAgICAgIHJldHVybiBuZXh0LnByb3h5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcsIDMuM10gICovXG4gICAgfVxuICB9O1xuXG4gIC8qICBkZWxpdmVyIGFuIGFjdGlvbiAgKi9cbiAgdmFyIGRlbGl2ZXIgPSBmdW5jdGlvbiAoY3Vyciwgc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1BFTkRJTkcpIHtcbiAgICAgIGN1cnIuc3RhdGUgPSBzdGF0ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMSwgMi4xLjMuMV0gICovXG4gICAgICBjdXJyW25hbWVdID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjIsIDIuMS4zLjJdICAqL1xuICAgICAgZXhlY3V0ZShjdXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnI7XG4gIH07XG5cbiAgLyogIGV4ZWN1dGUgYWxsIGhhbmRsZXJzICAqL1xuICB2YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uIChjdXJyKSB7XG4gICAgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX0ZVTEZJTExFRClcbiAgICAgIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgXCJvbkZ1bGZpbGxlZFwiLCBjdXJyLmZ1bGZpbGxWYWx1ZSk7XG4gICAgZWxzZSBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUkVKRUNURUQpXG4gICAgICBleGVjdXRlX2hhbmRsZXJzKGN1cnIsIFwib25SZWplY3RlZFwiLCAgY3Vyci5yZWplY3RSZWFzb24pO1xuICB9O1xuXG4gIC8qICBleGVjdXRlIHBhcnRpY3VsYXIgc2V0IG9mIGhhbmRsZXJzICAqL1xuICB2YXIgZXhlY3V0ZV9oYW5kbGVycyA9IGZ1bmN0aW9uIChjdXJyLCBuYW1lLCB2YWx1ZSkge1xuICAgIC8qIGdsb2JhbCBwcm9jZXNzOiB0cnVlICovXG4gICAgLyogZ2xvYmFsIHNldEltbWVkaWF0ZTogdHJ1ZSAqL1xuICAgIC8qIGdsb2JhbCBzZXRUaW1lb3V0OiB0cnVlICovXG5cbiAgICAvKiAgc2hvcnQtY2lyY3VpdCBwcm9jZXNzaW5nICAqL1xuICAgIGlmIChjdXJyW25hbWVdLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcblxuICAgIC8qICBpdGVyYXRlIG92ZXIgYWxsIGhhbmRsZXJzLCBleGFjdGx5IG9uY2UgICovXG4gICAgdmFyIGhhbmRsZXJzID0gY3VycltuYW1lXTtcbiAgICBjdXJyW25hbWVdID0gW107ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi4zLCAyLjIuMy4zXSAgKi9cbiAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGhhbmRsZXJzW2ldKHZhbHVlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNV0gICovXG4gICAgfTtcblxuICAgIC8qICBleGVjdXRlIHByb2NlZHVyZSBhc3luY2hyb25vdXNseSAgKi8gICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi40LCAzLjFdICAqL1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jKTtcbiAgICBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBzZXRJbW1lZGlhdGUoZnVuYyk7XG4gICAgZWxzZVxuICAgICAgc2V0VGltZW91dChmdW5jLCAwKTtcbiAgfTtcblxuICAvKiAgZ2VuZXJhdGUgYSByZXNvbHZlciBmdW5jdGlvbiAgKi9cbiAgdmFyIHJlc29sdmVyID0gZnVuY3Rpb24gKGNiLCBuZXh0LCBtZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjEsIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgICAgICBuZXh0W21ldGhvZF0uY2FsbChuZXh0LCB2YWx1ZSk7ICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHsgcmVzdWx0ID0gY2IodmFsdWUpOyB9ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjEsIDIuMi4zLjEsIDIuMi41LCAzLjJdICAqL1xuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIG5leHQucmVqZWN0KGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjJdICAqL1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKG5leHQsIHJlc3VsdCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMV0gICovXG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvKiAgXCJQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXCIgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjNdICAqL1xuICB2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB4KSB7XG4gICAgLyogIHNhbml0eSBjaGVjayBhcmd1bWVudHMgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjFdICAqL1xuICAgIGlmIChwcm9taXNlID09PSB4IHx8IHByb21pc2UucHJveHkgPT09IHgpIHtcbiAgICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiAgc3VyZ2ljYWxseSBjaGVjayBmb3IgYSBcInRoZW5cIiBtZXRob2RcbiAgICAgIChtYWlubHkgdG8ganVzdCBjYWxsIHRoZSBcImdldHRlclwiIG9mIFwidGhlblwiIG9ubHkgb25jZSkgICovXG4gICAgdmFyIHRoZW47XG4gICAgaWYgKCh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsKSB8fCB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0cnkgeyB0aGVuID0geC50aGVuOyB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjEsIDMuNV0gICovXG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBwcm9taXNlLnJlamVjdChlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMl0gICovXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAgaGFuZGxlIG93biBUaGVuYWJsZXMgICAgW1Byb21pc2VzL0ErIDIuMy4yXVxuICAgICAgYW5kIHNpbWlsYXIgXCJ0aGVuYWJsZXNcIiBbUHJvbWlzZXMvQSsgMi4zLjNdICAqL1xuICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8qICBjYWxsIHJldHJpZXZlZCBcInRoZW5cIiBtZXRob2QgKi8gICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjNdICAqL1xuICAgICAgICB0aGVuLmNhbGwoeCxcbiAgICAgICAgICAvKiAgcmVzb2x2ZVByb21pc2UgICovICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjFdICAqL1xuICAgICAgICAgIGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjsgcmVzb2x2ZWQgPSB0cnVlOyAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgICAgICBpZiAoeSA9PT0geCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDMuNl0gICovXG4gICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJjaXJjdWxhciB0aGVuYWJsZSBjaGFpblwiKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZSwgeSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qICByZWplY3RQcm9taXNlICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMl0gICovXG4gICAgICAgICAgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuOyByZXNvbHZlZCA9IHRydWU7ICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuNF0gICovXG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyogIGhhbmRsZSBvdGhlciB2YWx1ZXMgICovXG4gICAgcHJvbWlzZS5mdWxmaWxsKHgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjQsIDIuMy4zLjRdICAqL1xuICB9O1xuXG4gIC8vIHVzZSBuYXRpdmUgcHJvbWlzZXMgd2hlcmUgcG9zc2libGVcbiAgJCQuUHJvbWlzZSA9IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IGFwaSA6IFByb21pc2U7XG5cbiAgLy8gc28gd2UgYWx3YXlzIGhhdmUgUHJvbWlzZS5hbGwoKVxuICAkJC5Qcm9taXNlLmFsbCA9ICQkLlByb21pc2UuYWxsIHx8IGZ1bmN0aW9uKCBwcyApe1xuICAgIHJldHVybiBuZXcgJCQuUHJvbWlzZShmdW5jdGlvbiggcmVzb2x2ZUFsbCwgcmVqZWN0QWxsICl7XG4gICAgICB2YXIgdmFscyA9IG5ldyBBcnJheSggcHMubGVuZ3RoICk7XG4gICAgICB2YXIgZG9uZUNvdW50ID0gMDtcblxuICAgICAgdmFyIGZ1bGZpbGwgPSBmdW5jdGlvbiggaSwgdmFsICl7XG4gICAgICAgIHZhbHNbaV0gPSB2YWw7XG4gICAgICAgIGRvbmVDb3VudCsrO1xuXG4gICAgICAgIGlmKCBkb25lQ291bnQgPT09IHBzLmxlbmd0aCApe1xuICAgICAgICAgIHJlc29sdmVBbGwoIHZhbHMgKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAoZnVuY3Rpb24oIGkgKXtcbiAgICAgICAgICB2YXIgcCA9IHBzW2ldO1xuICAgICAgICAgIHZhciBpc1Byb21pc2UgPSBwLnRoZW4gIT0gbnVsbDtcblxuICAgICAgICAgIGlmKCBpc1Byb21pc2UgKXtcbiAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiggdmFsICl7XG4gICAgICAgICAgICAgIGZ1bGZpbGwoIGksIHZhbCApO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oIGVyciApe1xuICAgICAgICAgICAgICByZWplY3RBbGwoIGVyciApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBwO1xuICAgICAgICAgICAgZnVsZmlsbCggaSwgdmFsICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSggaSApO1xuICAgICAgfVxuXG4gICAgfSk7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbi8vIHR5cGUgdGVzdGluZyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG47KGZ1bmN0aW9uKCQkLCB3aW5kb3cpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHR5cGVvZnN0ciA9IHR5cGVvZiAnJztcbiAgdmFyIHR5cGVvZm9iaiA9IHR5cGVvZiB7fTtcbiAgdmFyIHR5cGVvZmZuID0gdHlwZW9mIGZ1bmN0aW9uKCl7fTtcblxuICAkJC5pcyA9IHtcbiAgICBkZWZpbmVkOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsOyAvLyBub3QgdW5kZWZpbmVkIG9yIG51bGxcbiAgICB9LFxuXG4gICAgc3RyaW5nOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT0gdHlwZW9mc3RyO1xuICAgIH0sXG4gICAgXG4gICAgZm46IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mZm47XG4gICAgfSxcbiAgICBcbiAgICBhcnJheTogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShvYmopIDogb2JqICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXk7XG4gICAgfSxcbiAgICBcbiAgICBwbGFpbk9iamVjdDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2ZvYmogJiYgISQkLmlzLmFycmF5KG9iaikgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gICAgfSxcblxuICAgIG9iamVjdDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2ZvYmo7XG4gICAgfSxcbiAgICBcbiAgICBudW1iZXI6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mIDEgJiYgIWlzTmFOKG9iaik7XG4gICAgfSxcblxuICAgIGludGVnZXI6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICAgIHJldHVybiAkJC5pcy5udW1iZXIob2JqKSAmJiBNYXRoLmZsb29yKG9iaikgPT09IG9iajtcbiAgICB9LFxuICAgIFxuICAgIGNvbG9yOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZiAnJyAmJiAkLkNvbG9yKG9iaikudG9TdHJpbmcoKSAhPT0gJyc7XG4gICAgfSxcbiAgICBcbiAgICBib29sOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZiB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgZWxlbWVudE9yQ29sbGVjdGlvbjogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiAkJC5pcy5lbGVtZW50KG9iaikgfHwgJCQuaXMuY29sbGVjdGlvbihvYmopO1xuICAgIH0sXG4gICAgXG4gICAgZWxlbWVudDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5FbGVtZW50ICYmIG9iai5fcHJpdmF0ZS5zaW5nbGU7XG4gICAgfSxcbiAgICBcbiAgICBjb2xsZWN0aW9uOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLkNvbGxlY3Rpb24gJiYgIW9iai5fcHJpdmF0ZS5zaW5nbGU7XG4gICAgfSxcbiAgICBcbiAgICBjb3JlOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLkNvcmU7XG4gICAgfSxcblxuICAgIHN0eWxlOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLlN0eWxlO1xuICAgIH0sXG5cbiAgICBzdHlsZXNoZWV0OiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLlN0eWxlc2hlZXQ7XG4gICAgfSxcblxuICAgIGV2ZW50OiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLkV2ZW50O1xuICAgIH0sXG5cbiAgICB0aHJlYWQ6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgJCQuVGhyZWFkO1xuICAgIH0sXG5cbiAgICBmYWJyaWM6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgJCQuRmFicmljO1xuICAgIH0sXG5cbiAgICBlbXB0eVN0cmluZzogZnVuY3Rpb24ob2JqKXtcbiAgICAgIGlmKCAhb2JqICl7IC8vIG51bGwgaXMgZW1wdHlcbiAgICAgICAgcmV0dXJuIHRydWU7IFxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcob2JqKSApe1xuICAgICAgICBpZiggb2JqID09PSAnJyB8fCBvYmoubWF0Y2goL15cXHMrJC8pICl7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGVtcHR5IHN0cmluZyBpcyBlbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gb3RoZXJ3aXNlLCB3ZSBkb24ndCBrbm93IHdoYXQgd2UndmUgZ290XG4gICAgfSxcbiAgICBcbiAgICBub25lbXB0eVN0cmluZzogZnVuY3Rpb24ob2JqKXtcbiAgICAgIGlmKCBvYmogJiYgJCQuaXMuc3RyaW5nKG9iaikgJiYgb2JqICE9PSAnJyAmJiAhb2JqLm1hdGNoKC9eXFxzKyQvKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBkb21FbGVtZW50OiBmdW5jdGlvbihvYmope1xuICAgICAgaWYoIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSBub3QgaW4gYSBicm93c2VyIHNvIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGJvdW5kaW5nQm94OiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuICQkLmlzLnBsYWluT2JqZWN0KG9iaikgJiYgXG4gICAgICAgICQkLmlzLm51bWJlcihvYmoueDEpICYmICQkLmlzLm51bWJlcihvYmoueDIpICYmXG4gICAgICAgICQkLmlzLm51bWJlcihvYmoueTEpICYmICQkLmlzLm51bWJlcihvYmoueTIpXG4gICAgICA7XG4gICAgfSxcblxuICAgIHByb21pc2U6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gJCQuaXMub2JqZWN0KG9iaikgJiYgJCQuaXMuZm4ob2JqLnRoZW4pO1xuICAgIH0sXG5cbiAgICB0b3VjaDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB3aW5kb3cgJiYgKCAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2ggKTtcbiAgICB9LFxuXG4gICAgZ2Vja286IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJyB8fCAoJ01vekFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG4gICAgfSxcblxuICAgIHdlYmtpdDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2Ygd2Via2l0VVJMICE9PSAndW5kZWZpbmVkJyB8fCAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG4gICAgfSxcblxuICAgIGNocm9taXVtOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH0sXG5cbiAgICBraHRtbDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBuYXZpZ2F0b3IudmVuZG9yLm1hdGNoKC9rZGUvaSk7IC8vIFRPRE8gcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvIGRldGVjdCB0aGlzLi4uXG4gICAgfSxcblxuICAgIGtodG1sRXRjOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuICQkLmlzLmtodG1sKCkgfHwgJCQuaXMud2Via2l0KCkgfHwgJCQuaXMuY2hyb21pdW0oKTtcbiAgICB9LFxuXG4gICAgdHJpZGVudDogZnVuY3Rpb24oKXtcbiAgICAgICByZXR1cm4gdHlwZW9mIEFjdGl2ZVhPYmplY3QgIT09ICd1bmRlZmluZWQnIHx8IC8qQGNjX29uIUAqL2ZhbHNlO1xuICAgIH0sXG5cbiAgICB3aW5kb3dzOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9XaW4vaSk7XG4gICAgfSxcblxuICAgIG1hYzogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvTWFjL2kpO1xuICAgIH0sXG5cbiAgICBsaW51eDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvTGludXgvaSk7XG4gICAgfSxcblxuICAgIHVuaXg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL1gxMS9pKTtcbiAgICB9XG4gIH07ICBcbiAgXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gdXRpbGl0eSBmdW5jdGlvbnMgb25seSBmb3IgaW50ZXJuYWwgdXNlXG5cbiAgJCQudXRpbCA9IHtcblxuICAgIC8vIHRoZSBqcXVlcnkgZXh0ZW5kKCkgZnVuY3Rpb25cbiAgICAvLyBOQjogbW9kaWZpZWQgdG8gdXNlICQkLmlzIGV0YyBzaW5jZSB3ZSBjYW4ndCB1c2UganF1ZXJ5IGZ1bmN0aW9uc1xuICAgIGV4dGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGRlZXAgPSBmYWxzZTtcblxuICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ID09PSAnYm9vbGVhbicgKSB7XG4gICAgICAgIGRlZXAgPSB0YXJnZXQ7XG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICAgICAgLy8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuICAgICAgICBpID0gMjtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG4gICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnICYmICEkJC5pcy5mbih0YXJnZXQpICkge1xuICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG4gICAgICBpZiAoIGxlbmd0aCA9PT0gaSApIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLS1pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICBpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG4gICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgIHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuICAgICAgICAgICAgaWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcbiAgICAgICAgICAgIGlmICggZGVlcCAmJiBjb3B5ICYmICggJCQuaXMucGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gJCQuaXMuYXJyYXkoY29weSkpICkgKSB7XG4gICAgICAgICAgICAgIGlmICggY29weUlzQXJyYXkgKSB7XG4gICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiAkJC5pcy5hcnJheShzcmMpID8gc3JjIDogW107XG5cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiAkJC5pcy5wbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSAkJC51dGlsLmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgfSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvLyByZXF1aXJlIHRoYXQgcHVsbHMgaW4gbW9kdWxlIGZyb20gY29tbW9uanMsIGFtZCwgb3Igd2luZG93IChmYWxsaW5nIGJhY2sgdW50aWwgZm91bmQpXG4gICAgcmVxdWlyZTogZnVuY3Rpb24oIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zICl7XG4gICAgICB2YXIgcmV0O1xuICAgICAgb3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgbXNnSWZOb3RGb3VuZDogdHJ1ZVxuICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICB2YXIgZnVsZmlsID0gZnVuY3Rpb24oIHJldCApe1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soIHJldCApO1xuICAgICAgfTtcblxuICAgICAgdmFyIGNoZWNrV2luZG93ID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICAgICAgaWYoIHdpbmRvdyApeyAvLyBkZXRlY3RlZCBicm93c2VyL3dpbmRvdyBlbnZcbiAgICAgICAgICByZXQgPSB3aW5kb3dbIG5hbWUgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByZXQgIT09IHVuZGVmaW5lZCApeyBmdWxmaWwocmV0KTsgfVxuICAgICAgICBpZiggbmV4dCApeyBuZXh0KCk7IH1cbiAgICAgIH07XG4gICAgICB2YXIgb25DaGVja1dpbmRvd0RvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggIWRvbmUgKXtcbiAgICAgICAgICBjaGVja0NvbW1vbkpzKCBvbkNoZWNrQ29tbW9uSnNEb25lICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGVja0NvbW1vbkpzID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICAgICAgaWYoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICYmIHJlcXVpcmUgKXsgLy8gZGV0ZWN0ZWQgY29tbW9uanMgZW52XG4gICAgICAgICAgcmV0ID0gcmVxdWlyZSggbmFtZSApOyAvLyByZWd1bGFyIHJlcXVpcmVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByZXQgIT09IHVuZGVmaW5lZCApeyBmdWxmaWwocmV0KTsgfVxuICAgICAgICBpZiggbmV4dCApeyBuZXh0KCk7IH1cbiAgICAgIH07XG4gICAgICB2YXIgb25DaGVja0NvbW1vbkpzRG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCAhZG9uZSApe1xuICAgICAgICAgIGNoZWNrQW1kKCBvbkNoZWNrQW1kRG9uZSApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hlY2tBbWQgPSBmdW5jdGlvbiggbmV4dCApe1xuICAgICAgICBpZiggdHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCAmJiByZXF1aXJlICl7IC8vIGRldGVjdGVkIGFtZCBlbnYgdy8gZGVmaW5lZCBtb2R1bGVcbiAgICAgICAgICByZXF1aXJlKFsgbmFtZSBdLCBmdW5jdGlvbiggbmFtZUltcGwgKXtcbiAgICAgICAgICAgIHJldCA9IG5hbWVJbXBsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggcmV0ICE9PSB1bmRlZmluZWQgKXsgZnVsZmlsKHJldCk7IH1cbiAgICAgICAgICAgIGlmKCBuZXh0ICl7IG5leHQoKTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIG9uQ2hlY2tBbWREb25lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoICFkb25lICYmIG9wdGlvbnMubXNnSWZOb3RGb3VuZCApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ0N5dG9zY2FwZS5qcyB0cmllZCB0byBwdWxsIGluIGRlcGVuZGVuY3kgYCcgKyBuYW1lICsgJ2AgYnV0IG5vIG1vZHVsZSAoaS5lLiBDb21tb25KUywgQU1ELCBvciB3aW5kb3cpIHdhcyBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBraWNrIG9mZiAxc3QgY2hlY2s6IHdpbmRvd1xuICAgICAgY2hlY2tXaW5kb3coIG9uQ2hlY2tXaW5kb3dEb25lICk7XG5cbiAgICB9LFxuXG4gICAgLy8gbXVsdGlwbGUgcmVxdWlyZXMgaW4gb25lIGNhbGxiYWNrXG4gICAgcmVxdWlyZXM6IGZ1bmN0aW9uKCBuYW1lcywgY2FsbGJhY2sgKXtcbiAgICAgIHZhciBpbXBscyA9IFtdO1xuICAgICAgdmFyIGdvdEltcGwgPSBbXTtcblxuICAgICAgdmFyIGNoZWNrRG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKysgKXsgLy8gY2hlY2sgaGF2ZSBhbGwgaW1wbHNcbiAgICAgICAgICBpZiggIWdvdEltcGxbaV0gKXsgcmV0dXJuOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2UsIGFsbCBnb3QgYWxsIGltcGxzID0+IGRvbmVcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoIGNhbGxiYWNrLCBpbXBscyApOyBcbiAgICAgIH07XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKysgKXsgKGZ1bmN0aW9uKCl7IC8vIHcvc2NvcGVcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgdmFyIGluZGV4ID0gaTtcblxuICAgICAgICAkJC51dGlsLnJlcXVpcmUobmFtZSwgZnVuY3Rpb24oaW1wbCl7XG4gICAgICAgICAgaW1wbHNbaW5kZXhdID0gaW1wbDtcbiAgICAgICAgICBnb3RJbXBsW2luZGV4XSA9IHRydWU7XG5cbiAgICAgICAgICBjaGVja0RvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpOyB9XG4gICAgfSxcblxuICAgIC8vIHBvcnRlZCBsb2Rhc2ggdGhyb3R0bGUgZnVuY3Rpb25cbiAgICB0aHJvdHRsZTogZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoJCQuaXMucGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIG9wdGlvbnMubGVhZGluZyA9IGxlYWRpbmc7XG4gICAgICBvcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICAgICAgb3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuXG4gICAgICByZXR1cm4gJCQudXRpbC5kZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgbm93OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuICtuZXcgRGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvLyBwb3J0ZWQgbG9kYXNoIGRlYm91bmNlIGZ1bmN0aW9uXG4gICAgZGVib3VuY2U6IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghJCQuaXMuZm4oZnVuYykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2FpdCA9IE1hdGgubWF4KDAsIHdhaXQpIHx8IDA7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCQkLmlzLnBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heFdhaXQgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucyAmJiAoTWF0aC5tYXgod2FpdCwgb3B0aW9ucy5tYXhXYWl0KSB8fCAwKTtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtICgkJC51dGlsLm5vdygpIC0gc3RhbXApO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSAkJC51dGlsLm5vdygpO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBtYXhEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0cmFpbGluZyB8fCAobWF4V2FpdCAhPT0gd2FpdCkpIHtcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gJCQudXRpbC5ub3coKTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3RhbXAgPSAkJC51dGlsLm5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGVycm9yOiBmdW5jdGlvbiggbXNnICl7XG4gICAgICBpZiggY29uc29sZSApe1xuICAgICAgICBpZiggY29uc29sZS5lcnJvciApe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApO1xuICAgICAgICB9IGVsc2UgaWYoIGNvbnNvbGUubG9nICl7XG4gICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG1zZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbXNnO1xuICAgICAgfVxuICAgIH0sICAgIFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmICggb2JqLmhhc093blByb3BlcnR5KGkpICkgeyAvLyBUT0RPIGlzIHRoaXMgaGFzT3duUHJvcGVydHkoKSBjYWxsIG5lY2Vzc2FyeSBmb3Igb3VyIHVzZT9cbiAgICAgICAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8vIGdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFyZ3VtZW50XG4gICAgY29weTogZnVuY3Rpb24oIG9iaiApe1xuICAgICAgaWYoIG9iaiA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGlmKCAkJC5pcy5hcnJheShvYmopICl7XG4gICAgICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3Qob2JqKSApe1xuICAgICAgICByZXR1cm4gJCQudXRpbC5jbG9uZSggb2JqICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgLy8gbWFrZXMgYSBmdWxsIGJiICh4MSwgeTEsIHgyLCB5MiwgdywgaCkgZnJvbSBpbXBsaWNpdCBwYXJhbXNcbiAgICBtYWtlQm91bmRpbmdCb3g6IGZ1bmN0aW9uKCBiYiApe1xuICAgICAgaWYoIGJiLngxICE9IG51bGwgJiYgYmIueTEgIT0gbnVsbCApe1xuICAgICAgICBpZiggYmIueDIgIT0gbnVsbCAmJiBiYi55MiAhPSBudWxsICYmIGJiLngyID49IGJiLngxICYmIGJiLnkyID49IGJiLnkxICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgICAgIHgyOiBiYi54MixcbiAgICAgICAgICAgIHkyOiBiYi55MixcbiAgICAgICAgICAgIHc6IGJiLngyIC0gYmIueDEsXG4gICAgICAgICAgICBoOiBiYi55MiAtIGJiLnkxXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmKCBiYi53ICE9IG51bGwgJiYgYmIuaCAhPSBudWxsICYmIGJiLncgPj0gMCAmJiBiYi5oID49IDAgKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICAgICAgeDI6IGJiLngxICsgYmIudyxcbiAgICAgICAgICAgIHkyOiBiYi55MSArIGJiLmgsXG4gICAgICAgICAgICB3OiBiYi53LFxuICAgICAgICAgICAgaDogYmIuaFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgfSxcblxuICAgIC8vIGhhcyBhbnl0aGluZyBiZWVuIHNldCBpbiB0aGUgbWFwXG4gICAgbWFwRW1wdHk6IGZ1bmN0aW9uKCBtYXAgKXtcbiAgICAgIHZhciBlbXB0eSA9IHRydWU7XG5cbiAgICAgIGlmKCBtYXAgIT0gbnVsbCApe1xuICAgICAgICBmb3IodmFyIGkgaW4gbWFwKXsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW1wdHk7XG4gICAgfSxcblxuICAgIC8vIHB1c2hlcyB0byB0aGUgYXJyYXkgYXQgdGhlIGVuZCBvZiBhIG1hcCAobWFwIG1heSBub3QgYmUgYnVpbHQpXG4gICAgcHVzaE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBhcnJheSA9ICQkLnV0aWwuZ2V0TWFwKG9wdGlvbnMpO1xuXG4gICAgICBpZiggYXJyYXkgPT0gbnVsbCApeyAvLyBpZiBlbXB0eSwgcHV0IGluaXRpYWwgYXJyYXlcbiAgICAgICAgJCQudXRpbC5zZXRNYXAoICQuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgdmFsdWU6IFsgb3B0aW9ucy52YWx1ZSBdXG4gICAgICAgIH0pICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheS5wdXNoKCBvcHRpb25zLnZhbHVlICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIHNldHMgdGhlIHZhbHVlIGluIGEgbWFwIChtYXAgbWF5IG5vdCBiZSBidWlsdClcbiAgICBzZXRNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgICB2YXIga2V5O1xuICAgICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KCBrZXkgKSApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1RyaWVkIHRvIHNldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaSA8IGtleXMubGVuZ3RoIC0gMSApe1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIGV4dGVuZCB0aGUgbWFwIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIGlmKCBvYmpba2V5XSA9PSBudWxsICl7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZXQgdGhlIHZhbHVlXG4gICAgICAgICAgb2JqW2tleV0gPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICAvLyBnZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCBldmVuIGlmIGl0J3Mgbm90IGJ1aWx0IGluIHBsYWNlc1xuICAgIGdldE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgIFxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyl7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdCgga2V5ICkgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdUcmllZCB0byBnZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgICBpZiggb2JqID09IG51bGwgKXtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8vIGRlbGV0ZXMgdGhlIGVudHJ5IGluIHRoZSBtYXBcbiAgICBkZWxldGVNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIga2VlcENoaWxkcmVuID0gb3B0aW9ucy5rZWVwQ2hpbGRyZW47XG4gICAgICBcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspe1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiggJCQuaXMucGxhaW5PYmplY3QoIGtleSApICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignVHJpZWQgdG8gZGVsZXRlIG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0S2V5ID0gaSA9PT0gb3B0aW9ucy5rZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmKCBsYXN0S2V5ICl7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGtlZXBDaGlsZHJlbiApeyAvLyB0aGVuIG9ubHkgZGVsZXRlIGNoaWxkIGZpZWxkcyBub3QgaW4ga2VlcENoaWxkcmVuXG4gICAgICAgICAgICBmb3IoIHZhciBjaGlsZCBpbiBvYmogKXtcbiAgICAgICAgICAgICAgaWYoICFrZWVwQ2hpbGRyZW5bY2hpbGRdICl7XG4gICAgICAgICAgICAgICAgb2JqW2NoaWxkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24oc3RyKXtcbiAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhzdHIpICl7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH0sXG5cbiAgICBjYW1lbDJkYXNoOiBmdW5jdGlvbiggc3RyICl7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjaCA9IHN0cltpXTtcbiAgICAgICAgdmFyIGNoTG93ZXJDYXNlID0gY2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGlzVXBwZXJDYXNlID0gY2ggIT09IGNoTG93ZXJDYXNlO1xuXG4gICAgICAgIGlmKCBpc1VwcGVyQ2FzZSApe1xuICAgICAgICAgIHJldC5wdXNoKCAnLScgKTtcbiAgICAgICAgICByZXQucHVzaCggY2hMb3dlckNhc2UgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQucHVzaCggY2ggKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbm9VcHBlckNhc2VzID0gcmV0Lmxlbmd0aCA9PT0gc3RyLmxlbmd0aDtcbiAgICAgIGlmKCBub1VwcGVyQ2FzZXMgKXsgcmV0dXJuIHN0cjsgfSAvLyBjaGVhcGVyIHRoYW4gLmpvaW4oKVxuXG4gICAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBkYXNoMmNhbWVsOiBmdW5jdGlvbiggc3RyICl7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICB2YXIgbmV4dElzVXBwZXIgPSBmYWxzZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGNoID0gc3RyW2ldO1xuICAgICAgICB2YXIgaXNEYXNoID0gY2ggPT09ICctJztcblxuICAgICAgICBpZiggaXNEYXNoICl7XG4gICAgICAgICAgbmV4dElzVXBwZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKCBuZXh0SXNVcHBlciApe1xuICAgICAgICAgICAgcmV0LnB1c2goIGNoLnRvVXBwZXJDYXNlKCkgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0LnB1c2goIGNoICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dElzVXBwZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBzdHJpcCBzcGFjZXMgZnJvbSBiZWdpbm5pbmcgb2Ygc3RyaW5nIGFuZCBlbmQgb2Ygc3RyaW5nXG4gICAgdHJpbTogZnVuY3Rpb24oIHN0ciApe1xuICAgICAgdmFyIGZpcnN0LCBsYXN0O1xuXG4gICAgICAvLyBmaW5kIGZpcnN0IG5vbi1zcGFjZSBjaGFyXG4gICAgICBmb3IoIGZpcnN0ID0gMDsgZmlyc3QgPCBzdHIubGVuZ3RoICYmIHN0cltmaXJzdF0gPT09ICcgJzsgZmlyc3QrKyApe31cblxuICAgICAgLy8gZmluZCBsYXN0IG5vbi1zcGFjZSBjaGFyXG4gICAgICBmb3IoIGxhc3QgPSBzdHIubGVuZ3RoIC0gMTsgbGFzdCA+IGZpcnN0ICYmIHN0cltsYXN0XSA9PT0gJyAnOyBsYXN0LS0gKXt9XG5cbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKGZpcnN0LCBsYXN0ICsgMSk7XG4gICAgfSxcblxuICAgIC8vIGdldCBbciwgZywgYl0gZnJvbSAjYWJjIG9yICNhYWJiY2NcbiAgICBoZXgydHVwbGU6IGZ1bmN0aW9uKCBoZXggKXtcbiAgICAgIGlmKCAhKGhleC5sZW5ndGggPT09IDQgfHwgaGV4Lmxlbmd0aCA9PT0gNykgfHwgaGV4WzBdICE9PSBcIiNcIiApeyByZXR1cm47IH1cblxuICAgICAgdmFyIHNob3J0SGV4ID0gaGV4Lmxlbmd0aCA9PT0gNDtcbiAgICAgIHZhciByLCBnLCBiO1xuICAgICAgdmFyIGJhc2UgPSAxNjtcblxuICAgICAgaWYoIHNob3J0SGV4ICl7XG4gICAgICAgIHIgPSBwYXJzZUludCggaGV4WzFdICsgaGV4WzFdLCBiYXNlICk7XG4gICAgICAgIGcgPSBwYXJzZUludCggaGV4WzJdICsgaGV4WzJdLCBiYXNlICk7XG4gICAgICAgIGIgPSBwYXJzZUludCggaGV4WzNdICsgaGV4WzNdLCBiYXNlICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gcGFyc2VJbnQoIGhleFsxXSArIGhleFsyXSwgYmFzZSApO1xuICAgICAgICBnID0gcGFyc2VJbnQoIGhleFszXSArIGhleFs0XSwgYmFzZSApO1xuICAgICAgICBiID0gcGFyc2VJbnQoIGhleFs1XSArIGhleFs2XSwgYmFzZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gaHNsKDAsIDAsIDApIG9yIGhzbGEoMCwgMCwgMCwgMClcbiAgICBoc2wydHVwbGU6IGZ1bmN0aW9uKCBoc2wgKXtcbiAgICAgIHZhciByZXQ7XG4gICAgICB2YXIgaCwgcywgbCwgYSwgciwgZywgYjtcbiAgICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCl7XG4gICAgICAgIGlmKHQgPCAwKSB0ICs9IDE7XG4gICAgICAgIGlmKHQgPiAxKSB0IC09IDE7XG4gICAgICAgIGlmKHQgPCAxLzYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgICBpZih0IDwgMS8yKSByZXR1cm4gcTtcbiAgICAgICAgaWYodCA8IDIvMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG5cbiAgICAgIHZhciBtID0gbmV3IFJlZ0V4cChcIl5cIiArICQkLnV0aWwucmVnZXguaHNsYSArIFwiJFwiKS5leGVjKGhzbCk7XG4gICAgICBpZiggbSApe1xuXG4gICAgICAgIC8vIGdldCBodWVcbiAgICAgICAgaCA9IHBhcnNlSW50KCBtWzFdICk7IFxuICAgICAgICBpZiggaCA8IDAgKXtcbiAgICAgICAgICBoID0gKCAzNjAgLSAoLTEqaCAlIDM2MCkgKSAlIDM2MDtcbiAgICAgICAgfSBlbHNlIGlmKCBoID4gMzYwICl7XG4gICAgICAgICAgaCA9IGggJSAzNjA7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSAzNjA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgICBzID0gcGFyc2VGbG9hdCggbVsyXSApO1xuICAgICAgICBpZiggcyA8IDAgfHwgcyA+IDEwMCApeyByZXR1cm47IH0gLy8gc2F0dXJhdGlvbiBpcyBbMCwgMTAwXVxuICAgICAgICBzID0gcy8xMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgICBsID0gcGFyc2VGbG9hdCggbVszXSApO1xuICAgICAgICBpZiggbCA8IDAgfHwgbCA+IDEwMCApeyByZXR1cm47IH0gLy8gbGlnaHRuZXNzIGlzIFswLCAxMDBdXG4gICAgICAgIGwgPSBsLzEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICAgIGEgPSBtWzRdO1xuICAgICAgICBpZiggYSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgYSA9IHBhcnNlRmxvYXQoIGEgKTtcblxuICAgICAgICAgIGlmKCBhIDwgMCB8fCBhID4gMSApeyByZXR1cm47IH0gLy8gYWxwaGEgaXMgWzAsIDFdXG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3csIGNvbnZlcnQgdG8gcmdiXG4gICAgICAgIC8vIGNvZGUgZnJvbSBodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0XG4gICAgICAgIGlmKCBzID09PSAwICl7XG4gICAgICAgICAgciA9IGcgPSBiID0gTWF0aC5yb3VuZChsICogMjU1KTsgLy8gYWNocm9tYXRpY1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgICAgICByID0gTWF0aC5yb3VuZCggMjU1ICogaHVlMnJnYihwLCBxLCBoICsgMS8zKSApO1xuICAgICAgICAgIGcgPSBNYXRoLnJvdW5kKCAyNTUgKiBodWUycmdiKHAsIHEsIGgpICk7XG4gICAgICAgICAgYiA9IE1hdGgucm91bmQoIDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCAtIDEvMykgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IFtyLCBnLCBiLCBhXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIHJnYigwLCAwLCAwKSBvciByZ2JhKDAsIDAsIDAsIDApXG4gICAgcmdiMnR1cGxlOiBmdW5jdGlvbiggcmdiICl7XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICB2YXIgbSA9IG5ldyBSZWdFeHAoXCJeXCIgKyAkJC51dGlsLnJlZ2V4LnJnYmEgKyBcIiRcIikuZXhlYyhyZ2IpO1xuICAgICAgaWYoIG0gKXtcbiAgICAgICAgcmV0ID0gW107XG5cbiAgICAgICAgdmFyIGlzUGN0ID0gW107XG4gICAgICAgIGZvciggdmFyIGkgPSAxOyBpIDw9IDM7IGkrKyApe1xuICAgICAgICAgIHZhciBjaGFubmVsID0gbVtpXTtcblxuICAgICAgICAgIGlmKCBjaGFubmVsWyBjaGFubmVsLmxlbmd0aCAtIDEgXSA9PT0gXCIlXCIgKXtcbiAgICAgICAgICAgIGlzUGN0W2ldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhbm5lbCA9IHBhcnNlRmxvYXQoIGNoYW5uZWwgKTtcblxuICAgICAgICAgIGlmKCBpc1BjdFtpXSApe1xuICAgICAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWwvMTAwICogMjU1OyAvLyBub3JtYWxpc2UgdG8gWzAsIDI1NV1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggY2hhbm5lbCA8IDAgfHwgY2hhbm5lbCA+IDI1NSApeyByZXR1cm47IH0gLy8gaW52YWxpZCBjaGFubmVsIHZhbHVlXG5cbiAgICAgICAgICByZXQucHVzaCggTWF0aC5mbG9vcihjaGFubmVsKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0TGVhc3RPbmVJc1BjdCA9IGlzUGN0WzFdIHx8IGlzUGN0WzJdIHx8IGlzUGN0WzNdO1xuICAgICAgICB2YXIgYWxsQXJlUGN0ID0gaXNQY3RbMV0gJiYgaXNQY3RbMl0gJiYgaXNQY3RbM107XG4gICAgICAgIGlmKCBhdExlYXN0T25lSXNQY3QgJiYgIWFsbEFyZVBjdCApeyByZXR1cm47IH0gLy8gbXVzdCBhbGwgYmUgcGVyY2VudCB2YWx1ZXMgaWYgb25lIGlzXG5cbiAgICAgICAgdmFyIGFscGhhID0gbVs0XTtcbiAgICAgICAgaWYoIGFscGhhICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoIGFscGhhICk7XG5cbiAgICAgICAgICBpZiggYWxwaGEgPCAwIHx8IGFscGhhID4gMSApeyByZXR1cm47IH0gLy8gaW52YWxpZCBhbHBoYSB2YWx1ZVxuXG4gICAgICAgICAgcmV0LnB1c2goIGFscGhhICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgY29sb3JuYW1lMnR1cGxlOiBmdW5jdGlvbiggY29sb3IgKXtcbiAgICAgIHJldHVybiAkJC51dGlsLmNvbG9yc1sgY29sb3IudG9Mb3dlckNhc2UoKSBdO1xuICAgIH0sXG5cbiAgICBjb2xvcjJ0dXBsZTogZnVuY3Rpb24oIGNvbG9yICl7XG4gICAgICByZXR1cm4gKCAkJC5pcy5hcnJheShjb2xvcikgPyBjb2xvciA6IG51bGwgKSBcbiAgICAgICAgfHwgJCQudXRpbC5jb2xvcm5hbWUydHVwbGUoY29sb3IpXG4gICAgICAgIHx8ICQkLnV0aWwuaGV4MnR1cGxlKGNvbG9yKVxuICAgICAgICB8fCAkJC51dGlsLnJnYjJ0dXBsZShjb2xvcilcbiAgICAgICAgfHwgJCQudXRpbC5oc2wydHVwbGUoY29sb3IpO1xuICAgIH0sXG5cbiAgICB0dXBsZTJoZXg6IGZ1bmN0aW9uKCB0dXBsZSApe1xuICAgICAgdmFyIHIgPSB0dXBsZVswXTtcbiAgICAgIHZhciBnID0gdHVwbGVbMV07XG4gICAgICB2YXIgYiA9IHR1cGxlWzJdO1xuXG4gICAgICBmdW5jdGlvbiBjaDJoZXgoIGNoICl7XG4gICAgICAgIHZhciBoZXggPSBjaC50b1N0cmluZygxNik7XG5cbiAgICAgICAgaWYoIGhleC5sZW5ndGggPT09IDEgKXtcbiAgICAgICAgICBoZXggPSAnMCcgKyBoZXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGV4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyMnICsgY2gyaGV4KHIpICsgY2gyaGV4KGcpICsgY2gyaGV4KGIpO1xuICAgIH0sXG5cbiAgICBjb2xvcnM6IHtcbiAgICAgIC8vIHNwZWNpYWwgY29sb3VyIG5hbWVzXG4gICAgICB0cmFuc3BhcmVudDogICAgICBbMCwwLDAsMF0sIC8vIE5CIGFscGhhID09PSAwXG5cbiAgICAgIC8vIHJlZ3VsYXIgY29sb3Vyc1xuICAgICAgYWxpY2VibHVlOiAgICAgICAgWzI0MCwyNDgsMjU1XSxcbiAgICAgIGFudGlxdWV3aGl0ZTogICAgICBbMjUwLDIzNSwyMTVdLFxuICAgICAgYXF1YTogICAgICAgICAgWzAsMjU1LDI1NV0sXG4gICAgICBhcXVhbWFyaW5lOiAgICAgICAgWzEyNywyNTUsMjEyXSxcbiAgICAgIGF6dXJlOiAgICAgICAgICBbMjQwLDI1NSwyNTVdLFxuICAgICAgYmVpZ2U6ICAgICAgICAgIFsyNDUsMjQ1LDIyMF0sXG4gICAgICBiaXNxdWU6ICAgICAgICAgIFsyNTUsMjI4LDE5Nl0sXG4gICAgICBibGFjazogICAgICAgICAgWzAsMCwwXSxcbiAgICAgIGJsYW5jaGVkYWxtb25kOiAgICAgIFsyNTUsMjM1LDIwNV0sXG4gICAgICBibHVlOiAgICAgICAgICBbMCwwLDI1NV0sXG4gICAgICBibHVldmlvbGV0OiAgICAgICAgWzEzOCw0MywyMjZdLFxuICAgICAgYnJvd246ICAgICAgICAgIFsxNjUsNDIsNDJdLFxuICAgICAgYnVybHl3b29kOiAgICAgICAgWzIyMiwxODQsMTM1XSxcbiAgICAgIGNhZGV0Ymx1ZTogICAgICAgIFs5NSwxNTgsMTYwXSxcbiAgICAgIGNoYXJ0cmV1c2U6ICAgICAgICBbMTI3LDI1NSwwXSxcbiAgICAgIGNob2NvbGF0ZTogICAgICAgIFsyMTAsMTA1LDMwXSxcbiAgICAgIGNvcmFsOiAgICAgICAgICBbMjU1LDEyNyw4MF0sXG4gICAgICBjb3JuZmxvd2VyYmx1ZTogICAgICBbMTAwLDE0OSwyMzddLFxuICAgICAgY29ybnNpbGs6ICAgICAgICBbMjU1LDI0OCwyMjBdLFxuICAgICAgY3JpbXNvbjogICAgICAgIFsyMjAsMjAsNjBdLFxuICAgICAgY3lhbjogICAgICAgICAgWzAsMjU1LDI1NV0sXG4gICAgICBkYXJrYmx1ZTogICAgICAgIFswLDAsMTM5XSxcbiAgICAgIGRhcmtjeWFuOiAgICAgICAgWzAsMTM5LDEzOV0sXG4gICAgICBkYXJrZ29sZGVucm9kOiAgICAgIFsxODQsMTM0LDExXSxcbiAgICAgIGRhcmtncmF5OiAgICAgICAgWzE2OSwxNjksMTY5XSxcbiAgICAgIGRhcmtncmVlbjogICAgICAgIFswLDEwMCwwXSxcbiAgICAgIGRhcmtncmV5OiAgICAgICAgWzE2OSwxNjksMTY5XSxcbiAgICAgIGRhcmtraGFraTogICAgICAgIFsxODksMTgzLDEwN10sXG4gICAgICBkYXJrbWFnZW50YTogICAgICBbMTM5LDAsMTM5XSxcbiAgICAgIGRhcmtvbGl2ZWdyZWVuOiAgICAgIFs4NSwxMDcsNDddLFxuICAgICAgZGFya29yYW5nZTogICAgICAgIFsyNTUsMTQwLDBdLFxuICAgICAgZGFya29yY2hpZDogICAgICAgIFsxNTMsNTAsMjA0XSxcbiAgICAgIGRhcmtyZWQ6ICAgICAgICBbMTM5LDAsMF0sXG4gICAgICBkYXJrc2FsbW9uOiAgICAgICAgWzIzMywxNTAsMTIyXSxcbiAgICAgIGRhcmtzZWFncmVlbjogICAgICBbMTQzLDE4OCwxNDNdLFxuICAgICAgZGFya3NsYXRlYmx1ZTogICAgICBbNzIsNjEsMTM5XSxcbiAgICAgIGRhcmtzbGF0ZWdyYXk6ICAgICAgWzQ3LDc5LDc5XSxcbiAgICAgIGRhcmtzbGF0ZWdyZXk6ICAgICAgWzQ3LDc5LDc5XSxcbiAgICAgIGRhcmt0dXJxdW9pc2U6ICAgICAgWzAsMjA2LDIwOV0sXG4gICAgICBkYXJrdmlvbGV0OiAgICAgICAgWzE0OCwwLDIxMV0sXG4gICAgICBkZWVwcGluazogICAgICAgIFsyNTUsMjAsMTQ3XSxcbiAgICAgIGRlZXBza3libHVlOiAgICAgIFswLDE5MSwyNTVdLFxuICAgICAgZGltZ3JheTogICAgICAgIFsxMDUsMTA1LDEwNV0sXG4gICAgICBkaW1ncmV5OiAgICAgICAgWzEwNSwxMDUsMTA1XSxcbiAgICAgIGRvZGdlcmJsdWU6ICAgICAgICBbMzAsMTQ0LDI1NV0sXG4gICAgICBmaXJlYnJpY2s6ICAgICAgICBbMTc4LDM0LDM0XSxcbiAgICAgIGZsb3JhbHdoaXRlOiAgICAgIFsyNTUsMjUwLDI0MF0sXG4gICAgICBmb3Jlc3RncmVlbjogICAgICBbMzQsMTM5LDM0XSxcbiAgICAgIGZ1Y2hzaWE6ICAgICAgICBbMjU1LDAsMjU1XSxcbiAgICAgIGdhaW5zYm9ybzogICAgICAgIFsyMjAsMjIwLDIyMF0sXG4gICAgICBnaG9zdHdoaXRlOiAgICAgICAgWzI0OCwyNDgsMjU1XSxcbiAgICAgIGdvbGQ6ICAgICAgICAgIFsyNTUsMjE1LDBdLFxuICAgICAgZ29sZGVucm9kOiAgICAgICAgWzIxOCwxNjUsMzJdLFxuICAgICAgZ3JheTogICAgICAgICAgWzEyOCwxMjgsMTI4XSxcbiAgICAgIGdyZXk6ICAgICAgICAgIFsxMjgsMTI4LDEyOF0sXG4gICAgICBncmVlbjogICAgICAgICAgWzAsMTI4LDBdLFxuICAgICAgZ3JlZW55ZWxsb3c6ICAgICAgWzE3MywyNTUsNDddLFxuICAgICAgaG9uZXlkZXc6ICAgICAgICBbMjQwLDI1NSwyNDBdLFxuICAgICAgaG90cGluazogICAgICAgIFsyNTUsMTA1LDE4MF0sXG4gICAgICBpbmRpYW5yZWQ6ICAgICAgICBbMjA1LDkyLDkyXSxcbiAgICAgIGluZGlnbzogICAgICAgICAgWzc1LDAsMTMwXSxcbiAgICAgIGl2b3J5OiAgICAgICAgICBbMjU1LDI1NSwyNDBdLFxuICAgICAga2hha2k6ICAgICAgICAgIFsyNDAsMjMwLDE0MF0sXG4gICAgICBsYXZlbmRlcjogICAgICAgIFsyMzAsMjMwLDI1MF0sXG4gICAgICBsYXZlbmRlcmJsdXNoOiAgICAgIFsyNTUsMjQwLDI0NV0sXG4gICAgICBsYXduZ3JlZW46ICAgICAgICBbMTI0LDI1MiwwXSxcbiAgICAgIGxlbW9uY2hpZmZvbjogICAgICBbMjU1LDI1MCwyMDVdLFxuICAgICAgbGlnaHRibHVlOiAgICAgICAgWzE3MywyMTYsMjMwXSxcbiAgICAgIGxpZ2h0Y29yYWw6ICAgICAgICBbMjQwLDEyOCwxMjhdLFxuICAgICAgbGlnaHRjeWFuOiAgICAgICAgWzIyNCwyNTUsMjU1XSxcbiAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAgWzI1MCwyNTAsMjEwXSxcbiAgICAgIGxpZ2h0Z3JheTogICAgICAgIFsyMTEsMjExLDIxMV0sXG4gICAgICBsaWdodGdyZWVuOiAgICAgICAgWzE0NCwyMzgsMTQ0XSxcbiAgICAgIGxpZ2h0Z3JleTogICAgICAgIFsyMTEsMjExLDIxMV0sXG4gICAgICBsaWdodHBpbms6ICAgICAgICBbMjU1LDE4MiwxOTNdLFxuICAgICAgbGlnaHRzYWxtb246ICAgICAgWzI1NSwxNjAsMTIyXSxcbiAgICAgIGxpZ2h0c2VhZ3JlZW46ICAgICAgWzMyLDE3OCwxNzBdLFxuICAgICAgbGlnaHRza3libHVlOiAgICAgIFsxMzUsMjA2LDI1MF0sXG4gICAgICBsaWdodHNsYXRlZ3JheTogICAgICBbMTE5LDEzNiwxNTNdLFxuICAgICAgbGlnaHRzbGF0ZWdyZXk6ICAgICAgWzExOSwxMzYsMTUzXSxcbiAgICAgIGxpZ2h0c3RlZWxibHVlOiAgICAgIFsxNzYsMTk2LDIyMl0sXG4gICAgICBsaWdodHllbGxvdzogICAgICBbMjU1LDI1NSwyMjRdLFxuICAgICAgbGltZTogICAgICAgICAgWzAsMjU1LDBdLFxuICAgICAgbGltZWdyZWVuOiAgICAgICAgWzUwLDIwNSw1MF0sXG4gICAgICBsaW5lbjogICAgICAgICAgWzI1MCwyNDAsMjMwXSxcbiAgICAgIG1hZ2VudGE6ICAgICAgICBbMjU1LDAsMjU1XSxcbiAgICAgIG1hcm9vbjogICAgICAgICAgWzEyOCwwLDBdLFxuICAgICAgbWVkaXVtYXF1YW1hcmluZTogICAgWzEwMiwyMDUsMTcwXSxcbiAgICAgIG1lZGl1bWJsdWU6ICAgICAgICBbMCwwLDIwNV0sXG4gICAgICBtZWRpdW1vcmNoaWQ6ICAgICAgWzE4Niw4NSwyMTFdLFxuICAgICAgbWVkaXVtcHVycGxlOiAgICAgIFsxNDcsMTEyLDIxOV0sXG4gICAgICBtZWRpdW1zZWFncmVlbjogICAgICBbNjAsMTc5LDExM10sXG4gICAgICBtZWRpdW1zbGF0ZWJsdWU6ICAgIFsxMjMsMTA0LDIzOF0sXG4gICAgICBtZWRpdW1zcHJpbmdncmVlbjogICAgWzAsMjUwLDE1NF0sXG4gICAgICBtZWRpdW10dXJxdW9pc2U6ICAgIFs3MiwyMDksMjA0XSxcbiAgICAgIG1lZGl1bXZpb2xldHJlZDogICAgWzE5OSwyMSwxMzNdLFxuICAgICAgbWlkbmlnaHRibHVlOiAgICAgIFsyNSwyNSwxMTJdLFxuICAgICAgbWludGNyZWFtOiAgICAgICAgWzI0NSwyNTUsMjUwXSxcbiAgICAgIG1pc3R5cm9zZTogICAgICAgIFsyNTUsMjI4LDIyNV0sXG4gICAgICBtb2NjYXNpbjogICAgICAgIFsyNTUsMjI4LDE4MV0sXG4gICAgICBuYXZham93aGl0ZTogICAgICBbMjU1LDIyMiwxNzNdLFxuICAgICAgbmF2eTogICAgICAgICAgWzAsMCwxMjhdLFxuICAgICAgb2xkbGFjZTogICAgICAgIFsyNTMsMjQ1LDIzMF0sXG4gICAgICBvbGl2ZTogICAgICAgICAgWzEyOCwxMjgsMF0sXG4gICAgICBvbGl2ZWRyYWI6ICAgICAgICBbMTA3LDE0MiwzNV0sXG4gICAgICBvcmFuZ2U6ICAgICAgICAgIFsyNTUsMTY1LDBdLFxuICAgICAgb3JhbmdlcmVkOiAgICAgICAgWzI1NSw2OSwwXSxcbiAgICAgIG9yY2hpZDogICAgICAgICAgWzIxOCwxMTIsMjE0XSxcbiAgICAgIHBhbGVnb2xkZW5yb2Q6ICAgICAgWzIzOCwyMzIsMTcwXSxcbiAgICAgIHBhbGVncmVlbjogICAgICAgIFsxNTIsMjUxLDE1Ml0sXG4gICAgICBwYWxldHVycXVvaXNlOiAgICAgIFsxNzUsMjM4LDIzOF0sXG4gICAgICBwYWxldmlvbGV0cmVkOiAgICAgIFsyMTksMTEyLDE0N10sXG4gICAgICBwYXBheWF3aGlwOiAgICAgICAgWzI1NSwyMzksMjEzXSxcbiAgICAgIHBlYWNocHVmZjogICAgICAgIFsyNTUsMjE4LDE4NV0sXG4gICAgICBwZXJ1OiAgICAgICAgICBbMjA1LDEzMyw2M10sXG4gICAgICBwaW5rOiAgICAgICAgICBbMjU1LDE5MiwyMDNdLFxuICAgICAgcGx1bTogICAgICAgICAgWzIyMSwxNjAsMjIxXSxcbiAgICAgIHBvd2RlcmJsdWU6ICAgICAgICBbMTc2LDIyNCwyMzBdLFxuICAgICAgcHVycGxlOiAgICAgICAgICBbMTI4LDAsMTI4XSxcbiAgICAgIHJlZDogICAgICAgICAgWzI1NSwwLDBdLFxuICAgICAgcm9zeWJyb3duOiAgICAgICAgWzE4OCwxNDMsMTQzXSxcbiAgICAgIHJveWFsYmx1ZTogICAgICAgIFs2NSwxMDUsMjI1XSxcbiAgICAgIHNhZGRsZWJyb3duOiAgICAgIFsxMzksNjksMTldLFxuICAgICAgc2FsbW9uOiAgICAgICAgICBbMjUwLDEyOCwxMTRdLFxuICAgICAgc2FuZHlicm93bjogICAgICAgIFsyNDQsMTY0LDk2XSxcbiAgICAgIHNlYWdyZWVuOiAgICAgICAgWzQ2LDEzOSw4N10sXG4gICAgICBzZWFzaGVsbDogICAgICAgIFsyNTUsMjQ1LDIzOF0sXG4gICAgICBzaWVubmE6ICAgICAgICAgIFsxNjAsODIsNDVdLFxuICAgICAgc2lsdmVyOiAgICAgICAgICBbMTkyLDE5MiwxOTJdLFxuICAgICAgc2t5Ymx1ZTogICAgICAgIFsxMzUsMjA2LDIzNV0sXG4gICAgICBzbGF0ZWJsdWU6ICAgICAgICBbMTA2LDkwLDIwNV0sXG4gICAgICBzbGF0ZWdyYXk6ICAgICAgICBbMTEyLDEyOCwxNDRdLFxuICAgICAgc2xhdGVncmV5OiAgICAgICAgWzExMiwxMjgsMTQ0XSxcbiAgICAgIHNub3c6ICAgICAgICAgIFsyNTUsMjUwLDI1MF0sXG4gICAgICBzcHJpbmdncmVlbjogICAgICBbMCwyNTUsMTI3XSxcbiAgICAgIHN0ZWVsYmx1ZTogICAgICAgIFs3MCwxMzAsMTgwXSxcbiAgICAgIHRhbjogICAgICAgICAgWzIxMCwxODAsMTQwXSxcbiAgICAgIHRlYWw6ICAgICAgICAgIFswLDEyOCwxMjhdLFxuICAgICAgdGhpc3RsZTogICAgICAgIFsyMTYsMTkxLDIxNl0sXG4gICAgICB0b21hdG86ICAgICAgICAgIFsyNTUsOTksNzFdLFxuICAgICAgdHVycXVvaXNlOiAgICAgICAgWzY0LDIyNCwyMDhdLFxuICAgICAgdmlvbGV0OiAgICAgICAgICBbMjM4LDEzMCwyMzhdLFxuICAgICAgd2hlYXQ6ICAgICAgICAgIFsyNDUsMjIyLDE3OV0sXG4gICAgICB3aGl0ZTogICAgICAgICAgWzI1NSwyNTUsMjU1XSxcbiAgICAgIHdoaXRlc21va2U6ICAgICAgICBbMjQ1LDI0NSwyNDVdLFxuICAgICAgeWVsbG93OiAgICAgICAgICBbMjU1LDI1NSwwXSxcbiAgICAgIHllbGxvd2dyZWVuOiAgICAgIFsxNTQsMjA1LDUwXVxuICAgIH1cbiAgICAgIFxuICB9O1xuXG4gICQkLnV0aWwucmVnZXggPSB7fTtcbiAgXG4gICQkLnV0aWwucmVnZXgubnVtYmVyID0gXCIoPzpbLV0/XFxcXGQqXFxcXC5cXFxcZCt8Wy1dP1xcXFxkK3xbLV0/XFxcXGQqXFxcXC5cXFxcZCtbZUVdXFxcXGQrKVwiO1xuICBcbiAgJCQudXRpbC5yZWdleC5yZ2JhID0gXCJyZ2JbYV0/XFxcXCgoXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXT8pXFxcXHMqLFxcXFxzKihcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0/KSg/OlxcXFxzKixcXFxccyooXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIikpP1xcXFwpXCI7XG4gICQkLnV0aWwucmVnZXgucmdiYU5vQmFja1JlZnMgPSBcInJnYlthXT9cXFxcKCg/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0/KVxcXFxzKixcXFxccyooPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKD86XCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXT8pKD86XFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpKT9cXFxcKVwiO1xuICBcbiAgJCQudXRpbC5yZWdleC5oc2xhID0gXCJoc2xbYV0/XFxcXCgoXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIilcXFxccyosXFxcXHMqKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0pXFxcXHMqLFxcXFxzKihcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdKSg/OlxcXFxzKixcXFxccyooXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIikpP1xcXFwpXCI7XG4gICQkLnV0aWwucmVnZXguaHNsYU5vQmFja1JlZnMgPSBcImhzbFthXT9cXFxcKCg/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpXFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0pXFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0pKD86XFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpKT9cXFxcKVwiO1xuICBcbiAgJCQudXRpbC5yZWdleC5oZXgzID0gXCJcXFxcI1swLTlhLWZBLUZdezN9XCI7XG4gICQkLnV0aWwucmVnZXguaGV4NiA9IFwiXFxcXCNbMC05YS1mQS1GXXs2fVwiO1xuXG4gIHZhciByYWYgPSAhd2luZG93ID8gbnVsbCA6ICggd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8ICBcbiAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKTtcblxuICByYWYgPSByYWYgfHwgZnVuY3Rpb24oZm4peyBpZihmbil7IHNldFRpbWVvdXQoZm4sIDEwMDAvNjApOyB9IH07XG5cbiAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihmbil7XG4gICAgcmFmKCBmbiApO1xuICB9O1xuXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5tYXRoID0ge307XG4gIFxuICAkJC5tYXRoLnNpZ251bSA9IGZ1bmN0aW9uKHgpe1xuICAgIGlmKCB4ID4gMCApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmKCB4IDwgMCApe1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG5cbiAgJCQubWF0aC5kaXN0YW5jZSA9IGZ1bmN0aW9uKCBwMSwgcDIgKXtcbiAgICB2YXIgZHggPSBwMi54IC0gcDEueDtcbiAgICB2YXIgZHkgPSBwMi55IC0gcDEueTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoIGR4KmR4ICsgZHkqZHkgKTtcbiAgfTtcblxuICAvLyBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQsOpemllcl9jdXJ2ZSNRdWFkcmF0aWNfY3VydmVzXG4gICQkLm1hdGgucWJlemllckF0ID0gZnVuY3Rpb24ocDAsIHAxLCBwMiwgdCl7XG4gICAgcmV0dXJuICgxIC0gdCkqKDEgLSB0KSpwMCArIDIqKDEgLSB0KSp0KnAxICsgdCp0KnAyO1xuICB9O1xuXG4gICQkLm1hdGgucWJlemllclB0QXQgPSBmdW5jdGlvbihwMCwgcDEsIHAyLCB0KXtcbiAgICByZXR1cm4ge1xuICAgICAgeDogJCQubWF0aC5xYmV6aWVyQXQoIHAwLngsIHAxLngsIHAyLngsIHQgKSxcbiAgICAgIHk6ICQkLm1hdGgucWJlemllckF0KCBwMC55LCBwMS55LCBwMi55LCB0IClcbiAgICB9O1xuICB9O1xuXG4gICQkLm1hdGguYm91bmRpbmdCb3hlc0ludGVyc2VjdCA9IGZ1bmN0aW9uKCBiYjEsIGJiMiApe1xuICAgIC8vIGNhc2U6IG9uZSBiYiB0byByaWdodCBvZiBvdGhlclxuICAgIGlmKCBiYjEueDEgPiBiYjIueDIgKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYoIGJiMi54MSA+IGJiMS54MiApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIGNhc2U6IG9uZSBiYiB0byBsZWZ0IG9mIG90aGVyXG4gICAgaWYoIGJiMS54MiA8IGJiMi54MSApeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiggYmIyLngyIDwgYmIxLngxICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gY2FzZTogb25lIGJiIGFib3ZlIG90aGVyXG4gICAgaWYoIGJiMS55MiA8IGJiMi55MSApeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiggYmIyLnkyIDwgYmIxLnkxICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gY2FzZTogb25lIGJiIGJlbG93IG90aGVyXG4gICAgaWYoIGJiMS55MSA+IGJiMi55MiApeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiggYmIyLnkxID4gYmIxLnkyICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gb3RoZXJ3aXNlLCBtdXN0IGhhdmUgc29tZSBvdmVybGFwXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgJCQubWF0aC5pbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiLCB4LCB5ICl7XG4gICAgcmV0dXJuIGJiLngxIDw9IHggJiYgeCA8PSBiYi54MiAmJiBiYi55MSA8PSB5ICYmIHkgPD0gYmIueTI7XG4gIH07XG5cbiAgJCQubWF0aC5wb2ludEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIsIHB0ICl7XG4gICAgcmV0dXJuIHRoaXMuaW5Cb3VuZGluZ0JveCggYmIsIHB0LngsIHB0LnkgKTtcbiAgfTtcblxuICAkJC5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICAgIHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICAgIFxuICAgIHZhciBjb3JuZXJSYWRpdXMgPSB0aGlzLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIFxuICAgIC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBzdHJhaWdodCBsaW5lIHNlZ21lbnRzXG4gICAgdmFyIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgXG4gICAgLy8gVG9wIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcbiAgICB7XG4gICAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgICAgdmFyIHRvcFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCAtIHBhZGRpbmc7XG4gICAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgICAgXG4gICAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuICAgICAgXG4gICAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBSaWdodCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG4gICAge1xuICAgICAgdmFyIHJpZ2h0U3RhcnRYID0gbm9kZVggKyBoYWxmV2lkdGggKyBwYWRkaW5nO1xuICAgICAgdmFyIHJpZ2h0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciByaWdodEVuZFggPSByaWdodFN0YXJ0WDtcbiAgICAgIHZhciByaWdodEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgICAgXG4gICAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCByaWdodFN0YXJ0WCwgcmlnaHRTdGFydFksIHJpZ2h0RW5kWCwgcmlnaHRFbmRZLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEJvdHRvbSBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG4gICAge1xuICAgICAgdmFyIGJvdHRvbVN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciBib3R0b21TdGFydFkgPSBub2RlWSArIGhhbGZIZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgdmFyIGJvdHRvbUVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgICB2YXIgYm90dG9tRW5kWSA9IGJvdHRvbVN0YXJ0WTtcbiAgICAgIFxuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tU3RhcnRYLCBib3R0b21TdGFydFksIGJvdHRvbUVuZFgsIGJvdHRvbUVuZFksIGZhbHNlKTtcbiAgICAgIFxuICAgICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gTGVmdCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG4gICAge1xuICAgICAgdmFyIGxlZnRTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCAtIHBhZGRpbmc7XG4gICAgICB2YXIgbGVmdFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgICB2YXIgbGVmdEVuZFggPSBsZWZ0U3RhcnRYO1xuICAgICAgdmFyIGxlZnRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIFxuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgbGVmdFN0YXJ0WCwgbGVmdFN0YXJ0WSwgbGVmdEVuZFgsIGxlZnRFbmRZLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBhcmMgc2VnbWVudHNcbiAgICB2YXIgYXJjSW50ZXJzZWN0aW9ucztcbiAgICBcbiAgICAvLyBUb3AgTGVmdFxuICAgIHtcbiAgICAgIHZhciB0b3BMZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIHRvcExlZnRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCBcbiAgICAgICAgdG9wTGVmdENlbnRlclgsIHRvcExlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gdG9wTGVmdENlbnRlclhcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BMZWZ0Q2VudGVyWSkge1xuICAgICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBUb3AgUmlnaHRcbiAgICB7XG4gICAgICB2YXIgdG9wUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgdG9wUmlnaHRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCBcbiAgICAgICAgdG9wUmlnaHRDZW50ZXJYLCB0b3BSaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSB0b3BSaWdodENlbnRlclhcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BSaWdodENlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQm90dG9tIFJpZ2h0XG4gICAge1xuICAgICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgXG4gICAgICAgIGJvdHRvbVJpZ2h0Q2VudGVyWCwgYm90dG9tUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gYm90dG9tUmlnaHRDZW50ZXJYXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tUmlnaHRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEJvdHRvbSBMZWZ0XG4gICAge1xuICAgICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgYm90dG9tTGVmdENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgICBhcmNJbnRlcnNlY3Rpb25zID0gdGhpcy5pbnRlcnNlY3RMaW5lQ2lyY2xlKFxuICAgICAgICB4LCB5LCBub2RlWCwgbm9kZVksIFxuICAgICAgICBib3R0b21MZWZ0Q2VudGVyWCwgYm90dG9tTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSBib3R0b21MZWZ0Q2VudGVyWFxuICAgICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbUxlZnRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdOyAvLyBpZiBub3RoaW5nXG4gIH07XG4gIFxuICAkJC5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0Qm94ID0gZnVuY3Rpb24oXG4gICAgYm94WDEsIGJveFkxLCBib3hYMiwgYm94WTIsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICBcbiAgICAvLyBXZSBoYXZlIHRoZSBmb2xsb3dpbmcgc2hwYWVcbiAgICBcbiAgICAvLyAgICBfX19fX1xuICAgIC8vICBffCAgICAgfF9cbiAgICAvLyB8ICAgICAgICAgfFxuICAgIC8vIHxfICAgICAgIF98XG4gICAgLy8gICB8X19fX198XG4gICAgLy9cbiAgICAvLyBXaXRoIGEgcXVhcnRlciBjaXJjbGUgYXQgZWFjaCBjb3JuZXIuXG4gICAgXG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IHRoaXMuZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgXG4gICAgdmFyIGhCb3hUb3BMZWZ0WCA9IGNlbnRlclggLSB3aWR0aCAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciBoQm94VG9wTGVmdFkgPSBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIGhCb3hCb3R0b21SaWdodFggPSBjZW50ZXJYICsgd2lkdGggLyAyICsgcGFkZGluZztcbiAgICB2YXIgaEJveEJvdHRvbVJpZ2h0WSA9IGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICBcbiAgICB2YXIgdkJveFRvcExlZnRYID0gY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIHZCb3hUb3BMZWZ0WSA9IGNlbnRlclkgLSBoZWlnaHQgLyAyIC0gcGFkZGluZztcbiAgICB2YXIgdkJveEJvdHRvbVJpZ2h0WCA9IGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciB2Qm94Qm90dG9tUmlnaHRZID0gY2VudGVyWSArIGhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZSBib3ggaXMgb3V0IG9mIGJvdW5kc1xuICAgIHZhciBib3hNaW5YID0gTWF0aC5taW4oYm94WDEsIGJveFgyKTtcbiAgICB2YXIgYm94TWF4WCA9IE1hdGgubWF4KGJveFgxLCBib3hYMik7XG4gICAgdmFyIGJveE1pblkgPSBNYXRoLm1pbihib3hZMSwgYm94WTIpO1xuICAgIHZhciBib3hNYXhZID0gTWF0aC5tYXgoYm94WTEsIGJveFkyKTtcbiAgICBcbiAgICBpZiAoYm94TWF4WCA8IGhCb3hUb3BMZWZ0WCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoYm94TWluWCA+IGhCb3hCb3R0b21SaWdodFgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGJveE1heFkgPCB2Qm94VG9wTGVmdFkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGJveE1pblkgPiB2Qm94Qm90dG9tUmlnaHRZKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGFuIGhCb3ggcG9pbnQgaXMgaW4gZ2l2ZW4gYm94XG4gICAgaWYgKGhCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIGhCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIGhCb3hUb3BMZWZ0WSA+PSBib3hNaW5ZICYmIGhCb3hUb3BMZWZ0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGhCb3hCb3R0b21SaWdodFggPj0gYm94TWluWCAmJiBoQm94Qm90dG9tUmlnaHRYIDw9IGJveE1heFhcbiAgICAgICAgJiYgaEJveFRvcExlZnRZID49IGJveE1pblkgJiYgaEJveFRvcExlZnRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaEJveEJvdHRvbVJpZ2h0WCA+PSBib3hNaW5YICYmIGhCb3hCb3R0b21SaWdodFggPD0gYm94TWF4WFxuICAgICAgICAmJiBoQm94Qm90dG9tUmlnaHRZID49IGJveE1pblkgJiYgaEJveEJvdHRvbVJpZ2h0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGhCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIGhCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIGhCb3hCb3R0b21SaWdodFkgPj0gYm94TWluWSAmJiBoQm94Qm90dG9tUmlnaHRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhIGdpdmVuIHBvaW50IGJveCBpcyBpbiB0aGUgaEJveFxuICAgIGlmIChib3hNaW5YID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gaEJveFRvcExlZnRZICYmIGJveE1pblkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gaEJveFRvcExlZnRZICYmIGJveE1pblkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gaEJveFRvcExlZnRZICYmIGJveE1heFkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNaW5YID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gaEJveFRvcExlZnRZICYmIGJveE1heFkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGFuIHZCb3ggcG9pbnQgaXMgaW4gZ2l2ZW4gYm94XG4gICAgaWYgKHZCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIHZCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIHZCb3hUb3BMZWZ0WSA+PSBib3hNaW5ZICYmIHZCb3hUb3BMZWZ0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHZCb3hCb3R0b21SaWdodFggPj0gYm94TWluWCAmJiB2Qm94Qm90dG9tUmlnaHRYIDw9IGJveE1heFhcbiAgICAgICAgJiYgdkJveFRvcExlZnRZID49IGJveE1pblkgJiYgdkJveFRvcExlZnRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAodkJveEJvdHRvbVJpZ2h0WCA+PSBib3hNaW5YICYmIHZCb3hCb3R0b21SaWdodFggPD0gYm94TWF4WFxuICAgICAgICAmJiB2Qm94Qm90dG9tUmlnaHRZID49IGJveE1pblkgJiYgdkJveEJvdHRvbVJpZ2h0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHZCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIHZCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIHZCb3hCb3R0b21SaWdodFkgPj0gYm94TWluWSAmJiB2Qm94Qm90dG9tUmlnaHRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhIGdpdmVuIHBvaW50IGJveCBpcyBpbiB0aGUgdkJveFxuICAgIGlmIChib3hNaW5YID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gdkJveFRvcExlZnRZICYmIGJveE1pblkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gdkJveFRvcExlZnRZICYmIGJveE1pblkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gdkJveFRvcExlZnRZICYmIGJveE1heFkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNaW5YID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gdkJveFRvcExlZnRZICYmIGJveE1heFkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIExhc3RseSwgY2hlY2sgaWYgb25lIG9mIHRoZSBlbGxpcHNlcyBjb2luY2lkZSB3aXRoIHRoZSBib3hcbiAgICBcbiAgICBpZiAodGhpcy5ib3hJbnRlcnNlY3RFbGxpcHNlKGJveE1pblgsIGJveE1pblksIGJveE1heFgsIGJveE1heFksIHBhZGRpbmcsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hUb3BMZWZ0WCArIHBhZGRpbmcsIGhCb3hUb3BMZWZ0WSArIHBhZGRpbmcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuYm94SW50ZXJzZWN0RWxsaXBzZShib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCB2Qm94Qm90dG9tUmlnaHRYIC0gcGFkZGluZywgaEJveFRvcExlZnRZICsgcGFkZGluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5ib3hJbnRlcnNlY3RFbGxpcHNlKGJveE1pblgsIGJveE1pblksIGJveE1heFgsIGJveE1heFksIHBhZGRpbmcsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hCb3R0b21SaWdodFggLSBwYWRkaW5nLCBoQm94Qm90dG9tUmlnaHRZIC0gcGFkZGluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5ib3hJbnRlcnNlY3RFbGxpcHNlKGJveE1pblgsIGJveE1pblksIGJveE1heFgsIGJveE1heFksIHBhZGRpbmcsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hUb3BMZWZ0WCArIHBhZGRpbmcsIGhCb3hCb3R0b21SaWdodFkgLSBwYWRkaW5nKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIC8vIEBPIEFwcHJveGltYXRlIGNvbGxpc2lvbiBmdW5jdGlvbnNcbiAgJCQubWF0aC5jaGVja0luQm91bmRpbmdDaXJjbGUgPSBmdW5jdGlvbihcbiAgICB4LCB5LCBmYXJ0aGVzdFBvaW50U3FEaXN0YW5jZSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgIFxuICAgIHggPSAoeCAtIGNlbnRlclgpIC8gKHdpZHRoICsgcGFkZGluZyk7XG4gICAgeSA9ICh5IC0gY2VudGVyWSkgLyAoaGVpZ2h0ICsgcGFkZGluZyk7XG4gICAgXG4gICAgcmV0dXJuICh4ICogeCArIHkgKiB5KSA8PSBmYXJ0aGVzdFBvaW50U3FEaXN0YW5jZTtcbiAgfTtcbiAgXG4gICQkLm1hdGguYm94SW5CZXppZXJWaWNpbml0eSA9IGZ1bmN0aW9uKFxuICAgIHgxYm94LCB5MWJveCwgeDJib3gsIHkyYm94LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2UpIHtcbiAgICBcbiAgICAvLyBSZXR1cm4gdmFsdWVzOlxuICAgIC8vIDAgLSBjdXJ2ZSBpcyBub3QgaW4gYm94XG4gICAgLy8gMSAtIGN1cnZlIG1heSBiZSBpbiBib3g7IG5lZWRzIHByZWNpc2UgY2hlY2tcbiAgICAvLyAyIC0gY3VydmUgaXMgaW4gYm94XG4gICAgXG4gICAgLy8gbWlkcG9pbnRcbiAgICB2YXIgbWlkWCA9IDAuMjUgKiB4MSArIDAuNSAqIHgyICsgMC4yNSAqIHgzO1xuICAgIHZhciBtaWRZID0gMC4yNSAqIHkxICsgMC41ICogeTIgKyAwLjI1ICogeTM7XG5cbiAgICB2YXIgYm94TWluWCA9IE1hdGgubWluKHgxYm94LCB4MmJveCkgLSB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1pblkgPSBNYXRoLm1pbih5MWJveCwgeTJib3gpIC0gdG9sZXJhbmNlO1xuICAgIHZhciBib3hNYXhYID0gTWF0aC5tYXgoeDFib3gsIHgyYm94KSArIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWF4WSA9IE1hdGgubWF4KHkxYm94LCB5MmJveCkgKyB0b2xlcmFuY2U7XG4gICAgXG4gICAgaWYgKHgxID49IGJveE1pblggJiYgeDEgPD0gYm94TWF4WCAmJiB5MSA+PSBib3hNaW5ZICYmIHkxIDw9IGJveE1heFkpIHsgLy8gKHgxLCB5MSkgaW4gYm94XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHgzID49IGJveE1pblggJiYgeDMgPD0gYm94TWF4WCAmJiB5MyA+PSBib3hNaW5ZICYmIHkzIDw9IGJveE1heFkpIHsgLy8gKHgzLCB5MykgaW4gYm94XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKG1pZFggPj0gYm94TWluWCAmJiBtaWRYIDw9IGJveE1heFggJiYgbWlkWSA+PSBib3hNaW5ZICYmIG1pZFkgPD0gYm94TWF4WSkgeyAvLyAobWlkWCwgbWlkWSkgaW4gYm94XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHgyID49IGJveE1pblggJiYgeDIgPD0gYm94TWF4WCAmJiB5MiA+PSBib3hNaW5ZICYmIHkyIDw9IGJveE1heFkpIHsgLy8gY3RybCBwdCBpbiBib3hcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBcbiAgICB2YXIgY3VydmVNaW5YID0gTWF0aC5taW4oeDEsIG1pZFgsIHgzKTtcbiAgICB2YXIgY3VydmVNaW5ZID0gTWF0aC5taW4oeTEsIG1pZFksIHkzKTtcbiAgICB2YXIgY3VydmVNYXhYID0gTWF0aC5tYXgoeDEsIG1pZFgsIHgzKTtcbiAgICB2YXIgY3VydmVNYXhZID0gTWF0aC5tYXgoeTEsIG1pZFksIHkzKTtcbiAgICBcbiAgICAvKlxuICAgIGNvbnNvbGUubG9nKGN1cnZlTWluWCArIFwiLCBcIiArIGN1cnZlTWluWSArIFwiLCBcIiArIGN1cnZlTWF4WCBcbiAgICAgICsgXCIsIFwiICsgY3VydmVNYXhZKTtcbiAgICBpZiAoY3VydmVNaW5YID09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5sb2coXCJ1bmRlZmluZWQgY3VydmVNaW5YOiBcIiArIHgxICsgXCIsIFwiICsgeDIgKyBcIiwgXCIgKyB4Myk7XG4gICAgfVxuICAgICovXG4gICAgXG4gICAgaWYgKGN1cnZlTWluWCA+IGJveE1heFhcbiAgICAgIHx8IGN1cnZlTWF4WCA8IGJveE1pblhcbiAgICAgIHx8IGN1cnZlTWluWSA+IGJveE1heFlcbiAgICAgIHx8IGN1cnZlTWF4WSA8IGJveE1pblkpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuIDA7ICBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIDE7XG4gIH07XG5cbiAgJCQubWF0aC5jaGVja0JlemllckluQm94ID0gZnVuY3Rpb24oXG4gICAgeDFib3gsIHkxYm94LCB4MmJveCwgeTJib3gsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRvbGVyYW5jZSkge1xuXG4gICAgZnVuY3Rpb24gc2FtcGxlSW5Cb3godCl7XG4gICAgICB2YXIgeCA9ICQkLm1hdGgucWJlemllckF0KHgxLCB4MiwgeDMsIHQpO1xuICAgICAgdmFyIHkgPSAkJC5tYXRoLnFiZXppZXJBdCh5MSwgeTIsIHkzLCB0KTtcblxuICAgICAgcmV0dXJuIHgxYm94IDw9IHggJiYgeCA8PSB4MmJveFxuICAgICAgICAmJiB5MWJveCA8PSB5ICYmIHkgPD0geTJib3hcbiAgICAgIDtcbiAgICB9XG5cbiAgICBmb3IoIHZhciB0ID0gMDsgdCA8PSAxOyB0ICs9IDAuMjUgKXtcbiAgICAgIGlmKCAhc2FtcGxlSW5Cb3godCkgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBcbiAgJCQubWF0aC5jaGVja1N0cmFpZ2h0RWRnZUluQm94ID0gZnVuY3Rpb24oXG4gICAgeDFib3gsIHkxYm94LCB4MmJveCwgeTJib3gsIHgxLCB5MSwgeDIsIHkyLCB0b2xlcmFuY2UpIHtcblxuICAgIHJldHVybiB4MWJveCA8PSB4MSAmJiB4MSA8PSB4MmJveFxuICAgICAgJiYgeDFib3ggPD0geDIgJiYgeDIgPD0geDJib3hcbiAgICAgICYmIHkxYm94IDw9IHkxICYmIHkxIDw9IHkyYm94XG4gICAgICAmJiB5MWJveCA8PSB5MiAmJiB5MiA8PSB5MmJveFxuICAgIDtcbiAgfTtcblxuICAkJC5tYXRoLmNoZWNrU3RyYWlnaHRFZGdlQ3Jvc3Nlc0JveCA9IGZ1bmN0aW9uKFxuICAgIHgxYm94LCB5MWJveCwgeDJib3gsIHkyYm94LCB4MSwgeTEsIHgyLCB5MiwgdG9sZXJhbmNlKSB7XG4gICAgXG4gICAvL2NvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdmFyIGJveE1pblggPSBNYXRoLm1pbih4MWJveCwgeDJib3gpIC0gdG9sZXJhbmNlO1xuICAgIHZhciBib3hNaW5ZID0gTWF0aC5taW4oeTFib3gsIHkyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWF4WCA9IE1hdGgubWF4KHgxYm94LCB4MmJveCkgKyB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFkgPSBNYXRoLm1heCh5MWJveCwgeTJib3gpICsgdG9sZXJhbmNlO1xuICAgIFxuICAgIC8vIENoZWNrIGxlZnQgKyByaWdodCBib3VuZHNcbiAgICB2YXIgYVggPSB4MiAtIHgxO1xuICAgIHZhciBiWCA9IHgxO1xuICAgIHZhciB5VmFsdWU7XG4gICAgXG4gICAgLy8gVG9wIGFuZCBib3R0b21cbiAgICB2YXIgYVkgPSB5MiAtIHkxO1xuICAgIHZhciBiWSA9IHkxO1xuICAgIHZhciB4VmFsdWU7XG4gICAgXG4gICAgaWYgKE1hdGguYWJzKGFYKSA8IDAuMDAwMSkge1xuICAgICAgcmV0dXJuICh4MSA+PSBib3hNaW5YICYmIHgxIDw9IGJveE1heFhcbiAgICAgICAgJiYgTWF0aC5taW4oeTEsIHkyKSA8PSBib3hNaW5ZXG4gICAgICAgICYmIE1hdGgubWF4KHkxLCB5MikgPj0gYm94TWF4WSk7ICBcbiAgICB9XG4gICAgXG4gICAgdmFyIHRMZWZ0ID0gKGJveE1pblggLSBiWCkgLyBhWDtcbiAgICBpZiAodExlZnQgPiAwICYmIHRMZWZ0IDw9IDEpIHtcbiAgICAgIHlWYWx1ZSA9IGFZICogdExlZnQgKyBiWTtcbiAgICAgIGlmICh5VmFsdWUgPj0gYm94TWluWSAmJiB5VmFsdWUgPD0gYm94TWF4WSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gXG4gICAgfVxuICAgIFxuICAgIHZhciB0UmlnaHQgPSAoYm94TWF4WCAtIGJYKSAvIGFYO1xuICAgIGlmICh0UmlnaHQgPiAwICYmIHRSaWdodCA8PSAxKSB7XG4gICAgICB5VmFsdWUgPSBhWSAqIHRSaWdodCArIGJZO1xuICAgICAgaWYgKHlWYWx1ZSA+PSBib3hNaW5ZICYmIHlWYWx1ZSA8PSBib3hNYXhZKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBcbiAgICB9XG4gICAgXG4gICAgdmFyIHRUb3AgPSAoYm94TWluWSAtIGJZKSAvIGFZO1xuICAgIGlmICh0VG9wID4gMCAmJiB0VG9wIDw9IDEpIHtcbiAgICAgIHhWYWx1ZSA9IGFYICogdFRvcCArIGJYO1xuICAgICAgaWYgKHhWYWx1ZSA+PSBib3hNaW5YICYmIHhWYWx1ZSA8PSBib3hNYXhYKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBcbiAgICB9XG4gICAgXG4gICAgdmFyIHRCb3R0b20gPSAoYm94TWF4WSAtIGJZKSAvIGFZO1xuICAgIGlmICh0Qm90dG9tID4gMCAmJiB0Qm90dG9tIDw9IDEpIHtcbiAgICAgIHhWYWx1ZSA9IGFYICogdEJvdHRvbSArIGJYO1xuICAgICAgaWYgKHhWYWx1ZSA+PSBib3hNaW5YICYmIHhWYWx1ZSA8PSBib3hNYXhYKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5jaGVja0JlemllckNyb3NzZXNCb3ggPSBmdW5jdGlvbihcbiAgICB4MWJveCwgeTFib3gsIHgyYm94LCB5MmJveCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlKSB7XG4gICAgXG4gICAgdmFyIGJveE1pblggPSBNYXRoLm1pbih4MWJveCwgeDJib3gpIC0gdG9sZXJhbmNlO1xuICAgIHZhciBib3hNaW5ZID0gTWF0aC5taW4oeTFib3gsIHkyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWF4WCA9IE1hdGgubWF4KHgxYm94LCB4MmJveCkgKyB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFkgPSBNYXRoLm1heCh5MWJveCwgeTJib3gpICsgdG9sZXJhbmNlO1xuICAgIFxuICAgIGlmICh4MSA+PSBib3hNaW5YICYmIHgxIDw9IGJveE1heFggJiYgeTEgPj0gYm94TWluWSAmJiB5MSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHgzID49IGJveE1pblggJiYgeDMgPD0gYm94TWF4WCAmJiB5MyA+PSBib3hNaW5ZICYmIHkzIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICB2YXIgYVggPSB4MSAtIDIgKiB4MiArIHgzO1xuICAgIHZhciBiWCA9IC0yICogeDEgKyAyICogeDI7XG4gICAgdmFyIGNYID0geDE7XG5cbiAgICB2YXIgeEludGVydmFscyA9IFtdO1xuICAgIFxuICAgIGlmIChNYXRoLmFicyhhWCkgPCAwLjAwMDEpIHtcbiAgICAgIHZhciBsZWZ0UGFyYW0gPSAoYm94TWluWCAtIHgxKSAvIGJYO1xuICAgICAgdmFyIHJpZ2h0UGFyYW0gPSAoYm94TWF4WCAtIHgxKSAvIGJYO1xuICAgICAgXG4gICAgICB4SW50ZXJ2YWxzLnB1c2gobGVmdFBhcmFtLCByaWdodFBhcmFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluZCB3aGVuIHggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgY3Jvc3NlcyB0aGUgbGVmdCBzaWRlIG9mIHRoZSBib3hcbiAgICAgIHZhciBkaXNjcmltaW5hbnRYMSA9IGJYICogYlggLSA0ICogYVggKiAoY1ggLSBib3hNaW5YKTtcbiAgICAgIHZhciB0WDEsIHRYMjtcbiAgICAgIGlmIChkaXNjcmltaW5hbnRYMSA+IDApIHtcbiAgICAgICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQoZGlzY3JpbWluYW50WDEpO1xuICAgICAgICB0WDEgPSAoLWJYICsgc3FydCkgLyAoMiAqIGFYKTtcbiAgICAgICAgdFgyID0gKC1iWCAtIHNxcnQpIC8gKDIgKiBhWCk7XG4gICAgICAgIFxuICAgICAgICB4SW50ZXJ2YWxzLnB1c2godFgxLCB0WDIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZGlzY3JpbWluYW50WDIgPSBiWCAqIGJYIC0gNCAqIGFYICogKGNYIC0gYm94TWF4WCk7XG4gICAgICB2YXIgdFgzLCB0WDQ7XG4gICAgICBpZiAoZGlzY3JpbWluYW50WDIgPiAwKSB7XG4gICAgICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudFgyKTtcbiAgICAgICAgdFgzID0gKC1iWCArIHNxcnQpIC8gKDIgKiBhWCk7XG4gICAgICAgIHRYNCA9ICgtYlggLSBzcXJ0KSAvICgyICogYVgpO1xuICAgICAgICBcbiAgICAgICAgeEludGVydmFscy5wdXNoKHRYMywgdFg0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgeEludGVydmFscy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICBcbiAgICB2YXIgYVkgPSB5MSAtIDIgKiB5MiArIHkzO1xuICAgIHZhciBiWSA9IC0yICogeTEgKyAyICogeTI7XG4gICAgdmFyIGNZID0geTE7XG4gICAgXG4gICAgdmFyIHlJbnRlcnZhbHMgPSBbXTtcbiAgICBcbiAgICBpZiAoTWF0aC5hYnMoYVkpIDwgMC4wMDAxKSB7XG4gICAgICB2YXIgdG9wUGFyYW0gPSAoYm94TWluWSAtIHkxKSAvIGJZO1xuICAgICAgdmFyIGJvdHRvbVBhcmFtID0gKGJveE1heFkgLSB5MSkgLyBiWTtcbiAgICAgIFxuICAgICAgeUludGVydmFscy5wdXNoKHRvcFBhcmFtLCBib3R0b21QYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXNjcmltaW5hbnRZMSA9IGJZICogYlkgLSA0ICogYVkgKiAoY1kgLSBib3hNaW5ZKTtcbiAgICAgIFxuICAgICAgdmFyIHRZMSwgdFkyO1xuICAgICAgaWYgKGRpc2NyaW1pbmFudFkxID4gMCkge1xuICAgICAgICB2YXIgc3FydCA9IE1hdGguc3FydChkaXNjcmltaW5hbnRZMSk7XG4gICAgICAgIHRZMSA9ICgtYlkgKyBzcXJ0KSAvICgyICogYVkpO1xuICAgICAgICB0WTIgPSAoLWJZIC0gc3FydCkgLyAoMiAqIGFZKTtcbiAgICAgICAgXG4gICAgICAgIHlJbnRlcnZhbHMucHVzaCh0WTEsIHRZMik7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIGRpc2NyaW1pbmFudFkyID0gYlkgKiBiWSAtIDQgKiBhWSAqIChjWSAtIGJveE1heFkpO1xuICAgICAgXG4gICAgICB2YXIgdFkzLCB0WTQ7XG4gICAgICBpZiAoZGlzY3JpbWluYW50WTIgPiAwKSB7XG4gICAgICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudFkyKTtcbiAgICAgICAgdFkzID0gKC1iWSArIHNxcnQpIC8gKDIgKiBhWSk7XG4gICAgICAgIHRZNCA9ICgtYlkgLSBzcXJ0KSAvICgyICogYVkpO1xuICAgICAgICBcbiAgICAgICAgeUludGVydmFscy5wdXNoKHRZMywgdFk0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgICAgIFxuICAgIHlJbnRlcnZhbHMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgeEludGVydmFscy5sZW5ndGg7IGluZGV4ICs9IDIpIHtcbiAgICAgIGZvciAodmFyIHlJbmRleCA9IDE7IHlJbmRleCA8IHlJbnRlcnZhbHMubGVuZ3RoOyB5SW5kZXggKz0gMikge1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgZXhpc3RzIHZhbHVlcyBmb3IgdGhlIEJlemllciBjdXJ2ZVxuICAgICAgICAvLyBwYXJhbWV0ZXIgYmV0d2VlbiAwIGFuZCAxIHdoZXJlIGJvdGggdGhlIGN1cnZlJ3NcbiAgICAgICAgLy8geCBhbmQgeSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoZSBib3VuZHMgc3BlY2lmaWVkIGJ5IHRoZSBib3hcbiAgICAgICAgaWYgKHhJbnRlcnZhbHNbaW5kZXhdIDwgeUludGVydmFsc1t5SW5kZXhdXG4gICAgICAgICAgJiYgeUludGVydmFsc1t5SW5kZXhdID49IDAuMFxuICAgICAgICAgICYmIHhJbnRlcnZhbHNbaW5kZXhdIDw9IDEuMFxuICAgICAgICAgICYmIHhJbnRlcnZhbHNbaW5kZXggKyAxXSA+IHlJbnRlcnZhbHNbeUluZGV4IC0gMV1cbiAgICAgICAgICAmJiB5SW50ZXJ2YWxzW3lJbmRleCAtIDFdIDw9IDEuMFxuICAgICAgICAgICYmIHhJbnRlcnZhbHNbaW5kZXggKyAxXSA+PSAwLjApIHtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICAkJC5tYXRoLmluTGluZVZpY2luaXR5ID0gZnVuY3Rpb24oeCwgeSwgbHgxLCBseTEsIGx4MiwgbHkyLCB0b2xlcmFuY2Upe1xuICAgIHZhciB0ID0gdG9sZXJhbmNlO1xuXG4gICAgdmFyIHgxID0gTWF0aC5taW4obHgxLCBseDIpO1xuICAgIHZhciB4MiA9IE1hdGgubWF4KGx4MSwgbHgyKTtcbiAgICB2YXIgeTEgPSBNYXRoLm1pbihseTEsIGx5Mik7XG4gICAgdmFyIHkyID0gTWF0aC5tYXgobHkxLCBseTIpO1xuXG4gICAgcmV0dXJuIHgxIC0gdCA8PSB4ICYmIHggPD0geDIgKyB0XG4gICAgICAmJiB5MSAtIHQgPD0geSAmJiB5IDw9IHkyICsgdDtcbiAgfTtcblxuICAkJC5tYXRoLmluQmV6aWVyVmljaW5pdHkgPSBmdW5jdGlvbihcbiAgICB4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2VTcXVhcmVkKSB7XG5cbiAgICB2YXIgYmIgPSB7XG4gICAgICB4MTogTWF0aC5taW4oIHgxLCB4MywgeDIgKSxcbiAgICAgIHgyOiBNYXRoLm1heCggeDEsIHgzLCB4MiApLFxuICAgICAgeTE6IE1hdGgubWluKCB5MSwgeTMsIHkyICksXG4gICAgICB5MjogTWF0aC5tYXgoIHkxLCB5MywgeTIgKVxuICAgIH07XG5cbiAgICAvLyBpZiBvdXRzaWRlIHRoZSByb3VnaCBib3VuZGluZyBib3ggZm9yIHRoZSBiZXppZXIsIHRoZW4gaXQgY2FuJ3QgYmUgYSBoaXRcbiAgICBpZiggeCA8IGJiLngxIHx8IHggPiBiYi54MiB8fCB5IDwgYmIueTEgfHwgeSA+IGJiLnkyICl7XG4gICAgICAvLyBjb25zb2xlLmxvZygnYmV6aWVyIG91dCBvZiByb3VnaCBiYicpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdkbyBtb3JlIGV4cGVuc2l2ZSBjaGVjaycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIH07XG4gIFxuICAkJC5tYXRoLnNvbHZlQ3ViaWMgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCByZXN1bHQpIHtcbiAgICBcbiAgICAvLyBTb2x2ZXMgYSBjdWJpYyBmdW5jdGlvbiwgcmV0dXJucyByb290IGluIGZvcm0gW3IxLCBpMSwgcjIsIGkyLCByMywgaTNdLCB3aGVyZVxuICAgIC8vIHIgaXMgdGhlIHJlYWwgY29tcG9uZW50LCBpIGlzIHRoZSBpbWFnaW5hcnkgY29tcG9uZW50XG5cbiAgICAvLyBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ2FyZGFubyBtZXRob2QgZnJvbSB0aGUgeWVhciAxNTQ1XG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19mdW5jdGlvbiNUaGVfbmF0dXJlX29mX3RoZV9yb290c1xuXG4gICAgYiAvPSBhO1xuICAgIGMgLz0gYTtcbiAgICBkIC89IGE7XG4gICAgXG4gICAgdmFyIGRpc2NyaW1pbmFudCwgcSwgciwgZHVtMSwgcywgdCwgdGVybTEsIHIxMztcblxuICAgIHEgPSAoMy4wICogYyAtIChiICogYikpIC8gOS4wO1xuICAgIHIgPSAtKDI3LjAgKiBkKSArIGIgKiAoOS4wICogYyAtIDIuMCAqIChiICogYikpO1xuICAgIHIgLz0gNTQuMDtcbiAgICBcbiAgICBkaXNjcmltaW5hbnQgPSBxICogcSAqIHEgKyByICogcjtcbiAgICByZXN1bHRbMV0gPSAwO1xuICAgIHRlcm0xID0gKGIgLyAzLjApO1xuICAgIFxuICAgIGlmIChkaXNjcmltaW5hbnQgPiAwKSB7XG4gICAgICBzID0gciArIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgICAgcyA9ICgocyA8IDApID8gLU1hdGgucG93KC1zLCAoMS4wIC8gMy4wKSkgOiBNYXRoLnBvdyhzLCAoMS4wIC8gMy4wKSkpO1xuICAgICAgdCA9IHIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICAgIHQgPSAoKHQgPCAwKSA/IC1NYXRoLnBvdygtdCwgKDEuMCAvIDMuMCkpIDogTWF0aC5wb3codCwgKDEuMCAvIDMuMCkpKTtcbiAgICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIHMgKyB0O1xuICAgICAgdGVybTEgKz0gKHMgKyB0KSAvIDIuMDtcbiAgICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC10ZXJtMTtcbiAgICAgIHRlcm0xID0gTWF0aC5zcXJ0KDMuMCkgKiAoLXQgKyBzKSAvIDI7XG4gICAgICByZXN1bHRbM10gPSB0ZXJtMTtcbiAgICAgIHJlc3VsdFs1XSA9IC10ZXJtMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgcmVzdWx0WzVdID0gcmVzdWx0WzNdID0gMDtcbiAgICBcbiAgICBpZiAoZGlzY3JpbWluYW50ID09PSAwKSB7XG4gICAgICByMTMgPSAoKHIgPCAwKSA/IC1NYXRoLnBvdygtciwgKDEuMCAvIDMuMCkpIDogTWF0aC5wb3cociwgKDEuMCAvIDMuMCkpKTtcbiAgICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIDIuMCAqIHIxMztcbiAgICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC0ocjEzICsgdGVybTEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBxID0gLXE7XG4gICAgZHVtMSA9IHEgKiBxICogcTtcbiAgICBkdW0xID0gTWF0aC5hY29zKHIgLyBNYXRoLnNxcnQoZHVtMSkpO1xuICAgIHIxMyA9IDIuMCAqIE1hdGguc3FydChxKTtcbiAgICByZXN1bHRbMF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcyhkdW0xIC8gMy4wKTtcbiAgICByZXN1bHRbMl0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDIuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgICByZXN1bHRbNF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDQuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgICBcbiAgICByZXR1cm47XG4gIH07XG5cbiAgJCQubWF0aC5zcURpc3RhbmNlVG9RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbihcbiAgICB4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgXG4gICAgLy8gRmluZCBtaW5pbXVtIGRpc3RhbmNlIGJ5IHVzaW5nIHRoZSBtaW5pbXVtIG9mIHRoZSBkaXN0YW5jZSBcbiAgICAvLyBmdW5jdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludCBhbmQgdGhlIGN1cnZlXG4gICAgXG4gICAgLy8gVGhpcyBnaXZlcyB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSByZXN1bHRpbmcgY3ViaWMgZXF1YXRpb25cbiAgICAvLyB3aG9zZSByb290cyB0ZWxsIHVzIHdoZXJlIGEgcG9zc2libGUgbWluaW11bSBpc1xuICAgIC8vIChDb2VmZmljaWVudHMgYXJlIGRpdmlkZWQgYnkgNClcbiAgICBcbiAgICB2YXIgYSA9IDEuMCAqIHgxKngxIC0gNCp4MSp4MiArIDIqeDEqeDMgKyA0KngyKngyIC0gNCp4Mip4MyArIHgzKngzXG4gICAgICArIHkxKnkxIC0gNCp5MSp5MiArIDIqeTEqeTMgKyA0KnkyKnkyIC0gNCp5Mip5MyArIHkzKnkzO1xuICAgIFxuICAgIHZhciBiID0gMS4wICogOSp4MSp4MiAtIDMqeDEqeDEgLSAzKngxKngzIC0gNip4Mip4MiArIDMqeDIqeDNcbiAgICAgICsgOSp5MSp5MiAtIDMqeTEqeTEgLSAzKnkxKnkzIC0gNip5Mip5MiArIDMqeTIqeTM7XG4gICAgXG4gICAgdmFyIGMgPSAxLjAgKiAzKngxKngxIC0gNip4MSp4MiArIHgxKngzIC0geDEqeCArIDIqeDIqeDIgKyAyKngyKnggLSB4Myp4XG4gICAgICArIDMqeTEqeTEgLSA2KnkxKnkyICsgeTEqeTMgLSB5MSp5ICsgMip5Mip5MiArIDIqeTIqeSAtIHkzKnk7XG4gICAgICBcbiAgICB2YXIgZCA9IDEuMCAqIHgxKngyIC0geDEqeDEgKyB4MSp4IC0geDIqeFxuICAgICAgKyB5MSp5MiAtIHkxKnkxICsgeTEqeSAtIHkyKnk7XG4gICAgXG4gICAgLy8gZGVidWcoXCJjb2VmZmljaWVudHM6IFwiICsgYSAvIGEgKyBcIiwgXCIgKyBiIC8gYSArIFwiLCBcIiArIGMgLyBhICsgXCIsIFwiICsgZCAvIGEpO1xuICAgIFxuICAgIHZhciByb290cyA9IFtdO1xuICAgIFxuICAgIC8vIFVzZSB0aGUgY3ViaWMgc29sdmluZyBhbGdvcml0aG1cbiAgICB0aGlzLnNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcm9vdHMpO1xuICAgIFxuICAgIHZhciB6ZXJvVGhyZXNob2xkID0gMC4wMDAwMDAxO1xuICAgIFxuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXggKz0gMikge1xuICAgICAgaWYgKE1hdGguYWJzKHJvb3RzW2luZGV4ICsgMV0pIDwgemVyb1RocmVzaG9sZFxuICAgICAgICAgICYmIHJvb3RzW2luZGV4XSA+PSAwXG4gICAgICAgICAgJiYgcm9vdHNbaW5kZXhdIDw9IDEuMCkge1xuICAgICAgICBwYXJhbXMucHVzaChyb290c1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBwYXJhbXMucHVzaCgxLjApO1xuICAgIHBhcmFtcy5wdXNoKDAuMCk7XG4gICAgXG4gICAgdmFyIG1pbkRpc3RhbmNlU3F1YXJlZCA9IC0xO1xuICAgIHZhciBjbG9zZXN0UGFyYW07XG4gICAgXG4gICAgdmFyIGN1clgsIGN1clksIGRpc3RTcXVhcmVkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJYID0gTWF0aC5wb3coMS4wIC0gcGFyYW1zW2ldLCAyLjApICogeDFcbiAgICAgICAgKyAyLjAgKiAoMSAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB4MlxuICAgICAgICArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHgzO1xuICAgICAgICBcbiAgICAgIGN1clkgPSBNYXRoLnBvdygxIC0gcGFyYW1zW2ldLCAyLjApICogeTFcbiAgICAgICAgKyAyICogKDEuMCAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB5MlxuICAgICAgICArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHkzO1xuICAgICAgICBcbiAgICAgIGRpc3RTcXVhcmVkID0gTWF0aC5wb3coY3VyWCAtIHgsIDIpICsgTWF0aC5wb3coY3VyWSAtIHksIDIpO1xuICAgICAgLy8gZGVidWcoJ2Rpc3RhbmNlIGZvciBwYXJhbSAnICsgcGFyYW1zW2ldICsgXCI6IFwiICsgTWF0aC5zcXJ0KGRpc3RTcXVhcmVkKSk7XG4gICAgICBpZiAobWluRGlzdGFuY2VTcXVhcmVkID49IDApIHtcbiAgICAgICAgaWYgKGRpc3RTcXVhcmVkIDwgbWluRGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICAgICAgY2xvc2VzdFBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICAgICAgY2xvc2VzdFBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKlxuICAgIGRlYnVnU3RhdHMuY2xpY2tYID0geDtcbiAgICBkZWJ1Z1N0YXRzLmNsaWNrWSA9IHk7XG4gICAgXG4gICAgZGVidWdTdGF0cy5jbG9zZXN0WCA9IE1hdGgucG93KDEuMCAtIGNsb3Nlc3RQYXJhbSwgMi4wKSAqIHgxXG4gICAgICAgICsgMi4wICogKDEuMCAtIGNsb3Nlc3RQYXJhbSkgKiBjbG9zZXN0UGFyYW0gKiB4MlxuICAgICAgICArIGNsb3Nlc3RQYXJhbSAqIGNsb3Nlc3RQYXJhbSAqIHgzO1xuICAgICAgICBcbiAgICBkZWJ1Z1N0YXRzLmNsb3Nlc3RZID0gTWF0aC5wb3coMS4wIC0gY2xvc2VzdFBhcmFtLCAyLjApICogeTFcbiAgICAgICAgKyAyLjAgKiAoMS4wIC0gY2xvc2VzdFBhcmFtKSAqIGNsb3Nlc3RQYXJhbSAqIHkyXG4gICAgICAgICsgY2xvc2VzdFBhcmFtICogY2xvc2VzdFBhcmFtICogeTM7XG4gICAgKi9cbiAgICBcbiAgICAvLyBkZWJ1ZyhcImdpdmVuOiBcIiBcbiAgICAvLyAgICsgXCIoIFwiICsgeCArIFwiLCBcIiArIHkgKyBcIiksIFwiIFxuICAgIC8vICAgKyBcIiggXCIgKyB4MSArIFwiLCBcIiArIHkxICsgXCIpLCBcIiBcbiAgICAvLyAgICsgXCIoIFwiICsgeDIgKyBcIiwgXCIgKyB5MiArIFwiKSwgXCJcbiAgICAvLyAgICsgXCIoIFwiICsgeDMgKyBcIiwgXCIgKyB5MyArIFwiKVwiKTtcbiAgICBcbiAgICBcbiAgICAvLyBkZWJ1ZyhcInJvb3RzOiBcIiArIHJvb3RzKTtcbiAgICAvLyBkZWJ1ZyhcInBhcmFtczogXCIgKyBwYXJhbXMpO1xuICAgIC8vIGRlYnVnKFwiY2xvc2VzdCBwYXJhbTogXCIgKyBjbG9zZXN0UGFyYW0pO1xuICAgIHJldHVybiBtaW5EaXN0YW5jZVNxdWFyZWQ7XG4gIH07XG4gIFxuICAkJC5tYXRoLnNxRGlzdGFuY2VUb0Zpbml0ZUxpbmUgPSBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBvZmZzZXQgPSBbeCAtIHgxLCB5IC0geTFdO1xuICAgIHZhciBsaW5lID0gW3gyIC0geDEsIHkyIC0geTFdO1xuICAgIFxuICAgIHZhciBsaW5lU3EgPSBsaW5lWzBdICogbGluZVswXSArIGxpbmVbMV0gKiBsaW5lWzFdO1xuICAgIHZhciBoeXBTcSA9IG9mZnNldFswXSAqIG9mZnNldFswXSArIG9mZnNldFsxXSAqIG9mZnNldFsxXTtcbiAgICBcbiAgICB2YXIgZG90UHJvZHVjdCA9IG9mZnNldFswXSAqIGxpbmVbMF0gKyBvZmZzZXRbMV0gKiBsaW5lWzFdO1xuICAgIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuICAgIFxuICAgIGlmIChkb3RQcm9kdWN0IDwgMCkge1xuICAgICAgcmV0dXJuIGh5cFNxO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYWRqU3EgPiBsaW5lU3EpIHtcbiAgICAgIHJldHVybiAoeCAtIHgyKSAqICh4IC0geDIpICsgKHkgLSB5MikgKiAoeSAtIHkyKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGh5cFNxIC0gYWRqU3E7XG4gIH07XG5cbiAgJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24gPSBmdW5jdGlvbihcbiAgICB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcblxuICAgIC8vdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50c1s2XTtcbiAgICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuXG4gICAgLy8gR2l2ZXMgbmVnYXRpdmUgYW5nbGVcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZGlyZWN0aW9uWzFdIC8gKE1hdGguc3FydChkaXJlY3Rpb25bMF0gKiBkaXJlY3Rpb25bMF0gXG4gICAgICArIGRpcmVjdGlvblsxXSAqIGRpcmVjdGlvblsxXSkpKTtcbiAgICBcbiAgICBpZiAoZGlyZWN0aW9uWzBdIDwgMCkge1xuICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IC1hbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgIH1cbiAgICAgICAgXG4gICAgdmFyIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgXG4vLyAgICBjb25zb2xlLmxvZyhcImJhc2U6IFwiICsgYmFzZVBvaW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IFxuICAgICAgICB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1tpICogMl0gKiBjb3NcbiAgICAgICAgICAtIGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIHNpbik7XG4gICAgICBcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBcbiAgICAgICAgaGVpZ2h0IC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBjb3MgXG4gICAgICAgICAgKyBiYXNlUG9pbnRzW2kgKiAyXSAqIHNpbik7XG5cbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSArPSBjZW50ZXJYO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSArPSBjZW50ZXJZO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcG9pbnRzO1xuICAgIFxuICAgIGlmIChwYWRkaW5nID4gMCkge1xuICAgICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IHRoaXMuZXhwYW5kUG9seWdvbihcbiAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMsXG4gICAgICAgIC1wYWRkaW5nKTtcbiAgICAgIFxuICAgICAgcG9pbnRzID0gdGhpcy5qb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuICAgIFxuICAgIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgICB2YXIgeTM7XG4gICAgXG4gICAgLy8gSW50ZXJzZWN0IHdpdGggdmVydGljYWwgbGluZSB0aHJvdWdoICh4LCB5KVxuICAgIHZhciB1cCA9IDA7XG4gICAgdmFyIGRvd24gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgXG4gICAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgICB5MSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgXG4gICAgICBpZiAoaSArIDEgPCBwb2ludHMubGVuZ3RoIC8gMikge1xuICAgICAgICB4MiA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICAgIHkyID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyXTtcbiAgICAgICAgeTIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMiArIDFdO1xuICAgICAgfVxuICAgICAgXG4vLyogICAgICBjb25zb2xlLmxvZyhcImxpbmUgZnJvbSAoXCIgKyB4MSArIFwiLCBcIiArIHkxICsgXCIpIHRvIChcIiArIHgyICsgXCIsIFwiICsgeTIgKyBcIilcIik7XG5cbi8vJiAgICAgIGNvbnNvbGUubG9nKHgxLCB4LCB4Mik7XG5cbiAgICAgIGlmICh4MSA9PSB4ICYmIHgyID09IHgpIHtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKCh4MSA+PSB4ICYmIHggPj0geDIpXG4gICAgICAgIHx8ICh4MSA8PSB4ICYmIHggPD0geDIpKSB7XG4gICAgICAgIFxuICAgICAgICB5MyA9ICh4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG4gICAgICAgIFxuICAgICAgICBpZiAoeTMgPiB5KSB7XG4gICAgICAgICAgdXArKztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHkzIDwgeSkge1xuICAgICAgICAgIGRvd24rKztcbiAgICAgICAgfVxuICAgICAgICBcbi8vKiAgICAgICAgY29uc29sZS5sb2coeTMsIHkpO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG4vLyogICAgICAgIGNvbnNvbGUubG9nKCcyMicpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH1cbiAgICBcbi8vKiAgICBjb25zb2xlLmxvZyhcInVwOiBcIiArIHVwICsgXCIsIGRvd246IFwiICsgZG93bik7XG4gICAgXG4gICAgaWYgKHVwICUgMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgJCQubWF0aC5qb2luTGluZXMgPSBmdW5jdGlvbihsaW5lU2V0KSB7XG4gICAgXG4gICAgdmFyIHZlcnRpY2VzID0gbmV3IEFycmF5KGxpbmVTZXQubGVuZ3RoIC8gMik7XG4gICAgXG4gICAgdmFyIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFk7XG4gICAgdmFyIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQ7IGkrKykge1xuICAgICAgY3VycmVudExpbmVTdGFydFggPSBsaW5lU2V0W2kgKiA0XTtcbiAgICAgIGN1cnJlbnRMaW5lU3RhcnRZID0gbGluZVNldFtpICogNCArIDFdO1xuICAgICAgY3VycmVudExpbmVFbmRYID0gbGluZVNldFtpICogNCArIDJdO1xuICAgICAgY3VycmVudExpbmVFbmRZID0gbGluZVNldFtpICogNCArIDNdO1xuICAgICAgXG4gICAgICBpZiAoaSA8IGxpbmVTZXQubGVuZ3RoIC8gNCAtIDEpIHtcbiAgICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WyhpICsgMSkgKiA0XTtcbiAgICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMV07XG4gICAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAyXTtcbiAgICAgICAgbmV4dExpbmVFbmRZID0gbGluZVNldFsoaSArIDEpICogNCArIDNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WzBdO1xuICAgICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbMV07XG4gICAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbMl07XG4gICAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbM107XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgICBjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksXG4gICAgICAgIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZLFxuICAgICAgICBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksXG4gICAgICAgIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZLFxuICAgICAgICB0cnVlKTtcbiAgICAgIFxuICAgICAgdmVydGljZXNbaSAqIDJdID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgICAgdmVydGljZXNbaSAqIDIgKyAxXSA9IGludGVyc2VjdGlvblsxXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHZlcnRpY2VzO1xuICB9O1xuXG4gICQkLm1hdGguZXhwYW5kUG9seWdvbiA9IGZ1bmN0aW9uKHBvaW50cywgcGFkKSB7XG4gICAgXG4gICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoICogMik7XG4gICAgXG4gICAgdmFyIGN1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFksIG5leHRQb2ludFgsIG5leHRQb2ludFk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBjdXJyZW50UG9pbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgIGN1cnJlbnRQb2ludFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIFxuICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRQb2ludFggPSBwb2ludHNbMF07XG4gICAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEN1cnJlbnQgbGluZTogW2N1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFldIHRvIFtuZXh0UG9pbnRYLCBuZXh0UG9pbnRZXVxuICAgICAgXG4gICAgICAvLyBBc3N1bWUgQ0NXIHBvbHlnb24gd2luZGluZ1xuICAgICAgXG4gICAgICB2YXIgb2Zmc2V0WCA9IChuZXh0UG9pbnRZIC0gY3VycmVudFBvaW50WSk7XG4gICAgICB2YXIgb2Zmc2V0WSA9IC0obmV4dFBvaW50WCAtIGN1cnJlbnRQb2ludFgpO1xuICAgICAgXG4gICAgICAvLyBOb3JtYWxpemVcbiAgICAgIHZhciBvZmZzZXRMZW5ndGggPSBNYXRoLnNxcnQob2Zmc2V0WCAqIG9mZnNldFggKyBvZmZzZXRZICogb2Zmc2V0WSk7XG4gICAgICB2YXIgbm9ybWFsaXplZE9mZnNldFggPSBvZmZzZXRYIC8gb2Zmc2V0TGVuZ3RoO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRZID0gb2Zmc2V0WSAvIG9mZnNldExlbmd0aDtcbiAgICAgIFxuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0XSA9IGN1cnJlbnRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDFdID0gY3VycmVudFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgMl0gPSBuZXh0UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAzXSA9IG5leHRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGV4cGFuZGVkTGluZVNldDtcbiAgfTtcblxuICAkJC5tYXRoLmludGVyc2VjdExpbmVFbGxpcHNlID0gZnVuY3Rpb24oXG4gICAgeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgZWxsaXBzZVdyYWRpdXMsIGVsbGlwc2VIcmFkaXVzKSB7XG4gICAgXG4gICAgdmFyIGRpc3BYID0gY2VudGVyWCAtIHg7XG4gICAgdmFyIGRpc3BZID0gY2VudGVyWSAtIHk7XG4gICAgXG4gICAgZGlzcFggLz0gZWxsaXBzZVdyYWRpdXM7XG4gICAgZGlzcFkgLz0gZWxsaXBzZUhyYWRpdXM7XG4gICAgXG4gICAgdmFyIGxlbiA9IE1hdGguc3FydChkaXNwWCAqIGRpc3BYICsgZGlzcFkgKiBkaXNwWSk7XG4gICAgXG4gICAgdmFyIG5ld0xlbmd0aCA9IGxlbiAtIDE7XG4gICAgXG4gICAgaWYgKG5ld0xlbmd0aCA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGxlblByb3BvcnRpb24gPSBuZXdMZW5ndGggLyBsZW47XG4gICAgXG4gICAgcmV0dXJuIFsoY2VudGVyWCAtIHgpICogbGVuUHJvcG9ydGlvbiArIHgsIChjZW50ZXJZIC0geSkgKiBsZW5Qcm9wb3J0aW9uICsgeV07XG4gIH07XG4gIFxuICAkJC5tYXRoLmRvdFByb2R1Y3QgPSBmdW5jdGlvbihcbiAgICB2ZWMxLCB2ZWMyKSB7XG4gICAgXG4gICAgaWYgKHZlYzEubGVuZ3RoICE9IDIgfHwgdmVjMi5sZW5ndGggIT0gMikge1xuICAgICAgdGhyb3cgJ2RvdCBwcm9kdWN0OiBhcmd1bWVudHMgYXJlIG5vdCB2ZWN0b3JzJztcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuICh2ZWMxWzBdICogdmVjMlswXSArIHZlYzFbMV0gKiB2ZWMyWzFdKTtcbiAgfTtcbiAgXG4gIC8vIFJldHVybnMgaW50ZXJzZWN0aW9ucyBvZiBpbmNyZWFzaW5nIGRpc3RhbmNlIGZyb20gbGluZSdzIHN0YXJ0IHBvaW50XG4gICQkLm1hdGguaW50ZXJzZWN0TGluZUNpcmNsZSA9IGZ1bmN0aW9uKFxuICAgIHgxLCB5MSwgeDIsIHkyLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMpIHtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZCwgZGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gICAgdmFyIGQgPSBbeDIgLSB4MSwgeTIgLSB5MV07IC8vIERpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICAgIHZhciBjID0gW2NlbnRlclgsIGNlbnRlclldOyAvLyBDZW50ZXIgb2YgY2lyY2xlXG4gICAgdmFyIGYgPSBbeDEgLSBjZW50ZXJYLCB5MSAtIGNlbnRlclldO1xuICAgIFxuICAgIHZhciBhID0gZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXTtcbiAgICB2YXIgYiA9IDIgKiAoZlswXSAqIGRbMF0gKyBmWzFdICogZFsxXSk7XG4gICAgdmFyIGMgPSAoZlswXSAqIGZbMF0gKyBmWzFdICogZlsxXSkgLSByYWRpdXMgKiByYWRpdXMgO1xuICAgIFxuICAgIHZhciBkaXNjcmltaW5hbnQgPSBiKmItNCphKmM7XG4gICAgXG4gICAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICAgIFxuICAgIHZhciB0TWluID0gTWF0aC5taW4odDEsIHQyKTtcbiAgICB2YXIgdE1heCA9IE1hdGgubWF4KHQxLCB0Mik7XG4gICAgdmFyIGluUmFuZ2VQYXJhbXMgPSBbXTtcbiAgICBcbiAgICBpZiAodE1pbiA+PSAwICYmIHRNaW4gPD0gMSkge1xuICAgICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNaW4pO1xuICAgIH1cbiAgICBcbiAgICBpZiAodE1heCA+PSAwICYmIHRNYXggPD0gMSkge1xuICAgICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNYXgpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgdmFyIG5lYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMF0gKyB4MTtcbiAgICB2YXIgbmVhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzBdICogZFsxXSArIHkxO1xuICAgIFxuICAgIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICBcbiAgICAgIGlmIChpblJhbmdlUGFyYW1zWzBdID09IGluUmFuZ2VQYXJhbXNbMV0pIHtcbiAgICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMF0gKyB4MTtcbiAgICAgICAgdmFyIGZhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzFdICogZFsxXSArIHkxO1xuICAgICAgXG4gICAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZLCBmYXJJbnRlcnNlY3Rpb25YLCBmYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWV07XG4gICAgfVxuICAgIFxuICB9O1xuICBcbiAgJCQubWF0aC5maW5kQ2lyY2xlTmVhclBvaW50ID0gZnVuY3Rpb24oY2VudGVyWCwgY2VudGVyWSwgXG4gICAgcmFkaXVzLCBmYXJYLCBmYXJZKSB7XG4gICAgXG4gICAgdmFyIGRpc3BsYWNlbWVudFggPSBmYXJYIC0gY2VudGVyWDtcbiAgICB2YXIgZGlzcGxhY2VtZW50WSA9IGZhclkgLSBjZW50ZXJZO1xuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXNwbGFjZW1lbnRYICogZGlzcGxhY2VtZW50WCBcbiAgICAgICsgZGlzcGxhY2VtZW50WSAqIGRpc3BsYWNlbWVudFkpO1xuICAgIFxuICAgIHZhciB1bml0RGlzcGxhY2VtZW50WCA9IGRpc3BsYWNlbWVudFggLyBkaXN0YW5jZTtcbiAgICB2YXIgdW5pdERpc3BsYWNlbWVudFkgPSBkaXNwbGFjZW1lbnRZIC8gZGlzdGFuY2U7XG4gICAgXG4gICAgcmV0dXJuIFtjZW50ZXJYICsgdW5pdERpc3BsYWNlbWVudFggKiByYWRpdXMsIFxuICAgICAgY2VudGVyWSArIHVuaXREaXNwbGFjZW1lbnRZICogcmFkaXVzXTtcbiAgfTtcbiAgXG4gICQkLm1hdGguZmluZE1heFNxRGlzdGFuY2VUb09yaWdpbiA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIHZhciBtYXhTcURpc3RhbmNlID0gMC4wMDAwMDE7XG4gICAgdmFyIHNxRGlzdGFuY2U7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBcbiAgICAgIHNxRGlzdGFuY2UgPSBwb2ludHNbaSAqIDJdICogcG9pbnRzW2kgKiAyXSBcbiAgICAgICAgKyBwb2ludHNbaSAqIDIgKyAxXSAqIHBvaW50c1tpICogMiArIDFdO1xuICAgICAgXG4gICAgICBpZiAoc3FEaXN0YW5jZSA+IG1heFNxRGlzdGFuY2UpIHtcbiAgICAgICAgbWF4U3FEaXN0YW5jZSA9IHNxRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBtYXhTcURpc3RhbmNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdCA9IGZ1bmN0aW9uKFxuICAgIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgaW5maW5pdGVMaW5lcykge1xuICAgIFxuICAgIHZhciB1YV90ID0gKHg0IC0geDMpICogKHkxIC0geTMpIC0gKHk0IC0geTMpICogKHgxIC0geDMpO1xuICAgIHZhciB1Yl90ID0gKHgyIC0geDEpICogKHkxIC0geTMpIC0gKHkyIC0geTEpICogKHgxIC0geDMpO1xuICAgIHZhciB1X2IgPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XG5cbiAgICBpZiAodV9iICE9PSAwKSB7XG4gICAgICB2YXIgdWEgPSB1YV90IC8gdV9iO1xuICAgICAgdmFyIHViID0gdWJfdCAvIHVfYjtcbiAgICAgIFxuICAgICAgaWYgKDAgPD0gdWEgJiYgdWEgPD0gMSAmJiAwIDw9IHViICYmIHViIDw9IDEpIHsgIFxuICAgICAgICByZXR1cm4gW3gxICsgdWEgKiAoeDIgLSB4MSksIHkxICsgdWEgKiAoeTIgLSB5MSldO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaW5maW5pdGVMaW5lcykge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW3gxICsgdWEgKiAoeDIgLSB4MSksIHkxICsgdWEgKiAoeTIgLSB5MSldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh1YV90ID09PSAwIHx8IHViX3QgPT09IDApIHtcblxuICAgICAgICAvLyBQYXJhbGxlbCwgY29pbmNpZGVudCBsaW5lcy4gQ2hlY2sgaWYgb3ZlcmxhcFxuXG4gICAgICAgIC8vIENoZWNrIGVuZHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICAgIGlmIChbeDEsIHgyLCB4NF0uc29ydCgpWzFdID09PSB4NCkge1xuICAgICAgICAgIHJldHVybiBbeDQsIHk0XTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgc3RhcnQgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAgICAgICAgaWYgKFt4MSwgeDIsIHgzXS5zb3J0KClbMV0gPT09IHgzKSB7XG4gICAgICAgICAgcmV0dXJuIFt4MywgeTNdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBFbmRwb2ludCBvZiBmaXJzdCBsaW5lXG4gICAgICAgIGlmIChbeDMsIHg0LCB4Ml0uc29ydCgpWzFdID09PSB4Mikge1xuICAgICAgICAgIHJldHVybiBbeDIsIHkyXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIFxuICAgICAgICAvLyBQYXJhbGxlbCwgbm9uLWNvaW5jaWRlbnRcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgXG4gIC8vIChib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAvLyAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hUb3BMZWZ0WCArIHBhZGRpbmcsIGhCb3hUb3BMZWZ0WSArIHBhZGRpbmcpKSB7XG4gIFxuICAkJC5tYXRoLmJveEludGVyc2VjdEVsbGlwc2UgPSBmdW5jdGlvbihcbiAgICB4MSwgeTEsIHgyLCB5MiwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgIFxuICAgIGlmICh4MiA8IHgxKSB7XG4gICAgICB2YXIgb2xkWDEgPSB4MTtcbiAgICAgIHgxID0geDI7XG4gICAgICB4MiA9IG9sZFgxO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTIgPCB5MSkge1xuICAgICAgdmFyIG9sZFkxID0geTE7XG4gICAgICB5MSA9IHkyO1xuICAgICAgeTIgPSBvbGRZMTtcbiAgICB9XG4gICAgXG4gICAgLy8gNCBvcnRobyBleHRyZW1lIHBvaW50c1xuICAgIHZhciB3ZXN0ID0gW2NlbnRlclggLSB3aWR0aCAvIDIgLSBwYWRkaW5nLCBjZW50ZXJZXTtcbiAgICB2YXIgZWFzdCA9IFtjZW50ZXJYICsgd2lkdGggLyAyICsgcGFkZGluZywgY2VudGVyWV07XG4gICAgdmFyIG5vcnRoID0gW2NlbnRlclgsIGNlbnRlclkgLSBoZWlnaHQgLyAyIC0gcGFkZGluZ107XG4gICAgdmFyIHNvdXRoID0gW2NlbnRlclgsIGNlbnRlclkgKyBoZWlnaHQgLyAyICsgcGFkZGluZ107XG4gICAgXG4gICAgLy8gb3V0IG9mIGJvdW5kczogcmV0dXJuIGZhbHNlXG4gICAgaWYgKHgyIDwgd2VzdFswXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgPiBlYXN0WzBdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmICh5MSA+IHNvdXRoWzFdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmICh5MiA8IG5vcnRoWzFdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIDEgb2YgNCBvcnRobyBleHRyZW1lIHBvaW50cyBpbiBib3g6IHJldHVybiB0cnVlXG4gICAgaWYgKHgxIDw9IGVhc3RbMF0gJiYgZWFzdFswXSA8PSB4MlxuICAgICAgICAmJiB5MSA8PSBlYXN0WzFdICYmIGVhc3RbMV0gPD0geTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgPD0gd2VzdFswXSAmJiB3ZXN0WzBdIDw9IHgyXG4gICAgICAgICYmIHkxIDw9IHdlc3RbMV0gJiYgd2VzdFsxXSA8PSB5Mikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MSA8PSBub3J0aFswXSAmJiBub3J0aFswXSA8PSB4MlxuICAgICAgICAmJiB5MSA8PSBub3J0aFsxXSAmJiBub3J0aFsxXSA8PSB5Mikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MSA8PSBzb3V0aFswXSAmJiBzb3V0aFswXSA8PSB4MlxuICAgICAgICAmJiB5MSA8PSBzb3V0aFsxXSAmJiBzb3V0aFsxXSA8PSB5Mikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIGJveCBjb3JuZXIgaW4gZWxsaXBzZTogcmV0dXJuIHRydWUgICAgXG4gICAgeDEgPSAoeDEgLSBjZW50ZXJYKSAvICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICB4MiA9ICh4MiAtIGNlbnRlclgpIC8gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgIFxuICAgIHkxID0gKHkxIC0gY2VudGVyWSkgLyAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgIHkyID0gKHkyIC0gY2VudGVyWSkgLyAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgIFxuICAgIGlmICh4MSAqIHgxICsgeTEgKiB5MSA8PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgyICogeDIgKyB5MSAqIHkxIDw9IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDIgKiB4MiArIHkyICogeTIgPD0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MSAqIHgxICsgeTIgKiB5MiA8PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5ib3hJbnRlcnNlY3RQb2x5Z29uID0gZnVuY3Rpb24oXG4gICAgeDEsIHkxLCB4MiwgeTIsIGJhc2VQb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgIFxuLy8gICAgY29uc29sZS5sb2coYXJndW1lbnRzKTtcbiAgICBcbiAgICBpZiAoeDIgPCB4MSkge1xuICAgICAgdmFyIG9sZFgxID0geDE7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeDIgPSBvbGRYMTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHkyIDwgeTEpIHtcbiAgICAgIHZhciBvbGRZMSA9IHkxO1xuICAgICAgeTEgPSB5MjtcbiAgICAgIHkyID0gb2xkWTE7XG4gICAgfVxuICAgIFxuICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gICAgXG4gICAgLy8gR2l2ZXMgbmVnYXRpdmUgb2YgYW5nbGVcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZGlyZWN0aW9uWzFdIC8gKE1hdGguc3FydChkaXJlY3Rpb25bMF0gKiBkaXJlY3Rpb25bMF0gXG4gICAgICArIGRpcmVjdGlvblsxXSAqIGRpcmVjdGlvblsxXSkpKTtcbiAgICBcbiAgICBpZiAoZGlyZWN0aW9uWzBdIDwgMCkge1xuICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IC1hbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgIH1cbiAgICBcbiAgICB2YXIgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICB2YXIgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gXG4gICAgICAgIHdpZHRoIC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyXSAqIGNvc1xuICAgICAgICAgIC0gYmFzZVBvaW50c1tpICogMiArIDFdICogc2luKTtcbiAgICAgIFxuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IFxuICAgICAgICBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGNvcyBcbiAgICAgICAgICArIGJhc2VQb2ludHNbaSAqIDJdICogc2luKTtcbiAgICAgIFxuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdICs9IGNlbnRlclg7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdICs9IGNlbnRlclk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFzc3VtZSB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggPiAwLCBhbmQgY2hlY2sgaWYgaW50ZXJzZWN0aW9uIGlzIHBvc3NpYmxlXG4gICAgdmFyIG1pblRyYW5zZm9ybWVkWCA9IHRyYW5zZm9ybWVkUG9pbnRzWzBdO1xuICAgIHZhciBtYXhUcmFuc2Zvcm1lZFggPSB0cmFuc2Zvcm1lZFBvaW50c1swXTtcbiAgICB2YXIgbWluVHJhbnNmb3JtZWRZID0gdHJhbnNmb3JtZWRQb2ludHNbMV07XG4gICAgdmFyIG1heFRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkUG9pbnRzWzFdO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBpZiAodHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID4gbWF4VHJhbnNmb3JtZWRYKSB7XG4gICAgICAgIG1heFRyYW5zZm9ybWVkWCA9IHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA8IG1pblRyYW5zZm9ybWVkWCkge1xuICAgICAgICBtaW5UcmFuc2Zvcm1lZFggPSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID4gbWF4VHJhbnNmb3JtZWRZKSB7XG4gICAgICAgIG1heFRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdIDwgbWluVHJhbnNmb3JtZWRZKSB7XG4gICAgICAgIG1pblRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICh4MiA8IG1pblRyYW5zZm9ybWVkWCAtIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgxID4gbWF4VHJhbnNmb3JtZWRYICsgcGFkZGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTIgPCBtaW5UcmFuc2Zvcm1lZFkgLSBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmICh5MSA+IG1heFRyYW5zZm9ybWVkWSArIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29udGludWUgY2hlY2tpbmcgd2l0aCBwYWRkaW5nLWNvcnJlY3RlZCBwb2ludHNcbiAgICB2YXIgcG9pbnRzO1xuICAgIFxuICAgIGlmIChwYWRkaW5nID4gMCkge1xuICAgICAgdmFyIGV4cGFuZGVkTGluZVNldCA9ICQkLm1hdGguZXhwYW5kUG9seWdvbihcbiAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMsXG4gICAgICAgIC1wYWRkaW5nKTtcbiAgICAgIFxuICAgICAgcG9pbnRzID0gJCQubWF0aC5qb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGEgcG9pbnQgaXMgaW4gYm94XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGlmICh4MSA8PSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl1cbiAgICAgICAgICAmJiB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPD0geDIpIHtcbiAgICAgICAgXG4gICAgICAgIGlmICh5MSA8PSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdXG4gICAgICAgICAgICAmJiB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdIDw9IHkyKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGludGVyc2VjdGlvbnMgd2l0aCB0aGUgc2VsZWN0aW9uIGJveFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgXG4gICAgICB2YXIgY3VycmVudFggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgdmFyIGN1cnJlbnRZID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICB2YXIgbmV4dFg7XG4gICAgICB2YXIgbmV4dFk7XG4gICAgICBcbiAgICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWzBdO1xuICAgICAgICBuZXh0WSA9IHBvaW50c1sxXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSW50ZXJzZWN0aW9uIHdpdGggdG9wIG9mIHNlbGVjdGlvbiBib3hcbiAgICAgIGlmICgkJC5tYXRoLmZpbml0ZUxpbmVzSW50ZXJzZWN0KGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZLCB4MSwgeTEsIHgyLCB5MSwgZmFsc2UpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEludGVyc2VjdGlvbiB3aXRoIGJvdHRvbSBvZiBzZWxlY3Rpb24gYm94XG4gICAgICBpZiAoJCQubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WSwgeDEsIHkyLCB4MiwgeTIsIGZhbHNlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJbnRlcnNlY3Rpb24gd2l0aCBsZWZ0IHNpZGUgb2Ygc2VsZWN0aW9uIGJveFxuICAgICAgaWYgKCQkLm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QoY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFksIHgxLCB5MSwgeDEsIHkyLCBmYWxzZSkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSW50ZXJzZWN0aW9uIHdpdGggcmlnaHQgc2lkZSBvZiBzZWxlY3Rpb24gYm94XG4gICAgICBpZiAoJCQubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WSwgeDIsIHkxLCB4MiwgeTIsIGZhbHNlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgLy8gQ2hlY2sgaWYgYm94IGNvcm5lciBpbiB0aGUgcG9seWdvblxuICAgIGlmICgkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgIHgxLCB5MSwgcG9pbnRzLCAwLCAwLCAxLCAxLCAwLCBkaXJlY3Rpb24pKSB7XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICB4MSwgeTIsIHBvaW50cywgMCwgMCwgMSwgMSwgMCwgZGlyZWN0aW9uKSkge1xuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgeDIsIHkyLCBwb2ludHMsIDAsIDAsIDEsIDEsIDAsIGRpcmVjdGlvbikpIHtcbiAgICAgICBcbiAgICAgIHJldHVybiB0cnVlOyBcbiAgICB9IGVsc2UgaWYgKCQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgeDIsIHkxLCBwb2ludHMsIDAsIDAsIDEsIDEsIDAsIGRpcmVjdGlvbikpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgICovXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICAgIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgICBcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIHZhciBpbnRlcnNlY3Rpb247XG4gICAgXG4gICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gYmFzZVBvaW50c1tpICogMl0gKiB3aWR0aCArIGNlbnRlclg7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gYmFzZVBvaW50c1tpICogMiArIDFdICogaGVpZ2h0ICsgY2VudGVyWTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHBvaW50cztcbiAgICBcbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSAkJC5tYXRoLmV4cGFuZFBvbHlnb24oXG4gICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzLFxuICAgICAgICAtcGFkZGluZyk7XG4gICAgICBcbiAgICAgIHBvaW50cyA9ICQkLm1hdGguam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIH1cbiAgICAvLyB2YXIgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgXG4gICAgdmFyIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIFxuICAgICAgY3VycmVudFggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgY3VycmVudFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgbmV4dFggPSBwb2ludHNbKGkgKyAxKSAqIDJdOyBcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWzBdOyBcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGludGVyc2VjdGlvbiA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIGN1cnJlbnRYLCBjdXJyZW50WSxcbiAgICAgICAgbmV4dFgsIG5leHRZKTtcbiAgICAgIFxuICAgICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH07XG4gIFxuICAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihcbiAgICBpbnRlcnNlY3Rpb24sIG9mZnNldCwgYW1vdW50KSB7XG4gICAgXG4gICAgdmFyIGRpc3AgPSBbaW50ZXJzZWN0aW9uWzBdIC0gb2Zmc2V0WzBdLCBpbnRlcnNlY3Rpb25bMV0gLSBvZmZzZXRbMV1dO1xuICAgIFxuICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQoZGlzcFswXSAqIGRpc3BbMF0gKyBkaXNwWzFdICogZGlzcFsxXSk7XG4gICAgXG4gICAgdmFyIGxlblJhdGlvID0gKGxlbmd0aCAtIGFtb3VudCkgLyBsZW5ndGg7XG4gICAgXG4gICAgaWYgKGxlblJhdGlvIDwgMCkge1xuICAgICAgbGVuUmF0aW8gPSAwLjAwMDAxO1xuICAgIH1cblxuICAgIHJldHVybiBbb2Zmc2V0WzBdICsgbGVuUmF0aW8gKiBkaXNwWzBdLCBvZmZzZXRbMV0gKyBsZW5SYXRpbyAqIGRpc3BbMV1dO1xuICB9O1xuXG4gICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlID0gZnVuY3Rpb24oc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICAgIHZhciBwb2ludHMgPSAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoc2lkZXMsIHJvdGF0aW9uUmFkaWFucyk7XG4gICAgcG9pbnRzID0gJCQubWF0aC5maXRQb2x5Z29uVG9TcXVhcmUocG9pbnRzKTtcblxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG5cbiAgJCQubWF0aC5maXRQb2x5Z29uVG9TcXVhcmUgPSBmdW5jdGlvbihwb2ludHMpe1xuICAgIHZhciB4LCB5O1xuICAgIHZhciBzaWRlcyA9IHBvaW50cy5sZW5ndGgvMjtcbiAgICB2YXIgbWluWCA9IEluZmluaXR5LCBtaW5ZID0gSW5maW5pdHksIG1heFggPSAtSW5maW5pdHksIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgIHggPSBwb2ludHNbMiAqIGldO1xuICAgICAgeSA9IHBvaW50c1syICogaSArIDFdO1xuXG4gICAgICBtaW5YID0gTWF0aC5taW4oIG1pblgsIHggKTtcbiAgICAgIG1heFggPSBNYXRoLm1heCggbWF4WCwgeCApO1xuICAgICAgbWluWSA9IE1hdGgubWluKCBtaW5ZLCB5ICk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgoIG1heFksIHkgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gc3RyZXRjaCBmYWN0b3JzXG4gICAgdmFyIHN4ID0gMiAvIChtYXhYIC0gbWluWCk7XG4gICAgdmFyIHN5ID0gMiAvIChtYXhZIC0gbWluWSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspe1xuICAgICAgeCA9IHBvaW50c1syICogaV0gPSBwb2ludHNbMiAqIGldICogc3g7XG4gICAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBwb2ludHNbMiAqIGkgKyAxXSAqIHN5O1xuXG4gICAgICBtaW5YID0gTWF0aC5taW4oIG1pblgsIHggKTtcbiAgICAgIG1heFggPSBNYXRoLm1heCggbWF4WCwgeCApO1xuICAgICAgbWluWSA9IE1hdGgubWluKCBtaW5ZLCB5ICk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgoIG1heFksIHkgKTtcbiAgICB9XG5cbiAgICBpZiggbWluWSA8IC0xICl7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspe1xuICAgICAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBwb2ludHNbMiAqIGkgKyAxXSArICgtMSAtbWluWSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG5cbiAgJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzID0gZnVuY3Rpb24oc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICAgIFxuICAgIHZhciBpbmNyZW1lbnQgPSAxLjAgLyBzaWRlcyAqIDIgKiBNYXRoLlBJO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2lkZXMgJSAyID09PSAwID8gXG4gICAgICBNYXRoLlBJIC8gMi4wICsgaW5jcmVtZW50IC8gMi4wIDogTWF0aC5QSSAvIDIuMDtcbi8vICAgIGNvbnNvbGUubG9nKG5vZGVTaGFwZXNbJ3NxdWFyZSddKTtcbiAgICBzdGFydEFuZ2xlICs9IHJvdGF0aW9uUmFkaWFucztcbiAgICBcbiAgICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KHNpZGVzICogMik7XG5cbiAgICB2YXIgY3VycmVudEFuZ2xlLCB4LCB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgY3VycmVudEFuZ2xlID0gaSAqIGluY3JlbWVudCArIHN0YXJ0QW5nbGU7XG4gICAgICBcbiAgICAgIHggPSBwb2ludHNbMiAqIGldID0gTWF0aC5jb3MoY3VycmVudEFuZ2xlKTsvLyAqICgxICsgaS8yKTtcbiAgICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXSA9IE1hdGguc2luKC1jdXJyZW50QW5nbGUpOy8vICAqICgxICsgaS8yKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfTtcblxuICAkJC5tYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIFxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXMsIHVubGVzcyBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodCBpcyBzbWFsbGVyIHRoYW4gZGVmYXVsdFxuICAgIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDQsIGhlaWdodCAvIDQsIDgpO1xuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIHJlZ2lzdGVyZWQgZXh0ZW5zaW9ucyB0byBjeXRvc2NhcGUsIGluZGV4ZWQgYnkgbmFtZVxuICB2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuICAkJC5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgXG4gIC8vIHJlZ2lzdGVyZWQgbW9kdWxlcyBmb3IgZXh0ZW5zaW9ucywgaW5kZXhlZCBieSBuYW1lXG4gIHZhciBtb2R1bGVzID0ge307XG4gICQkLm1vZHVsZXMgPSBtb2R1bGVzO1xuICBcbiAgZnVuY3Rpb24gc2V0RXh0ZW5zaW9uKHR5cGUsIG5hbWUsIHJlZ2lzdHJhbnQpe1xuICAgIHZhciBpbXBsID0ge307XG4gICAgaW1wbFtuYW1lXSA9IHJlZ2lzdHJhbnQ7XG4gICAgXG4gICAgc3dpdGNoKCB0eXBlICl7XG4gICAgY2FzZSAnY29yZSc6XG4gICAgY2FzZSAnY29sbGVjdGlvbic6XG4gICAgICAkJC5mblt0eXBlXSggaW1wbCApO1xuICAgIH1cbiAgICBcbiAgICAvLyBmaWxsIGluIG1pc3NpbmcgbGF5b3V0IGZ1bmN0aW9ucyBpbiB0aGUgcHJvdG90eXBlXG4gICAgaWYoIHR5cGUgPT09ICdsYXlvdXQnICl7XG4gICAgICB2YXIgbGF5b3V0UHJvdG8gPSByZWdpc3RyYW50LnByb3RvdHlwZTtcbiAgICAgIHZhciBvcHRMYXlvdXRGbnMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHRMYXlvdXRGbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGZuTmFtZSA9IG9wdExheW91dEZuc1tpXTtcblxuICAgICAgICBsYXlvdXRQcm90b1tmbk5hbWVdID0gbGF5b3V0UHJvdG9bZm5OYW1lXSB8fCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcbiAgICAgIH1cblxuICAgICAgLy8gZWl0aGVyIC5zdGFydCgpIG9yIC5ydW4oKSBpcyBkZWZpbmVkLCBzbyBhdXRvZ2VuIHRoZSBvdGhlclxuICAgICAgaWYoIGxheW91dFByb3RvLnN0YXJ0ICYmICFsYXlvdXRQcm90by5ydW4gKXtcbiAgICAgICAgbGF5b3V0UHJvdG8ucnVuID0gZnVuY3Rpb24oKXsgdGhpcy5zdGFydCgpOyByZXR1cm4gdGhpczsgfTtcbiAgICAgIH0gZWxzZSBpZiggIWxheW91dFByb3RvLnN0YXJ0ICYmIGxheW91dFByb3RvLnJ1biApe1xuICAgICAgICBsYXlvdXRQcm90by5zdGFydCA9IGZ1bmN0aW9uKCl7IHRoaXMucnVuKCk7IHJldHVybiB0aGlzOyB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggIWxheW91dFByb3RvLnN0b3AgKXtcbiAgICAgICAgbGF5b3V0UHJvdG8uc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIG9wdHMgJiYgb3B0cy5hbmltYXRlICl7XG4gICAgICAgICAgICBvcHRzLmVsZXMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0UHJvdG8ub24gPSAkJC5kZWZpbmUub24oeyBsYXlvdXQ6IHRydWUgfSk7XG4gICAgICBsYXlvdXRQcm90by5vbmUgPSAkJC5kZWZpbmUub24oeyBsYXlvdXQ6IHRydWUsIHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSk7XG4gICAgICBsYXlvdXRQcm90by5vbmNlID0gJCQuZGVmaW5lLm9uKHsgbGF5b3V0OiB0cnVlLCB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiB0cnVlIH0pO1xuICAgICAgbGF5b3V0UHJvdG8ub2ZmID0gJCQuZGVmaW5lLm9mZih7IGxheW91dDogdHJ1ZSB9KTtcbiAgICAgIGxheW91dFByb3RvLnRyaWdnZXIgPSAkJC5kZWZpbmUudHJpZ2dlcih7IGxheW91dDogdHJ1ZSB9KTtcblxuICAgICAgJCQuZGVmaW5lLmV2ZW50QWxpYXNlc09uKCBsYXlvdXRQcm90byApO1xuICAgIH1cblxuICAgIHJldHVybiAkJC51dGlsLnNldE1hcCh7XG4gICAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAgICBrZXlzOiBbIHR5cGUsIG5hbWUgXSxcbiAgICAgIHZhbHVlOiByZWdpc3RyYW50XG4gICAgfSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldEV4dGVuc2lvbih0eXBlLCBuYW1lKXtcbiAgICByZXR1cm4gJCQudXRpbC5nZXRNYXAoe1xuICAgICAgbWFwOiBleHRlbnNpb25zLFxuICAgICAga2V5czogWyB0eXBlLCBuYW1lIF1cbiAgICB9KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gc2V0TW9kdWxlKHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUsIHJlZ2lzdHJhbnQpe1xuICAgIHJldHVybiAkJC51dGlsLnNldE1hcCh7XG4gICAgICBtYXA6IG1vZHVsZXMsXG4gICAgICBrZXlzOiBbIHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUgXSxcbiAgICAgIHZhbHVlOiByZWdpc3RyYW50XG4gICAgfSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKXtcbiAgICByZXR1cm4gJCQudXRpbC5nZXRNYXAoe1xuICAgICAgbWFwOiBtb2R1bGVzLFxuICAgICAga2V5czogWyB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lIF1cbiAgICB9KTtcbiAgfVxuICBcbiAgJCQuZXh0ZW5zaW9uID0gZnVuY3Rpb24oKXtcbiAgICAvLyBlLmcuICQkLmV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJylcbiAgICBpZiggYXJndW1lbnRzLmxlbmd0aCA9PSAyICl7XG4gICAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFxuICAgIC8vIGUuZy4gJCQuZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCB7IC4uLiB9KVxuICAgIGVsc2UgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT0gMyApe1xuICAgICAgcmV0dXJuIHNldEV4dGVuc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBlLmcuICQkLmV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJylcbiAgICBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09IDQgKXtcbiAgICAgIHJldHVybiBnZXRNb2R1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gZS5nLiAkJC5leHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gICAgZWxzZSBpZiggYXJndW1lbnRzLmxlbmd0aCA9PSA1ICl7XG4gICAgICByZXR1cm4gc2V0TW9kdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFxuICAgIGVsc2Uge1xuICAgICAgJCQudXRpbC5lcnJvcignSW52YWxpZCBleHRlbnNpb24gYWNjZXNzIHN5bnRheCcpO1xuICAgIH1cbiAgXG4gIH07XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQsICQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgaWYoICEkICl7IHJldHVybjsgfSAvLyBubyBqcXVlcnkgPT4gZG9uJ3QgbmVlZCB0aGlzXG5cbiAgdmFyIGN5UmVnID0gZnVuY3Rpb24oICRlbGUgKXtcbiAgICB2YXIgZCA9ICRlbGVbMF0uX2N5cmVnID0gJGVsZVswXS5fY3lyZWcgfHwge307XG5cbiAgICByZXR1cm4gZDtcbiAgfTtcblxuICAvLyBhbGxvdyBjYWxscyBvbiBhIGpRdWVyeSBzZWxlY3RvciBieSBwcm94eWluZyBjYWxscyB0byAkLmN5dG9zY2FwZVxuICAvLyBlLmcuICQoXCIjZm9vXCIpLmN5dG9zY2FwZShvcHRpb25zKSA9PiAkLmN5dG9zY2FwZShvcHRpb25zKSBvbiAjZm9vXG4gICQuZm4uY3l0b3NjYXBlID0gZnVuY3Rpb24ob3B0cyl7XG4gICAgdmFyICR0aGlzID0gJCh0aGlzKTtcblxuICAgIC8vIGdldCBvYmplY3RcbiAgICBpZiggb3B0cyA9PT0gJ2dldCcgKXtcbiAgICAgIHJldHVybiBjeVJlZyggJHRoaXMgKS5jeTtcbiAgICB9XG4gICAgXG4gICAgLy8gYmluZCB0byByZWFkeVxuICAgIGVsc2UgaWYoICQkLmlzLmZuKG9wdHMpICl7XG5cbiAgICAgIHZhciByZWFkeSA9IG9wdHM7XG4gICAgICB2YXIgY3kgPSBjeVJlZyggJHRoaXMgKS5jeTtcbiAgICAgIFxuICAgICAgaWYoIGN5ICYmIGN5LmlzUmVhZHkoKSApeyAvLyBhbHJlYWR5IHJlYWR5IHNvIGp1c3QgdHJpZ2dlciBub3dcbiAgICAgICAgY3kudHJpZ2dlcigncmVhZHknLCBbXSwgcmVhZHkpO1xuXG4gICAgICB9IGVsc2UgeyAvLyBub3QgeWV0IHJlYWR5LCBzbyBhZGQgdG8gcmVhZGllcyBsaXN0XG4gICAgICAgIHZhciBkYXRhID0gY3lSZWcoICR0aGlzICk7XG4gICAgICAgIHZhciByZWFkaWVzID0gZGF0YS5yZWFkaWVzID0gZGF0YS5yZWFkaWVzIHx8IFtdO1xuXG4gICAgICAgIHJlYWRpZXMucHVzaCggcmVhZHkgKTtcbiAgICAgIH0gXG4gICAgICBcbiAgICB9XG4gICAgXG4gICAgLy8gcHJveHkgdG8gY3JlYXRlIGluc3RhbmNlXG4gICAgZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3Qob3B0cykgKXtcbiAgICAgIHJldHVybiAkdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIG9wdHMsIHtcbiAgICAgICAgICBjb250YWluZXI6ICQodGhpcylbMF1cbiAgICAgICAgfSk7XG4gICAgICBcbiAgICAgICAgY3l0b3NjYXBlKG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gYWxsb3cgYWNjZXNzIHRvIHRoZSBnbG9iYWwgY3l0b3NjYXBlIG9iamVjdCB1bmRlciBqcXVlcnkgZm9yIGxlZ2FjeSByZWFzb25zXG4gICQuY3l0b3NjYXBlID0gY3l0b3NjYXBlO1xuICBcbiAgLy8gdXNlIHNob3J0IGFsaWFzIChjeSkgaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICBpZiggJC5mbi5jeSA9PSBudWxsICYmICQuY3kgPT0gbnVsbCApe1xuICAgICQuZm4uY3kgPSAkLmZuLmN5dG9zY2FwZTtcbiAgICAkLmN5ID0gJC5jeXRvc2NhcGU7XG4gIH1cbiAgXG59KSh0eXBlb2YgalF1ZXJ5ICE9PSAndW5kZWZpbmVkJyA/IGpRdWVyeSA6IG51bGwgLCBjeXRvc2NhcGUpO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gc2hhbWVsZXNzbHkgdGFrZW4gZnJvbSBqUXVlcnlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2V2ZW50LmpzXG5cbiAgJCQuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcbiAgICAvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcbiAgICBpZiAoICEodGhpcyBpbnN0YW5jZW9mICQkLkV2ZW50KSApIHtcbiAgICAgIHJldHVybiBuZXcgJCQuRXZlbnQoIHNyYywgcHJvcHMgKTtcbiAgICB9XG5cbiAgICAvLyBFdmVudCBvYmplY3RcbiAgICBpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcbiAgICAgIHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG4gICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9ICggc3JjLmRlZmF1bHRQcmV2ZW50ZWQgKSA/IHJldHVyblRydWUgOiByZXR1cm5GYWxzZTtcblxuICAgIC8vIEV2ZW50IHR5cGVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgIH1cblxuICAgIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG4gICAgaWYgKCBwcm9wcyApIHtcbiAgICAgIC8vICQkLnV0aWwuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXG4gICAgICAvLyBtb3JlIGVmZmljaWVudCB0byBtYW51YWxseSBjb3B5IGZpZWxkcyB3ZSB1c2VcbiAgICAgIHRoaXMudHlwZSA9IHByb3BzLnR5cGUgIT09IHVuZGVmaW5lZCA/IHByb3BzLnR5cGUgOiB0aGlzLnR5cGU7XG4gICAgICB0aGlzLmN5ID0gcHJvcHMuY3k7XG4gICAgICB0aGlzLmN5VGFyZ2V0ID0gcHJvcHMuY3lUYXJnZXQ7XG4gICAgICB0aGlzLmN5UG9zaXRpb24gPSBwcm9wcy5jeVBvc2l0aW9uO1xuICAgICAgdGhpcy5jeVJlbmRlcmVkUG9zaXRpb24gPSBwcm9wcy5jeVJlbmRlcmVkUG9zaXRpb247XG4gICAgICB0aGlzLm5hbWVzcGFjZSA9IHByb3BzLm5hbWVzcGFjZTtcbiAgICAgIHRoaXMubGF5b3V0ID0gcHJvcHMubGF5b3V0O1xuICAgICAgdGhpcy5kYXRhID0gcHJvcHMuZGF0YTtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHByb3BzLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICB0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8ICtuZXcgRGF0ZSgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuICAkJC5FdmVudC5wcm90b3R5cGUgPSB7XG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICAgIGlmICggIWUgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgcHJldmVudERlZmF1bHQgZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICAgIGlmICggZS5wcmV2ZW50RGVmYXVsdCApIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICAgIGlmICggIWUgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgICAgaWYgKCBlLnN0b3BQcm9wYWdhdGlvbiApIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2VcbiAgfTtcbiAgXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHVzZSB0aGlzIG1vZHVsZSB0byBjaGVycnkgcGljayBmdW5jdGlvbnMgaW50byB5b3VyIHByb3RvdHlwZVxuICAvLyAodXNlZnVsIGZvciBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gdGhlIGNvcmUgYW5kIGNvbGxlY3Rpb25zLCBmb3IgZXhhbXBsZSlcblxuICAvLyBlLmcuXG4gIC8vICQkLmZuLmNvbGxlY3Rpb24oe1xuICAvLyAgIGZvbzogJCQuZGVmaW5lLmZvbyh7IC8qIHBhcmFtcy4uLiAqLyB9KVxuICAvLyB9KTtcblxuICAkJC5kZWZpbmUgPSB7XG5cbiAgICAvLyBhY2Nlc3MgZGF0YSBmaWVsZFxuICAgIGRhdGE6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHsgXG4gICAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgICBhbGxvd1NldHRpbmc6IGZhbHNlLFxuICAgICAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICAgIGltbXV0YWJsZUtleXM6IHt9LCAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcbiAgICAgICAgdXBkYXRlU3R5bGU6IGZhbHNlLFxuICAgICAgICBvblNldDogZnVuY3Rpb24oIHNlbGYgKXt9LFxuICAgICAgICBjYW5TZXQ6IGZ1bmN0aW9uKCBzZWxmICl7IHJldHVybiB0cnVlOyB9XG4gICAgICB9O1xuICAgICAgcGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZGF0YUltcGwoIG5hbWUsIHZhbHVlICl7XG4gICAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBzaW5nbGUgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmWzBdIDogc2VsZjtcblxuICAgICAgICAvLyAuZGF0YSgnZm9vJywgLi4uKVxuICAgICAgICBpZiggJCQuaXMuc3RyaW5nKG5hbWUpICl7IC8vIHNldCBvciBnZXQgcHJvcGVydHlcblxuICAgICAgICAgIC8vIC5kYXRhKCdmb28nKVxuICAgICAgICAgIGlmKCBwLmFsbG93R2V0dGluZyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7IC8vIGdldFxuXG4gICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgaWYoIHNpbmdsZSApe1xuICAgICAgICAgICAgICByZXQgPSBzaW5nbGUuX3ByaXZhdGVbIHAuZmllbGQgXVsgbmFtZSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyAuZGF0YSgnZm9vJywgJ2JhcicpXG4gICAgICAgICAgfSBlbHNlIGlmKCBwLmFsbG93U2V0dGluZyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgeyAvLyBzZXRcbiAgICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbbmFtZV07XG4gICAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBhbGwubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICAgICAgICAgICAgaWYoIHAuY2FuU2V0KCBhbGxbaV0gKSApe1xuICAgICAgICAgICAgICAgICAgYWxsW2ldLl9wcml2YXRlWyBwLmZpZWxkIF1bIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG4gICAgICAgICAgICAgIGlmKCBwLnVwZGF0ZVN0eWxlICl7IHNlbGYudXBkYXRlU3R5bGUoKTsgfVxuXG4gICAgICAgICAgICAgIC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgcC5vblNldCggc2VsZiApO1xuXG4gICAgICAgICAgICAgIGlmKCBwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50ICl7XG4gICAgICAgICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuc2V0dGluZ0V2ZW50ICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gLmRhdGEoeyAnZm9vJzogJ2JhcicgfSlcbiAgICAgICAgfSBlbHNlIGlmKCBwLmFsbG93U2V0dGluZyAmJiAkJC5pcy5wbGFpbk9iamVjdChuYW1lKSApeyAvLyBleHRlbmRcbiAgICAgICAgICB2YXIgb2JqID0gbmFtZTtcbiAgICAgICAgICB2YXIgaywgdjtcblxuICAgICAgICAgIGZvciggayBpbiBvYmogKXtcbiAgICAgICAgICAgIHYgPSBvYmpbIGsgXTtcblxuICAgICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trXTtcbiAgICAgICAgICAgIGlmKCB2YWxpZCApe1xuICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMCwgbCA9IGFsbC5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgICAgICAgICAgICBpZiggcC5jYW5TZXQoIGFsbFtpXSApICl7XG4gICAgICAgICAgICAgICAgICBhbGxbaV0uX3ByaXZhdGVbIHAuZmllbGQgXVsgayBdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcbiAgICAgICAgICBpZiggcC51cGRhdGVTdHlsZSApeyBzZWxmLnVwZGF0ZVN0eWxlKCk7IH1cblxuICAgICAgICAgIC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcbiAgICAgICAgICBwLm9uU2V0KCBzZWxmICk7XG5cbiAgICAgICAgICBpZiggcC5zZXR0aW5nVHJpZ2dlcnNFdmVudCApe1xuICAgICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuc2V0dGluZ0V2ZW50ICk7XG4gICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gLmRhdGEoZnVuY3Rpb24oKXsgLi4uIH0pXG4gICAgICAgIH0gZWxzZSBpZiggcC5hbGxvd0JpbmRpbmcgJiYgJCQuaXMuZm4obmFtZSkgKXsgLy8gYmluZCB0byBldmVudFxuICAgICAgICAgIHZhciBmbiA9IG5hbWU7XG4gICAgICAgICAgc2VsZi5iaW5kKCBwLmJpbmRpbmdFdmVudCwgZm4gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIC5kYXRhKClcbiAgICAgICAgfSBlbHNlIGlmKCBwLmFsbG93R2V0dGluZyAmJiBuYW1lID09PSB1bmRlZmluZWQgKXsgLy8gZ2V0IHdob2xlIG9iamVjdFxuICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgaWYoIHNpbmdsZSApe1xuICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlWyBwLmZpZWxkIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5hYmlsaXR5XG4gICAgICB9OyAvLyBmdW5jdGlvblxuICAgIH0sIC8vIGRhdGFcblxuICAgIC8vIHJlbW92ZSBkYXRhIGZpZWxkXG4gICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0geyBcbiAgICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgICAgZXZlbnQ6ICdkYXRhJyxcbiAgICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLFxuICAgICAgICBpbW11dGFibGVLZXlzOiB7fSAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcbiAgICAgIH07XG4gICAgICBwYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVEYXRhSW1wbCggbmFtZXMgKXtcbiAgICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgXG4gICAgICAgIC8vIC5yZW1vdmVEYXRhKCdmb28gYmFyJylcbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyhuYW1lcykgKXsgLy8gdGhlbiBnZXQgdGhlIGxpc3Qgb2Yga2V5cywgYW5kIGRlbGV0ZSB0aGVtXG4gICAgICAgICAgdmFyIGtleXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGw7IGkrKyApeyAvLyBkZWxldGUgZWFjaCBub24tZW1wdHkga2V5XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhrZXkpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbIGtleSBdOyAvLyBub3QgdmFsaWQgaWYgaW1tdXRhYmxlXG4gICAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgICAgZm9yKCB2YXIgaV9hID0gMCwgbF9hID0gYWxsLmxlbmd0aDsgaV9hIDwgbF9hOyBpX2ErKyApe1xuICAgICAgICAgICAgICAgIGFsbFsgaV9hIF0uX3ByaXZhdGVbIHAuZmllbGQgXVsga2V5IF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggcC50cmlnZ2VyRXZlbnQgKXtcbiAgICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLmV2ZW50ICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIC5yZW1vdmVEYXRhKClcbiAgICAgICAgfSBlbHNlIGlmKCBuYW1lcyA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gZGVsZXRlIGFsbCBrZXlzXG5cbiAgICAgICAgICBmb3IoIHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrICl7XG4gICAgICAgICAgICB2YXIgX3ByaXZhdGVGaWVsZHMgPSBhbGxbIGlfYSBdLl9wcml2YXRlWyBwLmZpZWxkIF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciggdmFyIGtleSBpbiBfcHJpdmF0ZUZpZWxkcyApe1xuICAgICAgICAgICAgICB2YXIgdmFsaWRLZXlUb0RlbGV0ZSA9ICFwLmltbXV0YWJsZUtleXNbIGtleSBdO1xuXG4gICAgICAgICAgICAgIGlmKCB2YWxpZEtleVRvRGVsZXRlICl7XG4gICAgICAgICAgICAgICAgX3ByaXZhdGVGaWVsZHNbIGtleSBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHAudHJpZ2dlckV2ZW50ICl7XG4gICAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5ldmVudCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9LCAvLyByZW1vdmVEYXRhXG5cbiAgICAvLyBldmVudCBmdW5jdGlvbiByZXVzYWJsZSBzdHVmZlxuICAgIGV2ZW50OiB7XG4gICAgICByZWdleDogLyhcXHcrKShcXC5cXHcrKT8vLCAvLyByZWdleCBmb3IgbWF0Y2hpbmcgZXZlbnQgc3RyaW5ncyAoZS5nLiBcImNsaWNrLm5hbWVzcGFjZVwiKVxuICAgICAgb3B0aW9uYWxUeXBlUmVnZXg6IC8oXFx3Kyk/KFxcLlxcdyspPy8sXG4gICAgICBmYWxzZUNhbGxiYWNrOiBmdW5jdGlvbigpeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9LFxuXG4gICAgLy8gZXZlbnQgYmluZGluZ1xuICAgIG9uOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIHVuYmluZFNlbGZPblRyaWdnZXI6IGZhbHNlLFxuICAgICAgICB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uSW1wbChldmVudHMsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjayl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gJCQuaXMuc3RyaW5nKGV2ZW50cyk7XG4gICAgICAgIHZhciBwID0gcGFyYW1zO1xuXG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChzZWxlY3RvcikgKXsgLy8gc2VsZWN0b3IgaXMgYWN0dWFsbHkgZGF0YVxuICAgICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XG4gICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMuZm4oc2VsZWN0b3IpIHx8IHNlbGVjdG9yID09PSBmYWxzZSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBjYWxsYmFja1xuICAgICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAkJC5pcy5mbihkYXRhKSB8fCBkYXRhID09PSBmYWxzZSApeyAvLyBkYXRhIGlzIGFjdHVhbGx5IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBpc24ndCBhIGNhbGxiYWNrLCB3ZSBjYW4ndCByZWFsbHkgZG8gYW55dGhpbmdcbiAgICAgICAgLy8gKGNhbid0IHNwZWFrIGZvciBtYXBwZWQgZXZlbnRzIGFyZyB2ZXJzaW9uKVxuICAgICAgICBpZiggISgkJC5pcy5mbihjYWxsYmFjaykgfHwgY2FsbGJhY2sgPT09IGZhbHNlKSAmJiBldmVudHNJc1N0cmluZyApe1xuICAgICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGV2ZW50c0lzU3RyaW5nICl7IC8vIHRoZW4gY29udmVydCB0byBtYXBcbiAgICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgICAgbWFwWyBldmVudHMgXSA9IGNhbGxiYWNrO1xuICAgICAgICAgIGV2ZW50cyA9IG1hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGV2dHMgaW4gZXZlbnRzICl7XG4gICAgICAgICAgY2FsbGJhY2sgPSBldmVudHNbZXZ0c107XG4gICAgICAgICAgaWYoIGNhbGxiYWNrID09PSBmYWxzZSApe1xuICAgICAgICAgICAgY2FsbGJhY2sgPSAkJC5kZWZpbmUuZXZlbnQuZmFsc2VDYWxsYmFjaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggISQkLmlzLmZuKGNhbGxiYWNrKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgZXZ0cyA9IGV2dHMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBldnQgPSBldnRzW2ldO1xuICAgICAgICAgICAgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGV2dCkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKCAkJC5kZWZpbmUuZXZlbnQucmVnZXggKTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuXG4gICAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjaywgLy8gY2FsbGJhY2sgdG8gcnVuXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSwgLy8gZXh0cmEgZGF0YSBpbiBldmVudE9iai5kYXRhXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVkOiBzZWxlY3RvciA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZXZ0IGlzIGRlbGVnYXRlZFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvciwgLy8gdGhlIHNlbGVjdG9yIHRvIG1hdGNoIGZvciBkZWxlZ2F0ZWQgZXZlbnRzXG4gICAgICAgICAgICAgICAgc2VsT2JqOiBuZXcgJCQuU2VsZWN0b3Ioc2VsZWN0b3IpLCAvLyBjYWNoZWQgc2VsZWN0b3Igb2JqZWN0IHRvIHNhdmUgcmVidWlsZGluZ1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsIC8vIHRoZSBldmVudCB0eXBlIChlLmcuICdjbGljaycpXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIC8vIHRoZSBldmVudCBuYW1lc3BhY2UgKGUuZy4gXCIuZm9vXCIpXG4gICAgICAgICAgICAgICAgdW5iaW5kU2VsZk9uVHJpZ2dlcjogcC51bmJpbmRTZWxmT25UcmlnZ2VyLFxuICAgICAgICAgICAgICAgIHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHAudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcixcbiAgICAgICAgICAgICAgICBiaW5kZXJzOiBhbGwgLy8gd2hvIGJvdW5kIHRvZ2V0aGVyXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgICB2YXIgX3AgPSBhbGxbal0uX3ByaXZhdGU7XG5cbiAgICAgICAgICAgICAgICBfcC5saXN0ZW5lcnMgPSBfcC5saXN0ZW5lcnMgfHwgW107XG4gICAgICAgICAgICAgICAgX3AubGlzdGVuZXJzLnB1c2goIGxpc3RlbmVyICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGZvciBldmVudHMgYXJyYXlcbiAgICAgICAgfSAvLyBmb3IgZXZlbnRzIG1hcFxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICB9OyAvLyBmdW5jdGlvblxuICAgIH0sIC8vIG9uXG5cbiAgICBldmVudEFsaWFzZXNPbjogZnVuY3Rpb24oIHByb3RvICl7XG4gICAgICB2YXIgcCA9IHByb3RvO1xuXG4gICAgICBwLmFkZExpc3RlbmVyID0gcC5saXN0ZW4gPSBwLmJpbmQgPSBwLm9uO1xuICAgICAgcC5yZW1vdmVMaXN0ZW5lciA9IHAudW5saXN0ZW4gPSBwLnVuYmluZCA9IHAub2ZmO1xuICAgICAgcC5lbWl0ID0gcC50cmlnZ2VyO1xuXG4gICAgICAvLyB0aGlzIGlzIGp1c3QgYSB3cmFwcGVyIGFsaWFzIG9mIC5vbigpXG4gICAgICBwLnBvbiA9IHAucHJvbWlzZU9uID0gZnVuY3Rpb24oIGV2ZW50cywgc2VsZWN0b3IgKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKTtcblxuICAgICAgICByZXR1cm4gbmV3ICQkLlByb21pc2UoZnVuY3Rpb24oIHJlc29sdmUsIHJlamVjdCApe1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICAgICAgICBzZWxmLm9mZi5hcHBseSggc2VsZiwgb2ZmQXJncyApO1xuXG4gICAgICAgICAgICByZXNvbHZlKCBlICk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBvbkFyZ3MgPSBhcmdzLmNvbmNhdChbIGNhbGxiYWNrIF0pO1xuICAgICAgICAgIHZhciBvZmZBcmdzID0gb25BcmdzLmNvbmNhdChbXSk7XG5cbiAgICAgICAgICBzZWxmLm9uLmFwcGx5KCBzZWxmLCBvbkFyZ3MgKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBvZmY6IGZ1bmN0aW9uIG9mZkltcGwoIHBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgfTtcbiAgICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgZXZlbnRzSXNTdHJpbmcgPSAkJC5pcy5zdHJpbmcoZXZlbnRzKTtcblxuICAgICAgICBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApeyAvLyB0aGVuIHVuYmluZCBhbGxcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICBhbGxbaV0uX3ByaXZhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICAgIH1cblxuICAgICAgICBpZiggJCQuaXMuZm4oc2VsZWN0b3IpIHx8IHNlbGVjdG9yID09PSBmYWxzZSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBjYWxsYmFja1xuICAgICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZXZlbnRzSXNTdHJpbmcgKXsgLy8gdGhlbiBjb252ZXJ0IHRvIG1hcFxuICAgICAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgICAgICBtYXBbIGV2ZW50cyBdID0gY2FsbGJhY2s7XG4gICAgICAgICAgZXZlbnRzID0gbWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKCB2YXIgZXZ0cyBpbiBldmVudHMgKXtcbiAgICAgICAgICBjYWxsYmFjayA9IGV2ZW50c1tldnRzXTtcblxuICAgICAgICAgIGlmKCBjYWxsYmFjayA9PT0gZmFsc2UgKXtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gJCQuZGVmaW5lLmV2ZW50LmZhbHNlQ2FsbGJhY2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXZ0cyA9IGV2dHMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICBmb3IoIHZhciBoID0gMDsgaCA8IGV2dHMubGVuZ3RoOyBoKysgKXtcbiAgICAgICAgICAgIHZhciBldnQgPSBldnRzW2hdO1xuICAgICAgICAgICAgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGV2dCkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKCAkJC5kZWZpbmUuZXZlbnQub3B0aW9uYWxUeXBlUmVnZXggKTsgLy8gW3R5cGVdWy5uYW1lc3BhY2VdXG4gICAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXSA/IG1hdGNoWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApeyAvL1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBhbGxbaV0uX3ByaXZhdGUubGlzdGVuZXJzID0gYWxsW2ldLl9wcml2YXRlLmxpc3RlbmVycyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbGlzdGVuZXJzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbal07XG4gICAgICAgICAgICAgICAgICB2YXIgbnNNYXRjaGVzID0gIW5hbWVzcGFjZSB8fCBuYW1lc3BhY2UgPT09IGxpc3RlbmVyLm5hbWVzcGFjZTtcbiAgICAgICAgICAgICAgICAgIHZhciB0eXBlTWF0Y2hlcyA9ICF0eXBlIHx8IGxpc3RlbmVyLnR5cGUgPT09IHR5cGU7XG4gICAgICAgICAgICAgICAgICB2YXIgY2JNYXRjaGVzID0gIWNhbGxiYWNrIHx8IGNhbGxiYWNrID09PSBsaXN0ZW5lci5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lck1hdGNoZXMgPSBuc01hdGNoZXMgJiYgdHlwZU1hdGNoZXMgJiYgY2JNYXRjaGVzO1xuXG4gICAgICAgICAgICAgICAgICAvLyBkZWxldGUgbGlzdGVuZXIgaWYgaXQgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgaWYoIGxpc3RlbmVyTWF0Y2hlcyApe1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBmb3IgbGlzdGVuZXJzXG4gICAgICAgICAgICAgIH0gLy8gZm9yIGFsbFxuICAgICAgICAgICAgfSAvLyBpZiBtYXRjaFxuICAgICAgICAgIH0gLy8gZm9yIGV2ZW50cyBhcnJheVxuXG4gICAgICAgIH0gLy8gZm9yIGV2ZW50cyBtYXBcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9LCAvLyBvZmZcblxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgcGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gZnVuY3Rpb24gdHJpZ2dlckltcGwoZXZlbnRzLCBleHRyYVBhcmFtcywgZm5Ub1RyaWdnZXIpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBldmVudHNJc1N0cmluZyA9ICQkLmlzLnN0cmluZyhldmVudHMpO1xuICAgICAgICB2YXIgZXZlbnRzSXNPYmplY3QgPSAkJC5pcy5wbGFpbk9iamVjdChldmVudHMpO1xuICAgICAgICB2YXIgZXZlbnRzSXNFdmVudCA9ICQkLmlzLmV2ZW50KGV2ZW50cyk7XG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgKCAkJC5pcy5jb3JlKHRoaXMpID8gdGhpcyA6IG51bGwgKTtcbiAgICAgICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5ID8gY3kuaGFzQ29tcG91bmROb2RlcygpIDogZmFsc2U7XG5cbiAgICAgICAgaWYoIGV2ZW50c0lzU3RyaW5nICl7IC8vIHRoZW4gbWFrZSBhIHBsYWluIGV2ZW50IG9iamVjdCBmb3IgZWFjaCBldmVudCBuYW1lXG4gICAgICAgICAgdmFyIGV2dHMgPSBldmVudHMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICBldmVudHMgPSBbXTtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZ0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGV2dCA9IGV2dHNbaV07XG4gICAgICAgICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoZXZ0KSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goICQkLmRlZmluZS5ldmVudC5yZWdleCApOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG4gICAgICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKCB7XG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIGV2ZW50c0lzT2JqZWN0ICl7IC8vIHB1dCBpbiBsZW5ndGggMSBhcnJheVxuICAgICAgICAgIHZhciBldmVudEFyZ09iaiA9IGV2ZW50cztcblxuICAgICAgICAgIGV2ZW50cyA9IFsgZXZlbnRBcmdPYmogXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBleHRyYVBhcmFtcyApe1xuICAgICAgICAgIGlmKCAhJCQuaXMuYXJyYXkoZXh0cmFQYXJhbXMpICl7IC8vIG1ha2Ugc3VyZSBleHRyYSBwYXJhbXMgYXJlIGluIGFuIGFycmF5IGlmIHNwZWNpZmllZFxuICAgICAgICAgICAgZXh0cmFQYXJhbXMgPSBbIGV4dHJhUGFyYW1zIF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIHdlJ3ZlIGdvdCBub3RoaW5nXG4gICAgICAgICAgZXh0cmFQYXJhbXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrICl7IC8vIHRyaWdnZXIgZWFjaCBldmVudCBpbiBvcmRlclxuICAgICAgICAgIHZhciBldnRPYmogPSBldmVudHNbaV07XG4gICAgICAgICAgXG4gICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2hcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyZXIgPSBhbGxbal07XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdHJpZ2dlcmVyLl9wcml2YXRlLmxpc3RlbmVycyA9IHRyaWdnZXJlci5fcHJpdmF0ZS5saXN0ZW5lcnMgfHwgW107XG4gICAgICAgICAgICB2YXIgdHJpZ2dlcmVySXNFbGVtZW50ID0gJCQuaXMuZWxlbWVudCh0cmlnZ2VyZXIpO1xuICAgICAgICAgICAgdmFyIGJ1YmJsZVVwID0gdHJpZ2dlcmVySXNFbGVtZW50IHx8IHBhcmFtcy5sYXlvdXQ7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgZXZlbnQgZm9yIHRoaXMgZWxlbWVudCBmcm9tIHRoZSBldmVudCBvYmplY3RcbiAgICAgICAgICAgIHZhciBldnQ7XG5cbiAgICAgICAgICAgIGlmKCBldmVudHNJc0V2ZW50ICl7IC8vIHRoZW4ganVzdCBnZXQgdGhlIG9iamVjdFxuICAgICAgICAgICAgICBldnQgPSBldnRPYmo7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBldnQuY3lUYXJnZXQgPSBldnQuY3lUYXJnZXQgfHwgdHJpZ2dlcmVyO1xuICAgICAgICAgICAgICBldnQuY3kgPSBldnQuY3kgfHwgY3k7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gd2UgaGF2ZSB0byBtYWtlIG9uZVxuICAgICAgICAgICAgICBldnQgPSBuZXcgJCQuRXZlbnQoIGV2dE9iaiwge1xuICAgICAgICAgICAgICAgIGN5VGFyZ2V0OiB0cmlnZ2VyZXIsXG4gICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogZXZ0T2JqLm5hbWVzcGFjZVxuICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGEgbGF5b3V0IHdhcyBzcGVjaWZpZWQsIHRoZW4gcHV0IGl0IGluIHRoZSB0eXBlZCBldmVudFxuICAgICAgICAgICAgaWYoIGV2dE9iai5sYXlvdXQgKXtcbiAgICAgICAgICAgICAgZXZ0LmxheW91dCA9IGV2dE9iai5sYXlvdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRyaWdnZXJlZCBieSBsYXlvdXQsIHB1dCBpbiBldmVudFxuICAgICAgICAgICAgaWYoIHBhcmFtcy5sYXlvdXQgKXtcbiAgICAgICAgICAgICAgZXZ0LmxheW91dCA9IHRyaWdnZXJlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgcmVuZGVyZWQgcG9zaXRpb24gYmFzZWQgb24gdGhlIHBhc3NlZCBwb3NpdGlvblxuICAgICAgICAgICAgaWYoIGV2dC5jeVBvc2l0aW9uICl7XG4gICAgICAgICAgICAgIHZhciBwb3MgPSBldnQuY3lQb3NpdGlvbjtcbiAgICAgICAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcblxuICAgICAgICAgICAgICBldnQuY3lSZW5kZXJlZFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IHBvcy54ICogem9vbSArIHBhbi54LFxuICAgICAgICAgICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBmblRvVHJpZ2dlciApeyAvLyB0aGVuIG92ZXJyaWRlIHRoZSBsaXN0ZW5lcnMgbGlzdCB3aXRoIGp1c3QgdGhlIG9uZSB3ZSBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgbGlzdGVuZXJzID0gW3tcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IGV2dC5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgdHlwZTogZXZ0LnR5cGUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZuVG9UcmlnZ2VyXG4gICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IoIHZhciBrID0gMDsgayA8IGxpc3RlbmVycy5sZW5ndGg7IGsrKyApeyAvLyBjaGVjayBlYWNoIGxpc3RlbmVyXG4gICAgICAgICAgICAgIHZhciBsaXMgPSBsaXN0ZW5lcnNba107XG4gICAgICAgICAgICAgIHZhciBuc01hdGNoZXMgPSAhbGlzLm5hbWVzcGFjZSB8fCBsaXMubmFtZXNwYWNlID09PSBldnQubmFtZXNwYWNlO1xuICAgICAgICAgICAgICB2YXIgdHlwZU1hdGNoZXMgPSBsaXMudHlwZSA9PT0gZXZ0LnR5cGU7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXRNYXRjaGVzID0gbGlzLmRlbGVnYXRlZCA/ICggdHJpZ2dlcmVyICE9PSBldnQuY3lUYXJnZXQgJiYgJCQuaXMuZWxlbWVudChldnQuY3lUYXJnZXQpICYmIGxpcy5zZWxPYmoubWF0Y2hlcyhldnQuY3lUYXJnZXQpICkgOiAodHJ1ZSk7IC8vIHdlJ3JlIG5vdCBnb2luZyB0byB2YWxpZGF0ZSB0aGUgaGllcmFyY2h5OyB0aGF0J3MgdG9vIGV4cGVuc2l2ZVxuICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJNYXRjaGVzID0gbnNNYXRjaGVzICYmIHR5cGVNYXRjaGVzICYmIHRhcmdldE1hdGNoZXM7XG5cbiAgICAgICAgICAgICAgaWYoIGxpc3RlbmVyTWF0Y2hlcyApeyAvLyB0aGVuIHRyaWdnZXIgaXRcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFsgZXZ0IF07XG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KCBleHRyYVBhcmFtcyApOyAvLyBhZGQgZXh0cmEgcGFyYW1zIHRvIGFyZ3MgbGlzdFxuXG4gICAgICAgICAgICAgICAgaWYoIGxpcy5kYXRhICl7IC8vIGFkZCBvbiBkYXRhIHBsdWdnZWQgaW50byBiaW5kaW5nXG4gICAgICAgICAgICAgICAgICBldnQuZGF0YSA9IGxpcy5kYXRhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIG9yIGNsZWFyIGl0IGluIGNhc2UgdGhlIGV2ZW50IG9iaiBpcyByZXVzZWRcbiAgICAgICAgICAgICAgICAgIGV2dC5kYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCBsaXMudW5iaW5kU2VsZk9uVHJpZ2dlciB8fCBsaXMudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlciApeyAvLyB0aGVuIHJlbW92ZSBsaXN0ZW5lclxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiggbGlzLnVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXIgKXsgLy8gdGhlbiBkZWxldGUgdGhlIGxpc3RlbmVyIGZvciBhbGwgYmluZGVyc1xuICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlcnMgPSBsaXMuYmluZGVycztcbiAgICAgICAgICAgICAgICAgIGZvciggdmFyIGwgPSAwOyBsIDwgYmluZGVycy5sZW5ndGg7IGwrKyApe1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGVyID0gYmluZGVyc1tsXTtcbiAgICAgICAgICAgICAgICAgICAgaWYoICFiaW5kZXIgfHwgYmluZGVyID09PSB0cmlnZ2VyZXIgKXsgY29udGludWU7IH0gLy8gYWxyZWFkeSBoYW5kbGVkIHRyaWdnZXJlciBvciB3ZSBjYW4ndCBoYW5kbGUgaXRcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGVyTGlzdGVuZXJzID0gYmluZGVyLl9wcml2YXRlLmxpc3RlbmVycztcbiAgICAgICAgICAgICAgICAgICAgZm9yKCB2YXIgbSA9IDA7IG0gPCBiaW5kZXJMaXN0ZW5lcnMubGVuZ3RoOyBtKysgKXtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGVyTGlzdGVuZXIgPSBiaW5kZXJMaXN0ZW5lcnNbbV07XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiggYmluZGVyTGlzdGVuZXIgPT09IGxpcyApeyAvLyBkZWxldGUgbGlzdGVuZXIgZnJvbSBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kZXJMaXN0ZW5lcnMuc3BsaWNlKG0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS0tO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJ1biB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGxpcy5kZWxlZ2F0ZWQgPyBldnQuY3lUYXJnZXQgOiB0cmlnZ2VyZXI7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGxpcy5jYWxsYmFjay5hcHBseSggY29udGV4dCwgYXJncyApO1xuXG4gICAgICAgICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgfHwgZXZ0LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKXtcbiAgICAgICAgICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYnViYmxlXG4gICAgICAgICAgICAgICAgICBidWJibGVVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApe1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UgaXMgYSBzaG9ydGhhbmQgZm9yIHN0b3BwaW5nIHByb3BhZ2F0aW9uIGFuZCBwcmV2ZW50aW5nIHRoZSBkZWYuIGFjdGlvblxuICAgICAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyBpZiBsaXN0ZW5lciBtYXRjaGVzXG4gICAgICAgICAgICB9IC8vIGZvciBlYWNoIGxpc3RlbmVyXG5cbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBldmVudCBmb3IgZWxlbWVudHNcbiAgICAgICAgICAgIGlmKCBidWJibGVVcCApe1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmRzID8gdHJpZ2dlcmVyLl9wcml2YXRlLnBhcmVudCA6IG51bGw7XG4gICAgICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgIT0gbnVsbCAmJiBwYXJlbnQubGVuZ3RoICE9PSAwO1xuXG4gICAgICAgICAgICAgIGlmKCBoYXNQYXJlbnQgKXsgLy8gdGhlbiBidWJibGUgdXAgdG8gcGFyZW50XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgICAgICAgIHBhcmVudC50cmlnZ2VyKGV2dCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSwgYnViYmxlIHVwIHRvIHRoZSBjb3JlXG4gICAgICAgICAgICAgICAgY3kudHJpZ2dlcihldnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IC8vIGZvciBlYWNoIG9mIGFsbFxuICAgICAgICB9IC8vIGZvciBlYWNoIGV2ZW50XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgIH07IC8vIGZ1bmN0aW9uXG4gICAgfSwgLy8gdHJpZ2dlclxuXG5cbiAgICBhbmltYXRlZDogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICAgIGZuUGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlZEltcGwoKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICB2YXIgZWxlID0gYWxsWzBdO1xuXG4gICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgLy8gYW5pbWF0ZWRcblxuICAgIGNsZWFyUXVldWU6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgICBmblBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJRdWV1ZUltcGwoKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSwgLy8gY2xlYXJRdWV1ZVxuXG4gICAgZGVsYXk6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgICBmblBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlJbXBsKCB0aW1lLCBjb21wbGV0ZSApe1xuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgICAgZGVsYXk6IHRpbWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aW1lLFxuICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSwgLy8gZGVsYXlcblxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgICBmblBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZUltcGwoIHByb3BlcnRpZXMsIHBhcmFtcyApe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgICAgdmFyIGlzQ29yZSA9ICFzZWxmSXNBcnJheUxpa2U7XG4gICAgICAgIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuXG4gICAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgICB2YXIgY2FsbFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgICAgdmFyIHE7XG4gICAgICAgIFxuICAgICAgICBpZiggcGFyYW1zID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwYXJhbXMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHBhcmFtcy5kdXJhdGlvbiA9IDQwMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3dpdGNoKCBwYXJhbXMuZHVyYXRpb24gKXtcbiAgICAgICAgY2FzZSAnc2xvdyc6XG4gICAgICAgICAgcGFyYW1zLmR1cmF0aW9uID0gNjAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmYXN0JzpcbiAgICAgICAgICBwYXJhbXMuZHVyYXRpb24gPSAyMDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzRW1wdHkgPSB0cnVlO1xuICAgICAgICBpZiggcHJvcGVydGllcyApeyBmb3IoIHZhciBpIGluIHByb3BlcnRpZXMgKXtcbiAgICAgICAgICBwcm9wZXJ0aWVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSB9XG5cbiAgICAgICAgaWYoIHByb3BlcnRpZXNFbXB0eSApe1xuICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBub3RoaW5nIHRvIGFuaW1hdGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzLmNzcyAmJiBpc0VsZXMgKXtcbiAgICAgICAgICBwcm9wZXJ0aWVzLmNzcyA9IHN0eWxlLmdldFZhbHVlU3R5bGUoIHByb3BlcnRpZXMuY3NzLCB7IGFycmF5OiB0cnVlIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb24gJiYgaXNFbGVzICl7XG4gICAgICAgICAgdmFyIHJwb3MgPSBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6ICggcnBvcy54IC0gcGFuLnggKSAvem9vbSxcbiAgICAgICAgICAgIHk6ICggcnBvcy55IC0gcGFuLnkgKSAvem9vbVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdmVycmlkZSBwYW4gdy8gcGFuQnkgaWYgc2V0XG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzLnBhbkJ5ICYmIGlzQ29yZSApe1xuICAgICAgICAgIHZhciBwYW5CeSA9IHByb3BlcnRpZXMucGFuQnk7XG4gICAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHtcbiAgICAgICAgICAgIHg6IGN5UGFuLnggKyBwYW5CeS54LFxuICAgICAgICAgICAgeTogY3lQYW4ueSArIHBhbkJ5LnlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgcGFuIHcvIGNlbnRlciBpZiBzZXRcbiAgICAgICAgdmFyIGNlbnRlciA9IHByb3BlcnRpZXMuY2VudGVyIHx8IHByb3BlcnRpZXMuY2VudHJlO1xuICAgICAgICBpZiggY2VudGVyICYmIGlzQ29yZSApe1xuICAgICAgICAgIHZhciBjZW50ZXJQYW4gPSBjeS5nZXRDZW50ZXJQYW4oIGNlbnRlci5lbGVzLCBwcm9wZXJ0aWVzLnpvb20gKTtcblxuICAgICAgICAgIGlmKCBjZW50ZXJQYW4gKXtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gY2VudGVyUGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG92ZXJyaWRlIHBhbiAmIHpvb20gdy8gZml0IGlmIHNldFxuICAgICAgICBpZiggcHJvcGVydGllcy5maXQgJiYgaXNDb3JlICl7XG4gICAgICAgICAgdmFyIGZpdCA9IHByb3BlcnRpZXMuZml0O1xuICAgICAgICAgIHZhciBmaXRWcCA9IGN5LmdldEZpdFZpZXdwb3J0KCBmaXQuZWxlcyB8fCBmaXQuYm91bmRpbmdCb3gsIGZpdC5wYWRkaW5nICk7XG5cbiAgICAgICAgICBpZiggZml0VnAgKXtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gZml0VnAucGFuOyAvL3sgeDogZml0VnAucGFuLngsIHk6IGZpdFZwLnBhbi55IH07XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBmaXRWcC56b29tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgIFxuICAgICAgICAgIGlmKCBlbGUuYW5pbWF0ZWQoKSAmJiAocGFyYW1zLnF1ZXVlID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLnF1ZXVlKSApe1xuICAgICAgICAgICAgcSA9IGVsZS5fcHJpdmF0ZS5hbmltYXRpb24ucXVldWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHEgPSBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcS5wdXNoKHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgICAgICAgICBkdXJhdGlvbjogcGFyYW1zLmR1cmF0aW9uLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBjYWxsVGltZTogY2FsbFRpbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBpc0VsZXMgKXtcbiAgICAgICAgICBjeS5hZGRUb0FuaW1hdGlvblBvb2woIHRoaXMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgICAgfTtcbiAgICB9LCAvLyBhbmltYXRlXG5cbiAgICBzdG9wOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgZm5QYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGZuUGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BJbXBsKCBjbGVhclF1ZXVlLCBqdW1wVG9FbmQgKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgICB2YXIgYW5pcyA9IGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudDtcblxuICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYW5pcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFuaXNbal07ICAgIFxuICAgICAgICAgICAgaWYoIGp1bXBUb0VuZCApe1xuICAgICAgICAgICAgICAvLyBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGxvb3AsIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgLy8gd2lsbCBnbyBzdHJhaWdodCB0byB0aGUgZW5kIGFuZCBiZSByZW1vdmVkXG4gICAgICAgICAgICAgIGFuaW1hdGlvbi5kdXJhdGlvbiA9IDA7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBjbGVhciB0aGUgcXVldWUgb2YgZnV0dXJlIGFuaW1hdGlvbnNcbiAgICAgICAgICBpZiggY2xlYXJRdWV1ZSApe1xuICAgICAgICAgICAgZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhanVtcFRvRW5kICl7XG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gbm90aWZ5ICh0aGUgYW5pbWF0aW9uIGxvb3AgZG9lc24ndCBkbyBpdCBmb3IgdXMgb24gYHN0b3BgKVxuICAgICAgICBjeS5ub3RpZnkoe1xuICAgICAgICAgIGNvbGxlY3Rpb246IHRoaXMsXG4gICAgICAgICAgdHlwZTogJ2RyYXcnXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0gLy8gc3RvcFxuXG4gIH07IC8vIGRlZmluZVxuXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLnNlbGVjdG9yID0gZnVuY3Rpb24obWFwLCBvcHRpb25zKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIG1hcCApe1xuICAgICAgdmFyIGZuID0gbWFwW25hbWVdO1xuICAgICAgJCQuU2VsZWN0b3IucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG5cbiAgJCQuU2VsZWN0b3IgPSBmdW5jdGlvbihvbmx5VGhpc0dyb3VwLCBzZWxlY3Rvcil7XG4gICAgXG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLlNlbGVjdG9yKSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5TZWxlY3Rvcihvbmx5VGhpc0dyb3VwLCBzZWxlY3Rvcik7XG4gICAgfVxuICBcbiAgICBpZiggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCAmJiBvbmx5VGhpc0dyb3VwICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHNlbGVjdG9yID0gb25seVRoaXNHcm91cDtcbiAgICAgIG9ubHlUaGlzR3JvdXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIFxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBcbiAgICBzZWxmLl9wcml2YXRlID0ge1xuICAgICAgc2VsZWN0b3JUZXh0OiBudWxsLFxuICAgICAgaW52YWxpZDogdHJ1ZVxuICAgIH07XG4gICAgXG4gICAgaWYoICFzZWxlY3RvciB8fCAoICQkLmlzLnN0cmluZyhzZWxlY3RvcikgJiYgc2VsZWN0b3IubWF0Y2goL15cXHMqJC8pICkgKXtcbiAgICAgIFxuICAgICAgaWYoIG9ubHlUaGlzR3JvdXAgPT0gbnVsbCApe1xuICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgc2VsZi5sZW5ndGggPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHNlbGZbMF0uZ3JvdXAgPSBvbmx5VGhpc0dyb3VwO1xuICAgICAgICBzZWxmLmxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgICAgICAgICAgIFxuICAgIH0gZWxzZSBpZiggJCQuaXMuZWxlbWVudCggc2VsZWN0b3IgKSApe1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSBuZXcgJCQuQ29sbGVjdGlvbihzZWxmLmN5KCksIFsgc2VsZWN0b3IgXSk7XG4gICAgICBcbiAgICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgICAgc2VsZlswXS5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgIHNlbGYubGVuZ3RoID0gMTtcbiAgICAgIFxuICAgIH0gZWxzZSBpZiggJCQuaXMuY29sbGVjdGlvbiggc2VsZWN0b3IgKSApe1xuICAgICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gICAgICBzZWxmWzBdLmNvbGxlY3Rpb24gPSBzZWxlY3RvcjtcbiAgICAgIHNlbGYubGVuZ3RoID0gMTtcbiAgICAgIFxuICAgIH0gZWxzZSBpZiggJCQuaXMuZm4oIHNlbGVjdG9yICkgKSB7XG4gICAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICAgIHNlbGZbMF0uZmlsdGVyID0gc2VsZWN0b3I7XG4gICAgICBzZWxmLmxlbmd0aCA9IDE7XG4gICAgICBcbiAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyggc2VsZWN0b3IgKSApe1xuXG4gICAgICAvLyB0aGUgY3VycmVudCBzdWJqZWN0IGluIHRoZSBxdWVyeVxuICAgICAgdmFyIGN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcbiAgICAgIFxuICAgICAgLy8gc3RvcmFnZSBmb3IgcGFyc2VkIHF1ZXJpZXNcbiAgICAgIHZhciBuZXdRdWVyeSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2xhc3NlczogW10sIFxuICAgICAgICAgIGNvbG9uU2VsZWN0b3JzOiBbXSxcbiAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICBncm91cDogbnVsbCxcbiAgICAgICAgICBpZHM6IFtdLFxuICAgICAgICAgIG1ldGE6IFtdLFxuXG4gICAgICAgICAgLy8gZmFrZSBzZWxlY3RvcnNcbiAgICAgICAgICBjb2xsZWN0aW9uOiBudWxsLCAvLyBhIGNvbGxlY3Rpb24gdG8gbWF0Y2ggYWdhaW5zdFxuICAgICAgICAgIGZpbHRlcjogbnVsbCwgLy8gZmlsdGVyIGZ1bmN0aW9uXG5cbiAgICAgICAgICAvLyB0aGVzZSBhcmUgZGVmaW5lZCBpbiB0aGUgdXB3YXJkIGRpcmVjdGlvbiByYXRoZXIgdGhhbiBkb3duIChlLmcuIGNoaWxkKVxuICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBnbyB1cCBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuICAgICAgICAgIHBhcmVudDogbnVsbCwgLy8gcGFyZW50IHF1ZXJ5IG9ialxuICAgICAgICAgIGFuY2VzdG9yOiBudWxsLCAvLyBhbmNlc3RvciBxdWVyeSBvYmpcbiAgICAgICAgICBzdWJqZWN0OiBudWxsLCAvLyBkZWZpbmVzIHN1YmplY3QgaW4gY29tcG91bmQgcXVlcnkgKHN1YmplY3QgcXVlcnkgb2JqOyBwb2ludHMgdG8gc2VsZiBpZiBzdWJqZWN0KVxuXG4gICAgICAgICAgLy8gdXNlIHRoZXNlIG9ubHkgd2hlbiBzdWJqZWN0IGhhcyBiZWVuIGRlZmluZWRcbiAgICAgICAgICBjaGlsZDogbnVsbCxcbiAgICAgICAgICBkZXNjZW5kYW50OiBudWxsXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICAvLyB0b2tlbnMgaW4gdGhlIHF1ZXJ5IGxhbmd1YWdlXG4gICAgICB2YXIgdG9rZW5zID0ge1xuICAgICAgICBtZXRhQ2hhcjogJ1tcXFxcIVxcXFxcIlxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLlxcXFwvXFxcXDpcXFxcO1xcXFw8XFxcXD1cXFxcPlxcXFw/XFxcXEBcXFxcW1xcXFxdXFxcXF5cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XScsIC8vIGNoYXJzIHdlIG5lZWQgdG8gZXNjYXBlIGluIHZhciBuYW1lcywgZXRjXG4gICAgICAgIGNvbXBhcmF0b3JPcDogJz18XFxcXCE9fD58Pj18PHw8PXxcXFxcJD18XFxcXF49fFxcXFwqPScsIC8vIGJpbmFyeSBjb21wYXJpc29uIG9wICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICAgICAgICBib29sT3A6ICdcXFxcP3xcXFxcIXxcXFxcXicsIC8vIGJvb2xlYW4gKHVuYXJ5KSBvcGVyYXRvcnMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpXG4gICAgICAgIHN0cmluZzogJ1wiKD86XFxcXFxcXFxcInxbXlwiXSkrXCInICsgJ3wnICsgXCInKD86XFxcXFxcXFwnfFteJ10pKydcIiwgLy8gc3RyaW5nIGxpdGVyYWxzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLSBkb3VibGVxdW90ZXMgfCBzaW5nbGVxdW90ZXNcbiAgICAgICAgbnVtYmVyOiAkJC51dGlsLnJlZ2V4Lm51bWJlciwgLy8gbnVtYmVyIGxpdGVyYWwgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tLSBlLmcuIDAuMTIzNCwgMTIzNCwgMTJlMTIzXG4gICAgICAgIG1ldGE6ICdkZWdyZWV8aW5kZWdyZWV8b3V0ZGVncmVlJywgLy8gYWxsb3dlZCBtZXRhZGF0YSBmaWVsZHMgKGkuZS4gYWxsb3dlZCBmdW5jdGlvbnMgdG8gdXNlIGZyb20gJCQuQ29sbGVjdGlvbilcbiAgICAgICAgc2VwYXJhdG9yOiAnXFxcXHMqLFxcXFxzKicsIC8vIHF1ZXJpZXMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMsIGUuZy4gZWRnZVtmb28gPSAnYmFyJ10sIG5vZGUuc29tZUNsYXNzXG4gICAgICAgIGRlc2NlbmRhbnQ6ICdcXFxccysnLFxuICAgICAgICBjaGlsZDogJ1xcXFxzKz5cXFxccysnLFxuICAgICAgICBzdWJqZWN0OiAnXFxcXCQnXG4gICAgICB9O1xuICAgICAgdG9rZW5zLnZhcmlhYmxlID0gJyg/OltcXFxcdy1dfCg/OlxcXFxcXFxcJysgdG9rZW5zLm1ldGFDaGFyICsnKSkrJzsgLy8gYSB2YXJpYWJsZSBuYW1lXG4gICAgICB0b2tlbnMudmFsdWUgPSB0b2tlbnMuc3RyaW5nICsgJ3wnICsgdG9rZW5zLm51bWJlcjsgLy8gYSB2YWx1ZSBsaXRlcmFsLCBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICB0b2tlbnMuY2xhc3NOYW1lID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhIGNsYXNzIG5hbWUgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG4gICAgICB0b2tlbnMuaWQgPSB0b2tlbnMudmFyaWFibGU7IC8vIGFuIGVsZW1lbnQgaWQgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG5cbiAgICAgIC8vIHdoZW4gYSB0b2tlbiBsaWtlIGEgdmFyaWFibGUgaGFzIGVzY2FwZWQgbWV0YSBjaGFyYWN0ZXJzLCB3ZSBuZWVkIHRvIGNsZWFuIHRoZSBiYWNrc2xhc2hlcyBvdXRcbiAgICAgIC8vIHNvIHRoYXQgdmFsdWVzIGdldCBjb21wYXJlZCBwcm9wZXJseSBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuICAgICAgdmFyIGNsZWFuTWV0YUNoYXJzID0gZnVuY3Rpb24oc3RyKXtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxcXFxcKCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKScsICdnJyksIGZ1bmN0aW9uKG1hdGNoLCAkMSwgb2Zmc2V0LCBvcmlnaW5hbCl7XG4gICAgICAgICAgcmV0dXJuICQxO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIGFkZCBAIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICAgICAgdmFyIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBvcCA9IG9wc1tpXTtcbiAgICAgICAgdG9rZW5zLmNvbXBhcmF0b3JPcCArPSAnfEAnICsgb3A7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCAhIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICAgICAgdmFyIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBvcCA9IG9wc1tpXTtcblxuICAgICAgICBpZiggb3AuaW5kZXhPZignIScpID49IDAgKXsgY29udGludWU7IH0gLy8gc2tpcCBvcHMgdGhhdCBleHBsaWNpdGx5IGNvbnRhaW4gIVxuICAgICAgICBpZiggb3AgPT09ICc9JyApeyBjb250aW51ZTsgfSAvLyBza2lwID0gYi9jICE9IGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuXG4gICAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xcXFxcIScgKyBvcDtcbiAgICAgIH1cblxuICAgICAgLy8gTk9URTogYWRkIG5ldyBleHByZXNzaW9uIHN5bnRheCBoZXJlIHRvIGhhdmUgaXQgcmVjb2duaXNlZCBieSB0aGUgcGFyc2VyO1xuICAgICAgLy8gLSBhIHF1ZXJ5IGNvbnRhaW5zIGFsbCBhZGphY2VudCAoaS5lLiBubyBzZXBhcmF0b3IgaW4gYmV0d2VlbikgZXhwcmVzc2lvbnM7XG4gICAgICAvLyAtIHRoZSBjdXJyZW50IHF1ZXJ5IGlzIHN0b3JlZCBpbiBzZWxmW2ldIC0tLSB5b3UgY2FuIHVzZSB0aGUgcmVmZXJlbmNlIHRvIGB0aGlzYCBpbiB0aGUgcG9wdWxhdGUgZnVuY3Rpb247XG4gICAgICAvLyAtIHlvdSBuZWVkIHRvIGNoZWNrIHRoZSBxdWVyeSBvYmplY3RzIGluIFNlbGVjdG9yLmZpbHRlcigpIGZvciBpdCBhY3R1YWxseSBmaWx0ZXIgcHJvcGVybHksIGJ1dCB0aGF0J3MgcHJldHR5IHN0cmFpZ2h0IGZvcndhcmRcbiAgICAgIC8vIC0gd2hlbiB5b3UgYWRkIHNvbWV0aGluZyBoZXJlLCBhbHNvIGFkZCB0byBTZWxlY3Rvci50b1N0cmluZygpXG4gICAgICB2YXIgZXhwcnMgPSB7XG4gICAgICAgIGdyb3VwOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgcmVnZXg6ICcobm9kZXxlZGdlfFxcXFwqKScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBncm91cCApe1xuICAgICAgICAgICAgdGhpcy5ncm91cCA9IGdyb3VwID09IFwiKlwiID8gZ3JvdXAgOiBncm91cCArICdzJztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIC8vIE5COiBpZiBvbmUgY29sb24gc2VsZWN0b3IgaXMgYSBzdWJzdHJpbmcgb2YgYW5vdGhlciBmcm9tIGl0cyBzdGFydCwgcGxhY2UgdGhlIGxvbmdlciBvbmUgZmlyc3RcbiAgICAgICAgICAvLyBlLmcuIDpmb29iYXJ8OmZvb1xuICAgICAgICAgIHJlZ2V4OiAnKDpzZWxlY3RlZHw6dW5zZWxlY3RlZHw6bG9ja2VkfDp1bmxvY2tlZHw6dmlzaWJsZXw6aGlkZGVufDp0cmFuc3BhcmVudHw6Z3JhYmJlZHw6ZnJlZXw6cmVtb3ZlZHw6aW5zaWRlfDpncmFiYmFibGV8OnVuZ3JhYmJhYmxlfDphbmltYXRlZHw6dW5hbmltYXRlZHw6c2VsZWN0YWJsZXw6dW5zZWxlY3RhYmxlfDpvcnBoYW58Om5vbm9ycGhhbnw6cGFyZW50fDpjaGlsZHw6bG9vcHw6c2ltcGxlfDphY3RpdmV8OmluYWN0aXZlfDp0b3VjaHw6YmFja2dyb3VuZGluZ3w6bm9uYmFja2dyb3VuZGluZyknLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggc3RhdGUgKXtcbiAgICAgICAgICAgIHRoaXMuY29sb25TZWxlY3RvcnMucHVzaCggc3RhdGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBpZDoge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnXFxcXCMoJysgdG9rZW5zLmlkICsnKScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBpZCApe1xuICAgICAgICAgICAgdGhpcy5pZHMucHVzaCggY2xlYW5NZXRhQ2hhcnMoaWQpICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgY2xhc3NOYW1lOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgcmVnZXg6ICdcXFxcLignKyB0b2tlbnMuY2xhc3NOYW1lICsnKScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKXtcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCBjbGVhbk1ldGFDaGFycyhjbGFzc05hbWUpICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgZGF0YUV4aXN0czoge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJysgdG9rZW5zLnZhcmlhYmxlICsnKVxcXFxzKlxcXFxdJyxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIHZhcmlhYmxlICl7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XG4gICAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGRhdGFDb21wYXJlOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxzKignKyB0b2tlbnMudmFyaWFibGUgKycpXFxcXHMqKCcrIHRva2Vucy5jb21wYXJhdG9yT3AgKycpXFxcXHMqKCcrIHRva2Vucy52YWx1ZSArJylcXFxccypcXFxcXScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCB2YXJpYWJsZSwgY29tcGFyYXRvck9wLCB2YWx1ZSApeyBcbiAgICAgICAgICAgIHZhciB2YWx1ZUlzU3RyaW5nID0gbmV3IFJlZ0V4cCgnXicgKyB0b2tlbnMuc3RyaW5nICsgJyQnKS5leGVjKHZhbHVlKSAhPSBudWxsO1xuXG4gICAgICAgICAgICBpZiggdmFsdWVJc1N0cmluZyApe1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBkYXRhQm9vbDoge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJysgdG9rZW5zLmJvb2xPcCArJylcXFxccyooJysgdG9rZW5zLnZhcmlhYmxlICsnKVxcXFxzKlxcXFxdJyxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGJvb2xPcCwgdmFyaWFibGUgKXtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6IGJvb2xPcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgbWV0YUNvbXBhcmU6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICByZWdleDogJ1xcXFxbXFxcXFtcXFxccyooJysgdG9rZW5zLm1ldGEgKycpXFxcXHMqKCcrIHRva2Vucy5jb21wYXJhdG9yT3AgKycpXFxcXHMqKCcrIHRva2Vucy5udW1iZXIgKycpXFxcXHMqXFxcXF1cXFxcXScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBtZXRhLCBjb21wYXJhdG9yT3AsIG51bWJlciApe1xuICAgICAgICAgICAgdGhpcy5tZXRhLnB1c2goe1xuICAgICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnMobWV0YSksXG4gICAgICAgICAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlcilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBuZXh0UXVlcnk6IHtcbiAgICAgICAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgICAgICAgcmVnZXg6IHRva2Vucy5zZXBhcmF0b3IsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvLyBnbyBvbiB0byBuZXh0IHF1ZXJ5XG4gICAgICAgICAgICBzZWxmWysraV0gPSBuZXdRdWVyeSgpO1xuICAgICAgICAgICAgY3VycmVudFN1YmplY3QgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjaGlsZDoge1xuICAgICAgICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICAgICAgICByZWdleDogdG9rZW5zLmNoaWxkLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gdGhpcyBxdWVyeSBpcyB0aGUgcGFyZW50IG9mIHRoZSBmb2xsb3dpbmcgcXVlcnlcbiAgICAgICAgICAgIHZhciBjaGlsZFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICAgIGNoaWxkUXVlcnkucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIGNoaWxkUXVlcnkuc3ViamVjdCA9IGN1cnJlbnRTdWJqZWN0O1xuXG4gICAgICAgICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgICAgICAgICAgc2VsZltpXSA9IGNoaWxkUXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlc2NlbmRhbnQ6IHtcbiAgICAgICAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgICAgICAgcmVnZXg6IHRva2Vucy5kZXNjZW5kYW50LFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gdGhpcyBxdWVyeSBpcyB0aGUgYW5jZXN0b3Igb2YgdGhlIGZvbGxvd2luZyBxdWVyeVxuICAgICAgICAgICAgdmFyIGRlc2NlbmRhbnRRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgICAgICBkZXNjZW5kYW50UXVlcnkuYW5jZXN0b3IgPSB0aGlzO1xuICAgICAgICAgICAgZGVzY2VuZGFudFF1ZXJ5LnN1YmplY3QgPSBjdXJyZW50U3ViamVjdDtcblxuICAgICAgICAgICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGRlc2NlbmRhbnQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgICAgICAgICAgc2VsZltpXSA9IGRlc2NlbmRhbnRRdWVyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3ViamVjdDoge1xuICAgICAgICAgIG1vZGlmaWVyOiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiB0b2tlbnMuc3ViamVjdCxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmKCBjdXJyZW50U3ViamVjdCAhPSBudWxsICYmIHRoaXMuc3ViamVjdCAhPSB0aGlzICl7XG4gICAgICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1JlZGVmaW5pdGlvbiBvZiBzdWJqZWN0IGluIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCcpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRTdWJqZWN0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdCA9IHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBqID0gMDtcbiAgICAgIGZvciggdmFyIG5hbWUgaW4gZXhwcnMgKXtcbiAgICAgICAgZXhwcnNbal0gPSBleHByc1tuYW1lXTtcbiAgICAgICAgZXhwcnNbal0ubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgICAgZXhwcnMubGVuZ3RoID0gajtcblxuICAgICAgc2VsZi5fcHJpdmF0ZS5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICAgIHZhciByZW1haW5pbmcgPSBzZWxlY3RvcjtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIFxuICAgICAgLy8gb2YgYWxsIHRoZSBleHByZXNzaW9ucywgZmluZCB0aGUgZmlyc3QgbWF0Y2ggaW4gdGhlIHJlbWFpbmluZyB0ZXh0XG4gICAgICB2YXIgY29uc3VtZUV4cHIgPSBmdW5jdGlvbiggZXhwZWN0YXRpb24gKXtcbiAgICAgICAgdmFyIGV4cHI7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgIFxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGV4cHJzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGUgPSBleHByc1tqXTtcbiAgICAgICAgICB2YXIgbiA9IGUubmFtZTtcblxuICAgICAgICAgIC8vIGlnbm9yZSB0aGlzIGV4cHJlc3Npb24gaWYgaXQgZG9lc24ndCBtZWV0IHRoZSBleHBlY3RhdGlvbiBmdW5jdGlvblxuICAgICAgICAgIGlmKCAkJC5pcy5mbiggZXhwZWN0YXRpb24gKSAmJiAhZXhwZWN0YXRpb24obiwgZSkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIHZhciBtID0gcmVtYWluaW5nLm1hdGNoKG5ldyBSZWdFeHAoICdeJyArIGUucmVnZXggKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIG0gIT0gbnVsbCApe1xuICAgICAgICAgICAgbWF0Y2ggPSBtO1xuICAgICAgICAgICAgZXhwciA9IGU7XG4gICAgICAgICAgICBuYW1lID0gbjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbnN1bWVkID0gbVswXTtcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGNvbnN1bWVkLmxlbmd0aCApOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYnJlYWs7IC8vIHdlJ3ZlIGNvbnN1bWVkIG9uZSBleHByLCBzbyB3ZSBjYW4gcmV0dXJuIG5vd1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHByOiBleHByLFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBjb25zdW1lIGFsbCBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBjb25zdW1lV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBtYXRjaCA9IHJlbWFpbmluZy5tYXRjaCgvXlxccysvKTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBtYXRjaCApe1xuICAgICAgICAgIHZhciBjb25zdW1lZCA9IG1hdGNoWzBdO1xuICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGNvbnN1bWVkLmxlbmd0aCApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTsgLy8gZ2V0IHN0YXJ0ZWRcblxuICAgICAgY29uc3VtZVdoaXRlc3BhY2UoKTsgLy8gZ2V0IHJpZCBvZiBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgIGZvcig7Oyl7ICAgICAgICBcbiAgICAgICAgdmFyIGNoZWNrID0gY29uc3VtZUV4cHIoKTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBjaGVjay5leHByID09IG51bGwgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdUaGUgc2VsZWN0b3IgYCcrIHNlbGVjdG9yICsnYGlzIGludmFsaWQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICBmb3IodmFyIGogPSAxOyBqIDwgY2hlY2subWF0Y2gubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgYXJncy5wdXNoKCBjaGVjay5tYXRjaFtqXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBsZXQgdGhlIHRva2VuIHBvcHVsYXRlIHRoZSBzZWxlY3RvciBvYmplY3QgKGkuZS4gaW4gc2VsZltpXSlcbiAgICAgICAgICB2YXIgcmV0ID0gY2hlY2suZXhwci5wb3B1bGF0ZS5hcHBseSggc2VsZltpXSwgYXJncyApO1xuXG4gICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXsgcmV0dXJuOyB9IC8vIGV4aXQgaWYgcG9wdWxhdGlvbiBmYWlsZWRcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gd2UncmUgZG9uZSB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHBhcnNlXG4gICAgICAgIGlmKCByZW1haW5pbmcubWF0Y2goL15cXHMqJC8pICl7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2VsZi5sZW5ndGggPSBpICsgMTtcblxuICAgICAgLy8gYWRqdXN0IHJlZmVyZW5jZXMgZm9yIHN1YmplY3RcbiAgICAgIGZvcihqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuXG4gICAgICAgIGlmKCBxdWVyeS5zdWJqZWN0ICE9IG51bGwgKXtcbiAgICAgICAgICAvLyBnbyB1cCB0aGUgdHJlZSB1bnRpbCB3ZSByZWFjaCB0aGUgc3ViamVjdFxuICAgICAgICAgIGZvcig7Oyl7XG4gICAgICAgICAgICBpZiggcXVlcnkuc3ViamVjdCA9PSBxdWVyeSApeyBicmVhazsgfSAvLyBkb25lIGlmIHN1YmplY3QgaXMgc2VsZlxuXG4gICAgICAgICAgICBpZiggcXVlcnkucGFyZW50ICE9IG51bGwgKXsgLy8gc3dhcCBwYXJlbnQvY2hpbGQgcmVmZXJlbmNlXG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBxdWVyeS5wYXJlbnQ7XG4gICAgICAgICAgICAgIHZhciBjaGlsZCA9IHF1ZXJ5O1xuXG4gICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgIHBhcmVudC5jaGlsZCA9IGNoaWxkO1xuXG4gICAgICAgICAgICAgIHF1ZXJ5ID0gcGFyZW50OyAvLyBnbyB1cCB0aGUgdHJlZVxuICAgICAgICAgICAgfSBlbHNlIGlmKCBxdWVyeS5hbmNlc3RvciAhPSBudWxsICl7IC8vIHN3YXAgYW5jZXN0b3IvZGVzY2VuZGFudFxuICAgICAgICAgICAgICB2YXIgYW5jZXN0b3IgPSBxdWVyeS5hbmNlc3RvcjtcbiAgICAgICAgICAgICAgdmFyIGRlc2NlbmRhbnQgPSBxdWVyeTtcblxuICAgICAgICAgICAgICBkZXNjZW5kYW50LmFuY2VzdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgYW5jZXN0b3IuZGVzY2VuZGFudCA9IGRlc2NlbmRhbnQ7XG5cbiAgICAgICAgICAgICAgcXVlcnkgPSBhbmNlc3RvcjsgLy8gZ28gdXAgdGhlIHRyZWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1doZW4gYWRqdXN0aW5nIHJlZmVyZW5jZXMgZm9yIHRoZSBzZWxlY3RvciBgJysgcXVlcnkgKydgLCBuZWl0aGVyIHBhcmVudCBub3IgYW5jZXN0b3Igd2FzIGZvdW5kJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gZm9yXG5cbiAgICAgICAgICBzZWxmW2pdID0gcXVlcnkuc3ViamVjdDsgLy8gc3ViamVjdCBzaG91bGQgYmUgdGhlIHJvb3QgcXVlcnlcbiAgICAgICAgfSAvLyBpZlxuICAgICAgfSAvLyBmb3JcblxuICAgICAgLy8gbWFrZSBzdXJlIGZvciBlYWNoIHF1ZXJ5IHRoYXQgdGhlIHN1YmplY3QgZ3JvdXAgbWF0Y2hlcyB0aGUgaW1wbGljaXQgZ3JvdXAgaWYgYW55XG4gICAgICBpZiggb25seVRoaXNHcm91cCAhPSBudWxsICl7XG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICBpZiggc2VsZltqXS5ncm91cCAhPSBudWxsICYmIHNlbGZbal0uZ3JvdXAgIT0gb25seVRoaXNHcm91cCApe1xuICAgICAgICAgICAgJCQudXRpbC5lcnJvcignR3JvdXAgYCcrIHNlbGZbal0uZ3JvdXAgKydgIGNvbmZsaWN0cyB3aXRoIGltcGxpY2l0IGdyb3VwIGAnKyBvbmx5VGhpc0dyb3VwICsnYCBpbiBzZWxlY3RvciBgJysgc2VsZWN0b3IgKydgJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZltqXS5ncm91cCA9IG9ubHlUaGlzR3JvdXA7IC8vIHNldCB0byBpbXBsaWNpdCBncm91cFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgJCQudXRpbC5lcnJvcignQSBzZWxlY3RvciBtdXN0IGJlIGNyZWF0ZWQgZnJvbSBhIHN0cmluZzsgZm91bmQgJyArIHNlbGVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLl9wcml2YXRlLmludmFsaWQgPSBmYWxzZTtcbiAgICBcbiAgfTtcblxuICAkJC5zZWxmbiA9ICQkLlNlbGVjdG9yLnByb3RvdHlwZTtcbiAgXG4gICQkLnNlbGZuLnNpemUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgfTtcbiAgXG4gICQkLnNlbGZuLmVxID0gZnVuY3Rpb24oaSl7XG4gICAgcmV0dXJuIHRoaXNbaV07XG4gIH07XG4gIFxuICAvLyBnZXQgZWxlbWVudHMgZnJvbSB0aGUgY29yZSBhbmQgdGhlbiBmaWx0ZXIgdGhlbVxuICAkJC5zZWxmbi5maW5kID0gZnVuY3Rpb24oKXtcbiAgICAvLyBUT0RPIGltcGwgaWYgd2UgZGVjaWRlIHRvIHVzZSBhIERCIGZvciBzdG9yaW5nIGVsZW1lbnRzXG4gIH07XG4gIFxuICB2YXIgcXVlcnlNYXRjaGVzID0gZnVuY3Rpb24ocXVlcnksIGVsZW1lbnQpe1xuICAgIC8vIGNoZWNrIGdyb3VwXG4gICAgaWYoIHF1ZXJ5Lmdyb3VwICE9IG51bGwgJiYgcXVlcnkuZ3JvdXAgIT0gJyonICYmIHF1ZXJ5Lmdyb3VwICE9IGVsZW1lbnQuX3ByaXZhdGUuZ3JvdXAgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY3kgPSBlbGVtZW50LmN5KCk7XG4gICAgXG4gICAgLy8gY2hlY2sgY29sb24gc2VsZWN0b3JzXG4gICAgdmFyIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSB0cnVlO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCBxdWVyeS5jb2xvblNlbGVjdG9ycy5sZW5ndGg7IGsrKyl7XG4gICAgICB2YXIgc2VsID0gcXVlcnkuY29sb25TZWxlY3RvcnNba107XG4gICAgICBcbiAgICAgIHN3aXRjaChzZWwpe1xuICAgICAgY2FzZSAnOnNlbGVjdGVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuc2VsZWN0ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5zZWxlY3RlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5zZWxlY3RlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpzZWxlY3RhYmxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuc2VsZWN0YWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp1bnNlbGVjdGFibGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuc2VsZWN0YWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpsb2NrZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5sb2NrZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5sb2NrZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQubG9ja2VkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnZpc2libGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC52aXNpYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmhpZGRlbic6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC52aXNpYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnRyYW5zcGFyZW50JzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQudHJhbnNwYXJlbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6Z3JhYmJlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmdyYWJiZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6ZnJlZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5ncmFiYmVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnJlbW92ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5yZW1vdmVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmluc2lkZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5yZW1vdmVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmdyYWJiYWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmdyYWJiYWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp1bmdyYWJiYWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5ncmFiYmFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6YW5pbWF0ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5hbmltYXRlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp1bmFuaW1hdGVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmFuaW1hdGVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnBhcmVudCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmlzTm9kZSgpICYmIGVsZW1lbnQuY2hpbGRyZW4oKS5ub25lbXB0eSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpjaGlsZCc6XG4gICAgICBjYXNlICc6bm9ub3JwaGFuJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuaXNOb2RlKCkgJiYgZWxlbWVudC5wYXJlbnQoKS5ub25lbXB0eSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpvcnBoYW4nOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc05vZGUoKSAmJiBlbGVtZW50LnBhcmVudCgpLmVtcHR5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmxvb3AnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc0VkZ2UoKSAmJiBlbGVtZW50LmRhdGEoJ3NvdXJjZScpID09PSBlbGVtZW50LmRhdGEoJ3RhcmdldCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpzaW1wbGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc0VkZ2UoKSAmJiBlbGVtZW50LmRhdGEoJ3NvdXJjZScpICE9PSBlbGVtZW50LmRhdGEoJ3RhcmdldCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzphY3RpdmUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5hY3RpdmUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6aW5hY3RpdmUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuYWN0aXZlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnRvdWNoJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICQkLmlzLnRvdWNoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmJhY2tncm91bmRpbmcnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5iYWNrZ3JvdW5kaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOm5vbmJhY2tncm91bmRpbmcnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuYmFja2dyb3VuZGluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoICFhbGxDb2xvblNlbGVjdG9yc01hdGNoICkgYnJlYWs7XG4gICAgfVxuICAgIGlmKCAhYWxsQ29sb25TZWxlY3RvcnNNYXRjaCApIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBjaGVjayBpZFxuICAgIHZhciBhbGxJZHNNYXRjaCA9IHRydWU7XG4gICAgZm9yKHZhciBrID0gMDsgayA8IHF1ZXJ5Lmlkcy5sZW5ndGg7IGsrKyl7XG4gICAgICB2YXIgaWQgPSBxdWVyeS5pZHNba107XG4gICAgICB2YXIgYWN0dWFsSWQgPSBlbGVtZW50Ll9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICBcbiAgICAgIGFsbElkc01hdGNoID0gYWxsSWRzTWF0Y2ggJiYgKGlkID09IGFjdHVhbElkKTtcbiAgICAgIFxuICAgICAgaWYoICFhbGxJZHNNYXRjaCApIGJyZWFrO1xuICAgIH1cbiAgICBpZiggIWFsbElkc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIGNoZWNrIGNsYXNzZXNcbiAgICB2YXIgYWxsQ2xhc3Nlc01hdGNoID0gdHJ1ZTtcbiAgICBmb3IodmFyIGsgPSAwOyBrIDwgcXVlcnkuY2xhc3Nlcy5sZW5ndGg7IGsrKyl7XG4gICAgICB2YXIgY2xzID0gcXVlcnkuY2xhc3Nlc1trXTtcbiAgICAgIFxuICAgICAgYWxsQ2xhc3Nlc01hdGNoID0gYWxsQ2xhc3Nlc01hdGNoICYmIGVsZW1lbnQuaGFzQ2xhc3MoY2xzKTtcbiAgICAgIFxuICAgICAgaWYoICFhbGxDbGFzc2VzTWF0Y2ggKSBicmVhaztcbiAgICB9XG4gICAgaWYoICFhbGxDbGFzc2VzTWF0Y2ggKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gZ2VuZXJpYyBjaGVja2luZyBmb3IgZGF0YS9tZXRhZGF0YVxuICAgIHZhciBvcGVyYW5kc01hdGNoID0gZnVuY3Rpb24ocGFyYW1zKXtcbiAgICAgIHZhciBhbGxEYXRhTWF0Y2hlcyA9IHRydWU7XG4gICAgICBmb3IodmFyIGsgPSAwOyBrIDwgcXVlcnlbcGFyYW1zLm5hbWVdLmxlbmd0aDsgaysrKXtcbiAgICAgICAgdmFyIGRhdGEgPSBxdWVyeVtwYXJhbXMubmFtZV1ba107XG4gICAgICAgIHZhciBvcGVyYXRvciA9IGRhdGEub3BlcmF0b3I7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgICAgIHZhciBmaWVsZCA9IGRhdGEuZmllbGQ7XG4gICAgICAgIHZhciBtYXRjaGVzO1xuICAgICAgICBcbiAgICAgICAgaWYoIG9wZXJhdG9yICE9IG51bGwgJiYgdmFsdWUgIT0gbnVsbCApe1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBmaWVsZFZhbCA9IHBhcmFtcy5maWVsZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgICB2YXIgZmllbGRTdHIgPSAhJCQuaXMuc3RyaW5nKGZpZWxkVmFsKSAmJiAhJCQuaXMubnVtYmVyKGZpZWxkVmFsKSA/ICcnIDogJycgKyBmaWVsZFZhbDtcbiAgICAgICAgICB2YXIgdmFsU3RyID0gJycgKyB2YWx1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgY2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gICAgICAgICAgaWYoIG9wZXJhdG9yLmluZGV4T2YoJ0AnKSA+PSAwICl7XG4gICAgICAgICAgICBmaWVsZFN0ciA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YWxTdHIgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCdAJywgJycpO1xuICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbm90RXhwciA9IGZhbHNlO1xuICAgICAgICAgIHZhciBoYW5kbGVkTm90RXhwciA9IGZhbHNlO1xuICAgICAgICAgIGlmKCBvcGVyYXRvci5pbmRleE9mKCchJykgPj0gMCApe1xuICAgICAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCchJywgJycpO1xuICAgICAgICAgICAgbm90RXhwciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGlmIHdlJ3JlIGRvaW5nIGEgY2FzZSBpbnNlbnNpdGl2ZSBjb21wYXJpc29uLCB0aGVuIHdlJ3JlIHVzaW5nIGEgU1RSSU5HIGNvbXBhcmlzb25cbiAgICAgICAgICAvLyBldmVuIGlmIHdlJ3JlIGNvbXBhcmluZyBudW1iZXJzXG4gICAgICAgICAgaWYoIGNhc2VJbnNlbnNpdGl2ZSApe1xuICAgICAgICAgICAgdmFsdWUgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZpZWxkVmFsID0gZmllbGRTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2gob3BlcmF0b3Ipe1xuICAgICAgICAgIGNhc2UgJyo9JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5zZWFyY2godmFsU3RyKSA+PSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnJD0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IG5ldyBSZWdFeHAodmFsU3RyICsgJyQnKS5leGVjKGZpZWxkU3RyKSAhPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnXj0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IG5ldyBSZWdFeHAoJ14nICsgdmFsU3RyKS5leGVjKGZpZWxkU3RyKSAhPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPT09IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsICE9PSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPiB2YWx1ZSA6IGZpZWxkVmFsIDw9IHZhbHVlO1xuICAgICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPj0gdmFsdWUgOiBmaWVsZFZhbCA8IHZhbHVlO1xuICAgICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICBtYXRjaGVzID0gIW5vdEV4cHIgPyBmaWVsZFZhbCA8IHZhbHVlIDogZmllbGRWYWwgPj0gdmFsdWU7XG4gICAgICAgICAgICBoYW5kbGVkTm90RXhwciA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICBtYXRjaGVzID0gIW5vdEV4cHIgPyBmaWVsZFZhbCA8PSB2YWx1ZSA6IGZpZWxkVmFsID4gdmFsdWU7XG4gICAgICAgICAgICBoYW5kbGVkTm90RXhwciA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiggb3BlcmF0b3IgIT0gbnVsbCApe1xuICAgICAgICAgIHN3aXRjaChvcGVyYXRvcil7XG4gICAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgICBtYXRjaGVzID0gcGFyYW1zLmZpZWxkVHJ1dGh5KGZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFwYXJhbXMuZmllbGRUcnV0aHkoZmllbGQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICBtYXRjaGVzID0gcGFyYW1zLmZpZWxkVW5kZWZpbmVkKGZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgICBcbiAgICAgICAgICBtYXRjaGVzID0gIXBhcmFtcy5maWVsZFVuZGVmaW5lZChmaWVsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggbm90RXhwciAmJiAhaGFuZGxlZE5vdEV4cHIgKXtcbiAgICAgICAgICBtYXRjaGVzID0gIW1hdGNoZXM7XG4gICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggIW1hdGNoZXMgKXtcbiAgICAgICAgICBhbGxEYXRhTWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvclxuICAgICAgXG4gICAgICByZXR1cm4gYWxsRGF0YU1hdGNoZXM7XG4gICAgfTsgLy8gb3BlcmFuZHNNYXRjaFxuICAgIFxuICAgIC8vIGNoZWNrIGRhdGEgbWF0Y2hlc1xuICAgIHZhciBhbGxEYXRhTWF0Y2hlcyA9IG9wZXJhbmRzTWF0Y2goe1xuICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgZmllbGRWYWx1ZTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICByZXR1cm4gZWxlbWVudC5fcHJpdmF0ZS5kYXRhW2ZpZWxkXTtcbiAgICAgIH0sXG4gICAgICBmaWVsZFJlZjogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICByZXR1cm4gJ2VsZW1lbnQuX3ByaXZhdGUuZGF0YS4nICsgZmllbGQ7XG4gICAgICB9LFxuICAgICAgZmllbGRVbmRlZmluZWQ6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuX3ByaXZhdGUuZGF0YVtmaWVsZF0gPT09IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBmaWVsZFRydXRoeTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICBpZiggZWxlbWVudC5fcHJpdmF0ZS5kYXRhW2ZpZWxkXSApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiggIWFsbERhdGFNYXRjaGVzICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIGNoZWNrIG1ldGFkYXRhIG1hdGNoZXNcbiAgICB2YXIgYWxsTWV0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKHtcbiAgICAgIG5hbWU6ICdtZXRhJyxcbiAgICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRbZmllbGRdKCk7XG4gICAgICB9LFxuICAgICAgZmllbGRSZWY6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuICdlbGVtZW50LicgKyBmaWVsZCArICcoKSc7XG4gICAgICB9LFxuICAgICAgZmllbGRVbmRlZmluZWQ6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRbZmllbGRdKCkgPT0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBmaWVsZFRydXRoeTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICBpZiggZWxlbWVudFtmaWVsZF0oKSApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiggIWFsbE1ldGFNYXRjaGVzICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIGNoZWNrIGNvbGxlY3Rpb25cbiAgICBpZiggcXVlcnkuY29sbGVjdGlvbiAhPSBudWxsICl7XG4gICAgICB2YXIgbWF0Y2hlc0FueSA9IHF1ZXJ5LmNvbGxlY3Rpb24uX3ByaXZhdGUuaWRzWyBlbGVtZW50LmlkKCkgXSAhPSBudWxsO1xuICAgICAgXG4gICAgICBpZiggIW1hdGNoZXNBbnkgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBjaGVjayBmaWx0ZXIgZnVuY3Rpb25cbiAgICBpZiggcXVlcnkuZmlsdGVyICE9IG51bGwgJiYgZWxlbWVudC5jb2xsZWN0aW9uKCkuZmlsdGVyKCBxdWVyeS5maWx0ZXIgKS5zaXplKCkgPT09IDAgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG5cbiAgICAvLyBjaGVjayBwYXJlbnQvY2hpbGQgcmVsYXRpb25zXG4gICAgdmFyIGNvbmZpcm1SZWxhdGlvbnMgPSBmdW5jdGlvbiggcXVlcnksIGVsZW1lbnRzICl7XG4gICAgICBpZiggcXVlcnkgIT0gbnVsbCApe1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCAhY3kuaGFzQ29tcG91bmROb2RlcygpICl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cygpOyAvLyBtYWtlIGVsZW1lbnRzIGZ1bmN0aW9uYWwgc28gd2Ugc2F2ZSBjeWNsZXMgaWYgcXVlcnkgPT0gbnVsbFxuXG4gICAgICAgIC8vIHF1ZXJ5IG11c3QgbWF0Y2ggZm9yIGF0IGxlYXN0IG9uZSBlbGVtZW50IChtYXkgYmUgcmVjdXJzaXZlKVxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgIGlmKCBxdWVyeU1hdGNoZXMoIHF1ZXJ5LCBlbGVtZW50c1tpXSApICl7XG4gICAgICAgICAgICBtYXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghIGNvbmZpcm1SZWxhdGlvbnMocXVlcnkucGFyZW50LCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGVsZW1lbnQucGFyZW50KCk7XG4gICAgfSkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoISBjb25maXJtUmVsYXRpb25zKHF1ZXJ5LmFuY2VzdG9yLCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGVsZW1lbnQucGFyZW50cygpO1xuICAgIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCEgY29uZmlybVJlbGF0aW9ucyhxdWVyeS5jaGlsZCwgZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuKCk7XG4gICAgfSkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoISBjb25maXJtUmVsYXRpb25zKHF1ZXJ5LmRlc2NlbmRhbnQsIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZWxlbWVudC5kZXNjZW5kYW50cygpO1xuICAgIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gd2UndmUgcmVhY2hlZCB0aGUgZW5kLCBzbyB3ZSd2ZSBtYXRjaGVkIGV2ZXJ5dGhpbmcgZm9yIHRoaXMgcXVlcnlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTsgLy8gcXVlcnlNYXRjaGVzXG5cbiAgLy8gZmlsdGVyIGFuIGV4aXN0aW5nIGNvbGxlY3Rpb25cbiAgJCQuc2VsZm4uZmlsdGVyID0gZnVuY3Rpb24oY29sbGVjdGlvbil7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeSA9IGNvbGxlY3Rpb24uY3koKTtcbiAgICBcbiAgICAvLyBkb24ndCBib3RoZXIgdHJ5aW5nIGlmIGl0J3MgaW52YWxpZFxuICAgIGlmKCBzZWxmLl9wcml2YXRlLmludmFsaWQgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3kgKTtcbiAgICB9XG4gIFxuICAgIHZhciBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG4gICAgICAgIFxuICAgICAgICBpZiggcXVlcnlNYXRjaGVzKHF1ZXJ5LCBlbGVtZW50KSApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFxuICAgIGlmKCBzZWxmLl9wcml2YXRlLnNlbGVjdG9yVGV4dCA9PSBudWxsICl7XG4gICAgICBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRydWU7IH07XG4gICAgfVxuICAgIFxuICAgIHZhciBmaWx0ZXJlZENvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmZpbHRlciggc2VsZWN0b3JGdW5jdGlvbiApO1xuICAgIFxuICAgIHJldHVybiBmaWx0ZXJlZENvbGxlY3Rpb247XG4gIH07IC8vIGZpbHRlclxuXG4gIC8vIGRvZXMgc2VsZWN0b3IgbWF0Y2ggYSBzaW5nbGUgZWxlbWVudD9cbiAgJCQuc2VsZm4ubWF0Y2hlcyA9IGZ1bmN0aW9uKGVsZSl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIC8vIGRvbid0IGJvdGhlciB0cnlpbmcgaWYgaXQncyBpbnZhbGlkXG4gICAgaWYoIHNlbGYuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspe1xuICAgICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcbiAgICAgIFxuICAgICAgaWYoIHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZWxlKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9OyAvLyBmaWx0ZXJcbiAgXG4gIC8vIGl0aCBxdWVyeSB0byBzdHJpbmdcbiAgJCQuc2VsZm4udG9TdHJpbmcgPSAkJC5zZWxmbi5zZWxlY3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgXG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIFxuICAgIHZhciBjbGVhbiA9IGZ1bmN0aW9uKG9iaiwgaXNWYWx1ZSl7XG4gICAgICBpZiggJCQuaXMuc3RyaW5nKG9iaikgKXtcbiAgICAgICAgcmV0dXJuIGlzVmFsdWUgPyAnXCInICsgb2JqICsgJ1wiJyA6IG9iajtcbiAgICAgIH0gXG4gICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgcXVlcnlUb1N0cmluZyA9IGZ1bmN0aW9uKHF1ZXJ5KXtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgaWYoIHF1ZXJ5LnN1YmplY3QgPT09IHF1ZXJ5ICl7XG4gICAgICAgIHN0ciArPSAnJCc7XG4gICAgICB9XG5cbiAgICAgIHZhciBncm91cCA9IGNsZWFuKHF1ZXJ5Lmdyb3VwKTtcbiAgICAgIHN0ciArPSBncm91cC5zdWJzdHJpbmcoMCwgZ3JvdXAubGVuZ3RoIC0gMSk7XG4gICAgICBcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5kYXRhLmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGRhdGEgPSBxdWVyeS5kYXRhW2pdO1xuICAgICAgICBcbiAgICAgICAgaWYoIGRhdGEudmFsdWUgKXtcbiAgICAgICAgICBzdHIgKz0gJ1snICsgZGF0YS5maWVsZCArIGNsZWFuKGRhdGEub3BlcmF0b3IpICsgY2xlYW4oZGF0YS52YWx1ZSwgdHJ1ZSkgKyAnXSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9ICdbJyArIGNsZWFuKGRhdGEub3BlcmF0b3IpICsgZGF0YS5maWVsZCArICddJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgcXVlcnkubWV0YS5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBtZXRhID0gcXVlcnkubWV0YVtqXTtcbiAgICAgICAgc3RyICs9ICdbWycgKyBtZXRhLmZpZWxkICsgY2xlYW4obWV0YS5vcGVyYXRvcikgKyBjbGVhbihtZXRhLnZhbHVlLCB0cnVlKSArICddXSc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5jb2xvblNlbGVjdG9ycy5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBzZWwgPSBxdWVyeS5jb2xvblNlbGVjdG9yc1tpXTtcbiAgICAgICAgc3RyICs9IHNlbDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHF1ZXJ5Lmlkcy5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBzZWwgPSAnIycgKyBxdWVyeS5pZHNbaV07XG4gICAgICAgIHN0ciArPSBzZWw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5jbGFzc2VzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIHNlbCA9ICcuJyArIHF1ZXJ5LmNsYXNzZXNbaV07XG4gICAgICAgIHN0ciArPSBzZWw7XG4gICAgICB9XG5cbiAgICAgIGlmKCBxdWVyeS5wYXJlbnQgIT0gbnVsbCApe1xuICAgICAgICBzdHIgPSBxdWVyeVRvU3RyaW5nKCBxdWVyeS5wYXJlbnQgKSArICcgPiAnICsgc3RyOyBcbiAgICAgIH1cblxuICAgICAgaWYoIHF1ZXJ5LmFuY2VzdG9yICE9IG51bGwgKXtcbiAgICAgICAgc3RyID0gcXVlcnlUb1N0cmluZyggcXVlcnkuYW5jZXN0b3IgKSArICcgJyArIHN0cjsgXG4gICAgICB9XG5cbiAgICAgIGlmKCBxdWVyeS5jaGlsZCAhPSBudWxsICl7XG4gICAgICAgIHN0ciArPSAnID4gJyArIHF1ZXJ5VG9TdHJpbmcoIHF1ZXJ5LmNoaWxkICk7IFxuICAgICAgfVxuXG4gICAgICBpZiggcXVlcnkuZGVzY2VuZGFudCAhPSBudWxsICl7XG4gICAgICAgIHN0ciArPSAnICcgKyBxdWVyeVRvU3RyaW5nKCBxdWVyeS5kZXNjZW5kYW50ICk7IFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzW2ldO1xuICAgICAgXG4gICAgICBzdHIgKz0gcXVlcnlUb1N0cmluZyggcXVlcnkgKTtcbiAgICAgIFxuICAgICAgaWYoIHRoaXMubGVuZ3RoID4gMSAmJiBpIDwgdGhpcy5sZW5ndGggLSAxICl7XG4gICAgICAgIHN0ciArPSAnLCAnO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5TdHlsZSA9IGZ1bmN0aW9uKCBjeSApe1xuXG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLlN0eWxlKSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5TdHlsZShjeSk7XG4gICAgfVxuXG4gICAgaWYoICEkJC5pcy5jb3JlKGN5KSApe1xuICAgICAgJCQudXRpbC5lcnJvcignQSBzdHlsZSBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBjeTogY3ksXG4gICAgICBjb3JlU3R5bGU6IHt9LFxuICAgICAgbmV3U3R5bGU6IHRydWVcbiAgICB9O1xuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuICB9O1xuXG4gIC8vIG5pY2UtdG8taGF2ZSBhbGlhc2VzXG4gICQkLnN0eWxlID0gJCQuU3R5bGU7XG4gICQkLnN0eWZuID0gJCQuU3R5bGUucHJvdG90eXBlO1xuXG4gIC8vIGRlZmluZSBmdW5jdGlvbnMgaW4gdGhlIFN0eWxlIHByb3RvdHlwZVxuICAkJC5mbi5zdHlsZSA9IGZ1bmN0aW9uKCBmbk1hcCwgb3B0aW9ucyApe1xuICAgIGZvciggdmFyIGZuTmFtZSBpbiBmbk1hcCApe1xuICAgICAgdmFyIGZuID0gZm5NYXBbIGZuTmFtZSBdO1xuICAgICAgJCQuU3R5bGUucHJvdG90eXBlID0gZm47XG4gICAgfVxuICB9O1xuXG4gIChmdW5jdGlvbigpe1xuICAgIHZhciBudW1iZXIgPSAkJC51dGlsLnJlZ2V4Lm51bWJlcjtcbiAgICB2YXIgcmdiYSA9ICQkLnV0aWwucmVnZXgucmdiYU5vQmFja1JlZnM7XG4gICAgdmFyIGhzbGEgPSAkJC51dGlsLnJlZ2V4LmhzbGFOb0JhY2tSZWZzO1xuICAgIHZhciBoZXgzID0gJCQudXRpbC5yZWdleC5oZXgzO1xuICAgIHZhciBoZXg2ID0gJCQudXRpbC5yZWdleC5oZXg2O1xuICAgIHZhciBkYXRhID0gZnVuY3Rpb24oIHByZWZpeCApeyByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoXFxcXHMqKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCkkJzsgfTtcbiAgICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uKCBwcmVmaXggKXsgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKChbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMgKyAnfCcgKyBoZXg2ICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJ3xcXFxcdyt8JyArIHJnYmEgKyAnfCcgKyBoc2xhICsgJ3wnICsgaGV4MyArICd8JyArIGhleDYgKyAnKVxcXFwpJCc7IH07XG5cbiAgICAvLyBlYWNoIHZpc3VhbCBzdHlsZSBwcm9wZXJ0eSBoYXMgYSB0eXBlIGFuZCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvIGl0XG4gICAgJCQuc3R5bGUudHlwZXMgPSB7XG4gICAgICB0aW1lOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCB1bml0czogJ3N8bXMnLCBpbXBsaWNpdFVuaXRzOiAnbXMnIH0sXG4gICAgICBwZXJjZW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBtYXg6IDEwMCwgdW5pdHM6ICclJyB9LFxuICAgICAgemVyb09uZU51bWJlcjogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgbWF4OiAxLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgICAgbk9uZU9uZU51bWJlcjogeyBudW1iZXI6IHRydWUsIG1pbjogLTEsIG1heDogMSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICAgIG5vbk5lZ2F0aXZlSW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBpbnRlZ2VyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgICAgcG9zaXRpb246IHsgZW51bXM6IFsncGFyZW50JywgJ29yaWdpbiddIH0sXG4gICAgICBhdXRvU2l6ZTogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgZW51bXM6IFsnYXV0byddIH0sXG4gICAgICBudW1iZXI6IHsgbnVtYmVyOiB0cnVlIH0sXG4gICAgICBzaXplOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwIH0sXG4gICAgICBiZ1NpemU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGFsbG93UGVyY2VudDogdHJ1ZSB9LFxuICAgICAgYmdXSDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgYWxsb3dQZXJjZW50OiB0cnVlLCBlbnVtczogWydhdXRvJ10gfSxcbiAgICAgIGJnUG9zOiB7IG51bWJlcjogdHJ1ZSwgYWxsb3dQZXJjZW50OiB0cnVlIH0sXG4gICAgICBiZ1JlcGVhdDogeyBlbnVtczogWydyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknLCAnbm8tcmVwZWF0J10gfSxcbiAgICAgIGJnRml0OiB7IGVudW1zOiBbJ25vbmUnLCAnY29udGFpbicsICdjb3ZlciddIH0sXG4gICAgICBiZ0NsaXA6IHsgZW51bXM6IFsnbm9uZScsICdub2RlJ10gfSxcbiAgICAgIGNvbG9yOiB7IGNvbG9yOiB0cnVlIH0sXG4gICAgICBsaW5lU3R5bGU6IHsgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCddIH0sXG4gICAgICBib3JkZXJTdHlsZTogeyBlbnVtczogWydzb2xpZCcsICdkb3R0ZWQnLCAnZGFzaGVkJywgJ2RvdWJsZSddIH0sXG4gICAgICBjdXJ2ZVN0eWxlOiB7IGVudW1zOiBbJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJ10gfSxcbiAgICAgIGZvbnRGYW1pbHk6IHsgcmVnZXg6ICdeKFtcXFxcdy0gXFxcXFwiXSsoPzpcXFxccyosXFxcXHMqW1xcXFx3LSBcXFxcXCJdKykqKSQnIH0sXG4gICAgICBmb250VmFyaWFudDogeyBlbnVtczogWydzbWFsbC1jYXBzJywgJ25vcm1hbCddIH0sXG4gICAgICBmb250U3R5bGU6IHsgZW51bXM6IFsnaXRhbGljJywgJ25vcm1hbCcsICdvYmxpcXVlJ10gfSxcbiAgICAgIGZvbnRXZWlnaHQ6IHsgZW51bXM6IFsnbm9ybWFsJywgJ2JvbGQnLCAnYm9sZGVyJywgJ2xpZ2h0ZXInLCAnMTAwJywgJzIwMCcsICczMDAnLCAnNDAwJywgJzUwMCcsICc2MDAnLCAnODAwJywgJzkwMCcsIDEwMCwgMjAwLCAzMDAsIDQwMCwgNTAwLCA2MDAsIDcwMCwgODAwLCA5MDBdIH0sXG4gICAgICB0ZXh0RGVjb3JhdGlvbjogeyBlbnVtczogWydub25lJywgJ3VuZGVybGluZScsICdvdmVybGluZScsICdsaW5lLXRocm91Z2gnXSB9LFxuICAgICAgdGV4dFRyYW5zZm9ybTogeyBlbnVtczogWydub25lJywgJ3VwcGVyY2FzZScsICdsb3dlcmNhc2UnXSB9LFxuICAgICAgdGV4dFdyYXA6IHsgZW51bXM6IFsnbm9uZScsICd3cmFwJ10gfSxcbiAgICAgIHRleHRCYWNrZ3JvdW5kU2hhcGU6IHsgZW51bXM6IFsncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJ119LFxuICAgICAgbm9kZVNoYXBlOiB7IGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScsICdlbGxpcHNlJywgJ3RyaWFuZ2xlJywgJ3NxdWFyZScsICdwZW50YWdvbicsICdoZXhhZ29uJywgJ2hlcHRhZ29uJywgJ29jdGFnb24nLCAnc3RhcicsICdkaWFtb25kJywgJ3ZlZScsICdyaG9tYm9pZCddIH0sXG4gICAgICBjb21wb3VuZEluY2x1ZGVMYWJlbHM6IHsgZW51bXM6IFsnaW5jbHVkZScsICdleGNsdWRlJ10gfSxcbiAgICAgIGFycm93U2hhcGU6IHsgZW51bXM6IFsndGVlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLXRlZScsICd0cmlhbmdsZS1iYWNrY3VydmUnLCAnaGFsZi10cmlhbmdsZS1vdmVyc2hvdCcsICdzcXVhcmUnLCAnY2lyY2xlJywgJ2RpYW1vbmQnLCAnbm9uZSddIH0sXG4gICAgICBhcnJvd0ZpbGw6IHsgZW51bXM6IFsnZmlsbGVkJywgJ2hvbGxvdyddIH0sXG4gICAgICBkaXNwbGF5OiB7IGVudW1zOiBbJ2VsZW1lbnQnLCAnbm9uZSddIH0sXG4gICAgICB2aXNpYmlsaXR5OiB7IGVudW1zOiBbJ2hpZGRlbicsICd2aXNpYmxlJ10gfSxcbiAgICAgIHZhbGlnbjogeyBlbnVtczogWyd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbSddIH0sXG4gICAgICBoYWxpZ246IHsgZW51bXM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSB9LFxuICAgICAgdGV4dDogeyBzdHJpbmc6IHRydWUgfSxcbiAgICAgIGRhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoJ2RhdGEnKSB9LFxuICAgICAgbGF5b3V0RGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogZGF0YSgnbGF5b3V0RGF0YScpIH0sXG4gICAgICBzY3JhdGNoOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBkYXRhKCdzY3JhdGNoJykgfSxcbiAgICAgIG1hcERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoJ21hcERhdGEnKSB9LFxuICAgICAgbWFwTGF5b3V0RGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogbWFwRGF0YSgnbWFwTGF5b3V0RGF0YScpIH0sXG4gICAgICBtYXBTY3JhdGNoOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBtYXBEYXRhKCdtYXBTY3JhdGNoJykgfSxcbiAgICAgIGZuOiB7IG1hcHBpbmc6IHRydWUsIGZuOiB0cnVlIH0sXG4gICAgICB1cmw6IHsgcmVnZXg6ICdedXJsXFxcXHMqXFxcXChcXFxccyooW15cXFxcc10rKVxcXFxzKlxcXFxzKlxcXFwpfG5vbmV8KC4rKSQnIH0sXG4gICAgICBwcm9wTGlzdDogeyBwcm9wTGlzdDogdHJ1ZSB9LFxuICAgICAgYW5nbGU6IHsgbnVtYmVyOiB0cnVlLCB1bml0czogJ2RlZ3xyYWQnIH0sXG4gICAgICB0ZXh0Um90YXRpb246IHsgZW51bXM6IFsnbm9uZScsICdhdXRvcm90YXRlJ10gfVxuICAgIH07XG5cbiAgICAvLyBkZWZpbmUgdmlzdWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgICB2YXIgdCA9ICQkLnN0eWxlLnR5cGVzO1xuICAgIHZhciBwcm9wcyA9ICQkLnN0eWxlLnByb3BlcnRpZXMgPSBbXG4gICAgICAvLyBsYWJlbHNcbiAgICAgIHsgbmFtZTogJ3RleHQtdmFsaWduJywgdHlwZTogdC52YWxpZ24gfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtaGFsaWduJywgdHlwZTogdC5oYWxpZ24gfSxcbiAgICAgIHsgbmFtZTogJ2NvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnY29udGVudCcsIHR5cGU6IHQudGV4dCB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1vdXRsaW5lLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1vdXRsaW5lLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1ib3JkZXItb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1ib3JkZXItY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LWJvcmRlci13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1ib3JkZXItc3R5bGUnLCB0eXBlOiB0LmJvcmRlclN0eWxlIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnLCB0eXBlOiB0LnRleHRCYWNrZ3JvdW5kU2hhcGV9LFxuICAgICAgLy8geyBuYW1lOiAndGV4dC1kZWNvcmF0aW9uJywgdHlwZTogdC50ZXh0RGVjb3JhdGlvbiB9LCAvLyBub3Qgc3VwcG9ydGVkIGluIGNhbnZhc1xuICAgICAgeyBuYW1lOiAndGV4dC10cmFuc2Zvcm0nLCB0eXBlOiB0LnRleHRUcmFuc2Zvcm0gfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtd3JhcCcsIHR5cGU6IHQudGV4dFdyYXAgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtbWF4LXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG5cbiAgICAgIC8vIHsgbmFtZTogJ3RleHQtcm90YXRpb24nLCB0eXBlOiB0LmFuZ2xlIH0sIC8vIFRPRE8gZGlzYWJsZWQgYi9jIHJvdGF0aW9uIGJyZWFrcyBib3VuZGluZyBib3hlc1xuICAgICAgeyBuYW1lOiAnZm9udC1mYW1pbHknLCB0eXBlOiB0LmZvbnRGYW1pbHkgfSxcbiAgICAgIHsgbmFtZTogJ2ZvbnQtc3R5bGUnLCB0eXBlOiB0LmZvbnRTdHlsZSB9LFxuICAgICAgLy8geyBuYW1lOiAnZm9udC12YXJpYW50JywgdHlwZTogdC5mb250VmFyaWFudCB9LCAvLyBub3QgdXNlZnVsXG4gICAgICB7IG5hbWU6ICdmb250LXdlaWdodCcsIHR5cGU6IHQuZm9udFdlaWdodCB9LFxuICAgICAgeyBuYW1lOiAnZm9udC1zaXplJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdtaW4tem9vbWVkLWZvbnQtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnZWRnZS10ZXh0LXJvdGF0aW9uJywgdHlwZTogdC50ZXh0Um90YXRpb24gfSxcblxuICAgICAgLy8gdmlzaWJpbGl0eVxuICAgICAgeyBuYW1lOiAnZGlzcGxheScsIHR5cGU6IHQuZGlzcGxheSB9LFxuICAgICAgeyBuYW1lOiAndmlzaWJpbGl0eScsIHR5cGU6IHQudmlzaWJpbGl0eSB9LFxuICAgICAgeyBuYW1lOiAnb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnei1pbmRleCcsIHR5cGU6IHQubm9uTmVnYXRpdmVJbnQgfSxcblxuICAgICAgLy8gb3ZlcmxheXNcbiAgICAgIHsgbmFtZTogJ292ZXJsYXktcGFkZGluZycsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnb3ZlcmxheS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ292ZXJsYXktb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuXG4gICAgICAvLyBzaGFkb3dzXG4gICAgICB7IG5hbWU6ICdzaGFkb3ctYmx1cicsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnc2hhZG93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnc2hhZG93LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3NoYWRvdy1vZmZzZXQteCcsIHR5cGU6IHQubnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdzaGFkb3ctb2Zmc2V0LXknLCB0eXBlOiB0Lm51bWJlciB9LFxuXG4gICAgICAvLyBsYWJlbCBzaGFkb3dzXG4gICAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1ibHVyJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LW9mZnNldC14JywgdHlwZTogdC5udW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LW9mZnNldC15JywgdHlwZTogdC5udW1iZXIgfSxcblxuICAgICAgLy8gdHJhbnNpdGlvbiBhbmlzXG4gICAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLXByb3BlcnR5JywgdHlwZTogdC5wcm9wTGlzdCB9LFxuICAgICAgeyBuYW1lOiAndHJhbnNpdGlvbi1kdXJhdGlvbicsIHR5cGU6IHQudGltZSB9LFxuICAgICAgeyBuYW1lOiAndHJhbnNpdGlvbi1kZWxheScsIHR5cGU6IHQudGltZSB9LFxuXG4gICAgICAvLyBub2RlIGJvZHlcbiAgICAgIHsgbmFtZTogJ2hlaWdodCcsIHR5cGU6IHQuYXV0b1NpemUgfSxcbiAgICAgIHsgbmFtZTogJ3dpZHRoJywgdHlwZTogdC5hdXRvU2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnc2hhcGUnLCB0eXBlOiB0Lm5vZGVTaGFwZSB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1ibGFja2VuJywgdHlwZTogdC5uT25lT25lTnVtYmVyIH0sXG5cbiAgICAgIC8vIG5vZGUgYm9yZGVyXG4gICAgICB7IG5hbWU6ICdib3JkZXItY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdib3JkZXItb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdib3JkZXItc3R5bGUnLCB0eXBlOiB0LmJvcmRlclN0eWxlIH0sXG5cbiAgICAgIC8vIG5vZGUgYmFja2dyb3VuZCBpbWFnZXNcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UnLCB0eXBlOiB0LnVybCB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCB0eXBlOiB0LmJnUG9zIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCB0eXBlOiB0LmJnUG9zIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXJlcGVhdCcsIHR5cGU6IHQuYmdSZXBlYXQgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtZml0JywgdHlwZTogdC5iZ0ZpdCB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJywgdHlwZTogdC5iZ0NsaXAgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtd2lkdGgnLCB0eXBlOiB0LmJnV0ggfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0JywgdHlwZTogdC5iZ1dIIH0sXG5cbiAgICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgICB7IG5hbWU6ICdwYWRkaW5nLWxlZnQnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ3BhZGRpbmctcmlnaHQnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ3BhZGRpbmctdG9wJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdwYWRkaW5nLWJvdHRvbScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAncG9zaXRpb24nLCB0eXBlOiB0LnBvc2l0aW9uIH0sXG4gICAgICB7IG5hbWU6ICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycsIHR5cGU6IHQuY29tcG91bmRJbmNsdWRlTGFiZWxzIH0sXG5cbiAgICAgIC8vIGVkZ2UgbGluZVxuICAgICAgeyBuYW1lOiAnbGluZS1zdHlsZScsIHR5cGU6IHQubGluZVN0eWxlIH0sXG4gICAgICB7IG5hbWU6ICdsaW5lLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnLCB0eXBlOiB0Lm51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnY29udHJvbC1wb2ludC13ZWlnaHQnLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ2N1cnZlLXN0eWxlJywgdHlwZTogdC5jdXJ2ZVN0eWxlIH0sXG4gICAgICB7IG5hbWU6ICdoYXlzdGFjay1yYWRpdXMnLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcblxuICAgICAgLy8gZWRnZSBhcnJvd3NcbiAgICAgIHsgbmFtZTogJ3NvdXJjZS1hcnJvdy1zaGFwZScsIHR5cGU6IHQuYXJyb3dTaGFwZSB9LFxuICAgICAgeyBuYW1lOiAndGFyZ2V0LWFycm93LXNoYXBlJywgdHlwZTogdC5hcnJvd1NoYXBlIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtc291cmNlLWFycm93LXNoYXBlJywgdHlwZTogdC5hcnJvd1NoYXBlIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtdGFyZ2V0LWFycm93LXNoYXBlJywgdHlwZTogdC5hcnJvd1NoYXBlIH0sXG4gICAgICB7IG5hbWU6ICdzb3VyY2UtYXJyb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICd0YXJnZXQtYXJyb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtc291cmNlLWFycm93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXRhcmdldC1hcnJvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ3NvdXJjZS1hcnJvdy1maWxsJywgdHlwZTogdC5hcnJvd0ZpbGwgfSxcbiAgICAgIHsgbmFtZTogJ3RhcmdldC1hcnJvdy1maWxsJywgdHlwZTogdC5hcnJvd0ZpbGwgfSxcbiAgICAgIHsgbmFtZTogJ21pZC1zb3VyY2UtYXJyb3ctZmlsbCcsIHR5cGU6IHQuYXJyb3dGaWxsIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtdGFyZ2V0LWFycm93LWZpbGwnLCB0eXBlOiB0LmFycm93RmlsbCB9LFxuXG4gICAgICAvLyB0aGVzZSBhcmUganVzdCBmb3IgdGhlIGNvcmVcbiAgICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ2FjdGl2ZS1iZy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ2FjdGl2ZS1iZy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdhY3RpdmUtYmctc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfVxuICAgIF07XG5cbiAgICAvLyBwaWUgYmFja2dyb3VuZHMgZm9yIG5vZGVzXG4gICAgJCQuc3R5bGUucGllQmFja2dyb3VuZE4gPSAxNjsgLy8gYmVjYXVzZSB0aGUgcGllIHByb3BlcnRpZXMgYXJlIG51bWJlcmVkLCBnaXZlIGFjY2VzcyB0byBhIGNvbnN0YW50IE4gKGZvciByZW5kZXJlciB1c2UpXG4gICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtc2l6ZScsIHR5cGU6IHQuYmdTaXplIH0pO1xuICAgIGZvciggdmFyIGkgPSAxOyBpIDw9ICQkLnN0eWxlLnBpZUJhY2tncm91bmROOyBpKysgKXtcbiAgICAgIHByb3BzLnB1c2goeyBuYW1lOiAncGllLScraSsnLWJhY2tncm91bmQtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0pO1xuICAgICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtJytpKyctYmFja2dyb3VuZC1zaXplJywgdHlwZTogdC5wZXJjZW50IH0pO1xuICAgICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtJytpKyctYmFja2dyb3VuZC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0pO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGFjY2VzcyBvZiBwcm9wZXJ0aWVzIGJ5IG5hbWUgKCBlLmcuICQkLnN0eWxlLnByb3BlcnRpZXMuaGVpZ2h0IClcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICBwcm9wc1sgcHJvcC5uYW1lIF0gPSBwcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICAgIH1cbiAgfSkoKTtcblxuICAvLyBhZGRzIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXQgdG8gdGhlIGN1cnJlbnQgc3R5bGVcbiAgJCQuc3R5Zm4uYWRkRGVmYXVsdFN0eWxlc2hlZXQgPSBmdW5jdGlvbigpe1xuICAgIC8vIHRvIGJlIG5pY2UsIHdlIGJ1aWxkIGZvbnQgcmVsYXRlZCBzdHlsZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGNvcmUgY29udGFpbmVyXG4gICAgLy8gc28gdGhhdCBjeXRvc2NhcGUgbWF0Y2hlcyB0aGUgc3R5bGUgb2YgaXRzIGNvbnRhaW5lciBieSBkZWZhdWx0XG4gICAgLy9cbiAgICAvLyB1bmZvcnR1bmF0ZWx5LCB0aGlzIGRvZXNuJ3Qgc2VlbSB3b3JrIGNvbnNpc3RlbnRseSBhbmQgY2FuIGdyYWIgdGhlIGRlZmF1bHQgc3R5bGVzaGVldCB2YWx1ZXNcbiAgICAvLyBpbnN0ZWFkIG9mIHRoZSBkZXZlbG9wZXIncyB2YWx1ZXMgc28gbGV0J3MganVzdCBtYWtlIGl0IGV4cGxpY2l0IGZvciB0aGUgZGV2IGZvciBub3dcbiAgICAvL1xuICAgIC8vIGRlbGF5aW5nIHRoZSByZWFkIG9mIHRoZXNlIHZhbCdzIGlzIG5vdCBhbiBvcHQnbjogdGhhdCB3b3VsZCBkZWxheSBpbml0J2wgbG9hZCB0aW1lXG4gICAgdmFyIGZvbnRGYW1pbHkgPSAnSGVsdmV0aWNhJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2ZvbnQtZmFtaWx5JykgfHwgJ3NhbnMtc2VyaWYnO1xuICAgIHZhciBmb250U3R5bGUgPSAnbm9ybWFsJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2ZvbnQtc3R5bGUnKSB8fCAnbm9ybWFsJztcbiAgICAvLyB2YXIgZm9udFZhcmlhbnQgPSAnbm9ybWFsJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2ZvbnQtdmFyaWFudCcpIHx8ICdub3JtYWwnO1xuICAgIHZhciBmb250V2VpZ2h0ID0gJ25vcm1hbCcgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCdmb250LXdlaWdodCcpIHx8ICdub3JtYWwnO1xuICAgIHZhciBjb2xvciA9ICcjMDAwJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2NvbG9yJykgfHwgJyMwMDAnO1xuICAgIHZhciB0ZXh0VHJhbnNmb3JtID0gJ25vbmUnIHx8IHRoaXMuY29udGFpbmVyUHJvcGVydHlBc1N0cmluZygndGV4dC10cmFuc2Zvcm0nKSB8fCAnbm9uZSc7XG4gICAgdmFyIGZvbnRTaXplID0gMTYgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCdmb250LXNpemUnKSB8fCAxNjtcbiAgICB2YXIgdGV4dE1heFdpZHRoID0gOTk5OSB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ3RleHQtbWF4LXdpZHRoJykgfHwgOTk5OTtcblxuICAgIC8vIGZpbGwgdGhlIHN0eWxlIHdpdGggdGhlIGRlZmF1bHQgc3R5bGVzaGVldFxuICAgIHRoaXNcbiAgICAgIC5zZWxlY3Rvcignbm9kZSwgZWRnZScpIC8vIGNvbW1vbiBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd0ZXh0LXZhbGlnbic6ICd0b3AnLFxuICAgICAgICAgICd0ZXh0LWhhbGlnbic6ICdjZW50ZXInLFxuICAgICAgICAgICdjb2xvcic6IGNvbG9yLFxuICAgICAgICAgICd0ZXh0LW91dGxpbmUtY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ3RleHQtb3V0bGluZS13aWR0aCc6IDAsXG4gICAgICAgICAgJ3RleHQtb3V0bGluZS1vcGFjaXR5JzogMSxcbiAgICAgICAgICAndGV4dC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnLFxuICAgICAgICAgICd0ZXh0LXRyYW5zZm9ybSc6IHRleHRUcmFuc2Zvcm0sXG4gICAgICAgICAgJ3RleHQtd3JhcCc6ICdub25lJyxcbiAgICAgICAgICAndGV4dC1tYXgtd2lkdGgnOiB0ZXh0TWF4V2lkdGgsXG4gICAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgICAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAwLFxuICAgICAgICAgICd0ZXh0LWJvcmRlci1vcGFjaXR5JzogMCxcbiAgICAgICAgICAndGV4dC1ib3JkZXItd2lkdGgnOiAwLFxuICAgICAgICAgICd0ZXh0LWJvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAgICAgJ3RleHQtYm9yZGVyLWNvbG9yJzonIzAwMCcsXG4gICAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6J3JlY3RhbmdsZScsXG4gICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogZm9udEZhbWlseSxcbiAgICAgICAgICAnZm9udC1zdHlsZSc6IGZvbnRTdHlsZSxcbiAgICAgICAgICAvLyAnZm9udC12YXJpYW50JzogZm9udFZhcmlhbnQsXG4gICAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogZm9udFdlaWdodCxcbiAgICAgICAgICAnZm9udC1zaXplJzogZm9udFNpemUsXG4gICAgICAgICAgJ21pbi16b29tZWQtZm9udC1zaXplJzogMCxcbiAgICAgICAgICAnZWRnZS10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICAgICAgICdkaXNwbGF5JzogJ2VsZW1lbnQnLFxuICAgICAgICAgICdvcGFjaXR5JzogMSxcbiAgICAgICAgICAnei1pbmRleCc6IDAsXG4gICAgICAgICAgJ2NvbnRlbnQnOiAnJyxcbiAgICAgICAgICAnb3ZlcmxheS1vcGFjaXR5JzogMCxcbiAgICAgICAgICAnb3ZlcmxheS1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAgICAgJ3NoYWRvdy1vcGFjaXR5JzogMCxcbiAgICAgICAgICAnc2hhZG93LWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAgICdzaGFkb3ctYmx1cic6IDEwLFxuICAgICAgICAgICdzaGFkb3ctb2Zmc2V0LXgnOiAwLFxuICAgICAgICAgICdzaGFkb3ctb2Zmc2V0LXknOiAwLFxuICAgICAgICAgICd0ZXh0LXNoYWRvdy1vcGFjaXR5JzogMCxcbiAgICAgICAgICAndGV4dC1zaGFkb3ctY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ3RleHQtc2hhZG93LWJsdXInOiA1LFxuICAgICAgICAgICd0ZXh0LXNoYWRvdy1vZmZzZXQteCc6IDAsXG4gICAgICAgICAgJ3RleHQtc2hhZG93LW9mZnNldC15JzogMCxcbiAgICAgICAgICAndHJhbnNpdGlvbi1wcm9wZXJ0eSc6ICdub25lJyxcbiAgICAgICAgICAndHJhbnNpdGlvbi1kdXJhdGlvbic6IDAsXG4gICAgICAgICAgJ3RyYW5zaXRpb24tZGVsYXknOiAwLFxuXG4gICAgICAgICAgLy8gbm9kZSBwcm9wc1xuICAgICAgICAgICdiYWNrZ3JvdW5kLWJsYWNrZW4nOiAwLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyM4ODgnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnOiAnNTAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi15JzogJzUwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9kZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnYXV0bycsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJ2F1dG8nLFxuICAgICAgICAgICdib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ2JvcmRlci1vcGFjaXR5JzogMSxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMCxcbiAgICAgICAgICAnYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAgICAgICAnaGVpZ2h0JzogMzAsXG4gICAgICAgICAgJ3dpZHRoJzogMzAsXG4gICAgICAgICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuXG4gICAgICAgICAgLy8gY29tcG91bmQgcHJvcHNcbiAgICAgICAgICAncGFkZGluZy10b3AnOiAwLFxuICAgICAgICAgICdwYWRkaW5nLWJvdHRvbSc6IDAsXG4gICAgICAgICAgJ3BhZGRpbmctbGVmdCc6IDAsXG4gICAgICAgICAgJ3BhZGRpbmctcmlnaHQnOiAwLFxuICAgICAgICAgICdwb3NpdGlvbic6ICdvcmlnaW4nLFxuICAgICAgICAgICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscyc6ICdpbmNsdWRlJyxcblxuXG4gICAgICAgICAgLy8gbm9kZSBwaWUgYmdcbiAgICAgICAgICAncGllLXNpemUnOiAnMTAwJScsXG4gICAgICAgICAgJ3BpZS0xLWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMi1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTMtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS00LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtNS1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTYtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS03LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtOC1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTktYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xMC1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTExLWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTItYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xMy1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTE0LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTUtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xNi1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTEtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTItYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTMtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTQtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTUtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTYtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTctYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTgtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTktYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTEwLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xMS1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMTItYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTEzLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xNC1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMTUtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTE2LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0yLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0zLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS00LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS01LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS02LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS03LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS04LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS05LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xMC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTEtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAncGllLTEyLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xMy1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTQtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAncGllLTE1LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xNi1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuXG4gICAgICAgICAgLy8gZWRnZSBwcm9wc1xuICAgICAgICAgICdzb3VyY2UtYXJyb3ctc2hhcGUnOiAnbm9uZScsXG4gICAgICAgICAgJ21pZC1zb3VyY2UtYXJyb3ctc2hhcGUnOiAnbm9uZScsXG4gICAgICAgICAgJ3RhcmdldC1hcnJvdy1zaGFwZSc6ICdub25lJyxcbiAgICAgICAgICAnbWlkLXRhcmdldC1hcnJvdy1zaGFwZSc6ICdub25lJyxcbiAgICAgICAgICAnc291cmNlLWFycm93LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdtaWQtc291cmNlLWFycm93LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnI2RkZCcsXG4gICAgICAgICAgJ21pZC10YXJnZXQtYXJyb3ctY29sb3InOiAnI2RkZCcsXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1maWxsJzogJ2ZpbGxlZCcsXG4gICAgICAgICAgJ21pZC1zb3VyY2UtYXJyb3ctZmlsbCc6ICdmaWxsZWQnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctZmlsbCc6ICdmaWxsZWQnLFxuICAgICAgICAgICdtaWQtdGFyZ2V0LWFycm93LWZpbGwnOiAnZmlsbGVkJyxcbiAgICAgICAgICAnbGluZS1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAgICAgJ2xpbmUtY29sb3InOiAnI2RkZCcsXG4gICAgICAgICAgJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJzogNDAsXG4gICAgICAgICAgJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0JzogMC41LFxuICAgICAgICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInLFxuICAgICAgICAgICdoYXlzdGFjay1yYWRpdXMnOiAwLjhcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignJG5vZGUgPiBub2RlJykgLy8gY29tcG91bmQgKHBhcmVudCkgbm9kZSBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd3aWR0aCc6ICdhdXRvJyxcbiAgICAgICAgICAnaGVpZ2h0JzogJ2F1dG8nLFxuICAgICAgICAgICdzaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAwLjUsXG4gICAgICAgICAgJ3BhZGRpbmctdG9wJzogMTAsXG4gICAgICAgICAgJ3BhZGRpbmctcmlnaHQnOiAxMCxcbiAgICAgICAgICAncGFkZGluZy1sZWZ0JzogMTAsXG4gICAgICAgICAgJ3BhZGRpbmctYm90dG9tJzogMTBcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignZWRnZScpIC8vIGp1c3QgZWRnZSBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd3aWR0aCc6IDFcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignOmFjdGl2ZScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdvdmVybGF5LWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAgICAgJ292ZXJsYXktb3BhY2l0eSc6IDAuMjVcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignY29yZScpIC8vIGp1c3QgY29yZSBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzZWxlY3Rpb24tYm94LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdzZWxlY3Rpb24tYm94LW9wYWNpdHknOiAwLjY1LFxuICAgICAgICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcic6ICcjYWFhJyxcbiAgICAgICAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnOiAxLFxuICAgICAgICAgICdhY3RpdmUtYmctY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdhY3RpdmUtYmctb3BhY2l0eSc6IDAuMTUsXG4gICAgICAgICAgJ2FjdGl2ZS1iZy1zaXplJzogMzAsXG4gICAgICAgICAgJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknOiAwLjEyNVxuICAgICAgICB9KVxuICAgIDtcblxuICAgIHRoaXMuZGVmYXVsdExlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB9O1xuXG4gIC8vIHJlbW92ZSBhbGwgY29udGV4dHNcbiAgJCQuc3R5Zm4uY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3ByaXZhdGUubmV3U3R5bGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgJCQuc3R5Zm4ucmVzZXRUb0RlZmF1bHQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLmFkZERlZmF1bHRTdHlsZXNoZWV0KCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBidWlsZHMgYSBzdHlsZSBvYmplY3QgZm9yIHRoZSAnY29yZScgc2VsZWN0b3JcbiAgJCQuc3R5Zm4uY29yZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlO1xuICB9O1xuXG4gIC8vIHBhcnNlIGEgcHJvcGVydHk7IHJldHVybiBudWxsIG9uIGludmFsaWQ7IHJldHVybiBwYXJzZWQgcHJvcGVydHkgb3RoZXJ3aXNlXG4gIC8vIGZpZWxkcyA6XG4gIC8vIC0gbmFtZSA6IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAvLyAtIHZhbHVlIDogdGhlIHBhcnNlZCwgbmF0aXZlLXR5cGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAvLyAtIHN0clZhbHVlIDogYSBzdHJpbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpbiB2YWxpZCBjc3NcbiAgLy8gLSBieXBhc3MgOiB0cnVlIGlmZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHlcbiAgJCQuc3R5Zm4ucGFyc2UgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCApe1xuXG4gICAgbmFtZSA9ICQkLnV0aWwuY2FtZWwyZGFzaCggbmFtZSApOyAvLyBtYWtlIHN1cmUgdGhlIHByb3BlcnR5IG5hbWUgaXMgaW4gZGFzaCBmb3JtIChlLmcuICdwcm9wZXJ0eS1uYW1lJyBub3QgJ3Byb3BlcnR5TmFtZScpXG4gICAgdmFyIHByb3BlcnR5ID0gJCQuc3R5bGUucHJvcGVydGllc1sgbmFtZSBdO1xuICAgIHZhciBwYXNzZWRWYWx1ZSA9IHZhbHVlO1xuICAgIHZhciB0eXBlcyA9ICQkLnN0eWxlLnR5cGVzO1xuXG4gICAgaWYoICFwcm9wZXJ0eSApeyByZXR1cm4gbnVsbDsgfSAvLyByZXR1cm4gbnVsbCBvbiBwcm9wZXJ0eSBvZiB1bmtub3duIG5hbWVcbiAgICBpZiggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCApeyByZXR1cm4gbnVsbDsgfSAvLyBjYW4ndCBhc3NpZ24gbnVsbFxuXG4gICAgdmFyIHZhbHVlSXNTdHJpbmcgPSAkJC5pcy5zdHJpbmcodmFsdWUpO1xuICAgIGlmKCB2YWx1ZUlzU3RyaW5nICl7IC8vIHRyaW0gdGhlIHZhbHVlIHRvIG1ha2UgcGFyc2luZyBlYXNpZXJcbiAgICAgIHZhbHVlID0gJCQudXRpbC50cmltKCB2YWx1ZSApO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gcHJvcGVydHkudHlwZTtcbiAgICBpZiggIXR5cGUgKXsgcmV0dXJuIG51bGw7IH0gLy8gbm8gdHlwZSwgbm8gbHVja1xuXG4gICAgLy8gY2hlY2sgaWYgYnlwYXNzIGlzIG51bGwgb3IgZW1wdHkgc3RyaW5nIChpLmUuIGluZGljYXRpb24gdG8gZGVsZXRlIGJ5cGFzcyBwcm9wZXJ0eSlcbiAgICBpZiggcHJvcElzQnlwYXNzICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IG51bGwpICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGJ5cGFzczogdHJ1ZSxcbiAgICAgICAgZGVsZXRlQnlwYXNzOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoYXNQaWUgPSBuYW1lLm1hdGNoKC9waWUtKFxcZCspLWJhY2tncm91bmQtc2l6ZS8pO1xuXG4gICAgLy8gY2hlY2sgaWYgdmFsdWUgaXMgYSBmdW5jdGlvbiB1c2VkIGFzIGEgbWFwcGVyXG4gICAgaWYoICQkLmlzLmZuKHZhbHVlKSApe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBzdHJWYWx1ZTogJ2ZuJyxcbiAgICAgICAgbWFwcGVkOiB0eXBlcy5mbixcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICAgIGhhc1BpZTogaGFzUGllXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHZhbHVlIGlzIG1hcHBlZFxuICAgIHZhciBkYXRhLCBtYXBEYXRhLCBsYXlvdXREYXRhLCBtYXBMYXlvdXREYXRhLCBzY3JhdGNoLCBtYXBTY3JhdGNoO1xuICAgIGlmKCAhdmFsdWVJc1N0cmluZyB8fCBwcm9wSXNGbGF0ICl7XG4gICAgICAvLyB0aGVuIGRvbid0IGJvdGhlciB0byBkbyB0aGUgZXhwZW5zaXZlIHJlZ2V4IGNoZWNrc1xuXG4gICAgfSBlbHNlIGlmKFxuICAgICAgKCBkYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMuZGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICAgKCBsYXlvdXREYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMubGF5b3V0RGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICAgKCBzY3JhdGNoID0gbmV3IFJlZ0V4cCggdHlwZXMuc2NyYXRjaC5yZWdleCApLmV4ZWMoIHZhbHVlICkgKVxuICAgICl7XG4gICAgICBpZiggcHJvcElzQnlwYXNzICl7IHJldHVybiBmYWxzZTsgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG4gICAgICB2YXIgbWFwcGVkO1xuICAgICAgaWYoIGRhdGEgKXtcbiAgICAgICAgbWFwcGVkID0gdHlwZXMuZGF0YTtcbiAgICAgIH0gZWxzZSBpZiggbGF5b3V0RGF0YSApe1xuICAgICAgICBtYXBwZWQgPSB0eXBlcy5sYXlvdXREYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkID0gdHlwZXMuc2NyYXRjaDtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IGRhdGEgfHwgbGF5b3V0RGF0YSB8fCBzY3JhdGNoO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIG1hcHBlZDogbWFwcGVkLFxuICAgICAgICBmaWVsZDogZGF0YVsxXSxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICAgIGhhc1BpZTogaGFzUGllXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmKFxuICAgICAgKCBtYXBEYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMubWFwRGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICAgKCBtYXBMYXlvdXREYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMubWFwTGF5b3V0RGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICAgKCBtYXBTY3JhdGNoID0gbmV3IFJlZ0V4cCggdHlwZXMubWFwU2NyYXRjaC5yZWdleCApLmV4ZWMoIHZhbHVlICkgKVxuICAgICl7XG4gICAgICBpZiggcHJvcElzQnlwYXNzICl7IHJldHVybiBmYWxzZTsgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG4gICAgICB2YXIgbWFwcGVkO1xuICAgICAgaWYoIG1hcERhdGEgKXtcbiAgICAgICAgbWFwcGVkID0gdHlwZXMubWFwRGF0YTtcbiAgICAgIH0gZWxzZSBpZiggbWFwTGF5b3V0RGF0YSApe1xuICAgICAgICBtYXBwZWQgPSB0eXBlcy5tYXBMYXlvdXREYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkID0gdHlwZXMubWFwU2NyYXRjaDtcbiAgICAgIH1cblxuICAgICAgbWFwRGF0YSA9IG1hcERhdGEgfHwgbWFwTGF5b3V0RGF0YSB8fCBtYXBTY3JhdGNoO1xuXG4gICAgICAvLyB3ZSBjYW4gbWFwIG9ubHkgaWYgdGhlIHR5cGUgaXMgYSBjb2xvdXIgb3IgYSBudW1iZXJcbiAgICAgIGlmKCAhKHR5cGUuY29sb3IgfHwgdHlwZS5udW1iZXIpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICB2YXIgdmFsdWVNaW4gPSB0aGlzLnBhcnNlKCBuYW1lLCBtYXBEYXRhWzRdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICAgIGlmKCAhdmFsdWVNaW4gfHwgdmFsdWVNaW4ubWFwcGVkICl7IHJldHVybiBmYWxzZTsgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuXG4gICAgICB2YXIgdmFsdWVNYXggPSB0aGlzLnBhcnNlKCBuYW1lLCBtYXBEYXRhWzVdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICAgIGlmKCAhdmFsdWVNYXggfHwgdmFsdWVNYXgubWFwcGVkICl7IHJldHVybiBmYWxzZTsgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuXG4gICAgICAvLyBjaGVjayBpZiB2YWx1ZU1pbiBhbmQgdmFsdWVNYXggYXJlIHRoZSBzYW1lXG4gICAgICBpZiggdmFsdWVNaW4udmFsdWUgPT09IHZhbHVlTWF4LnZhbHVlICl7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gY2FuJ3QgbWFrZSBtdWNoIG9mIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuXG4gICAgICB9IGVsc2UgaWYoIHR5cGUuY29sb3IgKXtcbiAgICAgICAgdmFyIGMxID0gdmFsdWVNaW4udmFsdWU7XG4gICAgICAgIHZhciBjMiA9IHZhbHVlTWF4LnZhbHVlO1xuXG4gICAgICAgIHZhciBzYW1lID0gYzFbMF0gPT09IGMyWzBdIC8vIHJlZFxuICAgICAgICAgICYmIGMxWzFdID09PSBjMlsxXSAvLyBncmVlblxuICAgICAgICAgICYmIGMxWzJdID09PSBjMlsyXSAvLyBibHVlXG4gICAgICAgICAgJiYgKCAvLyBvcHRpb25hbCBhbHBoYVxuICAgICAgICAgICAgYzFbM10gPT09IGMyWzNdIC8vIHNhbWUgYWxwaGEgb3V0cmlnaHRcbiAgICAgICAgICAgIHx8IChcbiAgICAgICAgICAgICAgKGMxWzNdID09IG51bGwgfHwgYzFbM10gPT09IDEpIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDE/XG4gICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAgIChjMlszXSA9PSBudWxsIHx8IGMyWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAyP1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgO1xuXG4gICAgICAgIGlmKCBzYW1lICl7IHJldHVybiBmYWxzZTsgfSAvLyBjYW4ndCBtYWtlIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIG1hcHBlZDogbWFwcGVkLFxuICAgICAgICBmaWVsZDogbWFwRGF0YVsxXSxcbiAgICAgICAgZmllbGRNaW46IHBhcnNlRmxvYXQoIG1hcERhdGFbMl0gKSwgLy8gbWluICYgbWF4IGFyZSBudW1lcmljXG4gICAgICAgIGZpZWxkTWF4OiBwYXJzZUZsb2F0KCBtYXBEYXRhWzNdICksXG4gICAgICAgIHZhbHVlTWluOiB2YWx1ZU1pbi52YWx1ZSxcbiAgICAgICAgdmFsdWVNYXg6IHZhbHVlTWF4LnZhbHVlLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzcyxcbiAgICAgICAgaGFzUGllOiBoYXNQaWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdGhlIHR5cGUgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0XG4gICAgaWYoIHR5cGUubnVtYmVyICl7XG4gICAgICB2YXIgdW5pdHM7XG4gICAgICB2YXIgaW1wbGljaXRVbml0cyA9ICdweCc7IC8vIG5vdCBzZXQgPT4gcHhcblxuICAgICAgaWYoIHR5cGUudW5pdHMgKXsgLy8gdXNlIHNwZWNpZmllZCB1bml0cyBpZiBzZXRcbiAgICAgICAgdW5pdHMgPSB0eXBlLnVuaXRzO1xuICAgICAgfVxuXG4gICAgICBpZiggdHlwZS5pbXBsaWNpdFVuaXRzICl7XG4gICAgICAgIGltcGxpY2l0VW5pdHMgPSB0eXBlLmltcGxpY2l0VW5pdHM7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhdHlwZS51bml0bGVzcyApe1xuICAgICAgICBpZiggdmFsdWVJc1N0cmluZyApe1xuICAgICAgICAgIHZhciB1bml0c1JlZ2V4ID0gJ3B4fGVtJyArICh0eXBlLmFsbG93UGVyY2VudCA/ICd8XFxcXCUnIDogJycpO1xuICAgICAgICAgIGlmKCB1bml0cyApeyB1bml0c1JlZ2V4ID0gdW5pdHM7IH0gLy8gb25seSBhbGxvdyBleHBsaWNpdCB1bml0cyBpZiBzbyBzZXRcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCggJ14oJyArICQkLnV0aWwucmVnZXgubnVtYmVyICsgJykoJyArIHVuaXRzUmVnZXggKyAnKT8nICsgJyQnICk7XG5cbiAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB1bml0cyA9IG1hdGNoWzJdIHx8IGltcGxpY2l0VW5pdHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiggIXVuaXRzIHx8IHR5cGUuaW1wbGljaXRVbml0cyApIHtcbiAgICAgICAgICB1bml0cyA9IGltcGxpY2l0VW5pdHM7IC8vIGltcGxpY2l0bHkgcHggaWYgdW5zcGVjaWZpZWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG5cbiAgICAgIC8vIGlmIG5vdCBhIG51bWJlciBhbmQgZW51bXMgbm90IGFsbG93ZWQsIHRoZW4gdGhlIHZhbHVlIGlzIGludmFsaWRcbiAgICAgIGlmKCBpc05hTih2YWx1ZSkgJiYgdHlwZS5lbnVtcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiB0aGlzIG51bWJlciB0eXBlIGFsc28gYWNjZXB0cyBzcGVjaWFsIGtleXdvcmRzIGluIHBsYWNlIG9mIG51bWJlcnNcbiAgICAgIC8vIChpLmUuIGBsZWZ0YCwgYGF1dG9gLCBldGMpXG4gICAgICBpZiggaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB2YWx1ZSA9IHBhc3NlZFZhbHVlO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdHlwZS5lbnVtcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbaV07XG5cbiAgICAgICAgICBpZiggZW4gPT09IHZhbHVlICl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDsgLy8gZmFpbGVkIG9uIGVudW0gYWZ0ZXIgZmFpbGluZyBvbiBudW1iZXJcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXG4gICAgICBpZiggdHlwZS5pbnRlZ2VyICYmICEkJC5pcy5pbnRlZ2VyKHZhbHVlKSApe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgdmFsdWUgaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiggKHR5cGUubWluICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCB0eXBlLm1pbilcbiAgICAgIHx8ICh0eXBlLm1heCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gdHlwZS5tYXgpXG4gICAgICApe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSArICh1bml0cyA/IHVuaXRzIDogJycpLFxuICAgICAgICB1bml0czogdW5pdHMsXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgICBoYXNQaWU6IGhhc1BpZSAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAwICYmIHZhbHVlICE9PSAnJ1xuICAgICAgfTtcblxuICAgICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHBpeGVsc1xuICAgICAgaWYoIHR5cGUudW5pdGxlc3MgfHwgKHVuaXRzICE9PSAncHgnICYmIHVuaXRzICE9PSAnZW0nKSApe1xuICAgICAgICAvLyB0aGVuIHB4VmFsdWUgZG9lcyBub3QgYXBwbHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5weFZhbHVlID0gKCB1bml0cyA9PT0gJ3B4JyB8fCAhdW5pdHMgPyAodmFsdWUpIDogKHRoaXMuZ2V0RW1TaXplSW5QaXhlbHMoKSAqIHZhbHVlKSApO1xuICAgICAgfVxuXG4gICAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gbXNcbiAgICAgIGlmKCB1bml0cyA9PT0gJ21zJyB8fCB1bml0cyA9PT0gJ3MnICl7XG4gICAgICAgIHJldC5tc1ZhbHVlID0gdW5pdHMgPT09ICdtcycgPyB2YWx1ZSA6IDEwMDAgKiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcblxuICAgIH0gZWxzZSBpZiggdHlwZS5wcm9wTGlzdCApIHtcblxuICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICB2YXIgcHJvcHNTdHIgPSAnJyArIHZhbHVlO1xuXG4gICAgICBpZiggcHJvcHNTdHIgPT09ICdub25lJyApe1xuICAgICAgICAvLyBsZWF2ZSBlbXB0eVxuXG4gICAgICB9IGVsc2UgeyAvLyBnbyBvdmVyIGVhY2ggcHJvcFxuXG4gICAgICAgIHZhciBwcm9wc1NwbGl0ID0gcHJvcHNTdHIuc3BsaXQoJywnKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wc1NwbGl0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gJCQudXRpbC50cmltKCBwcm9wc1NwbGl0W2ldICk7XG5cbiAgICAgICAgICBpZiggJCQuc3R5bGUucHJvcGVydGllc1twcm9wTmFtZV0gKXtcbiAgICAgICAgICAgIHByb3BzLnB1c2goIHByb3BOYW1lICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiBwcm9wcyxcbiAgICAgICAgc3RyVmFsdWU6IHByb3BzLmxlbmd0aCA9PT0gMCA/ICdub25lJyA6IHByb3BzLmpvaW4oJywgJyksXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgICB2YXIgdHVwbGUgPSAkJC51dGlsLmNvbG9yMnR1cGxlKCB2YWx1ZSApO1xuXG4gICAgICBpZiggIXR1cGxlICl7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB0dXBsZSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmKCB0eXBlLmVudW1zICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHR5cGUuZW51bXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVuID0gdHlwZS5lbnVtc1tpXTtcblxuICAgICAgICBpZiggZW4gPT09IHZhbHVlICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIH0gZWxzZSBpZiggdHlwZS5yZWdleCApe1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCggdHlwZS5yZWdleCApOyAvLyBtYWtlIGEgcmVnZXggZnJvbSB0aGUgdHlwZVxuICAgICAgdmFyIG0gPSByZWdleC5leGVjKCB2YWx1ZSApO1xuXG4gICAgICBpZiggbSApeyAvLyByZWdleCBtYXRjaGVzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogbSxcbiAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHsgLy8gcmVnZXggZG9lc24ndCBtYXRjaFxuICAgICAgICByZXR1cm4gbnVsbDsgLy8gZGlkbid0IG1hdGNoIHRoZSByZWdleCBzbyB0aGUgdmFsdWUgaXMgYm9ndXNcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiggdHlwZS5zdHJpbmcgKXtcbiAgICAgIC8vIGp1c3QgcmV0dXJuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgdHlwZSB3ZSBjYW4gaGFuZGxlXG4gICAgfVxuXG4gIH07XG5cbiAgLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZnJvbSB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yIHN0cmluZyBhbmQgc3dpdGNoIHRvIHRoYXQgY29udGV4dFxuICAkJC5zdHlmbi5zZWxlY3RvciA9IGZ1bmN0aW9uKCBzZWxlY3RvclN0ciApe1xuICAgIC8vICdjb3JlJyBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgZG9lcyBub3QgbmVlZCBhIHNlbGVjdG9yXG4gICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JTdHIgPT09ICdjb3JlJyA/IG51bGwgOiBuZXcgJCQuU2VsZWN0b3IoIHNlbGVjdG9yU3RyICk7XG5cbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7IC8vIG5ldyBjb250ZXh0IG1lYW5zIG5ldyBpbmRleFxuICAgIHRoaXNbaV0gPSB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICBwcm9wZXJ0aWVzOiBbXSxcbiAgICAgIG1hcHBlZFByb3BlcnRpZXM6IFtdLFxuICAgICAgaW5kZXg6IGlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gYWRkIG9uZSBvciBtYW55IGNzcyBydWxlcyB0byB0aGUgY3VycmVudCBjb250ZXh0XG4gICQkLnN0eWZuLmNzcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICBzd2l0Y2goIGFyZ3MubGVuZ3RoICl7XG4gICAgY2FzZSAxOlxuICAgICAgdmFyIG1hcCA9IGFyZ3NbMF07XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBtYXBWYWwgPSBtYXBbIHByb3AubmFtZSBdO1xuXG4gICAgICAgIGlmKCBtYXBWYWwgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIG1hcFZhbCA9IG1hcFsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBtYXBWYWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHRoaXMuY3NzUnVsZSggcHJvcC5uYW1lLCBtYXBWYWwgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICAgIHRoaXMuY3NzUnVsZSggYXJnc1swXSwgYXJnc1sxXSApO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7IC8vIGRvIG5vdGhpbmcgaWYgYXJncyBhcmUgaW52YWxpZFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICAkJC5zdHlmbi5zdHlsZSA9ICQkLnN0eWZuLmNzcztcblxuICAvLyBhZGQgYSBzaW5nbGUgY3NzIHJ1bGUgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuICAkJC5zdHlmbi5jc3NSdWxlID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlICl7XG4gICAgLy8gbmFtZS12YWx1ZSBwYWlyXG4gICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUgKTtcblxuICAgIC8vIGFkZCBwcm9wZXJ0eSB0byBjdXJyZW50IGNvbnRleHQgaWYgdmFsaWRcbiAgICBpZiggcHJvcGVydHkgKXtcbiAgICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goIHByb3BlcnR5ICk7XG4gICAgICB0aGlzW2ldLnByb3BlcnRpZXNbIHByb3BlcnR5Lm5hbWUgXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICAgIGlmKCBwcm9wZXJ0eS5oYXNQaWUgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNQaWUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiggcHJvcGVydHkubWFwcGVkICl7XG4gICAgICAgIHRoaXNbaV0ubWFwcGVkUHJvcGVydGllcy5wdXNoKCBwcm9wZXJ0eSApO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdG8gY29yZSBzdHlsZSBpZiBuZWNlc3NhcnlcbiAgICAgIHZhciBjdXJyZW50U2VsZWN0b3JJc0NvcmUgPSAhdGhpc1tpXS5zZWxlY3RvcjtcbiAgICAgIGlmKCBjdXJyZW50U2VsZWN0b3JJc0NvcmUgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbIHByb3BlcnR5Lm5hbWUgXSA9IHByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gKHBvdGVudGlhbGx5IGV4cGVuc2l2ZSBjYWxjdWxhdGlvbilcbiAgLy8gYXBwbHkgdGhlIHN0eWxlIHRvIHRoZSBlbGVtZW50IGJhc2VkIG9uXG4gIC8vIC0gaXRzIGJ5cGFzc1xuICAvLyAtIHdoYXQgc2VsZWN0b3JzIG1hdGNoIGl0XG4gICQkLnN0eWZuLmFwcGx5ID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiggc2VsZi5fcHJpdmF0ZS5uZXdTdHlsZSApeyAvLyBjbGVhciBzdHlsZSBjYWNoZXNcbiAgICAgIHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyA9IHt9O1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wcm9wRGlmZnMgPSB7fTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpZSA9IDA7IGllIDwgZWxlcy5sZW5ndGg7IGllKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2llXTtcbiAgICAgIHZhciBjeHRNZXRhID0gc2VsZi5nZXRDb250ZXh0TWV0YSggZWxlICk7XG4gICAgICB2YXIgY3h0U3R5bGUgPSBzZWxmLmdldENvbnRleHRTdHlsZSggY3h0TWV0YSApO1xuICAgICAgdmFyIGFwcCA9IHNlbGYuYXBwbHlDb250ZXh0U3R5bGUoIGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUgKTtcblxuICAgICAgc2VsZi51cGRhdGVUcmFuc2l0aW9ucyggZWxlLCBhcHAuZGlmZlByb3BzICk7XG4gICAgICBzZWxmLnVwZGF0ZVN0eWxlSGludHMoIGVsZSApO1xuXG4gICAgfSAvLyBmb3IgZWxlbWVudHNcblxuICAgIHNlbGYuX3ByaXZhdGUubmV3U3R5bGUgPSBmYWxzZTtcbiAgfTtcblxuICAkJC5zdHlmbi5nZXRQcm9wZXJ0aWVzRGlmZiA9IGZ1bmN0aW9uKCBvbGRDeHRLZXksIG5ld0N4dEtleSApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2FjaGUgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzIHx8IHt9O1xuICAgIHZhciBkdWFsQ3h0S2V5ID0gb2xkQ3h0S2V5ICsgJy0nICsgbmV3Q3h0S2V5O1xuICAgIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtkdWFsQ3h0S2V5XTtcblxuICAgIGlmKCBjYWNoZWRWYWwgKXtcbiAgICAgIHJldHVybiBjYWNoZWRWYWw7XG4gICAgfVxuXG4gICAgdmFyIGRpZmZQcm9wcyA9IFtdO1xuICAgIHZhciBhZGRlZFByb3AgPSB7fTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgICB2YXIgb2xkSGFzQ3h0ID0gb2xkQ3h0S2V5W2ldID09PSAndCc7XG4gICAgICB2YXIgbmV3SGFzQ3h0ID0gbmV3Q3h0S2V5W2ldID09PSAndCc7XG4gICAgICB2YXIgY3h0SGFzRGlmZmVkID0gb2xkSGFzQ3h0ICE9PSBuZXdIYXNDeHQ7XG4gICAgICB2YXIgY3h0SGFzTWFwcGVkUHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllcy5sZW5ndGggPiAwO1xuXG4gICAgICBpZiggY3h0SGFzRGlmZmVkIHx8IGN4dEhhc01hcHBlZFByb3BzICl7XG4gICAgICAgIHZhciBwcm9wcztcblxuICAgICAgICBpZiggY3h0SGFzRGlmZmVkICYmIGN4dEhhc01hcHBlZFByb3BzICl7XG4gICAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gc3VmZmljZXMgYi9jIG1hcHBlZFByb3BlcnRpZXMgaXMgYSBzdWJzZXQgb2YgcHJvcGVydGllc1xuICAgICAgICB9IGVsc2UgaWYoIGN4dEhhc0RpZmZlZCApe1xuICAgICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIG5lZWQgdG8gY2hlY2sgdGhlbSBhbGxcbiAgICAgICAgfSBlbHNlIGlmKCBjeHRIYXNNYXBwZWRQcm9wcyApe1xuICAgICAgICAgIHByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXM7IC8vIG9ubHkgbmVlZCB0byBjaGVjayBtYXBwZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuXG4gICAgICAgICAgLy8gaWYgYSBsYXRlciBjb250ZXh0IG92ZXJyaWRlcyB0aGlzIHByb3BlcnR5LCB0aGVuIHRoZSBmYWN0IHRoYXQgdGhpcyBjb250ZXh0IGhhcyBzd2l0Y2hlZC9kaWZmZWQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAvLyAoc2VtaSBleHBlbnNpdmUgY2hlY2sgc2luY2UgaXQgbWFrZXMgdGhpcyBmdW5jdGlvbiBPKG5eMikgb24gY29udGV4dCBsZW5ndGgsIGJ1dCB3b3J0aCBpdCBzaW5jZSBvdmVyYWxsIHJlc3VsdFxuICAgICAgICAgIC8vIGlzIGNhY2hlZClcbiAgICAgICAgICB2YXIgbGF0ZXJDeHRPdmVycmlkZXMgPSBmYWxzZTtcbiAgICAgICAgICBmb3IoIHZhciBrID0gaSArIDE7IGsgPCBzZWxmLmxlbmd0aDsgaysrICl7XG4gICAgICAgICAgICB2YXIgbGF0ZXJDeHQgPSBzZWxmW2tdO1xuICAgICAgICAgICAgdmFyIGhhc0xhdGVyQ3h0ID0gbmV3Q3h0S2V5W2tdID09PSAndCc7XG5cbiAgICAgICAgICAgIGlmKCAhaGFzTGF0ZXJDeHQgKXsgY29udGludWU7IH0gLy8gY2FuJ3Qgb3ZlcnJpZGUgdW5sZXNzIHRoZSBjb250ZXh0IGlzIGFjdGl2ZVxuXG4gICAgICAgICAgICBsYXRlckN4dE92ZXJyaWRlcyA9IGxhdGVyQ3h0LnByb3BlcnRpZXNbIHByb3AubmFtZSBdICE9IG51bGw7XG5cbiAgICAgICAgICAgIGlmKCBsYXRlckN4dE92ZXJyaWRlcyApeyBicmVhazsgfSAvLyBleGl0IGVhcmx5IGFzIGxvbmcgYXMgb25lIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICFhZGRlZFByb3BbbmFtZV0gJiYgIWxhdGVyQ3h0T3ZlcnJpZGVzICl7XG4gICAgICAgICAgICBhZGRlZFByb3BbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgZGlmZlByb3BzLnB1c2goIG5hbWUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZm9yIHByb3BzXG4gICAgICB9IC8vIGlmXG5cbiAgICB9IC8vIGZvciBjb250ZXh0c1xuXG4gICAgY2FjaGVbIGR1YWxDeHRLZXkgXSA9IGRpZmZQcm9wcztcbiAgICByZXR1cm4gZGlmZlByb3BzO1xuICB9O1xuXG4gICQkLnN0eWZuLmdldENvbnRleHRNZXRhID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3h0S2V5ID0gJyc7XG4gICAgdmFyIGRpZmZQcm9wcztcbiAgICB2YXIgcHJldktleSA9IGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSB8fCAnJztcblxuICAgIGlmKCBzZWxmLl9wcml2YXRlLm5ld1N0eWxlICl7XG4gICAgICBwcmV2S2V5ID0gJyc7IC8vIHNpbmNlIHdlIG5lZWQgdG8gYXBwbHkgYWxsIHN0eWxlIGlmIGEgZnJlc2ggc3R5bGVzaGVldFxuICAgIH1cblxuICAgIC8vIGdldCB0aGUgY3h0IGtleVxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGNvbnRleHQgPSBzZWxmW2ldO1xuICAgICAgdmFyIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgPSBjb250ZXh0LnNlbGVjdG9yICYmIGNvbnRleHQuc2VsZWN0b3IubWF0Y2hlcyggZWxlICk7IC8vIE5COiBjb250ZXh0LnNlbGVjdG9yIG1heSBiZSBudWxsIGZvciAnY29yZSdcblxuICAgICAgaWYoIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgKXtcbiAgICAgICAgY3h0S2V5ICs9ICd0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN4dEtleSArPSAnZic7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgY29udGV4dFxuXG4gICAgZGlmZlByb3BzID0gc2VsZi5nZXRQcm9wZXJ0aWVzRGlmZiggcHJldktleSwgY3h0S2V5ICk7XG5cbiAgICBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgPSBjeHRLZXk7XG5cbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBjeHRLZXksXG4gICAgICBkaWZmUHJvcE5hbWVzOiBkaWZmUHJvcHNcbiAgICB9O1xuICB9O1xuXG4gIC8vIGdldHMgYSBjb21wdXRlZCBlbGUgc3R5bGUgb2JqZWN0IGJhc2VkIG9uIG1hdGNoZWQgY29udGV4dHNcbiAgJCQuc3R5Zm4uZ2V0Q29udGV4dFN0eWxlID0gZnVuY3Rpb24oIGN4dE1ldGEgKXtcbiAgICB2YXIgY3h0S2V5ID0gY3h0TWV0YS5rZXk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgfHwge307XG5cbiAgICAvLyBpZiBhbHJlYWR5IGNvbXB1dGVkIHN0eWxlLCByZXR1cm5lZCBjYWNoZWQgY29weVxuICAgIGlmKCBjeHRTdHlsZXNbY3h0S2V5XSApeyByZXR1cm4gY3h0U3R5bGVzW2N4dEtleV07IH1cblxuICAgIHZhciBzdHlsZSA9IHtcbiAgICAgIF9wcml2YXRlOiB7XG4gICAgICAgIGtleTogY3h0S2V5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgICB2YXIgaGFzQ3h0ID0gY3h0S2V5W2ldID09PSAndCc7XG5cbiAgICAgIGlmKCAhaGFzQ3h0ICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY3h0LnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBjeHQucHJvcGVydGllc1tqXTtcbiAgICAgICAgdmFyIHN0eVByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wO1xuXG4gICAgICAgIHN0eVByb3AuY29udGV4dCA9IGN4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjeHRTdHlsZXNbY3h0S2V5XSA9IHN0eWxlO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICAkJC5zdHlmbi5hcHBseUNvbnRleHRTdHlsZSA9IGZ1bmN0aW9uKCBjeHRNZXRhLCBjeHRTdHlsZSwgZWxlICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkaWZmUHJvcHMgPSBjeHRNZXRhLmRpZmZQcm9wTmFtZXM7XG4gICAgdmFyIHJldERpZmZQcm9wcyA9IHt9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkaWZmUHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBkaWZmUHJvcE5hbWUgPSBkaWZmUHJvcHNbaV07XG4gICAgICB2YXIgY3h0UHJvcCA9IGN4dFN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcbiAgICAgIHZhciBlbGVQcm9wID0gZWxlLl9wcml2YXRlLnN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcblxuICAgICAgLy8gc2F2ZSBjeWNsZXMgd2hlbiB0aGUgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG4gICAgICBpZiggIWN4dFByb3AgfHwgZWxlUHJvcCA9PT0gY3h0UHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICB2YXIgcmV0RGlmZlByb3AgPSByZXREaWZmUHJvcHNbIGRpZmZQcm9wTmFtZSBdID0ge1xuICAgICAgICBwcmV2OiBlbGVQcm9wXG4gICAgICB9O1xuXG4gICAgICBzZWxmLmFwcGx5UGFyc2VkUHJvcGVydHkoIGVsZSwgY3h0UHJvcCApO1xuXG4gICAgICByZXREaWZmUHJvcC5uZXh0ID0gZWxlLl9wcml2YXRlLnN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcblxuICAgICAgaWYoIHJldERpZmZQcm9wLm5leHQgJiYgcmV0RGlmZlByb3AubmV4dC5ieXBhc3MgKXtcbiAgICAgICAgcmV0RGlmZlByb3AubmV4dCA9IHJldERpZmZQcm9wLm5leHQuYnlwYXNzZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpZmZQcm9wczogcmV0RGlmZlByb3BzXG4gICAgfTtcbiAgfTtcblxuICAkJC5zdHlmbi51cGRhdGVTdHlsZUhpbnRzID0gZnVuY3Rpb24oZWxlKXtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuXG4gICAgLy8gc2V0IHdoZXRoZXIgaGFzIHBpZSBvciBub3Q7IGZvciBncmVhdGVyIGVmZmljaWVuY3lcbiAgICB2YXIgaGFzUGllID0gZmFsc2U7XG4gICAgaWYoIF9wLmdyb3VwID09PSAnbm9kZXMnICYmIHNlbGYuX3ByaXZhdGUuaGFzUGllICl7XG4gICAgICBmb3IoIHZhciBpID0gMTsgaSA8PSAkJC5zdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrICl7IC8vIDEuLk5cbiAgICAgICAgdmFyIHNpemUgPSBfcC5zdHlsZVsncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnXS52YWx1ZTtcblxuICAgICAgICBpZiggc2l6ZSA+IDAgKXtcbiAgICAgICAgICBoYXNQaWUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3AuaGFzUGllID0gaGFzUGllO1xuXG4gICAgdmFyIHRyYW5zZm9ybSA9IHN0eWxlWyd0ZXh0LXRyYW5zZm9ybSddLnN0clZhbHVlO1xuICAgIHZhciBjb250ZW50ID0gc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcbiAgICB2YXIgZlN0eWxlID0gc3R5bGVbJ2ZvbnQtc3R5bGUnXS5zdHJWYWx1ZTtcbiAgICB2YXIgc2l6ZSA9IHN0eWxlWydmb250LXNpemUnXS5weFZhbHVlICsgJ3B4JztcbiAgICB2YXIgZmFtaWx5ID0gc3R5bGVbJ2ZvbnQtZmFtaWx5J10uc3RyVmFsdWU7XG4gICAgLy8gdmFyIHZhcmlhbnQgPSBzdHlsZVsnZm9udC12YXJpYW50J10uc3RyVmFsdWU7XG4gICAgdmFyIHdlaWdodCA9IHN0eWxlWydmb250LXdlaWdodCddLnN0clZhbHVlO1xuICAgIHZhciB2YWxpZ24gPSBzdHlsZVsndGV4dC12YWxpZ24nXS5zdHJWYWx1ZTtcbiAgICB2YXIgaGFsaWduID0gc3R5bGVbJ3RleHQtdmFsaWduJ10uc3RyVmFsdWU7XG4gICAgdmFyIG9XaWR0aCA9IHN0eWxlWyd0ZXh0LW91dGxpbmUtd2lkdGgnXS5weFZhbHVlO1xuICAgIHZhciB3cmFwID0gc3R5bGVbJ3RleHQtd3JhcCddLnN0clZhbHVlO1xuICAgIHZhciB3cmFwVyA9IHN0eWxlWyd0ZXh0LW1heC13aWR0aCddLnB4VmFsdWU7XG4gICAgX3AubGFiZWxLZXkgPSBmU3R5bGUgKyckJysgc2l6ZSArJyQnKyBmYW1pbHkgKyckJysgd2VpZ2h0ICsnJCcrIGNvbnRlbnQgKyckJysgdHJhbnNmb3JtICsnJCcrIHZhbGlnbiArJyQnKyBoYWxpZ24gKyckJysgb1dpZHRoICsgJyQnICsgd3JhcCArICckJyArIHdyYXBXO1xuICAgIF9wLmZvbnRLZXkgPSBmU3R5bGUgKyckJysgd2VpZ2h0ICsnJCcrIHNpemUgKyckJysgZmFtaWx5O1xuXG4gICAgdmFyIHdpZHRoID0gc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZTtcbiAgICB2YXIgaGVpZ2h0ID0gc3R5bGVbJ2hlaWdodCddLnB4VmFsdWU7XG4gICAgdmFyIGJvcmRlclcgPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcbiAgICBfcC5ib3VuZGluZ0JveEtleSA9IHdpZHRoICsnJCcrIGhlaWdodCArJyQnKyBib3JkZXJXO1xuXG4gICAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ2VkZ2VzJyApe1xuICAgICAgdmFyIGNwc3MgPSBzdHlsZVsnY29udHJvbC1wb2ludC1zdGVwLXNpemUnXS5weFZhbHVlO1xuICAgICAgdmFyIGNwZCA9IHN0eWxlWydjb250cm9sLXBvaW50LWRpc3RhbmNlJ10gPyBzdHlsZVsnY29udHJvbC1wb2ludC1kaXN0YW5jZSddLnB4VmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY3B3ID0gc3R5bGVbJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0J10udmFsdWU7XG4gICAgICB2YXIgY3VydmUgPSBzdHlsZVsnY3VydmUtc3R5bGUnXS5zdHJWYWx1ZTtcblxuICAgICAgX3AuYm91bmRpbmdCb3hLZXkgKz0gJyQnKyBjcHNzICsnJCcrIGNwZCArJyQnKyBjcHcgKyckJysgY3VydmU7XG4gICAgfVxuXG4gICAgX3Auc3R5bGVLZXkgPSBEYXRlLm5vdygpOyAvLyBwcm9iYWJseSBzYWZlIHRvIHVzZSBhcHBsaWVkIHRpbWUgYW5kIG11Y2ggZmFzdGVyXG4gICAgLy8gZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgLy8gICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgLy8gICB2YXIgZWxlUHJvcCA9IF9wLnN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAvLyAgIHZhciB2YWwgPSBlbGVQcm9wICYmIGVsZVByb3Auc3RyVmFsdWUgPyBlbGVQcm9wLnN0clZhbHVlIDogJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyAgIF9wLnN0eWxlS2V5ICs9ICckJyArIHZhbDtcbiAgICAvLyB9XG4gIH07XG5cbiAgLy8gYXBwbHkgYSBwcm9wZXJ0eSB0byB0aGUgc3R5bGUgKGZvciBpbnRlcm5hbCB1c2UpXG4gIC8vIHJldHVybnMgd2hldGhlciBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAvL1xuICAvLyBub3csIHRoaXMgZnVuY3Rpb24gZmxhdHRlbnMgdGhlIHByb3BlcnR5LCBhbmQgaGVyZSdzIGhvdzpcbiAgLy9cbiAgLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUsIGRlbGV0ZUJ5cGFzczogdHJ1ZSB9XG4gIC8vIG5vIHByb3BlcnR5IGlzIGdlbmVyYXRlZCwgaW5zdGVhZCB0aGUgYnlwYXNzIHByb3BlcnR5IGluIHRoZVxuICAvLyBlbGVtZW50J3Mgc3R5bGUgaXMgcmVwbGFjZWQgYnkgd2hhdCdzIHBvaW50ZWQgdG8gYnkgdGhlIGBieXBhc3NlZGBcbiAgLy8gZmllbGQgaW4gdGhlIGJ5cGFzcyBwcm9wZXJ0eSAoaS5lLiByZXN0b3JpbmcgdGhlIHByb3BlcnR5IHRoZVxuICAvLyBieXBhc3Mgd2FzIG92ZXJyaWRpbmcpXG4gIC8vXG4gIC8vIGZvciBwYXJzZWRQcm9wOnsgbWFwcGVkOiB0cnV0aHkgfVxuICAvLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBtYXBwaW5nOiBwcm9wIH1cbiAgLy9cbiAgLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUgfVxuICAvLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBieXBhc3NlZDogcGFyc2VkUHJvcCB9XG4gICQkLnN0eWZuLmFwcGx5UGFyc2VkUHJvcGVydHkgPSBmdW5jdGlvbiggZWxlLCBwYXJzZWRQcm9wICl7XG4gICAgdmFyIHByb3AgPSBwYXJzZWRQcm9wO1xuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgZmllbGRWYWwsIGZsYXRQcm9wO1xuICAgIHZhciB0eXBlcyA9ICQkLnN0eWxlLnR5cGVzO1xuICAgIHZhciB0eXBlID0gJCQuc3R5bGUucHJvcGVydGllc1sgcHJvcC5uYW1lIF0udHlwZTtcbiAgICB2YXIgcHJvcElzQnlwYXNzID0gcHJvcC5ieXBhc3M7XG4gICAgdmFyIG9yaWdQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgIHZhciBvcmlnUHJvcElzQnlwYXNzID0gb3JpZ1Byb3AgJiYgb3JpZ1Byb3AuYnlwYXNzO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgIC8vIGNhbid0IGFwcGx5IGF1dG8gdG8gd2lkdGggb3IgaGVpZ2h0IHVubGVzcyBpdCdzIGEgcGFyZW50IG5vZGVcbiAgICBpZiggKHBhcnNlZFByb3AubmFtZSA9PT0gJ2hlaWdodCcgfHwgcGFyc2VkUHJvcC5uYW1lID09PSAnd2lkdGgnKSAmJiBlbGUuaXNOb2RlKCkgKXtcbiAgICAgIGlmKCBwYXJzZWRQcm9wLnZhbHVlID09PSAnYXV0bycgJiYgIWVsZS5pc1BhcmVudCgpICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiggcGFyc2VkUHJvcC52YWx1ZSAhPT0gJ2F1dG8nICYmIGVsZS5pc1BhcmVudCgpICl7XG4gICAgICAgIHByb3AgPSBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZSggcGFyc2VkUHJvcC5uYW1lLCAnYXV0bycsIHByb3BJc0J5cGFzcyApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGJ5cGFzc1xuICAgIGlmKCBwcm9wSXNCeXBhc3MgJiYgcHJvcC5kZWxldGVCeXBhc3MgKXsgLy8gdGhlbiB0aGlzIHByb3BlcnR5IGlzIGp1c3QgaGVyZSB0byBpbmRpY2F0ZSB3ZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgdmFyIGN1cnJlbnRQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuXG4gICAgICAvLyBjYW4gb25seSBkZWxldGUgaWYgdGhlIGN1cnJlbnQgcHJvcCBpcyBhIGJ5cGFzcyBhbmQgaXQgcG9pbnRzIHRvIHRoZSBwcm9wZXJ0eSBpdCB3YXMgb3ZlcnJpZGluZ1xuICAgICAgaWYoICFjdXJyZW50UHJvcCApe1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gcHJvcGVydHkgaXMgYWxyZWFkeSBub3QgZGVmaW5lZFxuICAgICAgfSBlbHNlIGlmKCBjdXJyZW50UHJvcC5ieXBhc3MgJiYgY3VycmVudFByb3AuYnlwYXNzZWQgKXsgLy8gdGhlbiByZXBsYWNlIHRoZSBieXBhc3MgcHJvcGVydHkgd2l0aCB0aGUgb3JpZ2luYWxcblxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBieXBhc3NlZCBwcm9wZXJ0eSB3YXMgYWxyZWFkeSBhcHBsaWVkIChhbmQgdGhlcmVmb3JlIHBhcnNlZCksIHdlIGNhbiBqdXN0IHJlcGxhY2UgaXQgKG5vIHJlYXBwbHlpbmcgbmVjZXNzYXJ5KVxuICAgICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBjdXJyZW50UHJvcC5ieXBhc3NlZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJpbnRNYXBwaW5nRXJyID0gZnVuY3Rpb24oKXtcbiAgICAgICQkLnV0aWwuZXJyb3IoJ0RvIG5vdCBhc3NpZ24gbWFwcGluZ3MgdG8gZWxlbWVudHMgd2l0aG91dCBjb3JyZXNwb25kaW5nIGRhdGEgKGUuZy4gZWxlIGAnKyBlbGUuaWQoKSArJ2AgZm9yIHByb3BlcnR5IGAnKyBwcm9wLm5hbWUgKydgIHdpdGggZGF0YSBmaWVsZCBgJysgcHJvcC5maWVsZCArJ2ApOyB0cnkgYSBgWycrIHByb3AuZmllbGQgKyddYCBzZWxlY3RvciB0byBsaW1pdCBzY29wZSB0byBlbGVtZW50cyB3aXRoIGAnKyBwcm9wLmZpZWxkICsnYCBkZWZpbmVkJyk7XG4gICAgfTtcblxuICAgIC8vIHB1dCB0aGUgcHJvcGVydHkgaW4gdGhlIHN0eWxlIG9iamVjdHNcbiAgICBzd2l0Y2goIHByb3AubWFwcGVkICl7IC8vIGZsYXR0ZW4gdGhlIHByb3BlcnR5IGlmIG1hcHBlZFxuICAgIGNhc2UgdHlwZXMubWFwRGF0YTpcbiAgICBjYXNlIHR5cGVzLm1hcExheW91dERhdGE6XG4gICAgY2FzZSB0eXBlcy5tYXBTY3JhdGNoOlxuXG4gICAgICB2YXIgaXNMYXlvdXQgPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMubWFwTGF5b3V0RGF0YTtcbiAgICAgIHZhciBpc1NjcmF0Y2ggPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMubWFwU2NyYXRjaDtcblxuICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgdmFyIGZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoXCIuXCIpO1xuICAgICAgdmFyIGZpZWxkVmFsO1xuXG4gICAgICBpZiggaXNTY3JhdGNoIHx8IGlzTGF5b3V0ICl7XG4gICAgICAgIGZpZWxkVmFsID0gX3Auc2NyYXRjaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpZWxkVmFsID0gX3AuZGF0YTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoICYmIGZpZWxkVmFsOyBpKysgKXtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICBmaWVsZFZhbCA9IGZpZWxkVmFsWyBmaWVsZCBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGVyY2VudDtcbiAgICAgIGlmKCAhJCQuaXMubnVtYmVyKGZpZWxkVmFsKSApeyAvLyB0aGVuIGtlZXAgdGhlIG1hcHBpbmcgYnV0IGFzc3VtZSAwJSBmb3Igbm93XG4gICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVyY2VudCA9IChmaWVsZFZhbCAtIHByb3AuZmllbGRNaW4pIC8gKHByb3AuZmllbGRNYXggLSBwcm9wLmZpZWxkTWluKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRvIGJvdW5kIHBlcmNlbnQgdmFsdWVcbiAgICAgIGlmKCBwZXJjZW50IDwgMCApe1xuICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgIH0gZWxzZSBpZiggcGVyY2VudCA+IDEgKXtcbiAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgICAgIHZhciByMSA9IHByb3AudmFsdWVNaW5bMF07XG4gICAgICAgIHZhciByMiA9IHByb3AudmFsdWVNYXhbMF07XG4gICAgICAgIHZhciBnMSA9IHByb3AudmFsdWVNaW5bMV07XG4gICAgICAgIHZhciBnMiA9IHByb3AudmFsdWVNYXhbMV07XG4gICAgICAgIHZhciBiMSA9IHByb3AudmFsdWVNaW5bMl07XG4gICAgICAgIHZhciBiMiA9IHByb3AudmFsdWVNYXhbMl07XG4gICAgICAgIHZhciBhMSA9IHByb3AudmFsdWVNaW5bM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWluWzNdO1xuICAgICAgICB2YXIgYTIgPSBwcm9wLnZhbHVlTWF4WzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1heFszXTtcblxuICAgICAgICB2YXIgY2xyID0gW1xuICAgICAgICAgIE1hdGgucm91bmQoIHIxICsgKHIyIC0gcjEpKnBlcmNlbnQgKSxcbiAgICAgICAgICBNYXRoLnJvdW5kKCBnMSArIChnMiAtIGcxKSpwZXJjZW50ICksXG4gICAgICAgICAgTWF0aC5yb3VuZCggYjEgKyAoYjIgLSBiMSkqcGVyY2VudCApLFxuICAgICAgICAgIE1hdGgucm91bmQoIGExICsgKGEyIC0gYTEpKnBlcmNlbnQgKVxuICAgICAgICBdO1xuXG4gICAgICAgIGZsYXRQcm9wID0geyAvLyBjb2xvdXJzIGFyZSBzaW1wbGUsIHNvIGp1c3QgY3JlYXRlIHRoZSBmbGF0IHByb3BlcnR5IGluc3RlYWQgb2YgZXhwZW5zaXZlIHN0cmluZyBwYXJzaW5nXG4gICAgICAgICAgYnlwYXNzOiBwcm9wLmJ5cGFzcywgLy8gd2UncmUgYSBieXBhc3MgaWYgdGhlIG1hcHBpbmcgcHJvcGVydHkgaXMgYSBieXBhc3NcbiAgICAgICAgICBuYW1lOiBwcm9wLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IGNscixcbiAgICAgICAgICBzdHJWYWx1ZTogJ3JnYignICsgY2xyWzBdICsgJywgJyArIGNsclsxXSArICcsICcgKyBjbHJbMl0gKyAnKSdcbiAgICAgICAgfTtcblxuICAgICAgfSBlbHNlIGlmKCB0eXBlLm51bWJlciApe1xuICAgICAgICB2YXIgY2FsY1ZhbHVlID0gcHJvcC52YWx1ZU1pbiArIChwcm9wLnZhbHVlTWF4IC0gcHJvcC52YWx1ZU1pbikgKiBwZXJjZW50O1xuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgY2FsY1ZhbHVlLCBwcm9wLmJ5cGFzcywgdHJ1ZSApO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbiBvbmx5IG1hcCB0byBjb2xvdXJzIGFuZCBudW1iZXJzXG4gICAgICB9XG5cbiAgICAgIGlmKCAhZmxhdFByb3AgKXsgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gdXNlIHRoZSBvcmlnUHJvcCBzbyB3ZSBzdGlsbCBrZWVwIHRoZSBtYXBwaW5nIGl0c2VsZlxuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgb3JpZ1Byb3Auc3RyVmFsdWUsIHByb3AuYnlwYXNzLCB0cnVlICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhZmxhdFByb3AgKXsgcHJpbnRNYXBwaW5nRXJyKCk7IH1cbiAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gZGlyZWN0IG1hcHBpbmdcbiAgICBjYXNlIHR5cGVzLmRhdGE6XG4gICAgY2FzZSB0eXBlcy5sYXlvdXREYXRhOlxuICAgIGNhc2UgdHlwZXMuc2NyYXRjaDpcbiAgICAgIHZhciBpc0xheW91dCA9IHByb3AubWFwcGVkID09PSB0eXBlcy5sYXlvdXREYXRhO1xuICAgICAgdmFyIGlzU2NyYXRjaCA9IHByb3AubWFwcGVkID09PSB0eXBlcy5zY3JhdGNoO1xuXG4gICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdChcIi5cIik7XG4gICAgICB2YXIgZmllbGRWYWw7XG5cbiAgICAgIGlmKCBpc1NjcmF0Y2ggfHwgaXNMYXlvdXQgKXtcbiAgICAgICAgZmllbGRWYWwgPSBfcC5zY3JhdGNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmllbGRWYWwgPSBfcC5kYXRhO1xuICAgICAgfVxuXG4gICAgICBpZiggZmllbGRWYWwgKXsgZm9yKCB2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICBmaWVsZFZhbCA9IGZpZWxkVmFsWyBmaWVsZCBdO1xuICAgICAgfSB9XG5cbiAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBmaWVsZFZhbCwgcHJvcC5ieXBhc3MsIHRydWUgKTtcblxuICAgICAgaWYoICFmbGF0UHJvcCApeyAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiB1c2UgdGhlIG9yaWdQcm9wIHNvIHdlIHN0aWxsIGtlZXAgdGhlIG1hcHBpbmcgaXRzZWxmXG4gICAgICAgIHZhciBmbGF0UHJvcFZhbCA9IG9yaWdQcm9wID8gb3JpZ1Byb3Auc3RyVmFsdWUgOiAnJztcblxuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgZmxhdFByb3BWYWwsIHByb3AuYnlwYXNzLCB0cnVlICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhZmxhdFByb3AgKXsgcHJpbnRNYXBwaW5nRXJyKCk7IH1cbiAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSB0eXBlcy5mbjpcbiAgICAgIHZhciBmbiA9IHByb3AudmFsdWU7XG4gICAgICB2YXIgZm5SZXRWYWwgPSBmbiggZWxlICk7XG5cbiAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBmblJldFZhbCwgcHJvcC5ieXBhc3MsIHRydWUgKTtcbiAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBicmVhazsgLy8ganVzdCBzZXQgdGhlIHByb3BlcnR5XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBub3QgYSB2YWxpZCBtYXBwaW5nXG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5LCB0aGVuIGxpbmsgdGhlIHJlc3VsdGFudCBwcm9wZXJ0eSB0byB0aGUgb3JpZ2luYWwgb25lXG4gICAgaWYoIHByb3BJc0J5cGFzcyApe1xuICAgICAgaWYoIG9yaWdQcm9wSXNCeXBhc3MgKXsgLy8gdGhlbiB0aGlzIGJ5cGFzcyBvdmVycmlkZXMgdGhlIGV4aXN0aW5nIG9uZVxuICAgICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3AuYnlwYXNzZWQ7IC8vIHN0ZWFsIGJ5cGFzc2VkIHByb3AgZnJvbSBvbGQgYnlwYXNzXG4gICAgICB9IGVsc2UgeyAvLyB0aGVuIGxpbmsgdGhlIG9yaWcgcHJvcCB0byB0aGUgbmV3IGJ5cGFzc1xuICAgICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3A7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlWyBwcm9wLm5hbWUgXSA9IHByb3A7IC8vIGFuZCBzZXRcblxuICAgIH0gZWxzZSB7IC8vIHByb3AgaXMgbm90IGJ5cGFzc1xuICAgICAgaWYoIG9yaWdQcm9wSXNCeXBhc3MgKXsgLy8gdGhlbiBrZWVwIHRoZSBvcmlnIHByb3AgKHNpbmNlIGl0J3MgYSBieXBhc3MpIGFuZCBsaW5rIHRvIHRoZSBuZXcgcHJvcFxuICAgICAgICBvcmlnUHJvcC5ieXBhc3NlZCA9IHByb3A7XG4gICAgICB9IGVsc2UgeyAvLyB0aGVuIGp1c3QgcmVwbGFjZSB0aGUgb2xkIHByb3Agd2l0aCB0aGUgbmV3IG9uZVxuICAgICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIHVwZGF0ZXMgdGhlIHZpc3VhbCBzdHlsZSBmb3IgYWxsIGVsZW1lbnRzICh1c2VmdWwgZm9yIG1hbnVhbCBzdHlsZSBtb2RpZmljYXRpb24gYWZ0ZXIgaW5pdClcbiAgJCQuc3R5Zm4udXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBlbGVzID0gY3kuZWxlbWVudHMoKTtcblxuICAgIGVsZXMudXBkYXRlU3R5bGUoKTtcbiAgfTtcblxuICAvLyBqdXN0IHVwZGF0ZSB0aGUgZnVuY3Rpb25hbCBwcm9wZXJ0aWVzIChpLmUuIG1hcHBpbmdzKSBpbiB0aGUgZWxlbWVudHMnXG4gIC8vIHN0eWxlcyAobGVzcyBleHBlbnNpdmUgdGhhbiByZWNhbGN1bGF0aW9uKVxuICAkJC5zdHlmbi51cGRhdGVNYXBwZXJzID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXsgLy8gZm9yIGVhY2ggZWxlXG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrICl7IC8vIGZvciBlYWNoIHByb3BcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2pdO1xuICAgICAgICB2YXIgcHJvcEluU3R5bGUgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG5cbiAgICAgICAgaWYoIHByb3BJblN0eWxlICYmIHByb3BJblN0eWxlLm1hcHBpbmcgKXtcbiAgICAgICAgICB2YXIgbWFwcGluZyA9IHByb3BJblN0eWxlLm1hcHBpbmc7XG4gICAgICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIG1hcHBpbmcgKTsgLy8gcmVhcHBseSB0aGUgbWFwcGluZyBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyggZWxlICk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGRpZmZQcm9wcyA6IHsgbmFtZSA9PiB7IHByZXYsIG5leHQgfSB9XG4gICQkLnN0eWZuLnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICB2YXIgcHJvcHMgPSBzdHlsZVsndHJhbnNpdGlvbi1wcm9wZXJ0eSddLnZhbHVlO1xuICAgIHZhciBkdXJhdGlvbiA9IHN0eWxlWyd0cmFuc2l0aW9uLWR1cmF0aW9uJ10ubXNWYWx1ZTtcbiAgICB2YXIgZGVsYXkgPSBzdHlsZVsndHJhbnNpdGlvbi1kZWxheSddLm1zVmFsdWU7XG4gICAgdmFyIGNzcyA9IHt9O1xuXG4gICAgaWYoIHByb3BzLmxlbmd0aCA+IDAgJiYgZHVyYXRpb24gPiAwICl7XG5cbiAgICAgIC8vIGJ1aWxkIHVwIHRoZSBzdHlsZSB0byBhbmltYXRlIHRvd2FyZHNcbiAgICAgIHZhciBhbnlQcmV2ID0gZmFsc2U7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIHZhciBzdHlQcm9wID0gc3R5bGVbIHByb3AgXTtcbiAgICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wIF07XG5cbiAgICAgICAgaWYoICFkaWZmUHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBwcmV2UHJvcCA9IGRpZmZQcm9wLnByZXY7XG4gICAgICAgIHZhciBmcm9tUHJvcCA9IHByZXZQcm9wO1xuICAgICAgICB2YXIgdG9Qcm9wID0gZGlmZlByb3AubmV4dCAhPSBudWxsID8gZGlmZlByb3AubmV4dCA6IHN0eVByb3A7XG4gICAgICAgIHZhciBkaWZmID0gZmFsc2U7XG5cbiAgICAgICAgaWYoICFmcm9tUHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIC8vIGNvbnNpZGVyIHB4IHZhbHVlc1xuICAgICAgICBpZiggJCQuaXMubnVtYmVyKCBmcm9tUHJvcC5weFZhbHVlICkgJiYgJCQuaXMubnVtYmVyKCB0b1Byb3AucHhWYWx1ZSApICl7XG4gICAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnB4VmFsdWUgIT09IHRvUHJvcC5weFZhbHVlO1xuXG4gICAgICAgIC8vIGNvbnNpZGVyIG51bWVyaWNhbCB2YWx1ZXNcbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIoIGZyb21Qcm9wLnZhbHVlICkgJiYgJCQuaXMubnVtYmVyKCB0b1Byb3AudmFsdWUgKSApe1xuICAgICAgICAgIGRpZmYgPSBmcm9tUHJvcC52YWx1ZSAhPT0gdG9Qcm9wLnZhbHVlO1xuXG4gICAgICAgIC8vIGNvbnNpZGVyIGNvbG91ciB2YWx1ZXNcbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5hcnJheSggZnJvbVByb3AudmFsdWUgKSAmJiAkJC5pcy5hcnJheSggdG9Qcm9wLnZhbHVlICkgKXtcbiAgICAgICAgICBkaWZmID0gZnJvbVByb3AudmFsdWVbMF0gIT09IHRvUHJvcC52YWx1ZVswXVxuICAgICAgICAgICAgfHwgZnJvbVByb3AudmFsdWVbMV0gIT09IHRvUHJvcC52YWx1ZVsxXVxuICAgICAgICAgICAgfHwgZnJvbVByb3AudmFsdWVbMl0gIT09IHRvUHJvcC52YWx1ZVsyXVxuICAgICAgICAgIDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyB2YWx1ZSBpcyBnb29kIGZvciBhbiBhbmltYXRpb24gb25seSBpZiBpdCdzIGRpZmZlcmVudFxuICAgICAgICBpZiggZGlmZiApe1xuICAgICAgICAgIGNzc1sgcHJvcCBdID0gdG9Qcm9wLnN0clZhbHVlOyAvLyB0byB2YWxcbiAgICAgICAgICB0aGlzLmFwcGx5QnlwYXNzKGVsZSwgcHJvcCwgZnJvbVByb3Auc3RyVmFsdWUpOyAvLyBmcm9tIHZhbFxuICAgICAgICAgIGFueVByZXYgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIH0gLy8gZW5kIGlmIHByb3BzIGFsbG93IGFuaVxuXG4gICAgICAvLyBjYW4ndCB0cmFuc2l0aW9uIGlmIHRoZXJlJ3Mgbm90aGluZyBwcmV2aW91cyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICAgIGlmKCAhYW55UHJldiApeyByZXR1cm47IH1cblxuICAgICAgZWxlLl9wcml2YXRlLnRyYW5zaXRpb25pbmcgPSB0cnVlO1xuXG4gICAgICBlbGUuc3RvcCgpO1xuXG4gICAgICBpZiggZGVsYXkgPiAwICl7XG4gICAgICAgIGVsZS5kZWxheSggZGVsYXkgKTtcbiAgICAgIH1cblxuICAgICAgZWxlLmFuaW1hdGUoe1xuICAgICAgICBjc3M6IGNzc1xuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgaWYoICFpc0J5cGFzcyApe1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVCeXBhc3NlcyggZWxlLCBwcm9wcyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZS5fcHJpdmF0ZS50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmKCBlbGUuX3ByaXZhdGUudHJhbnNpdGlvbmluZyApe1xuICAgICAgZWxlLnN0b3AoKTtcblxuICAgICAgdGhpcy5yZW1vdmVCeXBhc3NlcyggZWxlLCBwcm9wcyApO1xuXG4gICAgICBlbGUuX3ByaXZhdGUudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGJ5cGFzc2VzIGFyZSBhcHBsaWVkIHRvIGFuIGV4aXN0aW5nIHN0eWxlIG9uIGFuIGVsZW1lbnQsIGFuZCBqdXN0IHRhY2tlZCBvbiB0ZW1wb3JhcmlseVxuICAvLyByZXR1cm5zIHRydWUgaWZmIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsIGZvciBhdCBsZWFzdCAxIHNwZWNpZmllZCBwcm9wZXJ0eVxuICAkJC5zdHlmbi5hcHBseUJ5cGFzcyA9IGZ1bmN0aW9uKCBlbGVzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuICAgIFxuICAgIC8vIHB1dCBhbGwgdGhlIHByb3BlcnRpZXMgKGNhbiBzcGVjaWZ5IG9uZSBvciBtYW55KSBpbiBhbiBhcnJheSBhZnRlciBwYXJzaW5nIHRoZW1cbiAgICBpZiggbmFtZSA9PT0gXCIqXCIgfHwgbmFtZSA9PT0gXCIqKlwiICl7IC8vIGFwcGx5IHRvIGFsbCBwcm9wZXJ0eSBuYW1lc1xuXG4gICAgICBpZiggdmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG5cbiAgICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhuYW1lKSApeyAvLyB0aGVuIHBhcnNlIHRoZSBzaW5nbGUgcHJvcGVydHlcbiAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICAgIHByb3BzLnB1c2goIHBhcnNlZFByb3AgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG5hbWUpICl7IC8vIHRoZW4gcGFyc2UgZWFjaCBwcm9wZXJ0eVxuICAgICAgdmFyIHNwZWNpZmllZFByb3BzID0gbmFtZTtcbiAgICAgIHVwZGF0ZVRyYW5zaXRpb25zID0gdmFsdWU7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1sgbmFtZSBdO1xuXG4gICAgICAgIGlmKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7IC8vIHRyeSBjYW1lbCBjYXNlIG5hbWUgdG9vXG4gICAgICAgICAgdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1sgJCQudXRpbC5kYXNoMmNhbWVsKG5hbWUpIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIHBhcnNlZFByb3AgKXtcbiAgICAgICAgICAgIHByb3BzLnB1c2goIHBhcnNlZFByb3AgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBjYW4ndCBkbyBhbnl0aGluZyB3aXRob3V0IHdlbGwgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gd2UndmUgZmFpbGVkIGlmIHRoZXJlIGFyZSBubyB2YWxpZCBwcm9wZXJ0aWVzXG4gICAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIG5vdywgYXBwbHkgdGhlIGJ5cGFzcyBwcm9wZXJ0aWVzIG9uIHRoZSBlbGVtZW50c1xuICAgIHZhciByZXQgPSBmYWxzZTsgLy8gcmV0dXJuIHRydWUgaWYgYXQgbGVhc3Qgb25lIHN1Y2Nlc2Z1bCBieXBhc3MgYXBwbGllZFxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApeyAvLyBmb3IgZWFjaCBlbGVcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgICAgdmFyIGRpZmZQcm9wO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7IC8vIGZvciBlYWNoIHByb3BcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcblxuICAgICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgICB2YXIgcHJldlByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICAgICAgZGlmZlByb3AgPSBkaWZmUHJvcHNbIHByb3AubmFtZSBdID0geyBwcmV2OiBwcmV2UHJvcCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIHByb3AgKSB8fCByZXQ7XG5cbiAgICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgICAgZGlmZlByb3AubmV4dCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgICAgfVxuXG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyggZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzICk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgZWxlc1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICAvLyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWZpYyBjYXNlcyBsaWtlIGFuaW1hdGlvblxuICAkJC5zdHlmbi5vdmVycmlkZUJ5cGFzcyA9IGZ1bmN0aW9uKCBlbGVzLCBuYW1lLCB2YWx1ZSApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgcHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsgJCQudXRpbC5jYW1lbDJkYXNoKG5hbWUpIF07XG5cbiAgICAgIGlmKCAhcHJvcC5ieXBhc3MgKXsgLy8gbmVlZCBhIGJ5cGFzcyBpZiBvbmUgZG9lc24ndCBleGlzdFxuICAgICAgICB0aGlzLmFwcGx5QnlwYXNzKCBlbGUsIG5hbWUsIHZhbHVlICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnZhbHVlID0gdmFsdWU7XG4gICAgICBwcm9wLnB4VmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgJCQuc3R5Zm4ucmVtb3ZlQWxsQnlwYXNzZXMgPSBmdW5jdGlvbiggZWxlcywgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnOyAvLyBlbXB0eSA9PiByZW1vdmUgYnlwYXNzXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBwcmV2UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wLm5hbWUgXSA9IHsgcHJldjogcHJldlByb3AgfTtcblxuICAgICAgICB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBwYXJzZWRQcm9wKTtcblxuICAgICAgICBkaWZmUHJvcC5uZXh0ID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVsZXNcbiAgfTtcblxuICAkJC5zdHlmbi5yZW1vdmVCeXBhc3NlcyA9IGZ1bmN0aW9uKCBlbGVzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbmFtZSA9IHByb3BzW2ldO1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbIG5hbWUgXTtcbiAgICAgICAgdmFyIHZhbHVlID0gJyc7IC8vIGVtcHR5ID0+IHJlbW92ZSBieXBhc3NcbiAgICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgdmFyIHByZXZQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbIHByb3AubmFtZSBdID0geyBwcmV2OiBwcmV2UHJvcCB9O1xuXG4gICAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIHBhcnNlZFByb3ApO1xuXG4gICAgICAgIGRpZmZQcm9wLm5leHQgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyggZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzICk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgZWxlc1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkLCB3aW5kb3cpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gZ2V0cyB3aGF0IGFuIGVtIHNpemUgY29ycmVzcG9uZHMgdG8gaW4gcGl4ZWxzIHJlbGF0aXZlIHRvIGEgZG9tIGVsZW1lbnRcbiAgJCQuc3R5Zm4uZ2V0RW1TaXplSW5QaXhlbHMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjeS5jb250YWluZXIoKTtcblxuICAgIGlmKCB3aW5kb3cgJiYgZG9tRWxlbWVudCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApe1xuICAgICAgdmFyIHB4QXNTdHIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LXNpemUnKTtcbiAgICAgIHZhciBweCA9IHBhcnNlRmxvYXQoIHB4QXNTdHIgKTtcbiAgICAgIHJldHVybiBweDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7IC8vIGluIGNhc2Ugd2UncmUgcnVubmluZyBvdXRzaWRlIG9mIHRoZSBicm93c2VyXG4gICAgfVxuICB9O1xuXG4gIC8vIGdldHMgY3NzIHByb3BlcnR5IGZyb20gdGhlIGNvcmUgY29udGFpbmVyXG4gICQkLnN0eWZuLmNvbnRhaW5lckNzcyA9IGZ1bmN0aW9uKCBwcm9wTmFtZSApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjeS5jb250YWluZXIoKTtcblxuICAgIGlmKCB3aW5kb3cgJiYgZG9tRWxlbWVudCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApe1xuICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbUVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoIHByb3BOYW1lICk7XG4gICAgfVxuICB9O1xuXG4gICQkLnN0eWZuLmNvbnRhaW5lclByb3BlcnR5ID0gZnVuY3Rpb24oIHByb3BOYW1lICl7XG4gICAgdmFyIHByb3BTdHIgPSB0aGlzLmNvbnRhaW5lckNzcyggcHJvcE5hbWUgKTtcbiAgICB2YXIgcHJvcCA9IHRoaXMucGFyc2UoIHByb3BOYW1lLCBwcm9wU3RyICk7XG4gICAgcmV0dXJuIHByb3A7XG4gIH07XG5cbiAgJCQuc3R5Zm4uY29udGFpbmVyUHJvcGVydHlBc1N0cmluZyA9IGZ1bmN0aW9uKCBwcm9wTmFtZSApe1xuICAgIHZhciBwcm9wID0gdGhpcy5jb250YWluZXJQcm9wZXJ0eSggcHJvcE5hbWUgKTtcblxuICAgIGlmKCBwcm9wICl7XG4gICAgICByZXR1cm4gcHJvcC5zdHJWYWx1ZTtcbiAgICB9XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUsIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBnZXRzIHRoZSByZW5kZXJlZCBzdHlsZSBmb3IgYW4gZWxlbWVudFxuICAkJC5zdHlmbi5nZXRSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIHZhciBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciByc3R5bGUgPSB7fTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIHN0eWxlUHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcblxuICAgICAgICBpZiggc3R5bGVQcm9wICl7XG4gICAgICAgICAgdmFyIHZhbCA9IHN0eWxlUHJvcC51bml0bGVzcyA/IHN0eWxlUHJvcC5zdHJWYWx1ZSA6IChzdHlsZVByb3AucHhWYWx1ZSAqIHpvb20pICsgJ3B4JztcbiAgICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gdmFsO1xuICAgICAgICAgIHJzdHlsZVsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnN0eWxlO1xuICAgIH1cbiAgfTtcblxuICAvLyBnZXRzIHRoZSByYXcgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbiAgJCQuc3R5Zm4uZ2V0UmF3U3R5bGUgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgdmFyIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gICAgaWYoIGVsZSApe1xuICAgICAgdmFyIHJzdHlsZSA9IHt9O1xuICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgc3R5bGVQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuXG4gICAgICAgIGlmKCBzdHlsZVByb3AgKXtcbiAgICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gc3R5bGVQcm9wLnN0clZhbHVlO1xuICAgICAgICAgIHJzdHlsZVsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXSA9IHN0eWxlUHJvcC5zdHJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnN0eWxlO1xuICAgIH1cbiAgfTtcblxuICAvLyBnZXRzIHRoZSB2YWx1ZSBzdHlsZSBmb3IgYW4gZWxlbWVudCAodXNlZnVsIGZvciB0aGluZ3MgbGlrZSBhbmltYXRpb25zKVxuICAkJC5zdHlmbi5nZXRWYWx1ZVN0eWxlID0gZnVuY3Rpb24oIGVsZSwgb3B0cyApe1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgdmFyIHJzdHlsZSA9IG9wdHMuYXJyYXkgPyBbXSA6IHt9OyBcbiAgICB2YXIgc3R5bGU7XG5cbiAgICBpZiggJCQuaXMuZWxlbWVudChlbGUpICl7XG4gICAgICBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTsgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlID0gZWxlOyAvLyBqdXN0IHBhc3NlZCB0aGUgc3R5bGUgaXRzZWxmXG4gICAgfVxuXG4gICAgaWYoIHN0eWxlICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgc3R5bGVQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdIHx8IHN0eWxlWyAkJC51dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKSBdO1xuXG4gICAgICAgIGlmKCBzdHlsZVByb3AgIT09IHVuZGVmaW5lZCAmJiAhJCQuaXMucGxhaW5PYmplY3QoIHN0eWxlUHJvcCApICl7IC8vIHRoZW4gbWFrZSBhIHByb3Agb2YgaXRcbiAgICAgICAgICBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgc3R5bGVQcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBzdHlsZVByb3AgKXtcbiAgICAgICAgICBpZiggb3B0cy5hcnJheSApe1xuICAgICAgICAgICAgcnN0eWxlLnB1c2goIHN0eWxlUHJvcCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gc3R5bGVQcm9wO1xuICAgICAgICAgICAgcnN0eWxlWyAkJC51dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKSBdID0gc3R5bGVQcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByc3R5bGU7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuc3R5bGUuYXBwbHlGcm9tSnNvbiA9IGZ1bmN0aW9uKCBzdHlsZSwganNvbiApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGNvbnRleHQgPSBqc29uW2ldO1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICAgIHZhciBwcm9wcyA9IGNvbnRleHQuc3R5bGUgfHwgY29udGV4dC5jc3M7XG5cbiAgICAgIHN0eWxlLnNlbGVjdG9yKCBzZWxlY3RvciApOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgICBmb3IoIHZhciBuYW1lIGluIHByb3BzICl7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3BzW25hbWVdO1xuXG4gICAgICAgIHN0eWxlLmNzcyggbmFtZSwgdmFsdWUgKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgLy8gc3RhdGljIGZ1bmN0aW9uXG4gICQkLnN0eWxlLmZyb21Kc29uID0gZnVuY3Rpb24oIGN5LCBqc29uICl7XG4gICAgdmFyIHN0eWxlID0gbmV3ICQkLlN0eWxlKGN5KTtcblxuICAgICQkLnN0eWxlLmFwcGx5RnJvbUpzb24oIHN0eWxlLCBqc29uICk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgLy8gYWNjZXNzaWJsZSBjeS5zdHlsZSgpIGZ1bmN0aW9uXG4gICQkLnN0eWZuLmZyb21Kc29uID0gZnVuY3Rpb24oIGpzb24gKXtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gICAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcblxuICAgICQkLnN0eWxlLmFwcGx5RnJvbUpzb24oIHN0eWxlLCBqc29uICk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuICAkJC5zdHlmbi5qc29uID0gZnVuY3Rpb24oKXtcbiAgICB2YXIganNvbiA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IHRoaXMuZGVmYXVsdExlbmd0aDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjeHQgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNlbGVjdG9yID0gY3h0LnNlbGVjdG9yO1xuICAgICAgdmFyIHByb3BzID0gY3h0LnByb3BlcnRpZXM7XG4gICAgICB2YXIgY3NzID0ge307XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgY3NzWyBwcm9wLm5hbWUgXSA9IHByb3Auc3RyVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGpzb24ucHVzaCh7XG4gICAgICAgIHNlbGVjdG9yOiAhc2VsZWN0b3IgPyAnY29yZScgOiBzZWxlY3Rvci50b1N0cmluZygpLFxuICAgICAgICBzdHlsZTogY3NzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5zdHlsZS5hcHBseUZyb21TdHJpbmcgPSBmdW5jdGlvbiggc3R5bGUsIHN0cmluZyApe1xuICAgIHZhciByZW1haW5pbmcgPSAnJyArIHN0cmluZztcbiAgICB2YXIgc2VsQW5kQmxvY2tTdHI7XG4gICAgdmFyIGJsb2NrUmVtO1xuICAgIHZhciBwcm9wQW5kVmFsU3RyO1xuXG4gICAgLy8gcmVtb3ZlIGNvbW1lbnRzIGZyb20gdGhlIHN0eWxlIHN0cmluZ1xuICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5yZXBsYWNlKC9bL11bKl0oXFxzfC4pKz9bKl1bL10vZywgJycpO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCl7XG4gICAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBzZWxlY3RvciBhbmQgYmxvY2sgZnJvbSB0aGUgcmVtYWluaW5nIHRleHQgdG8gcGFyc2VcbiAgICAgIGlmKCByZW1haW5pbmcubGVuZ3RoID4gc2VsQW5kQmxvY2tTdHIubGVuZ3RoICl7XG4gICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHIoIHNlbEFuZEJsb2NrU3RyLmxlbmd0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKXtcbiAgICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgICAgaWYoIGJsb2NrUmVtLmxlbmd0aCA+IHByb3BBbmRWYWxTdHIubGVuZ3RoICl7XG4gICAgICAgIGJsb2NrUmVtID0gYmxvY2tSZW0uc3Vic3RyKCBwcm9wQW5kVmFsU3RyLmxlbmd0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tSZW0gPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSh0cnVlKXtcbiAgICAgIHZhciBub3RoaW5nTGVmdFRvUGFyc2UgPSByZW1haW5pbmcubWF0Y2goL15cXHMqJC8pO1xuICAgICAgaWYoIG5vdGhpbmdMZWZ0VG9QYXJzZSApeyBicmVhazsgfVxuXG4gICAgICB2YXIgc2VsQW5kQmxvY2sgPSByZW1haW5pbmcubWF0Y2goL15cXHMqKCg/Oi58XFxzKSs/KVxccypcXHsoKD86LnxcXHMpKz8pXFx9Lyk7XG5cbiAgICAgIGlmKCAhc2VsQW5kQmxvY2sgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignSGFsdGluZyBzdHlsZXNoZWV0IHBhcnNpbmc6IFN0cmluZyBzdHlsZXNoZWV0IGNvbnRhaW5zIG1vcmUgdG8gcGFyc2UgYnV0IG5vIHNlbGVjdG9yIGFuZCBibG9jayBmb3VuZCBpbjogJyArIHJlbWFpbmluZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzZWxBbmRCbG9ja1N0ciA9IHNlbEFuZEJsb2NrWzBdO1xuXG4gICAgICAvLyBwYXJzZSB0aGUgc2VsZWN0b3JcbiAgICAgIHZhciBzZWxlY3RvclN0ciA9IHNlbEFuZEJsb2NrWzFdO1xuICAgICAgaWYoIHNlbGVjdG9yU3RyICE9PSAnY29yZScgKXtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gbmV3ICQkLlNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuICAgICAgICBpZiggc2VsZWN0b3IuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgc2VsZWN0b3IgZm91bmQgaW4gc3RyaW5nIHN0eWxlc2hlZXQ6ICcgKyBzZWxlY3RvclN0cik7XG5cbiAgICAgICAgICAvLyBza2lwIHRoaXMgc2VsZWN0b3IgYW5kIGJsb2NrXG4gICAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgICAgY29udGludWU7IFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIHRoZSBibG9jayBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICAgIHZhciBibG9ja1N0ciA9IHNlbEFuZEJsb2NrWzJdO1xuICAgICAgdmFyIGludmFsaWRCbG9jayA9IGZhbHNlO1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICAgIHZhciBwcm9wcyA9IFtdO1xuXG4gICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgdmFyIG5vdGhpbmdMZWZ0VG9QYXJzZSA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiQvKTtcbiAgICAgICAgaWYoIG5vdGhpbmdMZWZ0VG9QYXJzZSApeyBicmVhazsgfVxuXG4gICAgICAgIHZhciBwcm9wQW5kVmFsID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqKC4rPylcXHMqOlxccyooLis/KVxccyo7Lyk7XG5cbiAgICAgICAgaWYoICFwcm9wQW5kVmFsICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBmb3JtYXR0aW5nIG9mIHN0eWxlIHByb3BlcnR5IGFuZCB2YWx1ZSBkZWZpbml0aW9ucyBmb3VuZCBpbjonICsgYmxvY2tTdHIpO1xuICAgICAgICAgIGludmFsaWRCbG9jayA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wQW5kVmFsU3RyID0gcHJvcEFuZFZhbFswXTtcbiAgICAgICAgdmFyIHByb3BTdHIgPSBwcm9wQW5kVmFsWzFdO1xuICAgICAgICB2YXIgdmFsU3RyID0gcHJvcEFuZFZhbFsyXTtcblxuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbIHByb3BTdHIgXTtcbiAgICAgICAgaWYoICFwcm9wICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgbmFtZSBpbjogJyArIHByb3BBbmRWYWxTdHIpO1xuXG4gICAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHN0eWxlLnBhcnNlKCBwcm9wU3RyLCB2YWxTdHIgKTtcblxuICAgICAgICBpZiggIXBhcnNlZFByb3AgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGluOiAnICsgcHJvcEFuZFZhbFN0cik7XG5cbiAgICAgICAgICAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG4gICAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHByb3BTdHIsXG4gICAgICAgICAgdmFsOiB2YWxTdHJcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBpbnZhbGlkQmxvY2sgKXtcbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBwdXQgdGhlIHBhcnNlZCBibG9jayBpbiB0aGUgc3R5bGVcbiAgICAgIHN0eWxlLnNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICBzdHlsZS5jc3MoIHByb3AubmFtZSwgcHJvcC52YWwgKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gICQkLnN0eWxlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiggY3ksIHN0cmluZyApe1xuICAgIHZhciBzdHlsZSA9IG5ldyAkJC5TdHlsZShjeSk7XG4gICAgXG4gICAgJCQuc3R5bGUuYXBwbHlGcm9tU3RyaW5nKCBzdHlsZSwgc3RyaW5nICk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgJCQuc3R5Zm4uZnJvbVN0cmluZyA9IGZ1bmN0aW9uKCBzdHJpbmcgKXtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gICAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcblxuICAgICQkLnN0eWxlLmFwcGx5RnJvbVN0cmluZyggc3R5bGUsIHN0cmluZyApO1xuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gYSBkdW1teSBzdHlsZXNoZWV0IG9iamVjdCB0aGF0IGRvZXNuJ3QgbmVlZCBhIHJlZmVyZW5jZSB0byB0aGUgY29yZVxuICAvLyAodXNlZnVsIGZvciBpbml0KVxuICAkJC5zdHlsZXNoZWV0ID0gJCQuU3R5bGVzaGVldCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLlN0eWxlc2hlZXQpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLlN0eWxlc2hlZXQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgJCQuc2hlZXRmbiA9ICQkLlN0eWxlc2hlZXQucHJvdG90eXBlO1xuXG4gIC8vIGp1c3Qgc3RvcmUgdGhlIHNlbGVjdG9yIHRvIGJlIHBhcnNlZCBsYXRlclxuICAkJC5zaGVldGZuLnNlbGVjdG9yID0gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrO1xuXG4gICAgdGhpc1tpXSA9IHtcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgIHByb3BlcnRpZXM6IFtdXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIGp1c3Qgc3RvcmUgdGhlIHByb3BlcnR5IHRvIGJlIHBhcnNlZCBsYXRlclxuICAkJC5zaGVldGZuLmNzcyA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuXG4gICAgaWYoICQkLmlzLnN0cmluZyhuYW1lKSApe1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3QobmFtZSkgKXtcbiAgICAgIHZhciBtYXAgPSBuYW1lO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2pdO1xuICAgICAgICB2YXIgbWFwVmFsID0gbWFwWyBwcm9wLm5hbWUgXTtcblxuICAgICAgICBpZiggbWFwVmFsID09PSB1bmRlZmluZWQgKXsgLy8gYWxzbyB0cnkgY2FtZWwgY2FzZSBuYW1lXG4gICAgICAgICAgbWFwVmFsID0gbWFwWyAkJC51dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG1hcFZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbWFwVmFsO1xuXG4gICAgICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgJCQuc2hlZXRmbi5zdHlsZSA9ICQkLnNoZWV0Zm4uY3NzO1xuXG4gIC8vIGdlbmVyYXRlIGEgcmVhbCBzdHlsZSBvYmplY3QgZnJvbSB0aGUgZHVtbXkgc3R5bGVzaGVldFxuICAkJC5zaGVldGZuLmdlbmVyYXRlU3R5bGUgPSBmdW5jdGlvbiggY3kgKXtcbiAgICB2YXIgc3R5bGUgPSBuZXcgJCQuU3R5bGUoY3kpO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXNbaV07XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjb250ZXh0LnNlbGVjdG9yO1xuICAgICAgdmFyIHByb3BzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xuXG4gICAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcblxuICAgICAgICBzdHlsZS5jc3MoIHByb3AubmFtZSwgcHJvcC52YWx1ZSApOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuLy8gY3Jvc3MtZW52IHRocmVhZC93b3JrZXJcbi8vIE5CIDogdXNlcyAoaGVhdnl3ZWlnaHQpIHByb2Nlc3NlcyBvbiBub2RlanMgc28gYmVzdCBub3QgdG8gY3JlYXRlIHRvbyBtYW55IHRocmVhZHNcblxuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLlRocmVhZCA9IGZ1bmN0aW9uKCBmbiApe1xuICAgIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiAkJC5UaHJlYWQpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLlRocmVhZCggZm4gKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgcmVxdWlyZXM6IFtdLFxuICAgICAgZmlsZXM6IFtdLFxuICAgICAgcXVldWU6IG51bGwsXG4gICAgICBwYXNzOiBbXVxuICAgIH07XG5cbiAgICBpZiggZm4gKXtcbiAgICAgIHRoaXMucnVuKCBmbiApO1xuICAgIH1cblxuICB9O1xuXG4gICQkLnRocmVhZCA9ICQkLlRocmVhZDtcbiAgJCQudGhkZm4gPSAkJC5UaHJlYWQucHJvdG90eXBlOyAvLyBzaG9ydCBhbGlhc1xuXG4gICQkLmZuLnRocmVhZCA9IGZ1bmN0aW9uKCBmbk1hcCwgb3B0aW9ucyApe1xuICAgIGZvciggdmFyIG5hbWUgaW4gZm5NYXAgKXtcbiAgICAgIHZhciBmbiA9IGZuTWFwW25hbWVdO1xuICAgICAgJCQuVGhyZWFkLnByb3RvdHlwZVsgbmFtZSBdID0gZm47XG4gICAgfVxuICB9O1xuXG4gIHZhciBzdHJpbmdpZnlGaWVsZFZhbCA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgICB2YXIgdmFsU3RyID0gJCQuaXMuZm4oIHZhbCApID8gdmFsLnRvU3RyaW5nKCkgOiAnSlNPTi5wYXJzZShcIicgKyBKU09OLnN0cmluZ2lmeSh2YWwpICsgJ1wiKSc7XG5cbiAgICByZXR1cm4gdmFsU3RyO1xuICB9O1xuXG4gIC8vIGFsbG93cyBmb3IgcmVxdWlyZXMgd2l0aCBwcm90b3R5cGVzIGFuZCBzdWJvYmpzIGV0Y1xuICB2YXIgZm5Bc1JlcXVpcmUgPSBmdW5jdGlvbiggZm4gKXtcbiAgICB2YXIgcmVxO1xuICAgIHZhciBmbk5hbWU7XG5cbiAgICBpZiggJCQuaXMub2JqZWN0KGZuKSAmJiBmbi5mbiApeyAvLyBtYW51YWwgZm5cbiAgICAgIHJlcSA9IGZuQXMoIGZuLmZuLCBmbi5uYW1lICk7XG4gICAgICBmbk5hbWUgPSBmbi5uYW1lO1xuICAgICAgZm4gPSBmbi5mbjtcbiAgICB9IGVsc2UgaWYoICQkLmlzLmZuKGZuKSApeyAvLyBhdXRvIGZuXG4gICAgICByZXEgPSBmbi50b1N0cmluZygpO1xuICAgICAgZm5OYW1lID0gZm4ubmFtZTtcbiAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhmbikgKXsgLy8gc3RyaW5naWZpZWQgZm5cbiAgICAgIHJlcSA9IGZuO1xuICAgIH0gZWxzZSBpZiggJCQuaXMub2JqZWN0KGZuKSApeyAvLyBwbGFpbiBvYmplY3RcbiAgICAgIGlmKCBmbi5wcm90byApe1xuICAgICAgICByZXEgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcSA9IGZuLm5hbWUgKyAnID0ge307JztcbiAgICAgIH1cblxuICAgICAgZm5OYW1lID0gZm4ubmFtZTtcbiAgICAgIGZuID0gZm4ub2JqO1xuICAgIH1cblxuICAgIHJlcSArPSAnXFxuJztcblxuICAgIHZhciBwcm90b3JlcSA9IGZ1bmN0aW9uKCB2YWwsIHN1Ym5hbWUgKXtcbiAgICAgIGlmKCB2YWwucHJvdG90eXBlICl7XG4gICAgICAgIHZhciBwcm90b05vbmVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGZvciggdmFyIHByb3AgaW4gdmFsLnByb3RvdHlwZSApeyBwcm90b05vbmVtcHR5ID0gdHJ1ZTsgYnJlYWs7IH1cblxuICAgICAgICBpZiggcHJvdG9Ob25lbXB0eSApe1xuICAgICAgICAgIHJlcSArPSBmbkFzUmVxdWlyZSgge1xuICAgICAgICAgICAgbmFtZTogc3VibmFtZSxcbiAgICAgICAgICAgIG9iajogdmFsLFxuICAgICAgICAgICAgcHJvdG86IHRydWVcbiAgICAgICAgICB9LCB2YWwgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBwdWxsIGluIHByb3RvdHlwZVxuICAgIGlmKCBmbi5wcm90b3R5cGUgJiYgZm5OYW1lICE9IG51bGwgKXtcblxuICAgICAgZm9yKCB2YXIgbmFtZSBpbiBmbi5wcm90b3R5cGUgKXtcbiAgICAgICAgdmFyIHByb3RvU3RyID0gJyc7XG5cbiAgICAgICAgdmFyIHZhbCA9IGZuLnByb3RvdHlwZVsgbmFtZSBdO1xuICAgICAgICB2YXIgdmFsU3RyID0gc3RyaW5naWZ5RmllbGRWYWwoIHZhbCApO1xuICAgICAgICB2YXIgc3VibmFtZSA9IGZuTmFtZSArICcucHJvdG90eXBlLicgKyBuYW1lO1xuXG4gICAgICAgIHByb3RvU3RyICs9IHN1Ym5hbWUgKyAnID0gJyArIHZhbFN0ciArICc7XFxuJztcblxuICAgICAgICBpZiggcHJvdG9TdHIgKXtcbiAgICAgICAgICByZXEgKz0gcHJvdG9TdHI7XG4gICAgICAgIH1cblxuICAgICAgICBwcm90b3JlcSggdmFsLCBzdWJuYW1lICk7IC8vIHN1Ym9iamVjdCB3aXRoIHByb3RvdHlwZVxuICAgICAgfVxuICBcbiAgICB9XG5cbiAgICAvLyBwdWxsIGluIHByb3BlcnRpZXMgZm9yIG9iai9mbnNcbiAgICBpZiggISQkLmlzLnN0cmluZyhmbikgKXsgZm9yKCB2YXIgbmFtZSBpbiBmbiApe1xuICAgICAgdmFyIHByb3BzU3RyID0gJyc7XG5cbiAgICAgIGlmKCBmbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSApe1xuICAgICAgICB2YXIgdmFsID0gZm5bIG5hbWUgXTtcbiAgICAgICAgdmFyIHZhbFN0ciA9IHN0cmluZ2lmeUZpZWxkVmFsKCB2YWwgKTtcbiAgICAgICAgdmFyIHN1Ym5hbWUgPSBmbk5hbWUgKyAnW1wiJyArIG5hbWUgKyAnXCJdJztcblxuICAgICAgICBwcm9wc1N0ciArPSBzdWJuYW1lICsgJyA9ICcgKyB2YWxTdHIgKyAnO1xcbic7XG4gICAgICB9XG5cbiAgICAgIGlmKCBwcm9wc1N0ciApe1xuICAgICAgICByZXEgKz0gcHJvcHNTdHI7XG4gICAgICB9XG5cbiAgICAgIHByb3RvcmVxKCB2YWwsIHN1Ym5hbWUgKTsgLy8gc3Vib2JqZWN0IHdpdGggcHJvdG90eXBlXG4gICAgfSB9XG5cbiAgICByZXR1cm4gcmVxO1xuICB9O1xuICBcbiAgdmFyIGlzUGF0aFN0ciA9IGZ1bmN0aW9uKCBzdHIgKXtcbiAgICByZXR1cm4gJCQuaXMuc3RyaW5nKHN0cikgJiYgc3RyLm1hdGNoKC9cXC5qcyQvKTtcbiAgfTtcblxuICAkJC5mbi50aHJlYWQoe1xuXG4gICAgcmVxdWlyZTogZnVuY3Rpb24oIGZuLCBhcyApe1xuICAgICAgaWYoIGlzUGF0aFN0cihmbikgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5maWxlcy5wdXNoKCBmbiApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAgIFxuICAgICAgaWYoIGFzICl7XG4gICAgICAgIGlmKCAkJC5pcy5mbihmbikgKXtcbiAgICAgICAgICAvLyBkaXNhYmxlZCBiL2MgZG9lc24ndCB3b3JrIHdpdGggZm9yY2VkIG5hbWVzIG9uIGZ1bmN0aW9ucyB3LyBwcm90b3R5cGVzXG4gICAgICAgICAgLy9mbiA9IGZuQXMoIGZuLCBhcyApO1xuXG4gICAgICAgICAgYXMgPSBhcyB8fCBmbi5uYW1lO1xuXG4gICAgICAgICAgZm4gPSB7IG5hbWU6IGFzLCBmbjogZm4gfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbiA9IHsgbmFtZTogYXMsIG9iajogZm4gfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcml2YXRlLnJlcXVpcmVzLnB1c2goIGZuICk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBwYXNzOiBmdW5jdGlvbiggZGF0YSApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYXNzLnB1c2goIGRhdGEgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHJ1bjogZnVuY3Rpb24oIGZuLCBwYXNzICl7IC8vIGZuIHVzZWQgbGlrZSBtYWluKClcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBwYXNzID0gcGFzcyB8fCBfcC5wYXNzLnNoaWZ0KCk7XG5cbiAgICAgIGlmKCBfcC5zdG9wcGVkICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0F0dGVtcHRlZCB0byBydW4gYSBzdG9wcGVkIHRocmVhZCEgIFN0YXJ0IGEgbmV3IHRocmVhZCBvciBkbyBub3Qgc3RvcCB0aGUgZXhpc3RpbmcgdGhyZWFkIGFuZCByZXVzZSBpdC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiggX3AucnVubmluZyApe1xuICAgICAgICByZXR1cm4gX3AucXVldWUgPSBfcC5xdWV1ZS50aGVuKGZ1bmN0aW9uKCl7IC8vIGluZHVjdGl2ZSBzdGVwXG4gICAgICAgICAgcmV0dXJuIHNlbGYucnVuKCBmbiwgcGFzcyApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHVzZVdXID0gd2luZG93ICE9IG51bGw7XG4gICAgICB2YXIgdXNlTm9kZSA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICBzZWxmLnRyaWdnZXIoJ3J1bicpO1xuXG4gICAgICB2YXIgcnVuUCA9IG5ldyAkJC5Qcm9taXNlKGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKXtcblxuICAgICAgICBfcC5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICB2YXIgdGhyZWFkVGVjaEFscmVhZHlFeGlzdHMgPSBfcC5yYW47XG5cbiAgICAgICAgdmFyIGZuSW1wbFN0ciA9ICQkLmlzLnN0cmluZyggZm4gKSA/IGZuIDogZm4udG9TdHJpbmcoKTtcblxuICAgICAgICAvLyB3b3JrZXIgY29kZSB0byBleGVjXG4gICAgICAgIHZhciBmblN0ciA9ICdcXG4nICsgKCBfcC5yZXF1aXJlcy5tYXAoZnVuY3Rpb24oIHIgKXtcbiAgICAgICAgICByZXR1cm4gZm5Bc1JlcXVpcmUoIHIgKTtcbiAgICAgICAgfSkgKS5jb25jYXQoIF9wLmZpbGVzLm1hcChmdW5jdGlvbiggZiApe1xuICAgICAgICAgIGlmKCB1c2VXVyApe1xuICAgICAgICAgICAgdmFyIHd3aWZ5RmlsZSA9IGZ1bmN0aW9uKCBmaWxlICl7XG4gICAgICAgICAgICAgIGlmKCBmaWxlLm1hdGNoKC9eXFwuXFwvLykgfHwgZmlsZS5tYXRjaCgvXlxcLlxcLi8pICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyBmaWxlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYoIGZpbGUubWF0Y2goL15cXC8vKSApe1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgJy8nICsgZmlsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAnaW1wb3J0U2NyaXB0cyhcIicgKyB3d2lmeUZpbGUoZikgKyAnXCIpOyc7XG4gICAgICAgICAgfSBlbHNlIGlmKCB1c2VOb2RlICkge1xuICAgICAgICAgICAgcmV0dXJuICdldmFsKCByZXF1aXJlKFwiZnNcIikucmVhZEZpbGVTeW5jKFwiJyArIGYgKyAnXCIsIHsgZW5jb2Rpbmc6IFwidXRmOFwiIH0pICk7JztcbiAgICAgICAgICB9XG4gICAgICAgIH0pICkuY29uY2F0KFtcbiAgICAgICAgICAnKCBmdW5jdGlvbigpeycsXG4gICAgICAgICAgICAndmFyIHJldCA9ICgnICsgZm5JbXBsU3RyICsgJykoJyArIEpTT04uc3RyaW5naWZ5KHBhc3MpICsgJyk7JyxcbiAgICAgICAgICAgICdpZiggcmV0ICE9PSB1bmRlZmluZWQgKXsgcmVzb2x2ZShyZXQpOyB9JywgLy8gYXNzdW1lIGlmIHJhbiBmbiByZXR1cm5zIGRlZmluZWQgdmFsdWUgKGluY2wuIG51bGwpLCB0aGF0IHdlIHdhbnQgdG8gcmVzb2x2ZSB0byBpdFxuICAgICAgICAgICd9ICkoKVxcbidcbiAgICAgICAgXSkuam9pbignXFxuJyk7XG5cbiAgICAgICAgLy8gYmVjYXVzZSB3ZSd2ZSBub3cgY29uc3VtZWQgdGhlIHJlcXVpcmVzLCBlbXB0eSB0aGUgbGlzdCBzbyB3ZSBkb24ndCBkdXBlIG9uIG5leHQgcnVuKClcbiAgICAgICAgX3AucmVxdWlyZXMgPSBbXTtcbiAgICAgICAgX3AuZmlsZXMgPSBbXTtcblxuICAgICAgICBpZiggdXNlV1cgKXtcbiAgICAgICAgICB2YXIgZm5CbG9iLCBmblVybDtcblxuICAgICAgICAgIC8vIGFkZCBub3JtYWxpc2VkIHRocmVhZCBhcGkgZnVuY3Rpb25zXG4gICAgICAgICAgaWYoICF0aHJlYWRUZWNoQWxyZWFkeUV4aXN0cyApe1xuICAgICAgICAgICAgdmFyIGZuUHJlID0gZm5TdHIgKyAnJztcblxuICAgICAgICAgICAgZm5TdHIgPSBbXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBicm9hZGNhc3QobSl7IHJldHVybiBtZXNzYWdlKG0pOyB9OycsIC8vIGFsaWFzXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBtZXNzYWdlKG0peyBwb3N0TWVzc2FnZShtKTsgfTsnLFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gbGlzdGVuKGZuKXsnLFxuICAgICAgICAgICAgICAnICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKG0peyAnLFxuICAgICAgICAgICAgICAnICAgIGlmKCB0eXBlb2YgbSA9PT0gXCJvYmplY3RcIiAmJiAobS5kYXRhLiQkZXZhbCB8fCBtLmRhdGEgPT09IFwiJCRzdGFydFwiKSApeycsXG4gICAgICAgICAgICAgICcgICAgfSBlbHNlIHsgJyxcbiAgICAgICAgICAgICAgJyAgICAgIGZuKCBtLmRhdGEgKTsnLFxuICAgICAgICAgICAgICAnICAgIH0nLFxuICAgICAgICAgICAgICAnICB9KTsnLFxuICAgICAgICAgICAgICAnfTsnLCBcbiAgICAgICAgICAgICAgJ3NlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24obSl7ICBpZiggbS5kYXRhLiQkZXZhbCApeyBldmFsKCBtLmRhdGEuJCRldmFsICk7IH0gIH0pOycsXG4gICAgICAgICAgICAgICdmdW5jdGlvbiByZXNvbHZlKHYpeyBwb3N0TWVzc2FnZSh7ICQkcmVzb2x2ZTogdiB9KTsgfTsnLCBcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIHJlamVjdCh2KXsgcG9zdE1lc3NhZ2UoeyAkJHJlamVjdDogdiB9KTsgfTsnXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICAgIFxuICAgICAgICAgICAgZm5TdHIgKz0gZm5QcmU7XG5cbiAgICAgICAgICAgIGZuQmxvYiA9IG5ldyBCbG9iKFsgZm5TdHIgXSwge1xuICAgICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm5VcmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCggZm5CbG9iICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNyZWF0ZSB3ZWJ3b3JrZXIgYW5kIGxldCBpdCBleGVjIHRoZSBzZXJpYWxpc2VkIGNvZGVcbiAgICAgICAgICB2YXIgd3cgPSBfcC53ZWJ3b3JrZXIgPSBfcC53ZWJ3b3JrZXIgfHwgbmV3IFdvcmtlciggZm5VcmwgKTtcblxuICAgICAgICAgIGlmKCB0aHJlYWRUZWNoQWxyZWFkeUV4aXN0cyApeyAvLyB0aGVuIGp1c3QgZXhlYyBuZXcgcnVuKCkgY29kZVxuICAgICAgICAgICAgd3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAkJGV2YWw6IGZuU3RyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB3b3JrZXIgbWVzc2FnZXMgPT4gZXZlbnRzXG4gICAgICAgICAgdmFyIGNiO1xuICAgICAgICAgIHd3LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBjYiA9IGZ1bmN0aW9uKCBtICl7XG4gICAgICAgICAgICB2YXIgaXNPYmplY3QgPSAkJC5pcy5vYmplY3QobSkgJiYgJCQuaXMub2JqZWN0KCBtLmRhdGEgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIGlzT2JqZWN0ICYmICgnJCRyZXNvbHZlJyBpbiBtLmRhdGEpICl7XG4gICAgICAgICAgICAgIHd3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBjYik7IC8vIGRvbmUgbGlzdGVuaW5nIGIvYyByZXNvbHZlKClcblxuICAgICAgICAgICAgICByZXNvbHZlKCBtLmRhdGEuJCRyZXNvbHZlICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoIGlzT2JqZWN0ICYmICgnJCRyZWplY3QnIGluIG0uZGF0YSkgKXtcbiAgICAgICAgICAgICAgd3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGNiKTsgLy8gZG9uZSBsaXN0ZW5pbmcgYi9jIHJlamVjdCgpXG5cbiAgICAgICAgICAgICAgcmVqZWN0KCBtLmRhdGEuJCRyZWplY3QgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYudHJpZ2dlciggbmV3ICQkLkV2ZW50KG0sIHsgdHlwZTogJ21lc3NhZ2UnLCBtZXNzYWdlOiBtLmRhdGEgfSkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgICBpZiggIXRocmVhZFRlY2hBbHJlYWR5RXhpc3RzICl7XG4gICAgICAgICAgICB3dy5wb3N0TWVzc2FnZSgnJCRzdGFydCcpOyAvLyBzdGFydCB1cCB0aGUgd29ya2VyXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiggdXNlTm9kZSApe1xuICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBwcm9jZXNzXG4gICAgICAgICAgdmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG4gICAgICAgICAgdmFyIGNoaWxkX3Byb2Nlc3MgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3AuY2hpbGQgPSBfcC5jaGlsZCB8fCBjaGlsZF9wcm9jZXNzLmZvcmsoIHBhdGguam9pbihfX2Rpcm5hbWUsICd0aHJlYWQtbm9kZS1mb3JrJykgKTtcblxuICAgICAgICAgIC8vIGNoaWxkIHByb2Nlc3MgbWVzc2FnZXMgPT4gZXZlbnRzXG4gICAgICAgICAgdmFyIGNiO1xuICAgICAgICAgIGNoaWxkLm9uKCdtZXNzYWdlJywgY2IgPSBmdW5jdGlvbiggbSApe1xuICAgICAgICAgICAgaWYoICQkLmlzLm9iamVjdChtKSAmJiAoJyQkcmVzb2x2ZScgaW4gbSkgKXtcbiAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBjYik7IC8vIGRvbmUgbGlzdGVuaW5nIGIvYyByZXNvbHZlKClcblxuICAgICAgICAgICAgICByZXNvbHZlKCBtLiQkcmVzb2x2ZSApO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5vYmplY3QobSkgJiYgKCckJHJlamVjdCcgaW4gbSkgKXtcbiAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBjYik7IC8vIGRvbmUgbGlzdGVuaW5nIGIvYyByZWplY3QoKVxuXG4gICAgICAgICAgICAgIHJlamVjdCggbS4kJHJlamVjdCApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoe30sIHsgdHlwZTogJ21lc3NhZ2UnLCBtZXNzYWdlOiBtIH0pICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBhc2sgdGhlIGNoaWxkIHByb2Nlc3MgdG8gZXZhbCB0aGUgd29ya2VyIGNvZGVcbiAgICAgICAgICBjaGlsZC5zZW5kKHtcbiAgICAgICAgICAgICQkZXZhbDogZm5TdHJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkJC5lcnJvcignVHJpZWQgdG8gY3JlYXRlIHRocmVhZCBidXQgbm8gdW5kZXJseWluZyB0ZWNoIGZvdW5kIScpO1xuICAgICAgICAgIC8vIFRPRE8gZmFsbGJhY2sgb24gbWFpbiBKUyB0aHJlYWQ/XG4gICAgICAgIH1cblxuICAgICAgfSkudGhlbihmdW5jdGlvbiggdiApe1xuICAgICAgICBfcC5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIF9wLnJhbiA9IHRydWU7XG5cbiAgICAgICAgc2VsZi50cmlnZ2VyKCdyYW4nKTtcblxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0pO1xuXG4gICAgICBpZiggX3AucXVldWUgPT0gbnVsbCApe1xuICAgICAgICBfcC5xdWV1ZSA9IHJ1blA7IC8vIGkuZS4gZmlyc3Qgc3RlcCBvZiBpbmR1Y3RpdmUgcHJvbWlzZSBjaGFpbiAoZm9yIHF1ZXVlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnVuUDtcbiAgICB9LFxuXG4gICAgLy8gc2VuZCB0aGUgdGhyZWFkIGEgbWVzc2FnZVxuICAgIG1lc3NhZ2U6IGZ1bmN0aW9uKCBtICl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiggX3Aud2Vid29ya2VyICl7XG4gICAgICAgIF9wLndlYndvcmtlci5wb3N0TWVzc2FnZSggbSApO1xuICAgICAgfVxuXG4gICAgICBpZiggX3AuY2hpbGQgKXtcbiAgICAgICAgX3AuY2hpbGQuc2VuZCggbSApO1xuICAgICAgfSBcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiggX3Aud2Vid29ya2VyICl7XG4gICAgICAgIF9wLndlYndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYoIF9wLmNoaWxkICl7XG4gICAgICAgIF9wLmNoaWxkLmtpbGwoKTtcbiAgICAgIH0gXG5cbiAgICAgIF9wLnN0b3BwZWQgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdzdG9wJyk7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHN0b3BwZWQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdG9wcGVkO1xuICAgIH1cblxuICB9KTtcblxuICB2YXIgZm5BcyA9IGZ1bmN0aW9uKCBmbiwgbmFtZSApe1xuICAgIHZhciBmblN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gICAgZm5TdHIgPSBmblN0ci5yZXBsYWNlKC9mdW5jdGlvbi4qXFwoLywgJ2Z1bmN0aW9uICcgKyBuYW1lICsgJygnKTtcblxuICAgIHJldHVybiBmblN0cjtcbiAgfTtcblxuICB2YXIgZGVmaW5lRm5hbCA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZm5hbEltcGwoIGZuLCBhcmcxICl7XG4gICAgICB2YXIgZm5TdHIgPSBmbkFzKCBmbiwgJ18kXyRfJyArIG9wdHMubmFtZSApO1xuXG4gICAgICB0aGlzLnJlcXVpcmUoIGZuU3RyICk7XG5cbiAgICAgIHJldHVybiB0aGlzLnJ1biggWyBcbiAgICAgICAgJ2Z1bmN0aW9uKCBkYXRhICl7JyxcbiAgICAgICAgJyAgdmFyIG9yaWdSZXNvbHZlID0gcmVzb2x2ZTsnLFxuICAgICAgICAnICB2YXIgcmVzID0gW107JyxcbiAgICAgICAgJyAgJyxcbiAgICAgICAgJyAgcmVzb2x2ZSA9IGZ1bmN0aW9uKCB2YWwgKXsnLFxuICAgICAgICAnICAgIHJlcy5wdXNoKCB2YWwgKTsnLFxuICAgICAgICAnICB9OycsXG4gICAgICAgICcgICcsXG4gICAgICAgICcgIHZhciByZXQgPSBkYXRhLicgKyBvcHRzLm5hbWUgKyAnKCBfJF8kXycgKyBvcHRzLm5hbWUgKyAoIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gJywgJyArIEpTT04uc3RyaW5naWZ5KGFyZzEpIDogJycgKSArICcgKTsnLFxuICAgICAgICAnICAnLFxuICAgICAgICAnICByZXNvbHZlID0gb3JpZ1Jlc29sdmU7JyxcbiAgICAgICAgJyAgcmVzb2x2ZSggcmVzLmxlbmd0aCA+IDAgPyByZXMgOiByZXQgKTsnLFxuICAgICAgICAnfSdcbiAgICAgIF0uam9pbignXFxuJykgKTtcbiAgICB9O1xuICB9O1xuXG4gICQkLmZuLnRocmVhZCh7XG4gICAgcmVkdWNlOiBkZWZpbmVGbmFsKHsgbmFtZTogJ3JlZHVjZScgfSksXG5cbiAgICByZWR1Y2VSaWdodDogZGVmaW5lRm5hbCh7IG5hbWU6ICdyZWR1Y2VSaWdodCcgfSksXG5cbiAgICBtYXA6IGRlZmluZUZuYWwoeyBuYW1lOiAnbWFwJyB9KVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gIHZhciBmbiA9ICQkLnRoZGZuO1xuICBmbi5wcm9taXNlID0gZm4ucnVuO1xuICBmbi50ZXJtaW5hdGUgPSBmbi5oYWx0ID0gZm4uc3RvcDtcbiAgZm4uaW5jbHVkZSA9IGZuLnJlcXVpcmU7XG5cbiAgLy8gaGlnaGVyIGxldmVsIGFsaWFzIChpbiBjYXNlIHlvdSBsaWtlIHRoZSB3b3JrZXIgbWV0YXBob3IpXG4gICQkLndvcmtlciA9ICQkLldvcmtlciA9ICQkLlRocmVhZDtcblxuICAvLyBwdWxsIGluIGV2ZW50IGFwaXNcbiAgJCQuZm4udGhyZWFkKHtcbiAgICBvbjogJCQuZGVmaW5lLm9uKCksXG4gICAgb25lOiAkJC5kZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICAgIG9mZjogJCQuZGVmaW5lLm9mZigpLCBcbiAgICB0cmlnZ2VyOiAkJC5kZWZpbmUudHJpZ2dlcigpXG4gIH0pO1xuXG4gICQkLmRlZmluZS5ldmVudEFsaWFzZXNPbiggJCQudGhkZm4gKTtcbiAgXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLkZhYnJpYyA9IGZ1bmN0aW9uKCBOICl7XG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLkZhYnJpYykgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuRmFicmljKCBOICk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIHBhc3M6IFtdXG4gICAgfTtcblxuICAgIHZhciBkZWZOID0gNDtcblxuICAgIGlmKCAkJC5pcy5udW1iZXIoTikgKXtcbiAgICAgIC8vIHRoZW4gdXNlIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRocmVhZHNcbiAgICB9IGlmKCB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSAhPSBudWxsICl7XG4gICAgICBOID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgfSBlbHNlIGlmKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyApe1xuICAgICAgTiA9IHJlcXVpcmUoJ29zJykuY3B1cygpLmxlbmd0aDtcbiAgICB9IGVsc2UgeyAvLyBUT0RPIGNvdWxkIHVzZSBhbiBlc3RpbWF0aW9uIGhlcmUgYnV0IHdvdWxkIHRoZSBhZGRpdGlvbmFsIGV4cGVuc2UgYmUgd29ydGggaXQ/XG4gICAgICBOID0gZGVmTjtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IE47IGkrKyApe1xuICAgICAgdGhpc1tpXSA9ICQkLlRocmVhZCgpO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTjtcbiAgfTtcblxuICAkJC5mYWJyaWMgPSAkJC5GYWJyaWM7XG4gICQkLmZhYmZuID0gJCQuRmFicmljLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxuICAkJC5mbi5mYWJyaWMgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIGZuTWFwICl7XG4gICAgICB2YXIgZm4gPSBmbk1hcFtuYW1lXTtcbiAgICAgICQkLkZhYnJpYy5wcm90b3R5cGVbIG5hbWUgXSA9IGZuO1xuICAgIH1cbiAgfTtcblxuICAkJC5mbi5mYWJyaWMoe1xuXG4gICAgLy8gcmVxdWlyZSBmbiBpbiBhbGwgdGhyZWFkc1xuICAgIHJlcXVpcmU6IGZ1bmN0aW9uKCBmbiwgYXMgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgdGhyZWFkID0gdGhpc1tpXTtcblxuICAgICAgICB0aHJlYWQucmVxdWlyZSggZm4sIGFzICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgYSByYW5kb20gdGhyZWFkXG4gICAgcmFuZG9tOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGkgPSBNYXRoLnJvdW5kKCAodGhpcy5sZW5ndGggLSAxKSAqIE1hdGgucmFuZG9tKCkgKTtcbiAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuXG4gICAgICByZXR1cm4gdGhyZWFkO1xuICAgIH0sXG5cbiAgICAvLyBydW4gb24gcmFuZG9tIHRocmVhZFxuICAgIHJ1bjogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgcGFzcyA9IHRoaXMuX3ByaXZhdGUucGFzcy5zaGlmdCgpO1xuXG4gICAgICByZXR1cm4gdGhpcy5yYW5kb20oKS5wYXNzKCBwYXNzICkucnVuKCBmbiApO1xuICAgIH0sXG5cbiAgICAvLyBzZW5kcyBhIHJhbmRvbSB0aHJlYWQgYSBtZXNzYWdlXG4gICAgbWVzc2FnZTogZnVuY3Rpb24oIG0gKXtcbiAgICAgIHJldHVybiB0aGlzLnJhbmRvbSgpLm1lc3NhZ2UoIG0gKTtcbiAgICB9LFxuXG4gICAgLy8gc2VuZCBhbGwgdGhyZWFkcyBhIG1lc3NhZ2VcbiAgICBicm9hZGNhc3Q6IGZ1bmN0aW9uKCBtICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHRocmVhZCA9IHRoaXNbaV07XG5cbiAgICAgICAgdGhyZWFkLm1lc3NhZ2UoIG0gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIHN0b3AgYWxsIHRocmVhZHNcbiAgICBzdG9wOiBmdW5jdGlvbigpe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuXG4gICAgICAgIHRocmVhZC5zdG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICAvLyBwYXNzIGRhdGEgdG8gYmUgdXNlZCB3aXRoIC5zcHJlYWQoKSBldGMuXG4gICAgcGFzczogZnVuY3Rpb24oIGRhdGEgKXtcbiAgICAgIHZhciBwYXNzID0gdGhpcy5fcHJpdmF0ZS5wYXNzO1xuXG4gICAgICBpZiggJCQuaXMuYXJyYXkoZGF0YSkgKXtcbiAgICAgICAgcGFzcy5wdXNoKCBkYXRhICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkJC51dGlsLmVycm9yKCdPbmx5IGFycmF5cyBvciBjb2xsZWN0aW9ucyBtYXkgYmUgdXNlZCB3aXRoIGZhYnJpYy5wYXNzKCknKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHNwcmVhZFNpemU6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgc3Vic2l6ZSA9ICBNYXRoLmNlaWwoIHRoaXMuX3ByaXZhdGUucGFzc1swXS5sZW5ndGggLyB0aGlzLmxlbmd0aCApO1xuXG4gICAgICBzdWJzaXplID0gTWF0aC5tYXgoIDEsIHN1YnNpemUgKTsgLy8gZG9uJ3QgcGFzcyBsZXNzIHRoYW4gb25lIGVsZSB0byBlYWNoIHRocmVhZFxuXG4gICAgICByZXR1cm4gc3Vic2l6ZTtcbiAgICB9LFxuXG4gICAgLy8gc3BsaXQgdGhlIGRhdGEgaW50byBzbGljZXMgdG8gc3ByZWFkIHRoZSBkYXRhIGVxdWFsbHkgYW1vbmcgdGhyZWFkc1xuICAgIHNwcmVhZDogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICAgICAgdmFyIHN1YnNpemUgPSBzZWxmLnNwcmVhZFNpemUoKTsgLy8gbnVtYmVyIG9mIHBhc3MgZWxlcyB0byBoYW5kbGUgaW4gZWFjaCB0aHJlYWRcbiAgICAgIHZhciBwYXNzID0gX3AucGFzcy5zaGlmdCgpLmNvbmNhdChbXSk7IC8vIGtlZXAgYSBjb3B5XG4gICAgICB2YXIgcnVuUHMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgc2xpY2UgPSBwYXNzLnNwbGljZSggMCwgc3Vic2l6ZSApO1xuXG4gICAgICAgIHZhciBydW5QID0gdGhyZWFkLnBhc3MoIHNsaWNlICkucnVuKCBmbiApO1xuXG4gICAgICAgIHJ1blBzLnB1c2goIHJ1blAgKTtcblxuICAgICAgICB2YXIgZG9uZUVhcmx5ID0gcGFzcy5sZW5ndGggPT09IDA7XG4gICAgICAgIGlmKCBkb25lRWFybHkgKXsgYnJlYWs7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQkLlByb21pc2UuYWxsKCBydW5QcyApLnRoZW4oZnVuY3Rpb24oIHRoZW5zICl7XG4gICAgICAgIHZhciBwb3N0cGFzcyA9IFtdO1xuICAgICAgICB2YXIgcCA9IDA7XG5cbiAgICAgICAgLy8gZmlsbCBwb3N0cGFzcyB3aXRoIHRoZSB0b3RhbCByZXN1bHQgam9pbmVkIGZyb20gYWxsIHRocmVhZHNcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGVucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciB0aGVuID0gdGhlbnNbaV07IC8vIGFycmF5IHJlc3VsdCBmcm9tIHRocmVhZCBpXG5cbiAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHRoZW4ubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciB0ID0gdGhlbltqXTsgLy8gYXJyYXkgZWxlbWVudFxuXG4gICAgICAgICAgICBwb3N0cGFzc1sgcCsrIF0gPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3N0cGFzcztcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBwYXJhbGxlbCB2ZXJzaW9uIG9mIGFycmF5Lm1hcCgpXG4gICAgbWFwOiBmdW5jdGlvbiggZm4gKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgc2VsZi5yZXF1aXJlKCBmbiwgJ18kXyRfZmFibWFwJyApO1xuXG4gICAgICByZXR1cm4gc2VsZi5zcHJlYWQoZnVuY3Rpb24oIHNwbGl0ICl7XG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgICAgdmFyIG9yaWdSZXNvbHZlID0gcmVzb2x2ZTtcblxuICAgICAgICByZXNvbHZlID0gZnVuY3Rpb24oIHZhbCApe1xuICAgICAgICAgIG1hcHBlZC5wdXNoKCB2YWwgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIG9sZExlbiA9IG1hcHBlZC5sZW5ndGg7XG4gICAgICAgICAgdmFyIHJldCA9IF8kXyRfZmFibWFwKCBzcGxpdFtpXSApO1xuICAgICAgICAgIHZhciBub3RoaW5nSW5zZEJ5UmVzb2x2ZSA9IG9sZExlbiA9PT0gbWFwcGVkLmxlbmd0aDtcblxuICAgICAgICAgIGlmKCBub3RoaW5nSW5zZEJ5UmVzb2x2ZSApe1xuICAgICAgICAgICAgbWFwcGVkLnB1c2goIHJldCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUgPSBvcmlnUmVzb2x2ZTtcblxuICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgICAgfSk7XG5cbiAgICB9LFxuXG4gICAgLy8gcGFyYWxsZWwgdmVyc2lvbiBvZiBhcnJheS5maWx0ZXIoKVxuICAgIGZpbHRlcjogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIHBhc3MgPSBfcC5wYXNzWzBdO1xuXG4gICAgICByZXR1cm4gdGhpcy5tYXAoIGZuICkudGhlbihmdW5jdGlvbiggaW5jbHVkZSApe1xuICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXNzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGRhdHVtID0gcGFzc1tpXTtcbiAgICAgICAgICB2YXIgaW5jRGF0dW0gPSBpbmNsdWRlW2ldO1xuXG4gICAgICAgICAgaWYoIGluY0RhdHVtICl7XG4gICAgICAgICAgICByZXQucHVzaCggZGF0dW0gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIHNvcnRzIHRoZSBwYXNzZWQgYXJyYXkgdXNpbmcgYSBkaXZpZGUgYW5kIGNvbnF1ZXIgc3RyYXRlZ3lcbiAgICBzb3J0OiBmdW5jdGlvbiggY21wICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgUCA9IHRoaXMuX3ByaXZhdGUucGFzc1swXS5sZW5ndGg7XG4gICAgICB2YXIgc3Vic2l6ZSA9IHRoaXMuc3ByZWFkU2l6ZSgpO1xuXG4gICAgICBjbXAgPSBjbXAgfHwgZnVuY3Rpb24oIGEsIGIgKXsgLy8gZGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uXG4gICAgICAgIGlmKCBhIDwgYiApe1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmKCBhID4gYiApe1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlcXVpcmUoIGNtcCwgJ18kXyRfY21wJyApO1xuXG4gICAgICByZXR1cm4gc2VsZi5zcHJlYWQoZnVuY3Rpb24oIHNwbGl0ICl7IC8vIHNvcnQgZWFjaCBzcGxpdCBub3JtYWxseVxuICAgICAgICB2YXIgc29ydGVkU3BsaXQgPSBzcGxpdC5zb3J0KCBfJF8kX2NtcCApO1xuICAgICAgICByZXNvbHZlKCBzb3J0ZWRTcGxpdCApO1xuXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKCBqb2luZWQgKXtcbiAgICAgICAgLy8gZG8gYWxsIHRoZSBtZXJnaW5nIGluIHRoZSBtYWluIHRocmVhZCB0byBtaW5pbWlzZSBkYXRhIHRyYW5zZmVyXG5cbiAgICAgICAgLy8gVE9ETyBjb3VsZCBkbyBtZXJnaW5nIGluIHNlcGFyYXRlIHRocmVhZHMgYnV0IHdvdWxkIGluY3VyIGFkZCdsIGNvc3Qgb2YgZGF0YSB0cmFuc2ZlclxuICAgICAgICAvLyBmb3IgZWFjaCBsZXZlbCBvZiB0aGUgbWVyZ2VcblxuICAgICAgICB2YXIgbWVyZ2UgPSBmdW5jdGlvbiggaSwgaiwgbWF4ICl7XG4gICAgICAgICAgLy8gZG9uJ3Qgb3ZlcmZsb3cgYXJyYXlcbiAgICAgICAgICBqID0gTWF0aC5taW4oIGosIFAgKTtcbiAgICAgICAgICBtYXggPSBNYXRoLm1pbiggbWF4LCBQICk7XG5cbiAgICAgICAgICAvLyBsZWZ0IGFuZCByaWdodCBzaWRlcyBvZiBtZXJnZVxuICAgICAgICAgIHZhciBsID0gaTtcbiAgICAgICAgICB2YXIgciA9IGo7XG5cbiAgICAgICAgICB2YXIgc29ydGVkID0gW107XG5cbiAgICAgICAgICBmb3IoIHZhciBrID0gbDsgayA8IG1heDsgaysrICl7XG5cbiAgICAgICAgICAgIHZhciBlbGVJID0gam9pbmVkW2ldO1xuICAgICAgICAgICAgdmFyIGVsZUogPSBqb2luZWRbal07XG5cbiAgICAgICAgICAgIGlmKCBpIDwgciAmJiAoIGogPj0gbWF4IHx8IGNtcChlbGVJLCBlbGVKKSA8PSAwICkgKXtcbiAgICAgICAgICAgICAgc29ydGVkLnB1c2goIGVsZUkgKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc29ydGVkLnB1c2goIGVsZUogKTtcbiAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaW4gdGhlIGFycmF5IHByb3BlciwgcHV0IHRoZSBzb3J0ZWQgdmFsdWVzXG4gICAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBzb3J0ZWQubGVuZ3RoOyBrKysgKXsgLy8ga3RoIHNvcnRlZCBpdGVtXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsICsgaztcblxuICAgICAgICAgICAgam9pbmVkWyBpbmRleCBdID0gc29ydGVkW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IoIHZhciBzcGxpdEwgPSBzdWJzaXplOyBzcGxpdEwgPCBQOyBzcGxpdEwgKj0gMiApeyAvLyBtZXJnZSB1bnRpbCBhcnJheSBpcyBcInNwbGl0XCIgYXMgMVxuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBQOyBpICs9IDIqc3BsaXRMICl7XG4gICAgICAgICAgICBtZXJnZSggaSwgaSArIHNwbGl0TCwgaSArIDIqc3BsaXRMICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gam9pbmVkO1xuICAgICAgfSk7XG4gICAgfVxuXG5cbiAgfSk7XG5cbiAgdmFyIGRlZmluZVJhbmRvbVBhc3NlciA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oIGZuLCBhcmcxICl7XG4gICAgICB2YXIgcGFzcyA9IHRoaXMuX3ByaXZhdGUucGFzcy5zaGlmdCgpO1xuXG4gICAgICByZXR1cm4gdGhpcy5yYW5kb20oKS5wYXNzKCBwYXNzIClbIG9wdHMudGhyZWFkRm4gXSggZm4sIGFyZzEgKTtcbiAgICB9O1xuICB9O1xuXG4gICQkLmZuLmZhYnJpYyh7XG4gICAgcmFuZG9tTWFwOiBkZWZpbmVSYW5kb21QYXNzZXIoeyB0aHJlYWRGbjogJ21hcCcgfSksXG5cbiAgICByZWR1Y2U6IGRlZmluZVJhbmRvbVBhc3Nlcih7IHRocmVhZEZuOiAncmVkdWNlJyB9KSxcblxuICAgIHJlZHVjZVJpZ2h0OiBkZWZpbmVSYW5kb21QYXNzZXIoeyB0aHJlYWRGbjogJ3JlZHVjZVJpZ2h0JyB9KVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gIHZhciBmbiA9ICQkLmZhYmZuO1xuICBmbi5wcm9taXNlID0gZm4ucnVuO1xuICBmbi50ZXJtaW5hdGUgPSBmbi5oYWx0ID0gZm4uc3RvcDtcbiAgZm4uaW5jbHVkZSA9IGZuLnJlcXVpcmU7XG5cbiAgLy8gcHVsbCBpbiBldmVudCBhcGlzXG4gICQkLmZuLmZhYnJpYyh7XG4gICAgb246ICQkLmRlZmluZS5vbigpLFxuICAgIG9uZTogJCQuZGVmaW5lLm9uKHsgdW5iaW5kU2VsZk9uVHJpZ2dlcjogdHJ1ZSB9KSxcbiAgICBvZmY6ICQkLmRlZmluZS5vZmYoKSxcbiAgICB0cmlnZ2VyOiAkJC5kZWZpbmUudHJpZ2dlcigpXG4gIH0pO1xuXG4gICQkLmRlZmluZS5ldmVudEFsaWFzZXNPbiggJCQuZmFiZm4gKTtcblxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cbjsoZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gIH07XG4gIFxuICB2YXIgb3JpZ0RlZmF1bHRzID0gJCQudXRpbC5jb3B5KCBkZWZhdWx0cyApO1xuXG4gICQkLmRlZmF1bHRzID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgICBkZWZhdWx0cyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBvcmlnRGVmYXVsdHMsIG9wdHMpO1xuICB9O1xuXG4gICQkLmZuLmNvcmUgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIGZuTWFwICl7XG4gICAgICB2YXIgZm4gPSBmbk1hcFtuYW1lXTtcbiAgICAgICQkLkNvcmUucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG4gIFxuICAkJC5Db3JlID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuQ29yZSkgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuQ29yZShvcHRzKTtcbiAgICB9XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIG9wdHMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdHMpO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyO1xuICAgIHZhciByZWcgPSBjb250YWluZXIgPyBjb250YWluZXIuX2N5cmVnIDogbnVsbDsgLy8gZS5nLiBhbHJlYWR5IHJlZ2lzdGVyZWQgc29tZSBpbmZvIChlLmcuIHJlYWRpZXMpIHZpYSBqcXVlcnlcbiAgICByZWcgPSByZWcgfHwge307XG5cbiAgICBpZiggcmVnICYmIHJlZy5jeSApeyBcbiAgICAgIGlmKCBjb250YWluZXIgKXtcbiAgICAgICAgd2hpbGUoIGNvbnRhaW5lci5maXJzdENoaWxkICl7IC8vIGNsZWFuIHRoZSBjb250YWluZXJcbiAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lci5maXJzdENoaWxkICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmVnLmN5Lm5vdGlmeSh7IHR5cGU6ICdkZXN0cm95JyB9KTsgLy8gZGVzdHJveSB0aGUgcmVuZGVyZXJcblxuICAgICAgcmVnID0ge307IC8vIG9sZCBpbnN0YW5jZSA9PiByZXBsYWNlIHJlZyBjb21wbGV0ZWx5XG4gICAgfVxuXG4gICAgdmFyIHJlYWRpZXMgPSByZWcucmVhZGllcyA9IHJlZy5yZWFkaWVzIHx8IFtdO1xuICAgIFxuICAgIGlmKCBjb250YWluZXIgKXsgY29udGFpbmVyLl9jeXJlZyA9IHJlZzsgfSAvLyBtYWtlIHN1cmUgY29udGFpbmVyIGFzc29jJ2QgcmVnIHBvaW50cyB0byB0aGlzIGN5XG4gICAgcmVnLmN5ID0gY3k7XG5cbiAgICB2YXIgaGVhZCA9IHdpbmRvdyAhPT0gdW5kZWZpbmVkICYmIGNvbnRhaW5lciAhPT0gdW5kZWZpbmVkICYmICFvcHRzLmhlYWRsZXNzO1xuICAgIHZhciBvcHRpb25zID0gb3B0cztcbiAgICBvcHRpb25zLmxheW91dCA9ICQkLnV0aWwuZXh0ZW5kKCB7IG5hbWU6IGhlYWQgPyAnZ3JpZCcgOiAnbnVsbCcgfSwgb3B0aW9ucy5sYXlvdXQgKTtcbiAgICBvcHRpb25zLnJlbmRlcmVyID0gJCQudXRpbC5leHRlbmQoIHsgbmFtZTogaGVhZCA/ICdjYW52YXMnIDogJ251bGwnIH0sIG9wdGlvbnMucmVuZGVyZXIgKTtcbiAgICBcbiAgICB2YXIgZGVmVmFsID0gZnVuY3Rpb24oIGRlZiwgdmFsLCBhbHRWYWwgKXtcbiAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSBlbHNlIGlmKCBhbHRWYWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gYWx0VmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGNvbnRhaW5lcjogb3B0aW9ucy5jb250YWluZXIsIC8vIGh0bWwgZG9tIGVsZSBjb250YWluZXJcbiAgICAgIHJlYWR5OiBmYWxzZSwgLy8gd2hldGhlciByZWFkeSBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICAgIGluaXRyZW5kZXI6IGZhbHNlLCAvLyBoYXMgaW5pdHJlbmRlciBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsIC8vIGNhY2hlZCBvcHRpb25zXG4gICAgICBlbGVtZW50czogW10sIC8vIGFycmF5IG9mIGVsZW1lbnRzXG4gICAgICBpZDJpbmRleDoge30sIC8vIGVsZW1lbnQgaWQgPT4gaW5kZXggaW4gZWxlbWVudHMgYXJyYXlcbiAgICAgIGxpc3RlbmVyczogW10sIC8vIGxpc3Qgb2YgbGlzdGVuZXJzXG4gICAgICBvblJlbmRlcnM6IFtdLCAvLyByZW5kZXJpbmcgbGlzdGVuZXJzXG4gICAgICBhbmlFbGVzOiAkJC5Db2xsZWN0aW9uKHRoaXMpLCAvLyBlbGVtZW50cyBiZWluZyBhbmltYXRlZFxuICAgICAgc2NyYXRjaDoge30sIC8vIHNjcmF0Y2ggb2JqZWN0IGZvciBjb3JlXG4gICAgICBsYXlvdXQ6IG51bGwsXG4gICAgICByZW5kZXJlcjogbnVsbCxcbiAgICAgIG5vdGlmaWNhdGlvbnNFbmFibGVkOiB0cnVlLCAvLyB3aGV0aGVyIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgdG8gdGhlIHJlbmRlcmVyXG4gICAgICBtaW5ab29tOiAxZS01MCxcbiAgICAgIG1heFpvb206IDFlNTAsXG4gICAgICB6b29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuem9vbWluZ0VuYWJsZWQpLFxuICAgICAgdXNlclpvb21pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy51c2VyWm9vbWluZ0VuYWJsZWQpLFxuICAgICAgcGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnBhbm5pbmdFbmFibGVkKSxcbiAgICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclBhbm5pbmdFbmFibGVkKSxcbiAgICAgIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5ib3hTZWxlY3Rpb25FbmFibGVkKSxcbiAgICAgIGF1dG9sb2NrOiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b2xvY2ssIG9wdGlvbnMuYXV0b2xvY2tOb2RlcyksXG4gICAgICBhdXRvdW5ncmFiaWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5Tm9kZXMpLFxuICAgICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3Vuc2VsZWN0aWZ5KSxcbiAgICAgIHN0eWxlRW5hYmxlZDogb3B0aW9ucy5zdHlsZUVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IGhlYWQgOiBvcHRpb25zLnN0eWxlRW5hYmxlZCxcbiAgICAgIHpvb206ICQkLmlzLm51bWJlcihvcHRpb25zLnpvb20pID8gb3B0aW9ucy56b29tIDogMSxcbiAgICAgIHBhbjoge1xuICAgICAgICB4OiAkJC5pcy5wbGFpbk9iamVjdChvcHRpb25zLnBhbikgJiYgJCQuaXMubnVtYmVyKG9wdGlvbnMucGFuLngpID8gb3B0aW9ucy5wYW4ueCA6IDAsXG4gICAgICAgIHk6ICQkLmlzLnBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiAkJC5pcy5udW1iZXIob3B0aW9ucy5wYW4ueSkgPyBvcHRpb25zLnBhbi55IDogMFxuICAgICAgfSxcbiAgICAgIGFuaW1hdGlvbjogeyAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgICAgY3VycmVudDogW10sXG4gICAgICAgIHF1ZXVlOiBbXVxuICAgICAgfSxcbiAgICAgIGhhc0NvbXBvdW5kTm9kZXM6IGZhbHNlLFxuICAgICAgZGVmZXJyZWRFeGVjUXVldWU6IFtdXG4gICAgfTtcblxuICAgIC8vIHNldCBzZWxlY3Rpb24gdHlwZVxuICAgIHZhciBzZWxUeXBlID0gb3B0aW9ucy5zZWxlY3Rpb25UeXBlO1xuICAgIGlmKCBzZWxUeXBlID09PSB1bmRlZmluZWQgfHwgKHNlbFR5cGUgIT09ICdhZGRpdGl2ZScgJiYgc2VsVHlwZSAhPT0gJ3NpbmdsZScpICl7XG4gICAgICAvLyB0aGVuIHNldCBkZWZhdWx0XG5cbiAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbiAgICB9IGVsc2Uge1xuICAgICAgX3Auc2VsZWN0aW9uVHlwZSA9IHNlbFR5cGU7XG4gICAgfVxuXG4gICAgLy8gaW5pdCB6b29tIGJvdW5kc1xuICAgIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5taW5ab29tKSAmJiAkJC5pcy5udW1iZXIob3B0aW9ucy5tYXhab29tKSAmJiBvcHRpb25zLm1pblpvb20gPCBvcHRpb25zLm1heFpvb20gKXtcbiAgICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gICAgICBfcC5tYXhab29tID0gb3B0aW9ucy5tYXhab29tO1xuICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKG9wdGlvbnMubWluWm9vbSkgJiYgb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5tYXhab29tKSAmJiBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgICAgX3AubWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbTtcbiAgICB9XG5cbiAgICB2YXIgbG9hZEV4dERhdGEgPSBmdW5jdGlvbiggbmV4dCApe1xuICAgICAgdmFyIGFueUlzUHJvbWlzZSA9IGZhbHNlO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV4dERhdGEubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGRhdHVtID0gZXh0RGF0YVtpXTtcblxuICAgICAgICBpZiggJCQuaXMucHJvbWlzZShkYXR1bSkgKXtcbiAgICAgICAgICBhbnlJc1Byb21pc2UgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBhbnlJc1Byb21pc2UgKXtcbiAgICAgICAgcmV0dXJuICQkLlByb21pc2UuYWxsKCBleHREYXRhICkudGhlbiggbmV4dCApOyAvLyBsb2FkIGFsbCBkYXRhIGFzeW5jaHJvbm91c2x5LCB0aGVuIGV4ZWMgcmVzdCBvZiBpbml0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KCBleHREYXRhICk7IC8vIGV4ZWMgc3luY2hyb25vdXNseSBmb3IgY29udmVuaWVuY2VcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGV4dERhdGEgPSBbIG9wdGlvbnMuc3R5bGUsIG9wdGlvbnMuZWxlbWVudHMgXTtcbiAgICBsb2FkRXh0RGF0YShmdW5jdGlvbiggdGhlbnMgKXtcbiAgICAgIHZhciBpbml0U3R5bGUgPSB0aGVuc1swXTtcbiAgICAgIHZhciBpbml0RWxlcyA9IHRoZW5zWzFdO1xuICAgXG4gICAgICAvLyBpbml0IHN0eWxlXG4gICAgICBpZiggX3Auc3R5bGVFbmFibGVkICl7XG4gICAgICAgIGN5LnNldFN0eWxlKCBpbml0U3R5bGUgKTtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIHRoZSByZW5kZXJlclxuICAgICAgY3kuaW5pdFJlbmRlcmVyKCAkJC51dGlsLmV4dGVuZCh7XG4gICAgICAgIGhpZGVFZGdlc09uVmlld3BvcnQ6IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydCxcbiAgICAgICAgaGlkZUxhYmVsc09uVmlld3BvcnQ6IG9wdGlvbnMuaGlkZUxhYmVsc09uVmlld3BvcnQsXG4gICAgICAgIHRleHR1cmVPblZpZXdwb3J0OiBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0LFxuICAgICAgICB3aGVlbFNlbnNpdGl2aXR5OiAkJC5pcy5udW1iZXIob3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5KSAmJiBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgPiAwID8gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5IDogMSxcbiAgICAgICAgbW90aW9uQmx1cjogb3B0aW9ucy5tb3Rpb25CbHVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5tb3Rpb25CbHVyLCAvLyBvbiBieSBkZWZhdWx0XG4gICAgICAgIG1vdGlvbkJsdXJPcGFjaXR5OiBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5ID09PSB1bmRlZmluZWQgPyAwLjA1IDogb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eSxcbiAgICAgICAgcGl4ZWxSYXRpbzogJCQuaXMubnVtYmVyKG9wdGlvbnMucGl4ZWxSYXRpbykgJiYgb3B0aW9ucy5waXhlbFJhdGlvID4gMCA/IG9wdGlvbnMucGl4ZWxSYXRpbyA6IChvcHRpb25zLnBpeGVsUmF0aW8gPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IDEpLFxuICAgICAgICBkZXNrdG9wVGFwVGhyZXNob2xkOiBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQgPT09IHVuZGVmaW5lZCA/IDQgOiBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQsXG4gICAgICAgIHRvdWNoVGFwVGhyZXNob2xkOiBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkID09PSB1bmRlZmluZWQgPyA4IDogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZFxuICAgICAgfSwgb3B0aW9ucy5yZW5kZXJlcikgKTtcblxuICAgICAgLy8gdHJpZ2dlciB0aGUgcGFzc2VkIGZ1bmN0aW9uIGZvciB0aGUgYGluaXRyZW5kZXJgIGV2ZW50XG4gICAgICBpZiggb3B0aW9ucy5pbml0cmVuZGVyICl7XG4gICAgICAgIGN5Lm9uKCdpbml0cmVuZGVyJywgb3B0aW9ucy5pbml0cmVuZGVyKTtcbiAgICAgICAgY3kub24oJ2luaXRyZW5kZXInLCBmdW5jdGlvbigpe1xuICAgICAgICAgIGN5Ll9wcml2YXRlLmluaXRyZW5kZXIgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gaW5pdGlhbCBsb2FkXG4gICAgICBjeS5sb2FkKGluaXRFbGVzLCBmdW5jdGlvbigpeyAvLyBvbnJlYWR5XG4gICAgICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgICAgICBjeS5fcHJpdmF0ZS5yZWFkeSA9IHRydWU7XG5cbiAgICAgICAgLy8gaWYgYSByZWFkeSBjYWxsYmFjayBpcyBzcGVjaWZpZWQgYXMgYW4gb3B0aW9uLCB0aGUgYmluZCBpdFxuICAgICAgICBpZiggJCQuaXMuZm4oIG9wdGlvbnMucmVhZHkgKSApe1xuICAgICAgICAgIGN5Lm9uKCdyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBhbGwgdGhlIHJlYWR5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgYmVmb3JlIGNyZWF0aW5nIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCByZWFkaWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGZuID0gcmVhZGllc1tpXTtcbiAgICAgICAgICBjeS5vbigncmVhZHknLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIHJlZyApeyByZWcucmVhZGllcyA9IFtdOyB9IC8vIGNsZWFyIGIvYyB3ZSd2ZSBib3VuZCB0aGVtIGFsbCBhbmQgZG9uJ3Qgd2FudCB0byBrZWVwIGl0IGFyb3VuZCBpbiBjYXNlIGEgbmV3IGNvcmUgdXNlcyB0aGUgc2FtZSBkaXYgZXRjXG4gICAgICAgIFxuICAgICAgICBjeS50cmlnZ2VyKCdyZWFkeScpO1xuICAgICAgfSwgb3B0aW9ucy5kb25lKTtcblxuICAgIH0pO1xuICB9O1xuXG4gICQkLmNvcmVmbiA9ICQkLkNvcmUucHJvdG90eXBlOyAvLyBzaG9ydCBhbGlhc1xuICBcblxuICAkJC5mbi5jb3JlKHtcbiAgICBpc1JlYWR5OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVhZHk7XG4gICAgfSxcblxuICAgIHJlYWR5OiBmdW5jdGlvbiggZm4gKXtcbiAgICAgIGlmKCB0aGlzLmlzUmVhZHkoKSApe1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlYWR5JywgW10sIGZuKTsgLy8ganVzdCBjYWxscyBmbiBhcyB0aG91Z2ggdHJpZ2dlcmVkIHZpYSByZWFkeSBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbigncmVhZHknLCBmbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluaXRyZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5pbml0cmVuZGVyO1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5ub3RpZnkoeyB0eXBlOiAnZGVzdHJveScgfSk7IC8vIGRlc3Ryb3kgdGhlIHJlbmRlcmVyXG5cbiAgICAgIHZhciBkb21FbGUgPSB0aGlzLmNvbnRhaW5lcigpO1xuICAgICAgdmFyIHBhckVsZSA9IGRvbUVsZS5wYXJlbnROb2RlO1xuICAgICAgaWYoIHBhckVsZSApe1xuICAgICAgICBwYXJFbGUucmVtb3ZlQ2hpbGQoIGRvbUVsZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0RWxlbWVudEJ5SWQ6IGZ1bmN0aW9uKCBpZCApe1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fcHJpdmF0ZS5pZDJpbmRleFsgaWQgXTtcbiAgICAgIGlmKCBpbmRleCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzWyBpbmRleCBdO1xuICAgICAgfVxuXG4gICAgICAvLyB3b3JzdCBjYXNlLCByZXR1cm4gYW4gZW1wdHkgY29sbGVjdGlvblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzICk7XG4gICAgfSxcblxuICAgIHNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zZWxlY3Rpb25UeXBlO1xuICAgIH0sXG5cbiAgICBoYXNDb21wb3VuZE5vZGVzOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcztcbiAgICB9LFxuXG4gICAgc3R5bGVFbmFibGVkOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuICAgIH0sXG5cbiAgICBhZGRUb1Bvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuICAgICAgdmFyIGlkMmluZGV4ID0gdGhpcy5fcHJpdmF0ZS5pZDJpbmRleDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgaW5kZXggPSBpZDJpbmRleFsgaWQgXTtcbiAgICAgICAgdmFyIGFscmVhZHlJblBvb2wgPSBpbmRleCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmKCAhYWxyZWFkeUluUG9vbCApe1xuICAgICAgICAgIGluZGV4ID0gZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZSApO1xuICAgICAgICAgIGlkMmluZGV4WyBpZCBdID0gaW5kZXg7XG4gICAgICAgICAgZWxlLl9wcml2YXRlLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHJlbW92ZUZyb21Qb29sOiBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICAgIHZhciBpZDJpbmRleCA9IHRoaXMuX3ByaXZhdGUuaWQyaW5kZXg7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluZGV4ID0gaWQyaW5kZXhbIGlkIF07XG4gICAgICAgIHZhciBpblBvb2wgPSBpbmRleCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmKCBpblBvb2wgKXtcbiAgICAgICAgICB0aGlzLl9wcml2YXRlLmlkMmluZGV4WyBpZCBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGVsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGluZGV4IG9mIGFsbCBlbGVtZW50cyBwYXN0IHRoaXMgaW5kZXhcbiAgICAgICAgICBmb3IoIHZhciBqID0gaW5kZXg7IGogPCBlbGVtZW50cy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgdmFyIGppZCA9IGVsZW1lbnRzW2pdLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgICAgICBpZDJpbmRleFsgamlkIF0tLTtcbiAgICAgICAgICAgIGVsZW1lbnRzW2pdLl9wcml2YXRlLmluZGV4LS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgb3B0aW9uczogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiAkJC51dGlsLmNvcHkoIHRoaXMuX3ByaXZhdGUub3B0aW9ucyApO1xuICAgIH0sXG4gICAgXG4gICAganNvbjogZnVuY3Rpb24ocGFyYW1zKXtcbiAgICAgIHZhciBqc29uID0ge307XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgXG4gICAgICBqc29uLmVsZW1lbnRzID0ge307XG4gICAgICBjeS5lbGVtZW50cygpLmVhY2goZnVuY3Rpb24oaSwgZWxlKXtcbiAgICAgICAgdmFyIGdyb3VwID0gZWxlLmdyb3VwKCk7XG4gICAgICAgIFxuICAgICAgICBpZiggIWpzb24uZWxlbWVudHNbZ3JvdXBdICl7XG4gICAgICAgICAganNvbi5lbGVtZW50c1tncm91cF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAganNvbi5lbGVtZW50c1tncm91cF0ucHVzaCggZWxlLmpzb24oKSApO1xuICAgICAgfSk7XG5cbiAgICAgIGlmKCB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZCApe1xuICAgICAgICBqc29uLnN0eWxlID0gY3kuc3R5bGUoKS5qc29uKCk7XG4gICAgICB9XG5cbiAgICAgIGpzb24uem9vbWluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS56b29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclpvb21pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi56b29tID0gY3kuX3ByaXZhdGUuem9vbTtcbiAgICAgIGpzb24ubWluWm9vbSA9IGN5Ll9wcml2YXRlLm1pblpvb207XG4gICAgICBqc29uLm1heFpvb20gPSBjeS5fcHJpdmF0ZS5tYXhab29tO1xuICAgICAganNvbi5wYW5uaW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyUGFubmluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnBhbiA9IGN5Ll9wcml2YXRlLnBhbjtcbiAgICAgIGpzb24uYm94U2VsZWN0aW9uRW5hYmxlZCA9IGN5Ll9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICBqc29uLmxheW91dCA9IGN5Ll9wcml2YXRlLm9wdGlvbnMubGF5b3V0O1xuICAgICAganNvbi5yZW5kZXJlciA9IGN5Ll9wcml2YXRlLm9wdGlvbnMucmVuZGVyZXI7XG4gICAgICBqc29uLmhpZGVFZGdlc09uVmlld3BvcnQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgICBqc29uLmhpZGVMYWJlbHNPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy5oaWRlTGFiZWxzT25WaWV3cG9ydDtcbiAgICAgIGpzb24udGV4dHVyZU9uVmlld3BvcnQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgICAganNvbi53aGVlbFNlbnNpdGl2aXR5ID0gY3kuX3ByaXZhdGUub3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAganNvbi5tb3Rpb25CbHVyID0gY3kuX3ByaXZhdGUub3B0aW9ucy5tb3Rpb25CbHVyO1xuICAgICAgXG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuXG4gICAgLy8gZGVmZXIgZXhlY3V0aW9uIHVudGlsIG5vdCBidXN5IGFuZCBndWFyYW50ZWUgcmVsYXRpdmUgZXhlY3V0aW9uIG9yZGVyIG9mIGRlZmVycmVkIGZ1bmN0aW9uc1xuICAgIGRlZmVyOiBmdW5jdGlvbiggZm4gKXtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICB2YXIgX3AgPSBjeS5fcHJpdmF0ZTtcbiAgICAgIHZhciBxID0gX3AuZGVmZXJyZWRFeGVjUXVldWU7XG5cbiAgICAgIHEucHVzaCggZm4gKTtcblxuICAgICAgaWYoICFfcC5kZWZlcnJlZFRpbWVvdXQgKXtcbiAgICAgICAgX3AuZGVmZXJyZWRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHdoaWxlKCBxLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgICggcS5zaGlmdCgpICkoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfcC5kZWZlcnJlZFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gIH0pOyAgXG4gIFxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cbihmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIHJlYWR5KGYpIHtcbiAgICB2YXIgZm4gPSAoIGRvY3VtZW50ICYmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpICkgID8gZiA6IHJlYWR5O1xuXG4gICAgc2V0VGltZW91dChmbiwgOSwgZik7XG4gIH1cblxuICAkJC5mbi5jb3JlKHtcbiAgICBhZGQ6IGZ1bmN0aW9uKG9wdHMpe1xuICAgICAgXG4gICAgICB2YXIgZWxlbWVudHM7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgXG4gICAgICAvLyBhZGQgdGhlIGVsZW1lbnRzXG4gICAgICBpZiggJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihvcHRzKSApe1xuICAgICAgICB2YXIgZWxlcyA9IG9wdHM7XG5cbiAgICAgICAgaWYoIGVsZXMuX3ByaXZhdGUuY3kgPT09IGN5ICl7IC8vIHNhbWUgaW5zdGFuY2UgPT4ganVzdCByZXN0b3JlXG4gICAgICAgICAgZWxlbWVudHMgPSBlbGVzLnJlc3RvcmUoKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIGNvcHkgZnJvbSBqc29uXG4gICAgICAgICAgdmFyIGpzb25zID0gW107XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgICAganNvbnMucHVzaCggZWxlLmpzb24oKSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnRzID0gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBqc29ucyApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIHNwZWNpZnkgYW4gYXJyYXkgb2Ygb3B0aW9uc1xuICAgICAgZWxzZSBpZiggJCQuaXMuYXJyYXkob3B0cykgKXtcbiAgICAgICAgdmFyIGpzb25zID0gb3B0cztcblxuICAgICAgICBlbGVtZW50cyA9IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBqc29ucyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIHNwZWNpZnkgdmlhIG9wdHMubm9kZXMgYW5kIG9wdHMuZWRnZXNcbiAgICAgIGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG9wdHMpICYmICgkJC5pcy5hcnJheShvcHRzLm5vZGVzKSB8fCAkJC5pcy5hcnJheShvcHRzLmVkZ2VzKSkgKXtcbiAgICAgICAgdmFyIGVsZXNCeUdyb3VwID0gb3B0cztcbiAgICAgICAgdmFyIGpzb25zID0gW107XG5cbiAgICAgICAgdmFyIGdycyA9IFsnbm9kZXMnLCAnZWRnZXMnXTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDAsIGlsID0gZ3JzLmxlbmd0aDsgaSA8IGlsOyBpKysgKXtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSBncnNbaV07XG4gICAgICAgICAgdmFyIGVsZXNBcnJheSA9IGVsZXNCeUdyb3VwW2dyb3VwXTtcblxuICAgICAgICAgIGlmKCAkJC5pcy5hcnJheShlbGVzQXJyYXkpICl7XG5cbiAgICAgICAgICAgIGZvciggdmFyIGogPSAwLCBqbCA9IGVsZXNBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrICl7XG4gICAgICAgICAgICAgIHZhciBqc29uID0gZWxlc0FycmF5W2pdO1xuICAgICAgICAgICAgICBqc29uLmdyb3VwID0gZ3JvdXA7XG5cbiAgICAgICAgICAgICAganNvbnMucHVzaCgganNvbiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gXG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cyA9IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBqc29ucyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIHNwZWNpZnkgb3B0aW9ucyBmb3Igb25lIGVsZW1lbnRcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIganNvbiA9IG9wdHM7XG4gICAgICAgIGVsZW1lbnRzID0gKG5ldyAkJC5FbGVtZW50KCBjeSwganNvbiApKS5jb2xsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuICAgIFxuICAgIHJlbW92ZTogZnVuY3Rpb24oY29sbGVjdGlvbil7XG4gICAgICBpZiggJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihjb2xsZWN0aW9uKSApe1xuICAgICAgICBjb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKGNvbGxlY3Rpb24pICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IGNvbGxlY3Rpb247XG4gICAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLiQoIHNlbGVjdG9yICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZSgpO1xuICAgIH0sXG4gICAgXG4gICAgbG9hZDogZnVuY3Rpb24oZWxlbWVudHMsIG9ubG9hZCwgb25kb25lKXtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICBcbiAgICAgIGN5Lm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuXG4gICAgICAvLyByZW1vdmUgb2xkIGVsZW1lbnRzXG4gICAgICB2YXIgb2xkRWxlcyA9IGN5LmVsZW1lbnRzKCk7XG4gICAgICBpZiggb2xkRWxlcy5sZW5ndGggPiAwICl7XG4gICAgICAgIG9sZEVsZXMucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBlbGVtZW50cyAhPSBudWxsICl7XG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChlbGVtZW50cykgfHwgJCQuaXMuYXJyYXkoZWxlbWVudHMpICl7XG4gICAgICAgICAgY3kuYWRkKCBlbGVtZW50cyApO1xuICAgICAgICB9IFxuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBjYWxsYmFjaygpeyAgICAgICAgXG4gICAgICAgIGN5Lm9uZSgnbGF5b3V0cmVhZHknLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICBjeS5ub3RpZmljYXRpb25zKHRydWUpO1xuICAgICAgICAgIGN5LnRyaWdnZXIoZSk7IC8vIHdlIG1pc3NlZCB0aGlzIGV2ZW50IGJ5IHR1cm5pbmcgbm90aWZpY2F0aW9ucyBvZmYsIHNvIHBhc3MgaXQgb25cblxuICAgICAgICAgIGN5Lm5vdGlmeSh7XG4gICAgICAgICAgICB0eXBlOiAnbG9hZCcsXG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBjeS5lbGVtZW50cygpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjeS5vbmUoJ2xvYWQnLCBvbmxvYWQpO1xuICAgICAgICAgIGN5LnRyaWdnZXIoJ2xvYWQnKTtcbiAgICAgICAgfSkub25lKCdsYXlvdXRzdG9wJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICBjeS5vbmUoJ2RvbmUnLCBvbmRvbmUpO1xuICAgICAgICAgIGN5LnRyaWdnZXIoJ2RvbmUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgbGF5b3V0T3B0cyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBjeS5fcHJpdmF0ZS5vcHRpb25zLmxheW91dCk7XG4gICAgICAgIGxheW91dE9wdHMuZWxlcyA9IGN5LiQoKTtcblxuICAgICAgICBjeS5sYXlvdXQoIGxheW91dE9wdHMgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiggd2luZG93ICl7XG4gICAgICAgIHJlYWR5KCBjYWxsYmFjayApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uY29yZSh7XG4gICAgXG4gICAgLy8gcHVsbCBpbiBhbmltYXRpb24gZnVuY3Rpb25zXG4gICAgYW5pbWF0ZWQ6ICQkLmRlZmluZS5hbmltYXRlZCgpLFxuICAgIGNsZWFyUXVldWU6ICQkLmRlZmluZS5jbGVhclF1ZXVlKCksXG4gICAgZGVsYXk6ICQkLmRlZmluZS5kZWxheSgpLFxuICAgIGFuaW1hdGU6ICQkLmRlZmluZS5hbmltYXRlKCksXG4gICAgc3RvcDogJCQuZGVmaW5lLnN0b3AoKSxcblxuICAgIGFkZFRvQW5pbWF0aW9uUG9vbDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuOyB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuICAgICAgXG4gICAgICBjeS5fcHJpdmF0ZS5hbmlFbGVzLm1lcmdlKCBlbGVzICk7XG4gICAgfSxcblxuICAgIHN0YXJ0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuOyB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuXG4gICAgICAvLyBkb24ndCBleGVjdXRlIHRoZSBhbmltYXRpb24gbG9vcCBpbiBoZWFkbGVzcyBlbnZpcm9ubWVudHNcbiAgICAgIGlmKCAhd2luZG93ICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gZ2xvYmFsQW5pbWF0aW9uU3RlcCgpe1xuICAgICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbihub3cpe1xuICAgICAgICAgIGhhbmRsZUVsZW1lbnRzKG5vdyk7XG4gICAgICAgICAgZ2xvYmFsQW5pbWF0aW9uU3RlcCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZ2xvYmFsQW5pbWF0aW9uU3RlcCgpOyAvLyBmaXJzdCBjYWxsXG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnRzKG5vdyl7XG4gICAgICAgIG5vdyA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuYW5pRWxlcztcbiAgICAgICAgdmFyIGRvbmVFbGVzID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRWxlbWVudCggZWxlLCBpc0NvcmUgKXtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudDtcbiAgICAgICAgICB2YXIgcXVldWUgPSBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlO1xuICAgICAgICAgIHZhciByYW5BbmlzID0gZmFsc2U7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gaWYgbm90aGluZyBjdXJyZW50bHkgYW5pbWF0aW5nLCBnZXQgc29tZXRoaW5nIGZyb20gdGhlIHF1ZXVlXG4gICAgICAgICAgaWYoIGN1cnJlbnQubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHF1ZXVlLmxlbmd0aCA+IDAgPyBxdWV1ZS5zaGlmdCgpIDogbnVsbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIG5leHQgKXtcbiAgICAgICAgICAgICAgbmV4dC5jYWxsVGltZSA9IG5vdzsgLy8gd2FzIHF1ZXVlZCwgc28gdXBkYXRlIGNhbGwgdGltZVxuICAgICAgICAgICAgICBjdXJyZW50LnB1c2goIG5leHQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gc3RlcCBhbmQgcmVtb3ZlIGlmIGRvbmVcbiAgICAgICAgICB2YXIgY29tcGxldGVzID0gW107XG4gICAgICAgICAgZm9yKHZhciBpID0gY3VycmVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICAgICAgICB2YXIgYW5pID0gY3VycmVudFtpXTtcblxuICAgICAgICAgICAgLy8gc3RhcnQgaWYgbmVlZCBiZVxuICAgICAgICAgICAgaWYoICFhbmkuc3RhcnRlZCApeyBzdGFydEFuaW1hdGlvbiggZWxlLCBhbmkgKTsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdGVwKCBlbGUsIGFuaSwgbm93LCBpc0NvcmUgKTtcblxuICAgICAgICAgICAgaWYoIGFuaS5kb25lICl7XG4gICAgICAgICAgICAgIGNvbXBsZXRlcy5wdXNoKCBhbmkgKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW50W2ldXG4gICAgICAgICAgICAgIGN1cnJlbnQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByYW5BbmlzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gY2FsbCBjb21wbGV0ZSBjYWxsYmFja3NcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbXBsZXRlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGFuaSA9IGNvbXBsZXRlc1tpXTtcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IGFuaS5wYXJhbXMuY29tcGxldGU7XG5cbiAgICAgICAgICAgIGlmKCAkJC5pcy5mbihjb21wbGV0ZSkgKXtcbiAgICAgICAgICAgICAgY29tcGxldGUuYXBwbHkoIGVsZSwgWyBub3cgXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhaXNDb3JlICYmIGN1cnJlbnQubGVuZ3RoID09PSAwICYmIHF1ZXVlLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgICAgZG9uZUVsZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJhbkFuaXM7XG4gICAgICAgIH0gLy8gaGFuZGxlRWxlbWVudHNcblxuICAgICAgICAvLyBoYW5kbGUgYWxsIGVsZXNcbiAgICAgICAgZm9yKCB2YXIgZSA9IDA7IGUgPCBlbGVzLmxlbmd0aDsgZSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbZV07XG4gICAgICAgICAgXG4gICAgICAgICAgaGFuZGxlRWxlbWVudCggZWxlICk7XG4gICAgICAgIH0gLy8gZWFjaCBlbGVtZW50XG5cbiAgICAgICAgdmFyIHJhbkNvcmVBbmkgPSBoYW5kbGVFbGVtZW50KCBjeSwgdHJ1ZSApO1xuICAgICAgICBcbiAgICAgICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgICAgIGlmKCBlbGVzLmxlbmd0aCA+IDAgfHwgcmFuQ29yZUFuaSApe1xuICAgICAgICAgIHZhciB0b05vdGlmeTtcblxuICAgICAgICAgIGlmKCBlbGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIHZhciB1cGRhdGVkRWxlcyA9IGVsZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICAgIHRvTm90aWZ5ID0gdXBkYXRlZEVsZXMubGVuZ3RoID4gMCA/IGVsZXMuYWRkKCB1cGRhdGVkRWxlcyApIDogZWxlcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjeS5ub3RpZnkoe1xuICAgICAgICAgICAgdHlwZTogJ2RyYXcnLFxuICAgICAgICAgICAgY29sbGVjdGlvbjogdG9Ob3RpZnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBlbGVtZW50cyBmcm9tIGxpc3Qgb2YgY3VycmVudGx5IGFuaW1hdGluZyBpZiBpdHMgcXVldWVzIGFyZSBlbXB0eVxuICAgICAgICBlbGVzLnVubWVyZ2UoIGRvbmVFbGVzICk7XG5cbiAgICAgIH0gLy8gaGFuZGxlRWxlbWVudHNcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oIHNlbGYsIGFuaSApe1xuICAgICAgICB2YXIgaXNDb3JlID0gJCQuaXMuY29yZSggc2VsZiApO1xuICAgICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgICAgICAgdmFyIGVsZSA9IHNlbGY7XG4gICAgICAgIHZhciBzdHlsZSA9IGN5Ll9wcml2YXRlLnN0eWxlO1xuXG4gICAgICAgIGlmKCBpc0VsZXMgKXtcbiAgICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgICB5OiBwb3MueVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHN0YXJ0U3R5bGUgPSBzdHlsZS5nZXRWYWx1ZVN0eWxlKCBlbGUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBpc0NvcmUgKXtcbiAgICAgICAgICB2YXIgcGFuID0gY3kuX3ByaXZhdGUucGFuO1xuICAgICAgICAgIHZhciBzdGFydFBhbiA9IHtcbiAgICAgICAgICAgIHg6IHBhbi54LFxuICAgICAgICAgICAgeTogcGFuLnlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHN0YXJ0Wm9vbSA9IGN5Ll9wcml2YXRlLnpvb207XG4gICAgICAgIH1cblxuICAgICAgICBhbmkuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIGFuaS5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBhbmkuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIGFuaS5zdGFydFN0eWxlID0gc3RhcnRTdHlsZTtcbiAgICAgICAgYW5pLnN0YXJ0UGFuID0gc3RhcnRQYW47XG4gICAgICAgIGFuaS5zdGFydFpvb20gPSBzdGFydFpvb207XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXAoIHNlbGYsIGFuaW1hdGlvbiwgbm93LCBpc0NvcmUgKXtcbiAgICAgICAgdmFyIHN0eWxlID0gY3kuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gYW5pbWF0aW9uLnByb3BlcnRpZXM7XG4gICAgICAgIHZhciBwYXJhbXMgPSBhbmltYXRpb24ucGFyYW1zO1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gYW5pbWF0aW9uLnN0YXJ0VGltZTtcbiAgICAgICAgdmFyIHBlcmNlbnQ7XG4gICAgICAgIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuICAgICAgICBcbiAgICAgICAgaWYoIGFuaW1hdGlvbi5kdXJhdGlvbiA9PT0gMCApe1xuICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlcmNlbnQgPSBNYXRoLm1pbigxLCAobm93IC0gc3RhcnRUaW1lKS9hbmltYXRpb24uZHVyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHBlcmNlbnQgPCAwICl7XG4gICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiggcGVyY2VudCA+IDEgKXtcbiAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIHByb3BlcnRpZXMuZGVsYXkgPT0gbnVsbCApeyAvLyB0aGVuIHVwZGF0ZVxuXG4gICAgICAgICAgdmFyIHN0YXJ0UG9zID0gYW5pbWF0aW9uLnN0YXJ0UG9zaXRpb247XG4gICAgICAgICAgdmFyIGVuZFBvcyA9IHByb3BlcnRpZXMucG9zaXRpb247XG4gICAgICAgICAgdmFyIHBvcyA9IHNlbGYuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgaWYoIGVuZFBvcyAmJiBpc0VsZXMgKXtcbiAgICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQb3MueCwgZW5kUG9zLnggKSApe1xuICAgICAgICAgICAgICBwb3MueCA9IGVhc2UoIHN0YXJ0UG9zLngsIGVuZFBvcy54LCBwZXJjZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQb3MueSwgZW5kUG9zLnkgKSApe1xuICAgICAgICAgICAgICBwb3MueSA9IGVhc2UoIHN0YXJ0UG9zLnksIGVuZFBvcy55LCBwZXJjZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0UGFuID0gYW5pbWF0aW9uLnN0YXJ0UGFuO1xuICAgICAgICAgIHZhciBlbmRQYW4gPSBwcm9wZXJ0aWVzLnBhbjtcbiAgICAgICAgICB2YXIgcGFuID0gc2VsZi5fcHJpdmF0ZS5wYW47XG4gICAgICAgICAgdmFyIGFuaW1hdGluZ1BhbiA9IGVuZFBhbiAhPSBudWxsICYmIGlzQ29yZTtcbiAgICAgICAgICBpZiggYW5pbWF0aW5nUGFuICl7XG4gICAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UGFuLngsIGVuZFBhbi54ICkgKXtcbiAgICAgICAgICAgICAgcGFuLnggPSBlYXNlKCBzdGFydFBhbi54LCBlbmRQYW4ueCwgcGVyY2VudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UGFuLnksIGVuZFBhbi55ICkgKXtcbiAgICAgICAgICAgICAgcGFuLnkgPSBlYXNlKCBzdGFydFBhbi55LCBlbmRQYW4ueSwgcGVyY2VudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3BhbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydFpvb20gPSBhbmltYXRpb24uc3RhcnRab29tO1xuICAgICAgICAgIHZhciBlbmRab29tID0gcHJvcGVydGllcy56b29tO1xuICAgICAgICAgIHZhciBhbmltYXRpbmdab29tID0gZW5kWm9vbSAhPSBudWxsICYmIGlzQ29yZTtcbiAgICAgICAgICBpZiggYW5pbWF0aW5nWm9vbSApe1xuICAgICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFpvb20sIGVuZFpvb20gKSApe1xuICAgICAgICAgICAgICBzZWxmLl9wcml2YXRlLnpvb20gPSBlYXNlKCBzdGFydFpvb20sIGVuZFpvb20sIHBlcmNlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd6b29tJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGFuaW1hdGluZ1BhbiB8fCBhbmltYXRpbmdab29tICl7XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXdwb3J0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByb3BzID0gcHJvcGVydGllcy5zdHlsZSB8fCBwcm9wZXJ0aWVzLmNzcztcbiAgICAgICAgICBpZiggcHJvcHMgJiYgaXNFbGVzICl7XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXS5uYW1lO1xuICAgICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICAgICAgICB2YXIgZW5kID0gcHJvcDtcblxuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBhbmltYXRpb24uc3RhcnRTdHlsZVsgbmFtZSBdO1xuICAgICAgICAgICAgICB2YXIgZWFzZWRWYWwgPSBlYXNlKCBzdGFydCwgZW5kLCBwZXJjZW50ICk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzdHlsZS5vdmVycmlkZUJ5cGFzcyggc2VsZiwgbmFtZSwgZWFzZWRWYWwgKTtcbiAgICAgICAgICAgIH0gLy8gZm9yIHByb3BzXG4gICAgICAgICAgICBcbiAgICAgICAgICB9IC8vIGlmIFxuXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCAkJC5pcy5mbihwYXJhbXMuc3RlcCkgKXtcbiAgICAgICAgICBwYXJhbXMuc3RlcC5hcHBseSggc2VsZiwgWyBub3cgXSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggcGVyY2VudCA+PSAxICl7XG4gICAgICAgICAgYW5pbWF0aW9uLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcGVyY2VudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gdmFsaWQoc3RhcnQsIGVuZCl7XG4gICAgICAgIGlmKCBzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsICl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggJCQuaXMubnVtYmVyKHN0YXJ0KSAmJiAkJC5pcy5udW1iZXIoZW5kKSApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYoIChzdGFydCkgJiYgKGVuZCkgKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBlYXNlKHN0YXJ0UHJvcCwgZW5kUHJvcCwgcGVyY2VudCl7XG4gICAgICAgIGlmKCBwZXJjZW50IDwgMCApe1xuICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYoIHBlcmNlbnQgPiAxICl7XG4gICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnQsIGVuZDtcblxuICAgICAgICBpZiggc3RhcnRQcm9wLnB4VmFsdWUgIT0gbnVsbCB8fCBzdGFydFByb3AudmFsdWUgIT0gbnVsbCApe1xuICAgICAgICAgIHN0YXJ0ID0gc3RhcnRQcm9wLnB4VmFsdWUgIT0gbnVsbCA/IHN0YXJ0UHJvcC5weFZhbHVlIDogc3RhcnRQcm9wLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0ID0gc3RhcnRQcm9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGVuZFByb3AucHhWYWx1ZSAhPSBudWxsIHx8IGVuZFByb3AudmFsdWUgIT0gbnVsbCApe1xuICAgICAgICAgIGVuZCA9IGVuZFByb3AucHhWYWx1ZSAhPSBudWxsID8gZW5kUHJvcC5weFZhbHVlIDogZW5kUHJvcC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSBlbmRQcm9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICQkLmlzLm51bWJlcihzdGFydCkgJiYgJCQuaXMubnVtYmVyKGVuZCkgKXtcbiAgICAgICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcGVyY2VudDtcblxuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcihzdGFydFswXSkgJiYgJCQuaXMubnVtYmVyKGVuZFswXSkgKXsgLy8gdGhlbiBhc3N1bWUgYSBjb2xvdXJcbiAgICAgICAgICB2YXIgYzEgPSBzdGFydDtcbiAgICAgICAgICB2YXIgYzIgPSBlbmQ7XG5cbiAgICAgICAgICB2YXIgY2ggPSBmdW5jdGlvbihjaDEsIGNoMil7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGNoMiAtIGNoMTtcbiAgICAgICAgICAgIHZhciBtaW4gPSBjaDE7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCggcGVyY2VudCAqIGRpZmYgKyBtaW4gKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciByID0gY2goIGMxWzBdLCBjMlswXSApO1xuICAgICAgICAgIHZhciBnID0gY2goIGMxWzFdLCBjMlsxXSApO1xuICAgICAgICAgIHZhciBiID0gY2goIGMxWzJdLCBjMlsyXSApO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBbciwgZywgYl07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gICAgXG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUsIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApO1xuXG5cbiAgXG4gICAgXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uY29yZSh7XG4gICAgZGF0YTogJCQuZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVtb3ZlRGF0YTogJCQuZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGV2ZW50OiAnZGF0YScsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IHRydWVcbiAgICB9KSxcblxuICAgIHNjcmF0Y2g6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gICAgfSksXG5cbiAgICByZW1vdmVTY3JhdGNoOiAkJC5kZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICAgIH0pXG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5jb3JlKHtcbiAgICBvbjogJCQuZGVmaW5lLm9uKCksIC8vIC5vbiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBkYXRhXSwgaGFuZGxlcilcbiAgICBvbmU6ICQkLmRlZmluZS5vbih7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSksXG4gICAgb25jZTogJCQuZGVmaW5lLm9uKHsgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogdHJ1ZSB9KSxcbiAgICBvZmY6ICQkLmRlZmluZS5vZmYoKSwgLy8gLm9mZiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBoYW5kbGVyXSApXG4gICAgdHJpZ2dlcjogJCQuZGVmaW5lLnRyaWdnZXIoKSAvLyAudHJpZ2dlciggZXZlbnRzIFssIGV4dHJhUGFyYW1zXSApXG4gIH0pO1xuXG4gICQkLmRlZmluZS5ldmVudEFsaWFzZXNPbiggJCQuY29yZWZuICk7XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIFxuICAgIHBuZzogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgcmV0dXJuIHJlbmRlcmVyLnBuZyggb3B0aW9ucyApOyAgICAgIFxuICAgIH0sXG4gICAgXG4gICAganBnOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgXG4gICAgICBvcHRpb25zLmJnID0gb3B0aW9ucy5iZyB8fCAnI2ZmZic7XG5cbiAgICAgIHJldHVybiByZW5kZXJlci5qcGcoIG9wdGlvbnMgKTsgICAgICBcbiAgICB9XG4gICAgXG4gIH0pO1xuICBcbiAgJCQuY29yZWZuLmpwZWcgPSAkJC5jb3JlZm4uanBnO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIFxuICAgIGxheW91dDogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgICAgdmFyIGxheW91dDtcblxuICAgICAgLy8gYWx3YXlzIHVzZSBhIG5ldyBsYXlvdXQgdy8gaW5pdCBvcHRzOyBzbGlnaHRseSBkaWZmZXJlbnQgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgIC8vIGJ1dCBmaXhlcyBsYXlvdXQgcmV1c2UgaXNzdWVzIGxpa2UgZGFncmUgIzgxOSBcbiAgICAgIGlmKCBwYXJhbXMgPT0gbnVsbCApeyBcbiAgICAgICAgcGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIHRoaXMuX3ByaXZhdGUub3B0aW9ucy5sYXlvdXQpO1xuICAgICAgICBwYXJhbXMuZWxlcyA9IHRoaXMuJCgpO1xuICAgICAgfVxuXG4gICAgICBsYXlvdXQgPSB0aGlzLmluaXRMYXlvdXQoIHBhcmFtcyApO1xuICAgICAgbGF5b3V0LnJ1bigpO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgbWFrZUxheW91dDogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdExheW91dCggcGFyYW1zICk7XG4gICAgfSxcbiAgICBcbiAgICBpbml0TGF5b3V0OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgaWYoIG9wdGlvbnMgPT0gbnVsbCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdMYXlvdXQgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIG9wdGlvbnMubmFtZSA9PSBudWxsICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0EgYG5hbWVgIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICAgIHZhciBMYXlvdXRQcm90byA9ICQkLmV4dGVuc2lvbignbGF5b3V0JywgbmFtZSk7XG4gICAgICBcbiAgICAgIGlmKCBMYXlvdXRQcm90byA9PSBudWxsICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0NhbiBub3QgYXBwbHkgbGF5b3V0OiBObyBzdWNoIGxheW91dCBgJyArIG5hbWUgKyAnYCBmb3VuZDsgZGlkIHlvdSBpbmNsdWRlIGl0cyBKUyBmaWxlPycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuZWxlcyA9IG9wdGlvbnMuZWxlcyAhPSBudWxsID8gb3B0aW9ucy5lbGVzIDogdGhpcy4kKCk7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcoIG9wdGlvbnMuZWxlcyApICl7XG4gICAgICAgIG9wdGlvbnMuZWxlcyA9IHRoaXMuJCggb3B0aW9ucy5lbGVzICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0UHJvdG8oICQkLnV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGN5OiB0aGlzXG4gICAgICB9KSApO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgbGF5b3V0IGhhcyBfcHJpdmF0ZSBmb3IgdXNlIHcvIHN0ZCBhcGlzIGxpa2UgLm9uKClcbiAgICAgIGlmKCAhJCQuaXMucGxhaW5PYmplY3QobGF5b3V0Ll9wcml2YXRlKSApe1xuICAgICAgICBsYXlvdXQuX3ByaXZhdGUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0Ll9wcml2YXRlLmN5ID0gdGhpcztcbiAgICAgIGxheW91dC5fcHJpdmF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGxheW91dDtcbiAgICB9XG4gICAgXG4gIH0pO1xuXG4gICQkLmNvcmVmbi5jcmVhdGVMYXlvdXQgPSAkJC5jb3JlZm4ubWFrZUxheW91dDtcbiAgXG59KSggY3l0b3NjYXBlICk7XG4oZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcbiAgICBub3RpZnk6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIGlmKCB0aGlzLl9wcml2YXRlLmJhdGNoaW5nTm90aWZ5ICl7XG4gICAgICAgIHZhciBiRWxlcyA9IHRoaXMuX3ByaXZhdGUuYmF0Y2hOb3RpZnlFbGVzO1xuICAgICAgICB2YXIgYlR5cGVzID0gdGhpcy5fcHJpdmF0ZS5iYXRjaE5vdGlmeVR5cGVzO1xuXG4gICAgICAgIGlmKCBwYXJhbXMuY29sbGVjdGlvbiApeyBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmFtcy5jb2xsZWN0aW9uLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHBhcmFtcy5jb2xsZWN0aW9uW2ldO1xuXG4gICAgICAgICAgaWYoICFiRWxlcy5pZHNbIGVsZS5fcHJpdmF0ZS5pZCBdICl7XG4gICAgICAgICAgICBiRWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfVxuXG4gICAgICAgIGlmKCAhYlR5cGVzLmlkc1sgcGFyYW1zLnR5cGUgXSApe1xuICAgICAgICAgIGJUeXBlcy5wdXNoKCBwYXJhbXMudHlwZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuOyAvLyBub3RpZmljYXRpb25zIGFyZSBkaXNhYmxlZCBkdXJpbmcgYmF0Y2hpbmdcbiAgICAgIH1cblxuICAgICAgaWYoICF0aGlzLl9wcml2YXRlLm5vdGlmaWNhdGlvbnNFbmFibGVkICl7IHJldHVybjsgfSAvLyBleGl0IG9uIGRpc2FibGVkXG5cbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIoKTtcbiAgICAgIFxuICAgICAgcmVuZGVyZXIubm90aWZ5KHBhcmFtcyk7XG4gICAgfSxcbiAgICBcbiAgICBub3RpZmljYXRpb25zOiBmdW5jdGlvbiggYm9vbCApe1xuICAgICAgdmFyIHAgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgXG4gICAgICBpZiggYm9vbCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiBwLm5vdGlmaWNhdGlvbnNFbmFibGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcC5ub3RpZmljYXRpb25zRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBub05vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKCBjYWxsYmFjayApe1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zKGZhbHNlKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnModHJ1ZSk7XG4gICAgfSxcblxuICAgIHN0YXJ0QmF0Y2g6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBfcC5iYXRjaGluZ1N0eWxlID0gX3AuYmF0Y2hpbmdOb3RpZnkgPSB0cnVlO1xuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMgPSBbXTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5RWxlcyA9IFtdO1xuICAgICAgX3AuYmF0Y2hOb3RpZnlUeXBlcyA9IFtdO1xuXG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcy5pZHMgPSB7fTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5RWxlcy5pZHMgPSB7fTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMuaWRzID0ge307XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBlbmRCYXRjaDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIC8vIHVwZGF0ZSBzdHlsZSBmb3IgZGlydHkgZWxlc1xuICAgICAgX3AuYmF0Y2hpbmdTdHlsZSA9IGZhbHNlO1xuICAgICAgbmV3ICQkLkNvbGxlY3Rpb24odGhpcywgX3AuYmF0Y2hTdHlsZUVsZXMpLnVwZGF0ZVN0eWxlKCk7XG5cbiAgICAgIC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgb2YgcXVldWVkIGVsZXMgYW5kIGV2ZW50IHR5cGVzXG4gICAgICBfcC5iYXRjaGluZ05vdGlmeSA9IGZhbHNlO1xuICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICB0eXBlOiBfcC5iYXRjaE5vdGlmeVR5cGVzLFxuICAgICAgICBjb2xsZWN0aW9uOiBfcC5iYXRjaE5vdGlmeUVsZXNcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYmF0Y2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApe1xuICAgICAgdGhpcy5zdGFydEJhdGNoKCk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgYmF0Y2hEYXRhOiBmdW5jdGlvbiggbWFwICl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5iYXRjaChmdW5jdGlvbigpe1xuICAgICAgICBmb3IoIHZhciBpZCBpbiBtYXAgKXtcbiAgICAgICAgICB2YXIgZGF0YSA9IG1hcFtpZF07XG4gICAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuICAgICAgICAgIFxuICAgICAgICAgIGVsZS5kYXRhKCBkYXRhICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uY29yZSh7XG4gICAgXG4gICAgcmVuZGVyVG86IGZ1bmN0aW9uKCBjb250ZXh0LCB6b29tLCBwYW4sIHB4UmF0aW8gKXtcbiAgICAgIHZhciByID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcblxuICAgICAgci5yZW5kZXJUbyggY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvICk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVuZGVyZXI6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICB9LFxuXG4gICAgZm9yY2VSZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICdkcmF3J1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICdyZXNpemUnXG4gICAgICB9KTtcblxuICAgICAgdGhpcy50cmlnZ2VyKCdyZXNpemUnKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBcbiAgICBpbml0UmVuZGVyZXI6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICB2YXIgUmVuZGVyZXJQcm90byA9ICQkLmV4dGVuc2lvbigncmVuZGVyZXInLCBvcHRpb25zLm5hbWUpO1xuICAgICAgaWYoIFJlbmRlcmVyUHJvdG8gPT0gbnVsbCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGluaXRpYWxpc2U6IE5vIHN1Y2ggcmVuZGVyZXIgYCVzYCBmb3VuZDsgZGlkIHlvdSBpbmNsdWRlIGl0cyBKUyBmaWxlPycsIG9wdGlvbnMubmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5fcHJpdmF0ZS5yZW5kZXJlciA9IG5ldyBSZW5kZXJlclByb3RvKFxuICAgICAgICAkJC51dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICBzdHlsZTogY3kuX3ByaXZhdGUuc3R5bGVcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICAgXG4gICAgfSxcblxuICAgIHRyaWdnZXJPblJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjYnMgPSB0aGlzLl9wcml2YXRlLm9uUmVuZGVycztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGNiID0gY2JzW2ldO1xuXG4gICAgICAgIGNiKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvblJlbmRlcjogZnVuY3Rpb24oIGNiICl7XG4gICAgICB0aGlzLl9wcml2YXRlLm9uUmVuZGVycy5wdXNoKCBjYiApO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb2ZmUmVuZGVyOiBmdW5jdGlvbiggZm4gKXtcbiAgICAgIHZhciBjYnMgPSB0aGlzLl9wcml2YXRlLm9uUmVuZGVycztcblxuICAgICAgaWYoIGZuID09IG51bGwgKXsgLy8gdW5iaW5kIGFsbFxuICAgICAgICB0aGlzLl9wcml2YXRlLm9uUmVuZGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKysgKXsgLy8gdW5iaW5kIHNwZWNpZmllZFxuICAgICAgICB2YXIgY2IgPSBjYnNbaV07XG5cbiAgICAgICAgaWYoIGZuID09PSBjYiApe1xuICAgICAgICAgIGNicy5zcGxpY2UoIGksIDEgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgXG4gIH0pOyAgXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuXG4gICAgLy8gZ2V0IGEgY29sbGVjdGlvblxuICAgIC8vIC0gZW1wdHkgY29sbGVjdGlvbiBvbiBubyBhcmdzXG4gICAgLy8gLSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGluIHRoZSBncmFwaCBvbiBzZWxlY3RvciBhcmdcbiAgICAvLyAtIGd1YXJhbnRlZSBhIHJldHVybmVkIGNvbGxlY3Rpb24gd2hlbiBlbGVtZW50cyBvciBjb2xsZWN0aW9uIHNwZWNpZmllZFxuICAgIGNvbGxlY3Rpb246IGZ1bmN0aW9uKCBlbGVzICl7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcoIGVsZXMgKSApe1xuICAgICAgICByZXR1cm4gdGhpcy4kKCBlbGVzICk7XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggZWxlcyApICl7XG4gICAgICAgIHJldHVybiBlbGVzLmNvbGxlY3Rpb24oKTtcblxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5hcnJheSggZWxlcyApICl7XG4gICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcywgZWxlcyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMgKTtcbiAgICB9LFxuICAgIFxuICAgIG5vZGVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuJChmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5pc05vZGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgICAgcmV0dXJuIG5vZGVzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICAgIH0gXG5cbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9LFxuICAgIFxuICAgIGVkZ2VzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuJChmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgICAgcmV0dXJuIGVkZ2VzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH0sXG4gICAgICBcbiAgICAvLyBzZWFyY2ggdGhlIGdyYXBoIGxpa2UgalF1ZXJ5XG4gICAgJDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlcyA9IG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLCB0aGlzLl9wcml2YXRlLmVsZW1lbnRzICk7XG5cbiAgICAgIGlmKCBzZWxlY3RvciApe1xuICAgICAgICByZXR1cm4gZWxlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVzO1xuICAgIH1cbiAgICBcbiAgfSk7ICBcblxuICAvLyBhbGlhc2VzXG4gICQkLmNvcmVmbi5lbGVtZW50cyA9ICQkLmNvcmVmbi5maWx0ZXIgPSAkJC5jb3JlZm4uJDsgIFxuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIFxuICAgIHN0eWxlOiBmdW5jdGlvbiggbmV3U3R5bGUgKXtcbiAgICAgIGlmKCBuZXdTdHlsZSApe1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2V0U3R5bGUoIG5ld1N0eWxlICk7XG5cbiAgICAgICAgcy51cGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGU7XG4gICAgfSxcblxuICAgIHNldFN0eWxlOiBmdW5jdGlvbiggc3R5bGUgKXtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHlsZXNoZWV0KHN0eWxlKSApe1xuICAgICAgICBfcC5zdHlsZSA9IHN0eWxlLmdlbmVyYXRlU3R5bGUodGhpcyk7XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuYXJyYXkoc3R5bGUpICkge1xuICAgICAgICBfcC5zdHlsZSA9ICQkLnN0eWxlLmZyb21Kc29uKHRoaXMsIHN0eWxlKTtcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcoc3R5bGUpICl7XG4gICAgICAgIF9wLnN0eWxlID0gJCQuc3R5bGUuZnJvbVN0cmluZyh0aGlzLCBzdHlsZSk7XG4gICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wLnN0eWxlID0gbmV3ICQkLlN0eWxlKCB0aGlzICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcC5zdHlsZTtcbiAgICB9XG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uY29yZSh7XG5cbiAgICBhdXRvbG9jazogZnVuY3Rpb24oYm9vbCl7XG4gICAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2sgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2s7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBhdXRvdW5ncmFiaWZ5OiBmdW5jdGlvbihib29sKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBhdXRvdW5zZWxlY3RpZnk6IGZ1bmN0aW9uKGJvb2wpe1xuICAgICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBwYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIFxuICAgIHpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgdXNlclpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBcbiAgICBwYW46IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgICAgc3dpdGNoKCBhcmdzLmxlbmd0aCApe1xuICAgICAgY2FzZSAwOiAvLyAucGFuKClcbiAgICAgICAgcmV0dXJuIHBhbjtcblxuICAgICAgY2FzZSAxOiBcblxuICAgICAgICBpZiggJCQuaXMuc3RyaW5nKCBhcmdzWzBdICkgKXsgLy8gLnBhbigneCcpXG4gICAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgICByZXR1cm4gcGFuWyBkaW0gXTtcblxuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KCBhcmdzWzBdICkgKSB7IC8vIC5wYW4oeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoeCkgKXtcbiAgICAgICAgICAgIHBhbi54ID0geDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKHkpICl7XG4gICAgICAgICAgICBwYW4ueSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOiAvLyAucGFuKCd4JywgMTAwKVxuICAgICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgIHZhbCA9IGFyZ3NbMV07XG5cbiAgICAgICAgaWYoIChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgJCQuaXMubnVtYmVyKHZhbCkgKXtcbiAgICAgICAgICBwYW5bZGltXSA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhazsgLy8gaW52YWxpZFxuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBcbiAgICBwYW5CeTogZnVuY3Rpb24ocGFyYW1zKXtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgdmFyIGRpbSwgdmFsLCBkaW1zLCB4LCB5O1xuXG4gICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCggYXJncy5sZW5ndGggKXtcbiAgICAgIGNhc2UgMTogXG5cbiAgICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KCBhcmdzWzBdICkgKSB7IC8vIC5wYW5CeSh7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoeCkgKXtcbiAgICAgICAgICAgIHBhbi54ICs9IHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICQkLmlzLm51bWJlcih5KSApe1xuICAgICAgICAgICAgcGFuLnkgKz0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6IC8vIC5wYW5CeSgneCcsIDEwMClcbiAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgdmFsID0gYXJnc1sxXTtcblxuICAgICAgICBpZiggKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiAkJC5pcy5udW1iZXIodmFsKSApe1xuICAgICAgICAgIHBhbltkaW1dICs9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhazsgLy8gaW52YWxpZFxuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBcbiAgICBmaXQ6IGZ1bmN0aW9uKCBlbGVtZW50cywgcGFkZGluZyApe1xuICAgICAgdmFyIHZpZXdwb3J0U3RhdGUgPSB0aGlzLmdldEZpdFZpZXdwb3J0KCBlbGVtZW50cywgcGFkZGluZyApO1xuXG4gICAgICBpZiggdmlld3BvcnRTdGF0ZSApe1xuICAgICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgICBfcC56b29tID0gdmlld3BvcnRTdGF0ZS56b29tO1xuICAgICAgICBfcC5wYW4gPSB2aWV3cG9ydFN0YXRlLnBhbjtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB6b29tIHZpZXdwb3J0Jyk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgZ2V0Rml0Vmlld3BvcnQ6IGZ1bmN0aW9uKCBlbGVtZW50cywgcGFkZGluZyApe1xuICAgICAgaWYoICQkLmlzLm51bWJlcihlbGVtZW50cykgJiYgcGFkZGluZyA9PT0gdW5kZWZpbmVkICl7IC8vIGVsZW1lbnRzIGlzIG9wdGlvbmFsXG4gICAgICAgIHBhZGRpbmcgPSBlbGVtZW50cztcbiAgICAgICAgZWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiYjtcblxuICAgICAgaWYoICQkLmlzLnN0cmluZyhlbGVtZW50cykgKXtcbiAgICAgICAgdmFyIHNlbCA9IGVsZW1lbnRzO1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMuJCggc2VsICk7XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuYm91bmRpbmdCb3goZWxlbWVudHMpICl7IC8vIGFzc3VtZSBiYlxuICAgICAgICB2YXIgYmJlID0gZWxlbWVudHM7XG4gICAgICAgIGJiID0ge1xuICAgICAgICAgIHgxOiBiYmUueDEsXG4gICAgICAgICAgeTE6IGJiZS55MSxcbiAgICAgICAgICB4MjogYmJlLngyLFxuICAgICAgICAgIHkyOiBiYmUueTJcbiAgICAgICAgfTtcblxuICAgICAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICAgICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG5cbiAgICAgIH0gZWxzZSBpZiggISQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpICl7XG4gICAgICAgIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cygpO1xuICAgICAgfVxuXG4gICAgICBiYiA9IGJiIHx8IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgICAgdmFyIHpvb207XG4gICAgICBwYWRkaW5nID0gJCQuaXMubnVtYmVyKHBhZGRpbmcpID8gcGFkZGluZyA6IDA7XG5cbiAgICAgIGlmKCAhaXNOYU4odykgJiYgIWlzTmFOKGgpICYmIHcgPiAwICYmIGggPiAwICYmICFpc05hTihiYi53KSAmJiAhaXNOYU4oYmIuaCkgJiYgIGJiLncgPiAwICYmIGJiLmggPiAwICl7XG4gICAgICAgIHpvb20gPSBNYXRoLm1pbiggKHcgLSAyKnBhZGRpbmcpL2JiLncsIChoIC0gMipwYWRkaW5nKS9iYi5oICk7XG5cbiAgICAgICAgLy8gY3JvcCB6b29tXG4gICAgICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICAgICAgem9vbSA9IHpvb20gPCB0aGlzLl9wcml2YXRlLm1pblpvb20gPyB0aGlzLl9wcml2YXRlLm1pblpvb20gOiB6b29tO1xuXG4gICAgICAgIHZhciBwYW4gPSB7IC8vIG5vdyBwYW4gdG8gbWlkZGxlXG4gICAgICAgICAgeDogKHcgLSB6b29tKiggYmIueDEgKyBiYi54MiApKS8yLFxuICAgICAgICAgIHk6IChoIC0gem9vbSooIGJiLnkxICsgYmIueTIgKSkvMlxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgem9vbTogem9vbSwgXG4gICAgICAgICAgcGFuOiBwYW5cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgXG4gICAgbWluWm9vbTogZnVuY3Rpb24oIHpvb20gKXtcbiAgICAgIGlmKCB6b29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWluWm9vbTtcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKHpvb20pICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUubWluWm9vbSA9IHpvb207XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtYXhab29tOiBmdW5jdGlvbiggem9vbSApe1xuICAgICAgaWYoIHpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXhab29tO1xuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIoem9vbSkgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5tYXhab29tID0gem9vbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHpvb206IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBwb3M7IC8vIGluIHJlbmRlcmVkIHB4XG4gICAgICB2YXIgem9vbTtcblxuICAgICAgaWYoIHBhcmFtcyA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gZ2V0IHRoZSB6b29tXG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb207XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKHBhcmFtcykgKXsgLy8gdGhlbiBzZXQgdGhlIHpvb21cbiAgICAgICAgem9vbSA9IHBhcmFtcztcblxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdChwYXJhbXMpICl7IC8vIHRoZW4gem9vbSBhYm91dCBhIHBvaW50XG4gICAgICAgIHpvb20gPSBwYXJhbXMubGV2ZWw7XG5cbiAgICAgICAgaWYoIHBhcmFtcy5wb3NpdGlvbiApe1xuICAgICAgICAgIHZhciBwID0gcGFyYW1zLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgICAgICB2YXIgeiA9IHRoaXMuX3ByaXZhdGUuem9vbTtcblxuICAgICAgICAgIHBvcyA9IHsgLy8gY29udmVydCB0byByZW5kZXJlZCBweFxuICAgICAgICAgICAgeDogcC54ICogeiArIHBhbi54LFxuICAgICAgICAgICAgeTogcC55ICogeiArIHBhbi55XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmKCBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbiApe1xuICAgICAgICAgIHBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHBvcyAmJiAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBwYW5uaW5nIGRpc2FibGVkXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkICl7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyB6b29taW5nIGRpc2FibGVkXG4gICAgICB9XG5cbiAgICAgIGlmKCAhJCQuaXMubnVtYmVyKHpvb20pIHx8ICggcG9zICYmICghJCQuaXMubnVtYmVyKHBvcy54KSB8fCAhJCQuaXMubnVtYmVyKHBvcy55KSkgKSApe1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gY2FuJ3Qgem9vbSB3aXRoIGludmFsaWQgcGFyYW1zXG4gICAgICB9XG5cbiAgICAgIC8vIGNyb3Agem9vbVxuICAgICAgem9vbSA9IHpvb20gPiB0aGlzLl9wcml2YXRlLm1heFpvb20gPyB0aGlzLl9wcml2YXRlLm1heFpvb20gOiB6b29tO1xuICAgICAgem9vbSA9IHpvb20gPCB0aGlzLl9wcml2YXRlLm1pblpvb20gPyB0aGlzLl9wcml2YXRlLm1pblpvb20gOiB6b29tO1xuXG4gICAgICBpZiggcG9zICl7IC8vIHNldCB6b29tIGFib3V0IHBvc2l0aW9uXG4gICAgICAgIHZhciBwYW4xID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICAgIHZhciB6b29tMSA9IHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICAgICAgdmFyIHpvb20yID0gem9vbTtcbiAgICAgICAgXG4gICAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICAgIHg6IC16b29tMi96b29tMSAqIChwb3MueCAtIHBhbjEueCkgKyBwb3MueCxcbiAgICAgICAgICB5OiAtem9vbTIvem9vbTEgKiAocG9zLnkgLSBwYW4xLnkpICsgcG9zLnlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9wcml2YXRlLnpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLl9wcml2YXRlLnBhbiA9IHBhbjI7XG5cbiAgICAgICAgdmFyIHBvc0NoYW5nZWQgPSBwYW4xLnggIT09IHBhbjIueCB8fCBwYW4xLnkgIT09IHBhbjIueTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCcgem9vbSAnICsgKHBvc0NoYW5nZWQgPyAnIHBhbiAnIDogJycpICsgJyB2aWV3cG9ydCAnICk7XG4gICAgICBcbiAgICAgIH0gZWxzZSB7IC8vIGp1c3Qgc2V0IHRoZSB6b29tXG4gICAgICAgIHRoaXMuX3ByaXZhdGUuem9vbSA9IHpvb207XG4gICAgICAgIHRoaXMudHJpZ2dlcignem9vbSB2aWV3cG9ydCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHZpZXdwb3J0OiBmdW5jdGlvbiggb3B0cyApeyBcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgem9vbURlZmQgPSB0cnVlO1xuICAgICAgdmFyIHBhbkRlZmQgPSB0cnVlO1xuICAgICAgdmFyIGV2ZW50cyA9IFtdOyAvLyB0byB0cmlnZ2VyXG4gICAgICB2YXIgem9vbUZhaWxlZCA9IGZhbHNlO1xuICAgICAgdmFyIHBhbkZhaWxlZCA9IGZhbHNlO1xuXG4gICAgICBpZiggIW9wdHMgKXsgcmV0dXJuIHRoaXM7IH1cbiAgICAgIGlmKCAhJCQuaXMubnVtYmVyKG9wdHMuem9vbSkgKXsgem9vbURlZmQgPSBmYWxzZTsgfVxuICAgICAgaWYoICEkJC5pcy5wbGFpbk9iamVjdChvcHRzLnBhbikgKXsgcGFuRGVmZCA9IGZhbHNlOyB9XG4gICAgICBpZiggIXpvb21EZWZkICYmICFwYW5EZWZkICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIGlmKCB6b29tRGVmZCApe1xuICAgICAgICB2YXIgeiA9IG9wdHMuem9vbTtcblxuICAgICAgICBpZiggeiA8IF9wLm1pblpvb20gfHwgeiA+IF9wLm1heFpvb20gfHwgIV9wLnpvb21pbmdFbmFibGVkICl7XG4gICAgICAgICAgem9vbUZhaWxlZCA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcC56b29tID0gejtcblxuICAgICAgICAgIGV2ZW50cy5wdXNoKCd6b29tJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHBhbkRlZmQgJiYgKCF6b29tRmFpbGVkIHx8ICFvcHRzLmNhbmNlbE9uRmFpbGVkWm9vbSkgJiYgX3AucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgdmFyIHAgPSBvcHRzLnBhbjtcblxuICAgICAgICBpZiggJCQuaXMubnVtYmVyKHAueCkgKXtcbiAgICAgICAgICBfcC5wYW4ueCA9IHAueDtcbiAgICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAkJC5pcy5udW1iZXIocC55KSApe1xuICAgICAgICAgIF9wLnBhbi55ID0gcC55O1xuICAgICAgICAgIHBhbkZhaWxlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFwYW5GYWlsZWQgKXtcbiAgICAgICAgICBldmVudHMucHVzaCgncGFuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGV2ZW50cy5sZW5ndGggPiAwICl7XG4gICAgICAgIGV2ZW50cy5wdXNoKCd2aWV3cG9ydCcpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoIGV2ZW50cy5qb2luKCcgJykgKTtcblxuICAgICAgICB0aGlzLm5vdGlmeSh7XG4gICAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBcbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCBlbGVtZW50cyApe1xuICAgICAgdmFyIHBhbiA9IHRoaXMuZ2V0Q2VudGVyUGFuKCBlbGVtZW50cyApO1xuXG4gICAgICBpZiggcGFuICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUucGFuID0gcGFuO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgZ2V0Q2VudGVyUGFuOiBmdW5jdGlvbiggZWxlbWVudHMsIHpvb20gKXtcbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcoZWxlbWVudHMpICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IGVsZW1lbnRzO1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoIHNlbGVjdG9yICk7XG4gICAgICB9IGVsc2UgaWYoICEkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSApe1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJiID0gZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3ByaXZhdGUuem9vbSA6IHpvb207XG5cbiAgICAgIHZhciBwYW4gPSB7IC8vIG1pZGRsZVxuICAgICAgICB4OiAodyAtIHpvb20qKCBiYi54MSArIGJiLngyICkpLzIsXG4gICAgICAgIHk6IChoIC0gem9vbSooIGJiLnkxICsgYmIueTIgKSkvMlxuICAgICAgfTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHBhbjtcbiAgICB9LFxuICAgIFxuICAgIHJlc2V0OiBmdW5jdGlvbigpe1xuICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZpZXdwb3J0KHtcbiAgICAgICAgcGFuOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgem9vbTogMVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICB3aWR0aDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9wcml2YXRlLmNvbnRhaW5lcjtcblxuICAgICAgaWYoIGNvbnRhaW5lciApe1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMTsgLy8gZmFsbGJhY2sgaWYgbm8gY29udGFpbmVyIChub3QgMCBiL2MgY2FuIGJlIHVzZWQgZm9yIGRpdmlkaW5nIGV0YylcbiAgICB9LFxuXG4gICAgaGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX3ByaXZhdGUuY29udGFpbmVyO1xuXG4gICAgICBpZiggY29udGFpbmVyICl7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMTsgLy8gZmFsbGJhY2sgaWYgbm8gY29udGFpbmVyIChub3QgMCBiL2MgY2FuIGJlIHVzZWQgZm9yIGRpdmlkaW5nIGV0YylcbiAgICB9LFxuXG4gICAgZXh0ZW50OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgdmFyIHpvb20gPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgICB2YXIgcmIgPSB0aGlzLnJlbmRlcmVkRXh0ZW50KCk7XG5cbiAgICAgIHZhciBiID0ge1xuICAgICAgICB4MTogKCByYi54MSAtIHBhbi54ICkvem9vbSxcbiAgICAgICAgeDI6ICggcmIueDIgLSBwYW4ueCApL3pvb20sXG4gICAgICAgIHkxOiAoIHJiLnkxIC0gcGFuLnkgKS96b29tLFxuICAgICAgICB5MjogKCByYi55MiAtIHBhbi55ICkvem9vbSxcbiAgICAgIH07XG5cbiAgICAgIGIudyA9IGIueDIgLSBiLngxO1xuICAgICAgYi5oID0gYi55MiAtIGIueTE7XG5cbiAgICAgIHJldHVybiBiO1xuICAgIH0sXG5cbiAgICByZW5kZXJlZEV4dGVudDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKTtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogMCxcbiAgICAgICAgeTE6IDAsXG4gICAgICAgIHgyOiB3aWR0aCxcbiAgICAgICAgeTI6IGhlaWdodCxcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIGg6IGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGFsaWFzZXNcbiAgJCQuY29yZWZuLmNlbnRyZSA9ICQkLmNvcmVmbi5jZW50ZXI7XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgJCQuY29yZWZuLmF1dG9sb2NrTm9kZXMgPSAkJC5jb3JlZm4uYXV0b2xvY2s7XG4gICQkLmNvcmVmbi5hdXRvdW5ncmFiaWZ5Tm9kZXMgPSAkJC5jb3JlZm4uYXV0b3VuZ3JhYmlmeTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gVXNlIHRoaXMgaW50ZXJmYWNlIHRvIGRlZmluZSBmdW5jdGlvbnMgZm9yIGNvbGxlY3Rpb25zL2VsZW1lbnRzLlxuICAvLyBUaGlzIGludGVyZmFjZSBpcyBnb29kLCBiZWNhdXNlIGl0IGZvcmNlcyB5b3UgdG8gdGhpbmsgaW4gdGVybXNcbiAgLy8gb2YgdGhlIGNvbGxlY3Rpb25zIGNhc2UgKG1vcmUgdGhhbiAxIGVsZW1lbnQpLCBzbyB3ZSBkb24ndCBuZWVkXG4gIC8vIG5vdGlmaWNhdGlvbiBibG9ja2luZyBub25zZW5zZSBldmVyeXdoZXJlLlxuICAvL1xuICAvLyBPdGhlciBjb2xsZWN0aW9uLSouanMgZmlsZXMgZGVwZW5kIG9uIHRoaXMgYmVpbmcgZGVmaW5lZCBmaXJzdC5cbiAgLy8gSXQncyBhIHRyYWRlIG9mZjogSXQgc2ltcGxpZmllcyB0aGUgY29kZSBmb3IgQ29sbGVjdGlvbiBhbmQgXG4gIC8vIEVsZW1lbnQgaW50ZWdyYXRpb24gc28gbXVjaCB0aGF0IGl0J3Mgd29ydGggaXQgdG8gY3JlYXRlIHRoZVxuICAvLyBKUyBkZXBlbmRlbmN5LlxuICAvL1xuICAvLyBIYXZpbmcgdGhpcyBpbnRlZ3JhdGlvbiBndWFyYW50ZWVzIHRoYXQgd2UgY2FuIGNhbGwgYW55XG4gIC8vIGNvbGxlY3Rpb24gZnVuY3Rpb24gb24gYW4gZWxlbWVudCBhbmQgdmljZSB2ZXJzYS5cblxuICAvLyBlLmcuICQkLmZuLmNvbGxlY3Rpb24oeyBzb21lRnVuYzogZnVuY3Rpb24oKXsgLyogLi4uICovIH0gfSlcbiAgJCQuZm4uY29sbGVjdGlvbiA9ICQkLmZuLmVsZXMgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIGZuTWFwICl7XG4gICAgICB2YXIgZm4gPSBmbk1hcFtuYW1lXTtcblxuICAgICAgJCQuQ29sbGVjdGlvbi5wcm90b3R5cGVbIG5hbWUgXSA9IGZuO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIGZhY3RvcnkgZm9yIGdlbmVyYXRpbmcgZWRnZSBpZHMgd2hlbiBubyBpZCBpcyBzcGVjaWZpZWQgZm9yIGEgbmV3IGVsZW1lbnRcbiAgdmFyIGlkRmFjdG9yeSA9IHtcbiAgICBwcmVmaXg6IHtcbiAgICAgIG5vZGVzOiAnbicsXG4gICAgICBlZGdlczogJ2UnXG4gICAgfSxcbiAgICBpZDoge1xuICAgICAgbm9kZXM6IDAsXG4gICAgICBlZGdlczogMFxuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKGN5LCBlbGVtZW50LCB0cnlUaGlzSWQpe1xuICAgICAgdmFyIGpzb24gPSAkJC5pcy5lbGVtZW50KCBlbGVtZW50ICkgPyBlbGVtZW50Ll9wcml2YXRlIDogZWxlbWVudDtcbiAgICAgIHZhciBncm91cCA9IGpzb24uZ3JvdXA7XG4gICAgICB2YXIgaWQgPSB0cnlUaGlzSWQgIT0gbnVsbCA/IHRyeVRoaXNJZCA6IHRoaXMucHJlZml4W2dyb3VwXSArIHRoaXMuaWRbZ3JvdXBdO1xuICAgICAgXG4gICAgICBpZiggY3kuZ2V0RWxlbWVudEJ5SWQoaWQpLmVtcHR5KCkgKXtcbiAgICAgICAgdGhpcy5pZFtncm91cF0rKzsgLy8gd2UndmUgdXNlZCB0aGUgY3VycmVudCBpZCwgc28gbW92ZSBpdCB1cFxuICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIGtlZXAgdHJ5aW5nIHN1Y2Nlc3NpdmUgdW51c2VkIGlkc1xuICAgICAgICB3aGlsZSggIWN5LmdldEVsZW1lbnRCeUlkKGlkKS5lbXB0eSgpICl7XG4gICAgICAgICAgaWQgPSB0aGlzLnByZWZpeFtncm91cF0gKyAoICsrdGhpcy5pZFtncm91cF0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gRWxlbWVudFxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAvLyByZXByZXNlbnRzIGEgbm9kZSBvciBhbiBlZGdlXG4gICQkLkVsZW1lbnQgPSBmdW5jdGlvbihjeSwgcGFyYW1zLCByZXN0b3JlKXtcbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuRWxlbWVudCkgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuRWxlbWVudChjeSwgcGFyYW1zLCByZXN0b3JlKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmVzdG9yZSA9IChyZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSA/IHRydWUgOiBmYWxzZSk7XG4gICAgXG4gICAgaWYoIGN5ID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSB1bmRlZmluZWQgfHwgISQkLmlzLmNvcmUoY3kpICl7XG4gICAgICAkJC51dGlsLmVycm9yKCdBbiBlbGVtZW50IG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlIGFuZCBwYXJhbWV0ZXJzIHNldCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyB2YWxpZGF0ZSBncm91cFxuICAgIGlmKCBwYXJhbXMuZ3JvdXAgIT09ICdub2RlcycgJiYgcGFyYW1zLmdyb3VwICE9PSAnZWRnZXMnICl7XG4gICAgICAkJC51dGlsLmVycm9yKCdBbiBlbGVtZW50IG11c3QgYmUgb2YgdHlwZSBgbm9kZXNgIG9yIGBlZGdlc2A7IHlvdSBzcGVjaWZpZWQgYCcgKyBwYXJhbXMuZ3JvdXAgKyAnYCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBtYWtlIHRoZSBlbGVtZW50IGFycmF5LWxpa2UsIGp1c3QgbGlrZSBhIGNvbGxlY3Rpb25cbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgdGhpc1swXSA9IHRoaXM7XG4gICAgXG4gICAgLy8gTk9URTogd2hlbiBzb21ldGhpbmcgaXMgYWRkZWQgaGVyZSwgYWRkIGFsc28gdG8gZWxlLmpzb24oKVxuICAgIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBjeTogY3ksXG4gICAgICBzaW5nbGU6IHRydWUsIC8vIGluZGljYXRlcyB0aGlzIGlzIGFuIGVsZW1lbnRcbiAgICAgIGRhdGE6IHBhcmFtcy5kYXRhIHx8IHt9LCAvLyBkYXRhIG9iamVjdFxuICAgICAgcG9zaXRpb246IHBhcmFtcy5wb3NpdGlvbiB8fCB7fSwgLy8gKHgsIHkpIHBvc2l0aW9uIHBhaXJcbiAgICAgIGF1dG9XaWR0aDogdW5kZWZpbmVkLCAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIG5vZGVzIGNhbGN1bGF0ZWQgYnkgdGhlIHJlbmRlcmVyIHdoZW4gc2V0IHRvIHNwZWNpYWwgJ2F1dG8nIHZhbHVlXG4gICAgICBhdXRvSGVpZ2h0OiB1bmRlZmluZWQsIFxuICAgICAgbGlzdGVuZXJzOiBbXSwgLy8gYXJyYXkgb2YgYm91bmQgbGlzdGVuZXJzXG4gICAgICBncm91cDogcGFyYW1zLmdyb3VwLCAvLyBzdHJpbmc7ICdub2Rlcycgb3IgJ2VkZ2VzJ1xuICAgICAgc3R5bGU6IHt9LCAvLyBwcm9wZXJ0aWVzIGFzIHNldCBieSB0aGUgc3R5bGVcbiAgICAgIHJzdHlsZToge30sIC8vIHByb3BlcnRpZXMgZm9yIHN0eWxlIHNlbnQgZnJvbSB0aGUgcmVuZGVyZXIgdG8gdGhlIGNvcmVcbiAgICAgIHN0eWxlQ3h0czogW10sIC8vIGFwcGxpZWQgc3R5bGUgY29udGV4dHMgZnJvbSB0aGUgc3R5bGVyXG4gICAgICByZW1vdmVkOiB0cnVlLCAvLyB3aGV0aGVyIGl0J3MgaW5zaWRlIHRoZSB2aXM7IHRydWUgaWYgcmVtb3ZlZCAoc2V0IHRydWUgaGVyZSBzaW5jZSB3ZSBjYWxsIHJlc3RvcmUpXG4gICAgICBzZWxlY3RlZDogcGFyYW1zLnNlbGVjdGVkID8gdHJ1ZSA6IGZhbHNlLCAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0ZWRcbiAgICAgIHNlbGVjdGFibGU6IHBhcmFtcy5zZWxlY3RhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogKCBwYXJhbXMuc2VsZWN0YWJsZSA/IHRydWUgOiBmYWxzZSApLCAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0YWJsZVxuICAgICAgbG9ja2VkOiBwYXJhbXMubG9ja2VkID8gdHJ1ZSA6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGxvY2tlZCAoY2Fubm90IGJlIG1vdmVkKVxuICAgICAgZ3JhYmJlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZ3JhYmJlZCBieSB0aGUgbW91c2U7IHJlbmRlcmVyIHNldHMgdGhpcyBwcml2YXRlbHlcbiAgICAgIGdyYWJiYWJsZTogcGFyYW1zLmdyYWJiYWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICggcGFyYW1zLmdyYWJiYWJsZSA/IHRydWUgOiBmYWxzZSApLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGNhbiBiZSBncmFiYmVkXG4gICAgICBhY3RpdmU6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFjdGl2ZSBmcm9tIHVzZXIgaW50ZXJhY3Rpb25cbiAgICAgIGNsYXNzZXM6IHt9LCAvLyBtYXAgKCBjbGFzc05hbWUgPT4gdHJ1ZSApXG4gICAgICBhbmltYXRpb246IHsgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgICBxdWV1ZTogW11cbiAgICAgIH0sXG4gICAgICByc2NyYXRjaDoge30sIC8vIG9iamVjdCBpbiB3aGljaCB0aGUgcmVuZGVyZXIgY2FuIHN0b3JlIGluZm9ybWF0aW9uXG4gICAgICBzY3JhdGNoOiBwYXJhbXMuc2NyYXRjaCB8fCB7fSwgLy8gc2NyYXRjaCBvYmplY3RzXG4gICAgICBlZGdlczogW10sIC8vIGFycmF5IG9mIGNvbm5lY3RlZCBlZGdlc1xuICAgICAgY2hpbGRyZW46IFtdIC8vIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgfTtcbiAgICBcbiAgICAvLyByZW5kZXJlZFBvc2l0aW9uIG92ZXJyaWRlcyBpZiBzcGVjaWZpZWRcbiAgICBpZiggcGFyYW1zLnJlbmRlcmVkUG9zaXRpb24gKXtcbiAgICAgIHZhciBycG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgdGhpcy5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgeDogKHJwb3MueCAtIHBhbi54KS96b29tLFxuICAgICAgICB5OiAocnBvcy55IC0gcGFuLnkpL3pvb21cbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGlmKCAkJC5pcy5zdHJpbmcocGFyYW1zLmNsYXNzZXMpICl7XG4gICAgICB2YXIgY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgICBmb3IoIHZhciBpID0gMCwgbCA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuICAgICAgICBpZiggIWNscyB8fCBjbHMgPT09ICcnICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgc2VsZi5fcHJpdmF0ZS5jbGFzc2VzW2Nsc10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBwYXJhbXMuY3NzICl7XG4gICAgICBjeS5zdHlsZSgpLmFwcGx5QnlwYXNzKCB0aGlzLCBwYXJhbXMuY3NzICk7XG4gICAgfVxuICAgIFxuICAgIGlmKCByZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSApe1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICAgIFxuICB9O1xuXG4gIFxuICAvLyBDb2xsZWN0aW9uXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gIC8vIHJlcHJlc2VudHMgYSBzZXQgb2Ygbm9kZXMsIGVkZ2VzLCBvciBib3RoIHRvZ2V0aGVyXG4gICQkLkNvbGxlY3Rpb24gPSBmdW5jdGlvbihjeSwgZWxlbWVudHMsIG9wdGlvbnMpe1xuICAgIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiAkJC5Db2xsZWN0aW9uKSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgaWYoIGN5ID09PSB1bmRlZmluZWQgfHwgISQkLmlzLmNvcmUoY3kpICl7XG4gICAgICAkJC51dGlsLmVycm9yKCdBIGNvbGxlY3Rpb24gbXVzdCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHZhciBpZHMgPSB7fTtcbiAgICB2YXIgaW5kZXhlcyA9IHt9O1xuICAgIHZhciBjcmVhdGVkRWxlbWVudHMgPSBmYWxzZTtcbiAgICBcbiAgICBpZiggIWVsZW1lbnRzICl7XG4gICAgICBlbGVtZW50cyA9IFtdO1xuICAgIH0gZWxzZSBpZiggZWxlbWVudHMubGVuZ3RoID4gMCAmJiAkJC5pcy5wbGFpbk9iamVjdCggZWxlbWVudHNbMF0gKSAmJiAhJCQuaXMuZWxlbWVudCggZWxlbWVudHNbMF0gKSApe1xuICAgICAgY3JlYXRlZEVsZW1lbnRzID0gdHJ1ZTtcblxuICAgICAgLy8gbWFrZSBlbGVtZW50cyBmcm9tIGpzb24gYW5kIHJlc3RvcmUgYWxsIGF0IG9uY2UgbGF0ZXJcbiAgICAgIHZhciBlbGVzID0gW107XG4gICAgICB2YXIgZWxlc0lkcyA9IHt9O1xuXG4gICAgICBmb3IoIHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICB2YXIganNvbiA9IGVsZW1lbnRzW2ldO1xuXG4gICAgICAgIGlmKCBqc29uLmRhdGEgPT0gbnVsbCApe1xuICAgICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgZGF0YSA9IGpzb24uZGF0YTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgbmV3bHkgY3JlYXRlZCBlbGVtZW50cyBoYXZlIHZhbGlkIGlkc1xuICAgICAgICBpZiggZGF0YS5pZCA9PSBudWxsICl7XG4gICAgICAgICAgZGF0YS5pZCA9IGlkRmFjdG9yeS5nZW5lcmF0ZSggY3ksIGpzb24gKTtcbiAgICAgICAgfSBlbHNlIGlmKCBjeS5nZXRFbGVtZW50QnlJZCggZGF0YS5pZCApLmxlbmd0aCAhPT0gMCB8fCBlbGVzSWRzWyBkYXRhLmlkIF0gKXtcbiAgICAgICAgICBjb250aW51ZTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgcHJpb3IgaWQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGUgPSBuZXcgJCQuRWxlbWVudCggY3ksIGpzb24sIGZhbHNlICk7XG4gICAgICAgIGVsZXMucHVzaCggZWxlICk7XG4gICAgICAgIGVsZXNJZHNbIGRhdGEuaWQgXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRzID0gZWxlcztcbiAgICB9XG4gICAgXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiggIWVsZW1lbnQgKXsgIGNvbnRpbnVlOyB9XG4gICAgICBcbiAgICAgIHZhciBpZCA9IGVsZW1lbnQuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIFxuICAgICAgaWYoICFvcHRpb25zIHx8IChvcHRpb25zLnVuaXF1ZSAmJiAhaWRzWyBpZCBdICkgKXtcbiAgICAgICAgaWRzWyBpZCBdID0gZWxlbWVudDtcbiAgICAgICAgaW5kZXhlc1sgaWQgXSA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXNbIHRoaXMubGVuZ3RoIF0gPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgY3k6IGN5LFxuICAgICAgaWRzOiBpZHMsXG4gICAgICBpbmRleGVzOiBpbmRleGVzXG4gICAgfTtcblxuICAgIC8vIHJlc3RvcmUgdGhlIGVsZW1lbnRzIGlmIHdlIGNyZWF0ZWQgdGhlbSBmcm9tIGpzb25cbiAgICBpZiggY3JlYXRlZEVsZW1lbnRzICl7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG4gIH07XG4gIFxuICBcbiAgLy8gRnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gIC8vIGtlZXAgdGhlIHByb3RvdHlwZXMgaW4gc3luYyAoYW4gZWxlbWVudCBoYXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIGEgY29sbGVjdGlvbilcbiAgLy8gYW5kIHVzZSAkJC5lbGVmbiBhbmQgJCQuZWxlc2ZuIGFzIHNob3J0aGFuZHMgdG8gdGhlIHByb3RvdHlwZXNcbiAgJCQuZWxlZm4gPSAkJC5lbGVzZm4gPSAkJC5FbGVtZW50LnByb3RvdHlwZSA9ICQkLkNvbGxlY3Rpb24ucHJvdG90eXBlO1xuXG4gICQkLmVsZXNmbi5jeSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG4gIH07XG4gIFxuICAkJC5lbGVzZm4uZWxlbWVudCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXNbMF07XG4gIH07XG4gIFxuICAkJC5lbGVzZm4uY29sbGVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoICQkLmlzLmNvbGxlY3Rpb24odGhpcykgKXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7IC8vIGFuIGVsZW1lbnRcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgW3RoaXNdICk7XG4gICAgfVxuICB9O1xuXG4gICQkLmVsZXNmbi51bmlxdWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgdGhpcywgeyB1bmlxdWU6IHRydWUgfSApO1xuICB9O1xuXG4gICQkLmVsZXNmbi5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uKCBpZCApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGVsZSA9IHRoaXMuX3ByaXZhdGUuaWRzWyBpZCBdO1xuXG4gICAgcmV0dXJuIGVsZSA/IGVsZSA6ICQkLkNvbGxlY3Rpb24oY3kpOyAvLyBnZXQgZWxlIG9yIGVtcHR5IGNvbGxlY3Rpb25cbiAgfTtcblxuICAkJC5lbGVzZm4uanNvbiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXMuZWxlbWVudCgpO1xuICAgIGlmKCBlbGUgPT0gbnVsbCApeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICB2YXIgcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICBcbiAgICB2YXIganNvbiA9ICQkLnV0aWwuY29weSh7XG4gICAgICBkYXRhOiBwLmRhdGEsXG4gICAgICBwb3NpdGlvbjogcC5wb3NpdGlvbixcbiAgICAgIGdyb3VwOiBwLmdyb3VwLFxuICAgICAgYnlwYXNzOiBwLmJ5cGFzcyxcbiAgICAgIHJlbW92ZWQ6IHAucmVtb3ZlZCxcbiAgICAgIHNlbGVjdGVkOiBwLnNlbGVjdGVkLFxuICAgICAgc2VsZWN0YWJsZTogcC5zZWxlY3RhYmxlLFxuICAgICAgbG9ja2VkOiBwLmxvY2tlZCxcbiAgICAgIGdyYWJiZWQ6IHAuZ3JhYmJlZCxcbiAgICAgIGdyYWJiYWJsZTogcC5ncmFiYmFibGUsXG4gICAgICBjbGFzc2VzOiAnJ1xuICAgIH0pO1xuICAgIFxuICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgZm9yKCB2YXIgY2xzIGluIHAuY2xhc3NlcyApe1xuICAgICAgaWYoIHAuY2xhc3Nlc1tjbHNdICl7XG4gICAgICAgIGNsYXNzZXMucHVzaChjbHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuICAgICAganNvbi5jbGFzc2VzICs9IGNscyArICggaSA8IGNsYXNzZXMubGVuZ3RoIC0gMSA/ICcgJyA6ICcnICk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBqc29uO1xuICB9O1xuXG4gICQkLmVsZXNmbi5qc29ucyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGpzb25zID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuXG4gICAgICBqc29ucy5wdXNoKCBqc29uICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb25zO1xuICB9O1xuXG4gICQkLmVsZXNmbi5jbG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBlbGVzQXJyID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgICAgdmFyIGNsb25lID0gbmV3ICQkLkVsZW1lbnQoY3ksIGpzb24sIGZhbHNlKTsgLy8gTkIgbm8gcmVzdG9yZVxuXG4gICAgICBlbGVzQXJyLnB1c2goIGNsb25lICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZWxlc0FyciApO1xuICB9O1xuICAkJC5lbGVzZm4uY29weSA9ICQkLmVsZXNmbi5jbG9uZTtcblxuICAkJC5lbGVzZm4ucmVzdG9yZSA9IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVzdG9yZWQgPSBbXTtcbiAgICB2YXIgY3kgPSBzZWxmLmN5KCk7XG4gICAgXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgKXtcbiAgICAgIG5vdGlmeVJlbmRlcmVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYXJyYXlzIG9mIG5vZGVzIGFuZCBlZGdlcywgc2luY2Ugd2UgbmVlZCB0b1xuICAgIC8vIHJlc3RvcmUgdGhlIG5vZGVzIGZpcnN0XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIG5vZGVzID0gW10sIGVkZ2VzID0gW107XG4gICAgdmFyIG51bU5vZGVzID0gMDtcbiAgICB2YXIgbnVtRWRnZXMgPSAwO1xuICAgIGZvciggdmFyIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuICAgICAgXG4gICAgICAvLyBrZWVwIG5vZGVzIGZpcnN0IGluIHRoZSBhcnJheSBhbmQgZWRnZXMgYWZ0ZXJcbiAgICAgIGlmKCBlbGUuaXNOb2RlKCkgKXsgLy8gcHV0IHRvIGZyb250IG9mIGFycmF5IGlmIG5vZGVcbiAgICAgICAgbm9kZXMucHVzaCggZWxlICk7XG4gICAgICAgIG51bU5vZGVzKys7XG4gICAgICB9IGVsc2UgeyAvLyBwdXQgdG8gZW5kIG9mIGFycmF5IGlmIGVkZ2VcbiAgICAgICAgZWRnZXMucHVzaCggZWxlICk7XG4gICAgICAgIG51bUVkZ2VzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudHMgPSBub2Rlcy5jb25jYXQoIGVkZ2VzICk7XG5cbiAgICAvLyBub3csIHJlc3RvcmUgZWFjaCBlbGVtZW50XG4gICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVtZW50c1tpXTtcblxuICAgICAgaWYoICFlbGUucmVtb3ZlZCgpICl7XG4gICAgICAgIC8vIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBfcHJpdmF0ZSA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBkYXRhID0gX3ByaXZhdGUuZGF0YTtcbiAgICAgIFxuICAgICAgLy8gc2V0IGlkIGFuZCB2YWxpZGF0ZVxuICAgICAgaWYoIGRhdGEuaWQgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICBkYXRhLmlkID0gaWRGYWN0b3J5LmdlbmVyYXRlKCBjeSwgZWxlICk7XG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGRhdGEuaWQpIHx8ICEkJC5pcy5zdHJpbmcoZGF0YS5pZCkgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignQ2FuIG5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIGludmFsaWQgc3RyaW5nIElEIGAnICsgZGF0YS5pZCArICdgJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBpdCBoYXMgZW1wdHkgc3RyaW5nIGFzIGlkIG9yIG5vbi1zdHJpbmcgaWRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYoIGN5LmdldEVsZW1lbnRCeUlkKCBkYXRhLmlkICkubGVuZ3RoICE9PSAwICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0NhbiBub3QgY3JlYXRlIHNlY29uZCBlbGVtZW50IHdpdGggSUQgYCcgKyBkYXRhLmlkICsgJ2AnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIG9uZSBhbHJlYWR5IGhhcyB0aGF0IGlkXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWQgPSBkYXRhLmlkOyAvLyBpZCBpcyBmaW5hbGlzZWQsIG5vdyBsZXQncyBrZWVwIGEgcmVmXG4gICAgICBcbiAgICAgIGlmKCBlbGUuaXNFZGdlKCkgKXsgLy8gZXh0cmEgY2hlY2tzIGZvciBlZGdlc1xuICAgICAgICBcbiAgICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbJ3NvdXJjZScsICd0YXJnZXQnXTtcbiAgICAgICAgdmFyIGZpZWxkc0xlbmd0aCA9IGZpZWxkcy5sZW5ndGg7XG4gICAgICAgIHZhciBiYWRTb3VyY2VPclRhcmdldCA9IGZhbHNlO1xuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgZmllbGRzTGVuZ3RoOyBqKyspe1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tqXTtcbiAgICAgICAgICB2YXIgdmFsID0gZGF0YVtmaWVsZF07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gJycgKXtcbiAgICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkIHByb3Blcmx5XG4gICAgICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIHVuc3BlY2lmaWVkICcgKyBmaWVsZCk7XG4gICAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmKCBjeS5nZXRFbGVtZW50QnlJZCh2YWwpLmVtcHR5KCkgKXsgXG4gICAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgZWRnZSBpZiBvbmUgb2YgaXRzIG5vZGVzIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggbm9uZXhpc3RhbnQgJyArIGZpZWxkICsgJyBgJyArIHZhbCArICdgJyk7XG4gICAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGJhZFNvdXJjZU9yVGFyZ2V0ICl7IGNvbnRpbnVlOyB9IC8vIGNhbid0IGNyZWF0ZSB0aGlzXG4gICAgICAgIFxuICAgICAgICB2YXIgc3JjID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuc291cmNlICk7XG4gICAgICAgIHZhciB0Z3QgPSBjeS5nZXRFbGVtZW50QnlJZCggZGF0YS50YXJnZXQgKTtcblxuICAgICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaCggZWRnZSApO1xuICAgICAgICB0Z3QuX3ByaXZhdGUuZWRnZXMucHVzaCggZWRnZSApO1xuXG4gICAgICAgIGVkZ2UuX3ByaXZhdGUuc291cmNlID0gc3JjO1xuICAgICAgICBlZGdlLl9wcml2YXRlLnRhcmdldCA9IHRndDtcblxuICAgICAgfSAvLyBpZiBpcyBlZGdlXG4gICAgICAgXG4gICAgICAvLyBjcmVhdGUgbW9jayBpZHMgbWFwIGZvciBlbGVtZW50IHNvIGl0IGNhbiBiZSB1c2VkIGxpa2UgY29sbGVjdGlvbnNcbiAgICAgIF9wcml2YXRlLmlkcyA9IHt9O1xuICAgICAgX3ByaXZhdGUuaWRzWyBpZCBdID0gZWxlO1xuXG4gICAgICBfcHJpdmF0ZS5yZW1vdmVkID0gZmFsc2U7XG4gICAgICBjeS5hZGRUb1Bvb2woIGVsZSApO1xuICAgICAgXG4gICAgICByZXN0b3JlZC5wdXNoKCBlbGUgKTtcbiAgICB9IC8vIGZvciBlYWNoIGVsZW1lbnRcblxuICAgIC8vIGRvIGNvbXBvdW5kIG5vZGUgc2FuaXR5IGNoZWNrc1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApeyAvLyBlYWNoIG5vZGUgXG4gICAgICB2YXIgbm9kZSA9IGVsZW1lbnRzW2ldO1xuICAgICAgdmFyIGRhdGEgPSBub2RlLl9wcml2YXRlLmRhdGE7XG5cbiAgICAgIHZhciBwYXJlbnRJZCA9IG5vZGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQ7XG4gICAgICB2YXIgc3BlY2lmaWVkUGFyZW50ID0gcGFyZW50SWQgIT0gbnVsbDtcblxuICAgICAgaWYoIHNwZWNpZmllZFBhcmVudCApe1xuICAgICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHBhcmVudElkICk7XG5cbiAgICAgICAgaWYoIHBhcmVudC5lbXB0eSgpICl7XG4gICAgICAgICAgLy8gbm9uLWV4aXN0YW50IHBhcmVudDsganVzdCByZW1vdmUgaXRcbiAgICAgICAgICBkYXRhLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2VsZkFzUGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgICAgIHdoaWxlKCAhYW5jZXN0b3IuZW1wdHkoKSApe1xuICAgICAgICAgICAgaWYoIG5vZGUuc2FtZShhbmNlc3RvcikgKXtcbiAgICAgICAgICAgICAgLy8gbWFyayBzZWxmIGFzIHBhcmVudCBhbmQgcmVtb3ZlIGZyb20gZGF0YVxuICAgICAgICAgICAgICBzZWxmQXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICBkYXRhLnBhcmVudCA9IHVuZGVmaW5lZDsgLy8gcmVtb3ZlIHBhcmVudCByZWZlcmVuY2VcblxuICAgICAgICAgICAgICAvLyBleGl0IG9yIHdlIGxvb3AgZm9yZXZlclxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIXNlbGZBc1BhcmVudCApe1xuICAgICAgICAgICAgLy8gY29ubmVjdCB3aXRoIGNoaWxkcmVuXG4gICAgICAgICAgICBwYXJlbnRbMF0uX3ByaXZhdGUuY2hpbGRyZW4ucHVzaCggbm9kZSApO1xuICAgICAgICAgICAgbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICAgICAgICAgIC8vIGxldCB0aGUgY29yZSBrbm93IHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaFxuICAgICAgICAgICAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGVsc2VcbiAgICAgIH0gLy8gaWYgc3BlY2lmaWVkIHBhcmVudFxuICAgIH0gLy8gZm9yIGVhY2ggbm9kZVxuICAgIFxuICAgIHJlc3RvcmVkID0gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCByZXN0b3JlZCApO1xuICAgIGlmKCByZXN0b3JlZC5sZW5ndGggPiAwICl7XG5cbiAgICAgIHZhciB0b1VwZGF0ZVN0eWxlID0gcmVzdG9yZWQuYWRkKCByZXN0b3JlZC5jb25uZWN0ZWROb2RlcygpICkuYWRkKCByZXN0b3JlZC5wYXJlbnQoKSApO1xuICAgICAgdG9VcGRhdGVTdHlsZS51cGRhdGVTdHlsZSggbm90aWZ5UmVuZGVyZXIgKTtcblxuICAgICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICAgIHJlc3RvcmVkLnJ0cmlnZ2VyKCdhZGQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3RvcmVkLnRyaWdnZXIoJ2FkZCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc2VsZjsgLy8gY2hhaW5hYmlsaXR5XG4gIH07XG4gIFxuICAkJC5lbGVzZm4ucmVtb3ZlZCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAmJiBlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbiAgfTtcblxuICAkJC5lbGVzZm4uaW5zaWRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlICYmICFlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbiAgfTtcblxuICAkJC5lbGVzZm4ucmVtb3ZlID0gZnVuY3Rpb24oIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZW1vdmVkID0gW107XG4gICAgdmFyIGVsZXNUb1JlbW92ZSA9IFtdO1xuICAgIHZhciBlbGVzVG9SZW1vdmVJZHMgPSB7fTtcbiAgICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5O1xuICAgIFxuICAgIGlmKCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBub3RpZnlSZW5kZXJlciA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIGFkZCBjb25uZWN0ZWQgZWRnZXNcbiAgICBmdW5jdGlvbiBhZGRDb25uZWN0ZWRFZGdlcyhub2RlKXtcbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7IFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBhZGQoIGVkZ2VzW2ldICk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuXG4gICAgLy8gYWRkIGRlc2NlbmRhbnQgbm9kZXNcbiAgICBmdW5jdGlvbiBhZGRDaGlsZHJlbihub2RlKXtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuY2hpbGRyZW47XG4gICAgICBcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgYWRkKCBjaGlsZHJlbltpXSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZCggZWxlICl7XG4gICAgICB2YXIgYWxyZWFkeUFkZGVkID0gIGVsZXNUb1JlbW92ZUlkc1sgZWxlLmlkKCkgXTtcbiAgICAgIGlmKCBhbHJlYWR5QWRkZWQgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlc1RvUmVtb3ZlSWRzWyBlbGUuaWQoKSBdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIGVsZS5pc05vZGUoKSApe1xuICAgICAgICBlbGVzVG9SZW1vdmUucHVzaCggZWxlICk7IC8vIG5vZGVzIGFyZSByZW1vdmVkIGxhc3RcblxuICAgICAgICBhZGRDb25uZWN0ZWRFZGdlcyggZWxlICk7XG4gICAgICAgIGFkZENoaWxkcmVuKCBlbGUgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZXNUb1JlbW92ZS51bnNoaWZ0KCBlbGUgKTsgLy8gZWRnZXMgYXJlIHJlbW92ZWQgZmlyc3RcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYWtlIHRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIHJlbW92ZVxuICAgIC8vIChtYXkgYmUgcmVtb3ZpbmcgbW9yZSB0aGFuIHNwZWNpZmllZCBkdWUgdG8gY29ubmVjdGVkIGVkZ2VzIGV0YylcblxuICAgIGZvciggdmFyIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuXG4gICAgICBhZGQoIGVsZSApO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiByZW1vdmVFZGdlUmVmKG5vZGUsIGVkZ2Upe1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGNvbm5lY3RlZEVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tqXTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBlZGdlID09PSBjb25uZWN0ZWRFZGdlICl7XG4gICAgICAgICAgY29ubmVjdGVkRWRnZXMuc3BsaWNlKCBqLCAxICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVDaGlsZFJlZihwYXJlbnQsIGVsZSl7XG4gICAgICBlbGUgPSBlbGVbMF07XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgaWYoIGNoaWxkcmVuW2pdWzBdID09PSBlbGVbMF0gKXtcbiAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNUb1JlbW92ZVtpXTtcblxuICAgICAgLy8gbWFyayBhcyByZW1vdmVkXG4gICAgICBlbGUuX3ByaXZhdGUucmVtb3ZlZCA9IHRydWU7XG5cbiAgICAgIC8vIHJlbW92ZSBmcm9tIGNvcmUgcG9vbFxuICAgICAgY3kucmVtb3ZlRnJvbVBvb2woIGVsZSApO1xuXG4gICAgICAvLyBhZGQgdG8gbGlzdCBvZiByZW1vdmVkIGVsZW1lbnRzXG4gICAgICByZW1vdmVkLnB1c2goIGVsZSApO1xuXG4gICAgICBpZiggZWxlLmlzRWRnZSgpICl7IC8vIHJlbW92ZSByZWZlcmVuY2VzIHRvIHRoaXMgZWRnZSBpbiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgICAgIHZhciBzcmMgPSBlbGUuc291cmNlKClbMF07XG4gICAgICAgIHZhciB0Z3QgPSBlbGUudGFyZ2V0KClbMF07XG5cbiAgICAgICAgcmVtb3ZlRWRnZVJlZiggc3JjLCBlbGUgKTtcbiAgICAgICAgcmVtb3ZlRWRnZVJlZiggdGd0LCBlbGUgKTtcblxuICAgICAgfSBlbHNlIHsgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBwYXJlbnQgXG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGUucGFyZW50KCk7XG5cbiAgICAgICAgaWYoIHBhcmVudC5sZW5ndGggIT09IDAgKXtcbiAgICAgICAgICByZW1vdmVDaGlsZFJlZihwYXJlbnQsIGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuICAgIHZhciBlbGVzU3RpbGxJbnNpZGUgPSBjeS5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gZmFsc2U7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzU3RpbGxJbnNpZGUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzU3RpbGxJbnNpZGVbaV07XG5cbiAgICAgIGlmKCBlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlbW92ZWRFbGVtZW50cyA9IG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCksIHJlbW92ZWQgKTtcbiAgICBpZiggcmVtb3ZlZEVsZW1lbnRzLnNpemUoKSA+IDAgKXtcbiAgICAgIC8vIG11c3QgbWFudWFsbHkgbm90aWZ5IHNpbmNlIHRyaWdnZXIgd29uJ3QgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IG9uY2UgcmVtb3ZlZFxuICAgICAgXG4gICAgICBpZiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgICAgdGhpcy5jeSgpLm5vdGlmeSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgICAgY29sbGVjdGlvbjogcmVtb3ZlZEVsZW1lbnRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZW1vdmVkRWxlbWVudHMudHJpZ2dlcigncmVtb3ZlJyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGVtcHR5IHJlbWFpbmluZyBwYXJlbnQgbm9kZXNcbiAgICB2YXIgY2hlY2tlZFBhcmVudElkID0ge307XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzVG9SZW1vdmUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzVG9SZW1vdmVbaV07XG4gICAgICB2YXIgaXNOb2RlID0gZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnO1xuICAgICAgdmFyIHBhcmVudElkID0gZWxlLl9wcml2YXRlLmRhdGEucGFyZW50O1xuXG4gICAgICBpZiggaXNOb2RlICYmIHBhcmVudElkICE9PSB1bmRlZmluZWQgJiYgIWNoZWNrZWRQYXJlbnRJZFsgcGFyZW50SWQgXSApe1xuICAgICAgICBjaGVja2VkUGFyZW50SWRbIHBhcmVudElkIF0gPSB0cnVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHBhcmVudElkICk7XG5cbiAgICAgICAgaWYoIHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoICE9PSAwICYmICFwYXJlbnQuX3ByaXZhdGUucmVtb3ZlZCAmJiBwYXJlbnQuY2hpbGRyZW4oKS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICBwYXJlbnQudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gICQkLmVsZXNmbi5tb3ZlID0gZnVuY3Rpb24oIHN0cnVjdCApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiggc3RydWN0LnNvdXJjZSAhPT0gdW5kZWZpbmVkIHx8IHN0cnVjdC50YXJnZXQgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdmFyIHNyY0lkID0gc3RydWN0LnNvdXJjZTtcbiAgICAgIHZhciB0Z3RJZCA9IHN0cnVjdC50YXJnZXQ7XG4gICAgICB2YXIgc3JjRXhpc3RzID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHNyY0lkICkubGVuZ3RoID4gMDtcbiAgICAgIHZhciB0Z3RFeGlzdHMgPSBjeS5nZXRFbGVtZW50QnlJZCggdGd0SWQgKS5sZW5ndGggPiAwO1xuXG4gICAgICBpZiggc3JjRXhpc3RzIHx8IHRndEV4aXN0cyApe1xuICAgICAgICB2YXIganNvbnMgPSB0aGlzLmpzb25zKCk7XG5cbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGpzb24gPSBqc29uc1tpXTtcblxuICAgICAgICAgIGlmKCBqc29uLmdyb3VwID09PSAnZWRnZXMnICl7XG4gICAgICAgICAgICBpZiggc3JjRXhpc3RzICl7IGpzb24uZGF0YS5zb3VyY2UgPSBzcmNJZDsgfVxuICAgICAgICAgICAgaWYoIHRndEV4aXN0cyApeyBqc29uLmRhdGEudGFyZ2V0ID0gdGd0SWQ7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3kuYWRkKCBqc29ucyApO1xuICAgICAgfVxuIFxuICAgIH0gZWxzZSBpZiggc3RydWN0LnBhcmVudCAhPT0gdW5kZWZpbmVkICl7IC8vIG1vdmUgbm9kZSB0byBuZXcgcGFyZW50XG4gICAgICB2YXIgcGFyZW50SWQgPSBzdHJ1Y3QucGFyZW50O1xuICAgICAgdmFyIHBhcmVudEV4aXN0cyA9IHBhcmVudElkID09PSBudWxsIHx8IGN5LmdldEVsZW1lbnRCeUlkKCBwYXJlbnRJZCApLmxlbmd0aCA+IDA7XG4gICAgXG4gICAgICBpZiggcGFyZW50RXhpc3RzICl7XG4gICAgICAgIHZhciBqc29ucyA9IHRoaXMuanNvbnMoKTtcbiAgICAgICAgdmFyIGRlc2NzID0gdGhpcy5kZXNjZW5kYW50cygpO1xuICAgICAgICB2YXIgZGVzY3NFdGMgPSBkZXNjcy5tZXJnZSggZGVzY3MuYWRkKHRoaXMpLmNvbm5lY3RlZEVkZ2VzKCkgKTtcblxuICAgICAgICB0aGlzLnJlbW92ZSgpOyAvLyBOQjogYWxzbyByZW1vdmVzIGRlc2NlbmRhbnRzIGFuZCB0aGVpciBjb25uZWN0ZWQgZWRnZXNcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIganNvbiA9IGpzb25zW2ldO1xuXG4gICAgICAgICAgaWYoIGpzb24uZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgICAgIGpzb24uZGF0YS5wYXJlbnQgPSBwYXJlbnRJZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBhcmVudElkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3kuYWRkKCBqc29ucyApLm1lcmdlKCBkZXNjc0V0Yy5yZXN0b3JlKCkgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gaWYgbm90aGluZyBkb25lXG4gIH07XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gc2VhcmNoLCBzcGFubmluZyB0cmVlcywgZXRjXG4gICQkLmZuLmVsZXMoe1xuXG4gICAgLy8gc3RkIGZ1bmN0aW9uYWwgZWxlIGZpcnN0IGNhbGxiYWNrIHN0eWxlXG4gICAgc3RkQnJlYWR0aEZpcnN0U2VhcmNoOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgb3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKCB7fSwgb3B0aW9ucywge1xuICAgICAgICBzdGQ6IHRydWVcbiAgICAgIH0gKTtcblxuICAgICAgcmV0dXJuIHRoaXMuYnJlYWR0aEZpcnN0U2VhcmNoKCBvcHRpb25zICk7XG4gICAgfSxcblxuICAgIC8vIGRvIGEgYnJlYWR0aCBmaXJzdCBzZWFyY2ggZnJvbSB0aGUgbm9kZXMgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBmcm9tIHBzZXVkb2NvZGUgb24gd2lraXBlZGlhXG4gICAgYnJlYWR0aEZpcnN0U2VhcmNoOiBmdW5jdGlvbiggcm9vdHMsIGZuLCBkaXJlY3RlZCApe1xuICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICB2YXIgc3RkO1xuICAgICAgdmFyIHRoaXNBcmc7XG4gICAgICBpZiggJCQuaXMucGxhaW5PYmplY3Qocm9vdHMpICYmICEkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKHJvb3RzKSApe1xuICAgICAgICBvcHRpb25zID0gcm9vdHM7XG4gICAgICAgIHJvb3RzID0gb3B0aW9ucy5yb290cztcbiAgICAgICAgZm4gPSBvcHRpb25zLnZpc2l0O1xuICAgICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICAgIHN0ZCA9IG9wdGlvbnMuc3RkO1xuICAgICAgICB0aGlzQXJnID0gb3B0aW9ucy50aGlzQXJnO1xuICAgICAgfVxuXG4gICAgICBkaXJlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgISQkLmlzLmZuKGZuKSA/IGZuIDogZGlyZWN0ZWQ7XG4gICAgICBmbiA9ICQkLmlzLmZuKGZuKSA/IGZuIDogZnVuY3Rpb24oKXt9O1xuICAgICAgXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHYgPSAkJC5pcy5zdHJpbmcocm9vdHMpID8gdGhpcy5maWx0ZXIocm9vdHMpIDogcm9vdHM7XG4gICAgICB2YXIgUSA9IFtdO1xuICAgICAgdmFyIGNvbm5lY3RlZE5vZGVzID0gW107XG4gICAgICB2YXIgY29ubmVjdGVkQnkgPSB7fTtcbiAgICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgICAgdmFyIFYgPSB7fTtcbiAgICAgIHZhciBqID0gMDtcbiAgICAgIHZhciBmb3VuZDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcblxuICAgICAgLy8gZW5xdWV1ZSB2XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIHZbaV0uaXNOb2RlKCkgKXtcbiAgICAgICAgICBRLnVuc2hpZnQoIHZbaV0gKTtcbiAgICAgICAgICBWWyB2W2ldLmlkKCkgXSA9IHRydWU7IFxuXG4gICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCggdltpXSApO1xuICAgICAgICAgIGlkMmRlcHRoWyB2W2ldLmlkKCkgXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUoIFEubGVuZ3RoICE9PSAwICl7XG4gICAgICAgIHZhciB2ID0gUS5zaGlmdCgpO1xuICAgICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFsgdi5pZCgpIF07XG4gICAgICAgIHZhciBwcmV2RWRnZSA9IGNvbm5lY3RlZEJ5WyB2LmlkKCkgXTtcbiAgICAgICAgdmFyIHByZXZOb2RlID0gcHJldkVkZ2UgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHByZXZFZGdlLmNvbm5lY3RlZE5vZGVzKCkubm90KCB2IClbMF07XG4gICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgaWYoIHN0ZCApe1xuICAgICAgICAgIHJldCA9IGZuLmNhbGwodGhpc0FyZywgdiwgcHJldkVkZ2UsIHByZXZOb2RlLCBqKyssIGRlcHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBmbi5jYWxsKHYsIGorKywgZGVwdGgsIHYsIHByZXZFZGdlLCBwcmV2Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggcmV0ID09PSB0cnVlICl7XG4gICAgICAgICAgZm91bmQgPSB2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2d0VkZ2VzID0gdi5jb25uZWN0ZWRFZGdlcyhkaXJlY3RlZCA/IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGEoJ3NvdXJjZScpID09PSB2LmlkKCk7IH0gOiB1bmRlZmluZWQpLmludGVyc2VjdCggZWRnZXMgKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGUgPSB2d0VkZ2VzW2ldO1xuICAgICAgICAgIHZhciB3ID0gZS5jb25uZWN0ZWROb2RlcyhmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5pZCgpICE9PSB2LmlkKCk7IH0pLmludGVyc2VjdCggbm9kZXMgKTtcblxuICAgICAgICAgIGlmKCB3Lmxlbmd0aCAhPT0gMCAmJiAhVlsgdy5pZCgpIF0gKXtcbiAgICAgICAgICAgIHcgPSB3WzBdO1xuXG4gICAgICAgICAgICBRLnB1c2goIHcgKTtcbiAgICAgICAgICAgIFZbIHcuaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWQyZGVwdGhbIHcuaWQoKSBdID0gaWQyZGVwdGhbIHYuaWQoKSBdICsgMTtcblxuICAgICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCggdyApO1xuICAgICAgICAgICAgY29ubmVjdGVkQnlbIHcuaWQoKSBdID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9XG5cbiAgICAgIHZhciBjb25uZWN0ZWRFbGVzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkTm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBjb25uZWN0ZWROb2Rlc1tpXTtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRCeVsgbm9kZS5pZCgpIF07XG5cbiAgICAgICAgaWYoIGVkZ2UgKXtcbiAgICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaCggbm9kZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGNvbm5lY3RlZEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgICAgZm91bmQ6IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZm91bmQsIHsgdW5pcXVlOiB0cnVlIH0gKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gc3RkIGZ1bmN0aW9uYWwgZWxlIGZpcnN0IGNhbGxiYWNrIHN0eWxlXG4gICAgc3RkRGVwdGhGaXJzdFNlYXJjaDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIG9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCgge30sIG9wdGlvbnMsIHtcbiAgICAgICAgc3RkOiB0cnVlXG4gICAgICB9ICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmRlcHRoRmlyc3RTZWFyY2goIG9wdGlvbnMgKTtcbiAgICB9LFxuXG4gICAgLy8gZG8gYSBkZXB0aCBmaXJzdCBzZWFyY2ggb24gdGhlIG5vZGVzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgLy8gZnJvbSBwc2V1ZG9jb2RlIG9uIHdpa2lwZWRpYSAoaXRlcmF0aXZlIGltcGwpXG4gICAgZGVwdGhGaXJzdFNlYXJjaDogZnVuY3Rpb24oIHJvb3RzLCBmbiwgZGlyZWN0ZWQgKXtcbiAgICAgIHZhciBvcHRpb25zO1xuICAgICAgdmFyIHN0ZDtcbiAgICAgIHZhciB0aGlzQXJnO1xuICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KHJvb3RzKSAmJiAhJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihyb290cykgKXtcbiAgICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gICAgICAgIGZuID0gb3B0aW9ucy52aXNpdDtcbiAgICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgICBzdGQgPSBvcHRpb25zLnN0ZDtcbiAgICAgICAgdGhpc0FyZyA9IG9wdGlvbnMudGhpc0FyZztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZGlyZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICEkJC5pcy5mbihmbikgPyBmbiA6IGRpcmVjdGVkO1xuICAgICAgZm4gPSAkJC5pcy5mbihmbikgPyBmbiA6IGZ1bmN0aW9uKCl7fTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgdiA9ICQkLmlzLnN0cmluZyhyb290cykgPyB0aGlzLmZpbHRlcihyb290cykgOiByb290cztcbiAgICAgIHZhciBTID0gW107XG4gICAgICB2YXIgY29ubmVjdGVkTm9kZXMgPSBbXTtcbiAgICAgIHZhciBjb25uZWN0ZWRCeSA9IHt9O1xuICAgICAgdmFyIGlkMmRlcHRoID0ge307XG4gICAgICB2YXIgZGlzY292ZXJlZCA9IHt9O1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdmFyIGZvdW5kO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICAvLyBwdXNoIHZcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKyApe1xuICAgICAgICBpZiggdltpXS5pc05vZGUoKSApe1xuICAgICAgICAgIFMucHVzaCggdltpXSApO1xuXG4gICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCggdltpXSApO1xuICAgICAgICAgIGlkMmRlcHRoWyB2W2ldLmlkKCkgXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUoIFMubGVuZ3RoICE9PSAwICl7XG4gICAgICAgIHZhciB2ID0gUy5wb3AoKTtcblxuICAgICAgICBpZiggIWRpc2NvdmVyZWRbIHYuaWQoKSBdICl7XG4gICAgICAgICAgZGlzY292ZXJlZFsgdi5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHYuaWQoKSBdO1xuICAgICAgICAgIHZhciBwcmV2RWRnZSA9IGNvbm5lY3RlZEJ5WyB2LmlkKCkgXTtcbiAgICAgICAgICB2YXIgcHJldk5vZGUgPSBwcmV2RWRnZSA9PSBudWxsID8gdW5kZWZpbmVkIDogcHJldkVkZ2UuY29ubmVjdGVkTm9kZXMoKS5ub3QoIHYgKVswXTtcbiAgICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgICAgaWYoIHN0ZCApe1xuICAgICAgICAgICAgcmV0ID0gZm4uY2FsbCh0aGlzQXJnLCB2LCBwcmV2RWRnZSwgcHJldk5vZGUsIGorKywgZGVwdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBmbi5jYWxsKHYsIGorKywgZGVwdGgsIHYsIHByZXZFZGdlLCBwcmV2Tm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHJldCA9PT0gdHJ1ZSApe1xuICAgICAgICAgICAgZm91bmQgPSB2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB2d0VkZ2VzID0gdi5jb25uZWN0ZWRFZGdlcyhkaXJlY3RlZCA/IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGEoJ3NvdXJjZScpID09PSB2LmlkKCk7IH0gOiB1bmRlZmluZWQpLmludGVyc2VjdCggZWRnZXMgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHZ3RWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBlID0gdndFZGdlc1tpXTtcbiAgICAgICAgICAgIHZhciB3ID0gZS5jb25uZWN0ZWROb2RlcyhmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5pZCgpICE9PSB2LmlkKCk7IH0pLmludGVyc2VjdCggbm9kZXMgKTtcblxuICAgICAgICAgICAgaWYoIHcubGVuZ3RoICE9PSAwICYmICFkaXNjb3ZlcmVkWyB3LmlkKCkgXSApe1xuICAgICAgICAgICAgICB3ID0gd1swXTtcblxuICAgICAgICAgICAgICBTLnB1c2goIHcgKTtcblxuICAgICAgICAgICAgICBpZDJkZXB0aFsgdy5pZCgpIF0gPSBpZDJkZXB0aFsgdi5pZCgpIF0gKyAxO1xuXG4gICAgICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHcgKTtcbiAgICAgICAgICAgICAgY29ubmVjdGVkQnlbIHcuaWQoKSBdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbm5lY3RlZEVsZXMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IGNvbm5lY3RlZE5vZGVzW2ldO1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEJ5WyBub2RlLmlkKCkgXTtcblxuICAgICAgICBpZiggZWRnZSApe1xuICAgICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaCggZWRnZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKCBub2RlICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgY29ubmVjdGVkRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLFxuICAgICAgICBmb3VuZDogbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBmb3VuZCwgeyB1bmlxdWU6IHRydWUgfSApXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBrcnVza2FsJ3MgYWxnb3JpdGhtIChmaW5kcyBtaW4gc3Bhbm5pbmcgdHJlZSwgYXNzdW1pbmcgdW5kaXJlY3RlZCBncmFwaClcbiAgICAvLyBpbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgICBrcnVza2FsOiBmdW5jdGlvbiggd2VpZ2h0Rm4gKXtcbiAgICAgIHdlaWdodEZuID0gJCQuaXMuZm4od2VpZ2h0Rm4pID8gd2VpZ2h0Rm4gOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfTsgLy8gaWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuXG4gICAgICBmdW5jdGlvbiBmaW5kU2V0KGVsZSl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZXMgPSBmb3Jlc3RbaV07XG5cbiAgICAgICAgICBpZiggZWxlcy5hbnlTYW1lKGVsZSkgKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVsZXM6IGVsZXMsXG4gICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgQSA9IG5ldyAkJC5Db2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIFtdKTtcbiAgICAgIHZhciBmb3Jlc3QgPSBbXTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBmb3Jlc3QucHVzaCggbm9kZXNbaV0uY29sbGVjdGlvbigpICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICAgIHZhciBTID0gZWRnZXMudG9BcnJheSgpLnNvcnQoZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIHZhciB3ZWlnaHRBID0gd2VpZ2h0Rm4uY2FsbChhLCBhKTtcbiAgICAgICAgdmFyIHdlaWdodEIgPSB3ZWlnaHRGbi5jYWxsKGIsIGIpO1xuXG4gICAgICAgIHJldHVybiB3ZWlnaHRBIC0gd2VpZ2h0QjtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgUy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlZGdlID0gU1tpXTtcbiAgICAgICAgdmFyIHUgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgICB2YXIgdiA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgICAgIHZhciBzZXRVID0gZmluZFNldCh1KTtcbiAgICAgICAgdmFyIHNldFYgPSBmaW5kU2V0KHYpO1xuXG4gICAgICAgIGlmKCBzZXRVLmluZGV4ICE9PSBzZXRWLmluZGV4ICl7XG4gICAgICAgICAgQSA9IEEuYWRkKCBlZGdlICk7XG5cbiAgICAgICAgICAvLyBjb21iaW5lIGZvcmVzdHMgZm9yIHUgYW5kIHZcbiAgICAgICAgICBmb3Jlc3RbIHNldFUuaW5kZXggXSA9IHNldFUuZWxlcy5hZGQoIHNldFYuZWxlcyApO1xuICAgICAgICAgIGZvcmVzdC5zcGxpY2UoIHNldFYuaW5kZXgsIDEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZXMuYWRkKCBBICk7XG5cbiAgICB9LFxuXG4gICAgZGlqa3N0cmE6IGZ1bmN0aW9uKCByb290LCB3ZWlnaHRGbiwgZGlyZWN0ZWQgKXtcbiAgICAgIHZhciBvcHRpb25zO1xuICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KHJvb3QpICYmICEkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKHJvb3QpICl7XG4gICAgICAgIG9wdGlvbnMgPSByb290O1xuICAgICAgICByb290ID0gb3B0aW9ucy5yb290O1xuICAgICAgICB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB3ZWlnaHRGbiA9ICQkLmlzLmZuKHdlaWdodEZuKSA/IHdlaWdodEZuIDogZnVuY3Rpb24oKXsgcmV0dXJuIDE7IH07IC8vIGlmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcblxuICAgICAgdmFyIHNvdXJjZSA9ICQkLmlzLnN0cmluZyhyb290KSA/IHRoaXMuZmlsdGVyKHJvb3QpWzBdIDogcm9vdFswXTtcbiAgICAgIHZhciBkaXN0ID0ge307XG4gICAgICB2YXIgcHJldiA9IHt9O1xuICAgICAgdmFyIGtub3duRGlzdCA9IHt9O1xuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuZmlsdGVyKGZ1bmN0aW9uKCl7IHJldHVybiAhdGhpcy5pc0xvb3AoKTsgfSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgUSA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGRpc3RbIG5vZGVzW2ldLmlkKCkgXSA9IG5vZGVzW2ldLnNhbWUoIHNvdXJjZSApID8gMCA6IEluZmluaXR5O1xuICAgICAgICBRLnB1c2goIG5vZGVzW2ldICk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZUZuID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICByZXR1cm4gZGlzdFsgbm9kZS5pZCgpIF07XG4gICAgICB9O1xuICAgICAgXG4gICAgICBRID0gbmV3ICQkLkNvbGxlY3Rpb24oY3ksIFEpO1xuICAgIFxuICAgICAgdmFyIGhlYXAgPSAkJC5NaW5oZWFwKGN5LCBRLCB2YWx1ZUZuKTtcbiAgICBcbiAgICAgIHZhciBkaXN0QmV0d2VlbiA9IGZ1bmN0aW9uKHUsIHYpe1xuICAgICAgICB2YXIgdXZzID0gKCBkaXJlY3RlZCA/IHUuZWRnZXNUbyh2KSA6IHUuZWRnZXNXaXRoKHYpICkuaW50ZXJzZWN0KGVkZ2VzKTtcbiAgICAgICAgdmFyIHNtYWxsZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHNtYWxsZXN0RWRnZTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHV2cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gdXZzW2ldO1xuICAgICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseSggZWRnZSwgW2VkZ2VdICk7XG5cbiAgICAgICAgICBpZiggd2VpZ2h0IDwgc21hbGxlc3REaXN0YW5jZSB8fCAhc21hbGxlc3RFZGdlICl7XG4gICAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlID0gd2VpZ2h0O1xuICAgICAgICAgICAgc21hbGxlc3RFZGdlID0gZWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVkZ2U6IHNtYWxsZXN0RWRnZSxcbiAgICAgICAgICBkaXN0OiBzbWFsbGVzdERpc3RhbmNlXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB3aGlsZShoZWFwLnNpemUoKSA+IDApe1xuICAgICAgICB2YXIgc21hbGxlc3RFbCA9IGhlYXAucG9wKCksXG4gICAgICAgIHNtYWxsZXRzRGlzdCA9IHNtYWxsZXN0RWwudmFsdWUsXG4gICAgICAgIHVpZCA9IHNtYWxsZXN0RWwuaWQsXG4gICAgICAgIHUgPSBjeS5nZXRFbGVtZW50QnlJZCh1aWQpO1xuICAgIFxuICAgICAgICBrbm93bkRpc3RbdWlkXSA9IHNtYWxsZXRzRGlzdDtcbiAgICAgIFxuICAgICAgICBpZiggc21hbGxldHNEaXN0ID09PSBNYXRoLkluZmluaXRlICl7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdS5uZWlnaGJvcmhvb2QoKS5pbnRlcnNlY3Qobm9kZXMpO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciB2ID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICAgICAgdmFyIHZEaXN0ID0gZGlzdEJldHdlZW4odSwgdik7XG5cbiAgICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcblxuICAgICAgICAgIGlmKCBhbHQgPCBoZWFwLmdldFZhbHVlQnlJZCh2aWQpICl7XG4gICAgICAgICAgICBoZWFwLmVkaXQodmlkLCBhbHQpO1xuICAgICAgICAgICAgcHJldlsgdmlkIF0gPSB7XG4gICAgICAgICAgICAgIG5vZGU6IHUsXG4gICAgICAgICAgICAgIGVkZ2U6IHZEaXN0LmVkZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGZvciBcbiAgICAgIH0gLy8gd2hpbGVcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzdGFuY2VUbzogZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgdmFyIHRhcmdldCA9ICQkLmlzLnN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG5cbiAgICAgICAgICByZXR1cm4ga25vd25EaXN0WyB0YXJnZXQuaWQoKSBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhdGhUbzogZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgdmFyIHRhcmdldCA9ICQkLmlzLnN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgICAgdmFyIFMgPSBbXTtcbiAgICAgICAgICB2YXIgdSA9IHRhcmdldDtcblxuICAgICAgICAgIGlmKCB0YXJnZXQubGVuZ3RoID4gMCApe1xuICAgICAgICAgICAgUy51bnNoaWZ0KCB0YXJnZXQgKTtcblxuICAgICAgICAgICAgd2hpbGUoIHByZXZbIHUuaWQoKSBdICl7XG4gICAgICAgICAgICAgIHZhciBwID0gcHJldlsgdS5pZCgpIF07XG5cbiAgICAgICAgICAgICAgUy51bnNoaWZ0KCBwLmVkZ2UgKTtcbiAgICAgICAgICAgICAgUy51bnNoaWZ0KCBwLm5vZGUgKTtcblxuICAgICAgICAgICAgICB1ID0gcC5ub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIFMgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9ICBcbiAgfSk7XG5cbiAgLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRoaWNhbCBhbGlhc1xuICAkJC5lbGVzZm4uYmZzID0gJCQuZWxlc2ZuLmJyZWFkdGhGaXJzdFNlYXJjaDtcbiAgJCQuZWxlc2ZuLmRmcyA9ICQkLmVsZXNmbi5kZXB0aEZpcnN0U2VhcmNoO1xuICAkJC5lbGVzZm4uc3RkQmZzID0gJCQuZWxlc2ZuLnN0ZEJyZWFkdGhGaXJzdFNlYXJjaDtcbiAgJCQuZWxlc2ZuLnN0ZERmcyA9ICQkLmVsZXNmbi5zdGREZXB0aEZpcnN0U2VhcmNoO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCkgeyBcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEFkZGl0aW9uYWwgZ3JhcGggYW5hbHlzaXMgYWxnb3JpdGhtc1xuICAkJC5mbi5lbGVzKHtcblxuICAgIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgcm9vdCAvLyBzdGFydGluZyBub2RlIChlaXRoZXIgZWxlbWVudCBvciBzZWxlY3RvciBzdHJpbmcpXG4gICAgLy8gICB3ZWlnaHQ6IGZ1bmN0aW9uKCBlZGdlICl7fSAvLyBzcGVjaWZpZXMgd2VpZ2h0IHRvIHVzZSBmb3IgYGVkZ2VgL2B0aGlzYC4gSWYgbm90IHByZXNlbnQsIGl0IHdpbGwgYmUgYXN1bWVkIGEgd2VpZ2h0IG9mIDEgZm9yIGFsbCBlZGdlc1xuICAgIC8vICAgaGV1cmlzdGljOiBmdW5jdGlvbiggbm9kZSApe30gLy8gc3BlY2lmaWVzIGhldXJpc3RpYyB2YWx1ZSBmb3IgYG5vZGVgL2B0aGlzYFxuICAgIC8vICAgZGlyZWN0ZWQgLy8gZGVmYXVsdCBmYWxzZVxuICAgIC8vICAgZ29hbCAvLyB0YXJnZXQgbm9kZSAoZWl0aGVyIGVsZW1lbnQgb3Igc2VsZWN0b3Igc3RyaW5nKS4gTWFuZGF0b3J5LlxuXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vICAgZm91bmQgOiB0cnVlL2ZhbHNlIC8vIHdoZXRoZXIgYSBwYXRoIGZyb20gcm9vdCB0byBnb2FsIGhhcyBiZWVuIGZvdW5kXG4gICAgLy8gICBkaXN0YW5jZSAvLyBEaXN0YW5jZSBmb3IgdGhlIHNob3J0ZXN0IHBhdGggZnJvbSByb290IHRvIGdvYWxcbiAgICAvLyAgIHBhdGggLy8gQXJyYXkgb2YgaWRzIG9mIG5vZGVzIGluIHNob3J0ZXN0IHBhdGhcbiAgICBhU3RhcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBSZWNvbnN0cnVjdHMgdGhlIHBhdGggZnJvbSBTdGFydCB0byBFbmQsIGFjdW11bGF0aW5nIHRoZSByZXN1bHQgaW4gcGF0aEFjdW1cbiAgICAgIHZhciByZWNvbnN0cnVjdFBhdGggPSBmdW5jdGlvbihzdGFydCwgZW5kLCBjYW1lRnJvbU1hcCwgcGF0aEFjdW0pIHtcbiAgICAgICAgLy8gQmFzZSBjYXNlXG4gICAgICAgIGlmIChzdGFydCA9PSBlbmQpIHtcbiAgICAgICAgICBwYXRoQWN1bS5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZChlbmQpICk7XG4gICAgICAgICAgcmV0dXJuIHBhdGhBY3VtO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZW5kIGluIGNhbWVGcm9tTWFwKSB7XG4gICAgICAgICAgLy8gV2Uga25vdyB3aGljaCBub2RlIGlzIGJlZm9yZSB0aGUgbGFzdCBvbmVcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBjYW1lRnJvbU1hcFtlbmRdO1xuICAgICAgICAgIHZhciBwcmV2aW91c0VkZ2UgPSBjYW1lRnJvbUVkZ2VbZW5kXTtcblxuICAgICAgICAgIHBhdGhBY3VtLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKGVuZCkgKTtcbiAgICAgICAgICBwYXRoQWN1bS5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZChwcmV2aW91c0VkZ2UpICk7XG5cblxuICAgICAgICAgIHJldHVybiByZWNvbnN0cnVjdFBhdGgoc3RhcnQsIFxuICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cywgXG4gICAgICAgICAgICAgICAgICAgICAgIGNhbWVGcm9tTWFwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgcGF0aEFjdW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCByZWFjaCBoZXJlIVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAgICAgICBcbiAgICAgIH07XG5cbiAgICAgIC8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGluIG9wZW5TZXQgd2hpY2ggaGFzIG1pbmltdW0gZlNjb3JlXG4gICAgICB2YXIgZmluZE1pbiA9IGZ1bmN0aW9uKG9wZW5TZXQsIGZTY29yZSkge1xuICAgICAgICBpZiAob3BlblNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBTaG91bGQgbmV2ZXIgYmUgdGhlIGNhc2VcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaW5Qb3MgPSAwO1xuICAgICAgICB2YXIgdGVtcFNjb3JlID0gZlNjb3JlW29wZW5TZXRbMF1dO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG9wZW5TZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcyA9IGZTY29yZVtvcGVuU2V0W2ldXTtcbiAgICAgICAgICBpZiAocyA8IHRlbXBTY29yZSkge1xuICAgICAgICAgICAgdGVtcFNjb3JlID0gcztcbiAgICAgICAgICAgIG1pblBvcyA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW5Qb3M7XG4gICAgICB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gbG9nRGVidWcoXCJTdGFydGluZyBhU3Rhci4uLlwiKTsgXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnJvb3QgIT0gbnVsbCkgeyAgICAgICAgXG4gICAgICAgIHZhciBzb3VyY2UgPSAkJC5pcy5zdHJpbmcob3B0aW9ucy5yb290KSA/IFxuICAgICAgICAgIC8vIHVzZSBpdCBhcyBhIHNlbGVjdG9yLCBlLmcuIFwiI3Jvb3RJRFxuICAgICAgICAgIHRoaXMuZmlsdGVyKG9wdGlvbnMucm9vdClbMF0gOiBcbiAgICAgICAgICBvcHRpb25zLnJvb3RbMF07XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiU291cmNlIG5vZGU6ICVzXCIsIHNvdXJjZS5pZCgpKTsgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBnb2FsIC0gbWFuZGF0b3J5IVxuICAgICAgaWYgKG9wdGlvbnMuZ29hbCAhPSBudWxsKSB7ICAgICAgIFxuICAgICAgICB2YXIgdGFyZ2V0ID0gJCQuaXMuc3RyaW5nKG9wdGlvbnMuZ29hbCkgPyBcbiAgICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNnb2FsSURcbiAgICAgICAgICB0aGlzLmZpbHRlcihvcHRpb25zLmdvYWwpWzBdIDogXG4gICAgICAgICAgb3B0aW9ucy5nb2FsWzBdO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlRhcmdldCBub2RlOiAlc1wiLCB0YXJnZXQuaWQoKSk7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gSGV1cmlzdGljIGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLmhldXJpc3RpYyAhPSBudWxsICYmICQkLmlzLmZuKG9wdGlvbnMuaGV1cmlzdGljKSkgeyAgICAgICBcbiAgICAgICAgdmFyIGhldXJpc3RpYyA9IG9wdGlvbnMuaGV1cmlzdGljO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhldXJpc3RpYyA9IGZ1bmN0aW9uKCl7IHJldHVybiAwOyB9OyAvLyB1c2UgY29uc3RhbnQgaWYgdW5zcGVjaWZpZWRcbiAgICAgICAgLy8gJCQudXRpbC5lcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIChoZXVyaXN0aWMpISBBYm9ydGluZy5cIik7XG4gICAgICAgIC8vIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmICQkLmlzLmZuKG9wdGlvbnMud2VpZ2h0KSkgeyAgICAgICBcbiAgICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKGUpIHtyZXR1cm4gMTt9O1xuICAgICAgfVxuXG4gICAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsKSB7ICAgICAgIFxuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbG9zZWRTZXQgPSBbXTtcbiAgICAgIHZhciBvcGVuU2V0ID0gW3NvdXJjZS5pZCgpXTtcbiAgICAgIHZhciBjYW1lRnJvbSA9IHt9O1xuICAgICAgdmFyIGNhbWVGcm9tRWRnZSA9IHt9O1xuICAgICAgdmFyIGdTY29yZSA9IHt9O1xuICAgICAgdmFyIGZTY29yZSA9IHt9O1xuXG4gICAgICBnU2NvcmVbc291cmNlLmlkKCldID0gMDtcbiAgICAgIGZTY29yZVtzb3VyY2UuaWQoKV0gPSBoZXVyaXN0aWMoc291cmNlKTtcbiAgICAgIFxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbihlKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9KTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgLy8gQ291bnRlclxuICAgICAgdmFyIHN0ZXBzID0gMDtcblxuICAgICAgLy8gTWFpbiBsb29wIFxuICAgICAgd2hpbGUgKG9wZW5TZXQubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbWluUG9zID0gZmluZE1pbihvcGVuU2V0LCBmU2NvcmUpO1xuICAgICAgICB2YXIgY01pbiA9IGN5LmdldEVsZW1lbnRCeUlkKCBvcGVuU2V0W21pblBvc10gKTtcbiAgICAgICAgc3RlcHMrKztcblxuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlxcblN0ZXA6ICVzXCIsIHN0ZXBzKTtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJQcm9jZXNzaW5nIG5vZGU6ICVzLCBmU2NvcmUgPSAlc1wiLCBjTWluLmlkKCksIGZTY29yZVtjTWluLmlkKCldKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHdlJ3ZlIGZvdW5kIG91ciBnb2FsLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgICAgIGlmIChjTWluLmlkKCkgPT0gdGFyZ2V0LmlkKCkpIHtcbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIkZvdW5kIGdvYWwgbm9kZSFcIik7XG4gICAgICAgICAgdmFyIHJQYXRoID0gcmVjb25zdHJ1Y3RQYXRoKHNvdXJjZS5pZCgpLCB0YXJnZXQuaWQoKSwgY2FtZUZyb20sIFtdKTtcbiAgICAgICAgICByUGF0aC5yZXZlcnNlKCk7XG4gICAgICAgICAgLy8gbG9nRGVidWcoXCJQYXRoOiAlc1wiLCByUGF0aCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvdW5kIDogdHJ1ZSxcbiAgICAgICAgICAgIGRpc3RhbmNlIDogZ1Njb3JlW2NNaW4uaWQoKV0sXG4gICAgICAgICAgICBwYXRoIDogbmV3ICQkLkNvbGxlY3Rpb24oY3ksIHJQYXRoKSxcbiAgICAgICAgICAgIHN0ZXBzIDogc3RlcHNcbiAgICAgICAgICB9OyAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGNNaW4gdG8gcHJvY2Vzc2VkIG5vZGVzXG4gICAgICAgIGNsb3NlZFNldC5wdXNoKGNNaW4uaWQoKSk7XG4gICAgICAgIC8vIFJlbW92ZSBjTWluIGZyb20gYm91bmRhcnkgbm9kZXNcbiAgICAgICAgb3BlblNldC5zcGxpY2UobWluUG9zLCAxKTtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJBZGRlZCBub2RlIHRvIGNsb3NlZFNldCwgcmVtb3ZlZCBmcm9tIG9wZW5TZXQuXCIpO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlByb2Nlc3NpbmcgbmVpZ2hib3JzLi4uXCIpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzY29yZXMgZm9yIG5laWdoYm9ycyBvZiBjTWluXG4gICAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IGlmIGdyYXBoIGlzIGRpcmVjdGVkIG9yIG5vdFxuICAgICAgICB2YXIgdndFZGdlcyA9IGNNaW4uY29ubmVjdGVkRWRnZXMoKTtcbiAgICAgICAgaWYoIGRpcmVjdGVkICl7IHZ3RWRnZXMgPSB2d0VkZ2VzLnN0ZEZpbHRlcihmdW5jdGlvbihlbGUpeyByZXR1cm4gZWxlLmRhdGEoJ3NvdXJjZScpID09PSBjTWluLmlkKCk7IH0pOyB9XG4gICAgICAgIHZ3RWRnZXMgPSB2d0VkZ2VzLmludGVyc2VjdChlZGdlcyk7ICBcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlID0gdndFZGdlc1tpXTtcbiAgICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24obil7IHJldHVybiBuLmlkKCkgIT09IGNNaW4uaWQoKTsgfSkuaW50ZXJzZWN0KG5vZGVzKTtcblxuICAgICAgICAgIC8vIGxvZ0RlYnVnKFwiICAgcHJvY2Vzc2luZyBuZWlnaGJvcjogJXNcIiwgdy5pZCgpKTtcbiAgICAgICAgICAvLyBpZiBub2RlIGlzIGluIGNsb3NlZFNldCwgaWdub3JlIGl0XG4gICAgICAgICAgaWYgKGNsb3NlZFNldC5pbmRleE9mKHcuaWQoKSkgIT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGxvZ0RlYnVnKFwiICAgYWxyZWFkeSBpbiBjbG9zZWRTZXQsIGlnbm9yaW5nIGl0LlwiKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBOZXcgdGVudGF0aXZlIHNjb3JlIGZvciBub2RlIHdcbiAgICAgICAgICB2YXIgdGVtcFNjb3JlID0gZ1Njb3JlW2NNaW4uaWQoKV0gKyB3ZWlnaHRGbi5hcHBseShlLCBbZV0pO1xuICAgICAgICAgIC8vIGxvZ0RlYnVnKFwiICAgdGVudGF0aXZlIGdTY29yZTogJWRcIiwgdGVtcFNjb3JlKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBnU2NvcmUgZm9yIG5vZGUgdyBpZjpcbiAgICAgICAgICAvLyAgIHcgbm90IHByZXNlbnQgaW4gb3BlblNldFxuICAgICAgICAgIC8vIE9SXG4gICAgICAgICAgLy8gICB0ZW50YXRpdmUgZ1Njb3JlIGlzIGxlc3MgdGhhbiBwcmV2aW91cyB2YWx1ZVxuXG4gICAgICAgICAgLy8gdyBub3QgaW4gb3BlblNldFxuICAgICAgICAgIGlmIChvcGVuU2V0LmluZGV4T2Yody5pZCgpKSA9PSAtMSkge1xuICAgICAgICAgICAgZ1Njb3JlW3cuaWQoKV0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgICBmU2NvcmVbdy5pZCgpXSA9IHRlbXBTY29yZSArIGhldXJpc3RpYyh3KTtcbiAgICAgICAgICAgIG9wZW5TZXQucHVzaCh3LmlkKCkpOyAvLyBBZGQgbm9kZSB0byBvcGVuU2V0XG4gICAgICAgICAgICBjYW1lRnJvbVt3LmlkKCldID0gY01pbi5pZCgpO1xuICAgICAgICAgICAgY2FtZUZyb21FZGdlW3cuaWQoKV0gPSBlLmlkKCk7XG4gICAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIiAgIG5vdCBpbiBvcGVuU2V0LCBhZGRpbmcgaXQuIFwiKTtcbiAgICAgICAgICAgIC8vIGxvZ0RlYnVnKFwiICAgZlNjb3JlKCVzKSA9ICVzXCIsIHcuaWQoKSwgdGVtcFNjb3JlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3IGFscmVhZHkgaW4gb3BlblNldCwgYnV0IHdpdGggZ3JlYXRlciBnU2NvcmVcbiAgICAgICAgICBpZiAodGVtcFNjb3JlIDwgZ1Njb3JlW3cuaWQoKV0pIHtcbiAgICAgICAgICAgIGdTY29yZVt3LmlkKCldID0gdGVtcFNjb3JlO1xuICAgICAgICAgICAgZlNjb3JlW3cuaWQoKV0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgICBjYW1lRnJvbVt3LmlkKCldID0gY01pbi5pZCgpO1xuICAgICAgICAgICAgLy8gbG9nRGVidWcoXCIgICBiZXR0ZXIgc2NvcmUsIHJlcGxhY2luZyBnU2NvcmUuIFwiKTtcbiAgICAgICAgICAgIC8vIGxvZ0RlYnVnKFwiICAgZlNjb3JlKCVzKSA9ICVzXCIsIHcuaWQoKSwgdGVtcFNjb3JlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSAvLyBFbmQgb2YgbmVpZ2hib3JzIHVwZGF0ZVxuXG4gICAgICB9IC8vIEVuZCBvZiBtYWluIGxvb3BcblxuICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCBoZXJlLCB0aGVuIHdlJ3ZlIG5vdCByZWFjaGVkIG91ciBnb2FsXG4gICAgICAvLyBsb2dEZWJ1ZyhcIlJlYWNoZWQgZW5kIG9mIGNvbXB1dGF0aW9uIHdpdGhvdXQgZmluZGluZyBvdXIgZ29hbFwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvdW5kIDogZmFsc2UsXG4gICAgICAgIGRpc3RhbmNlIDogdW5kZWZpbmVkLFxuICAgICAgICBwYXRoIDogdW5kZWZpbmVkLFxuICAgICAgICBzdGVwcyA6IHN0ZXBzXG4gICAgICB9O1xuICAgIH0sIC8vIGFTdGFyKClcblxuXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGRpcmVjdGVkIC8vIGRlZmF1bHQgZmFsc2VcbiAgICAvLyByZXRPYmogPT4gcmV0dXJuZWQgb2JqZWN0IGJ5IGZ1bmN0aW9uXG4gICAgLy8gICBwYXRoVG8gOiBmdW5jdGlvbihmcm9tSWQsIHRvSWQpIC8vIFJldHVybnMgdGhlIHNob3J0ZXN0IHBhdGggZnJvbSBub2RlIHdpdGggSUQgXCJmcm9tSURcIiB0byBub2RlIHdpdGggSUQgXCJ0b0lkXCIsIGFzIGFuIGFycmF5IG9mIG5vZGUgSURzXG4gICAgLy8gICBkaXN0YW5jZVRvOiBmdW5jdGlvbihmcm9tSWQsIHRvSWQpIC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIG9mIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gbm9kZSB3aXRoIElEIFwiZnJvbUlEXCIgdG8gbm9kZSB3aXRoIElEIFwidG9JZFwiXG4gICAgZmxveWRXYXJzaGFsbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgZmxveWRXYXJzaGFsbC4uLlwiKTsgXG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLndlaWdodCkpIHsgICAgICAgXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbihlKSB7cmV0dXJuIDE7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKGUpeyByZXR1cm4gIWUuaXNMb29wKCk7IH0pO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgICB9ICAgICBcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICAgIHZhciBkaXN0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld1JvdyA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICAgIGlmIChpID09IGopIHtcbiAgICAgICAgICAgIG5ld1Jvd1tqXSA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1Jvd1tqXSA9IEluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkaXN0LnB1c2gobmV3Um93KTtcbiAgICAgIH0gICAgICAgICAgIFxuXG4gICAgICAvLyBJbml0aWFsaXplIG1hdHJpeCB1c2VkIGZvciBwYXRoIHJlY29uc3RydWN0aW9uXG4gICAgICAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuICAgICAgdmFyIG5leHQgPSBbXTtcbiAgICAgIHZhciBlZGdlTmV4dCA9IFtdO1xuXG4gICAgICB2YXIgaW5pdE1hdHJpeCA9IGZ1bmN0aW9uKG5leHQpe1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICB2YXIgbmV3Um93ID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICAgIG5ld1Jvd1tqXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dC5wdXNoKG5ld1Jvdyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGluaXRNYXRyaXgobmV4dCk7XG4gICAgICBpbml0TWF0cml4KGVkZ2VOZXh0KTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBlZGdlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGggOyBpKyspIHsgICAgIFxuICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tpXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbaV0udGFyZ2V0KCkuaWQoKV07ICAgIFxuICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoZWRnZXNbaV0sIFtlZGdlc1tpXV0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBwcm9jZXNzIGFub3RoZXIgZWRnZSBiZXR3ZWVuIHNhbWUgMiBub2Rlc1xuICAgICAgICBpZiAoZGlzdFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID4gd2VpZ2h0KSB7XG4gICAgICAgICAgZGlzdFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gd2VpZ2h0O1xuICAgICAgICAgIG5leHRbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IHRhcmdldEluZGV4O1xuICAgICAgICAgIGVkZ2VOZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSBlZGdlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCBwcm9jZXNzICdyZXZlcnNlZCcgZWRnZXNcbiAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGggOyBpKyspIHsgICAgIFxuICAgICAgICAgIHZhciBzb3VyY2VJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2ldLnRhcmdldCgpLmlkKCldOyAgICBcbiAgICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tpXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoZWRnZXNbaV0sIFtlZGdlc1tpXV0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgICAgICBpZiAoZGlzdFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID4gd2VpZ2h0KSB7XG4gICAgICAgICAgICBkaXN0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB3ZWlnaHQ7XG4gICAgICAgICAgICBuZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgICAgIGVkZ2VOZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSBlZGdlc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWFpbiBsb29wXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IG51bU5vZGVzOyBrKyspIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZGlzdFtpXVtrXSArIGRpc3Rba11bal0gPCBkaXN0W2ldW2pdKSB7XG4gICAgICAgICAgICAgIGRpc3RbaV1bal0gPSBkaXN0W2ldW2tdICsgZGlzdFtrXVtqXTtcbiAgICAgICAgICAgICAgbmV4dFtpXVtqXSA9IG5leHRbaV1ba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJ1aWxkIHJlc3VsdCBvYmplY3QgICAgICAgXG4gICAgICB2YXIgcG9zaXRpb24yaWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBwb3NpdGlvbjJpZC5wdXNoKG5vZGVzW2ldLmlkKCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzID0ge1xuICAgICAgICBkaXN0YW5jZTogZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKGZyb20pKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgZnJvbUlkID0gKGN5LmZpbHRlcihmcm9tKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciBmcm9tSWQgPSBmcm9tLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgdG9JZCA9IChjeS5maWx0ZXIodG8pWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciB0b0lkID0gdG8uaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGlzdFtpZDJwb3NpdGlvbltmcm9tSWRdXVtpZDJwb3NpdGlvblt0b0lkXV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0aDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoQXV4ID0gZnVuY3Rpb24oZnJvbSwgdG8sIG5leHQsIHBvc2l0aW9uMmlkLCBlZGdlTmV4dCkge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjeS5nZXRFbGVtZW50QnlJZCggcG9zaXRpb24yaWRbZnJvbV0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0W2Zyb21dW3RvXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXRoID0gWyBjeS5nZXRFbGVtZW50QnlJZChwb3NpdGlvbjJpZFtmcm9tXSkgXTtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gZnJvbTtcbiAgICAgICAgICAgIHdoaWxlIChmcm9tICE9PSB0bykge1xuICAgICAgICAgICAgICBwcmV2ID0gZnJvbTtcbiAgICAgICAgICAgICAgZnJvbSA9IG5leHRbZnJvbV1bdG9dO1xuXG4gICAgICAgICAgICAgIHZhciBlZGdlID0gZWRnZU5leHRbcHJldl1bZnJvbV07XG4gICAgICAgICAgICAgIHBhdGgucHVzaCggZWRnZSApO1xuXG4gICAgICAgICAgICAgIHBhdGgucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbZnJvbV0pICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhmcm9tKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIGZyb21JZCA9IChjeS5maWx0ZXIoZnJvbSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgZnJvbUlkID0gZnJvbS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcodG8pKSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKHRvKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHZhciBwYXRoQXJyID0gcmVjb25zdHJ1Y3RQYXRoQXV4KGlkMnBvc2l0aW9uW2Zyb21JZF0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQycG9zaXRpb25bdG9JZF0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uMmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZU5leHQpO1xuXG4gICAgICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcGF0aEFyciApO1xuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlcztcblxuICAgIH0sIC8vIGZsb3lkV2Fyc2hhbGxcblxuXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgcm9vdDogc3RhcnRpbmcgbm9kZSAoZWl0aGVyIGVsZW1lbnQgb3Igc2VsZWN0b3Igc3RyaW5nKVxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGRpcmVjdGVkIC8vIGRlZmF1bHQgZmFsc2VcbiAgICAvLyByZXRPYmogPT4gcmV0dXJuZWQgb2JqZWN0IGJ5IGZ1bmN0aW9uXG4gICAgLy8gICBwYXRoVG8gOiBmdW5jdGlvbih0b0lkKSAvLyBSZXR1cm5zIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gcm9vdCBub2RlIHRvIG5vZGUgd2l0aCBJRCBcInRvSWRcIiwgYXMgYW4gYXJyYXkgb2Ygbm9kZSBJRHNcbiAgICAvLyAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKHRvSWQpIC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIG9mIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gcm9vdCBub2RlIHRvIG5vZGUgd2l0aCBJRCBcInRvSWRcIlxuICAgIC8vICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogdHJ1ZS9mYWxzZSAoaWYgdHJ1ZSwgcGF0aFRvIGFuZCBkaXN0YW5jZVRvIHdpbGwgYmUgdW5kZWZpbmVkKVxuICAgIGJlbGxtYW5Gb3JkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIGlmIChkZWJ1Zykge1xuICAgICAgLy8gICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH07XG5cbiAgICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICAgIC8vIGRlYnVnIC0gb3B0aW9uYWxcbiAgICAgIC8vIGlmIChvcHRpb25zLmRlYnVnICE9IG51bGwpIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgLy8gfVxuICAgICAgLy8gbG9nRGVidWcoXCJTdGFydGluZyBiZWxsbWFuRm9yZC4uLlwiKTsgXG5cbiAgICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLndlaWdodCkpIHsgICAgICAgXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbihlKSB7cmV0dXJuIDE7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgICAgaWYgKG9wdGlvbnMucm9vdCAhPSBudWxsKSB7ICAgICAgIFxuICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkpIHtcbiAgICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5maWx0ZXIob3B0aW9ucy5yb290KVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gb3B0aW9ucy5yb290WzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiU291cmNlIG5vZGU6ICVzXCIsIHNvdXJjZS5pZCgpKTsgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkJC51dGlsLmVycm9yKFwib3B0aW9ucy5yb290IHJlcXVpcmVkXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbihlKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9KTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgICAgfSAgICAgXG5cbiAgICAgIC8vIEluaXRpYWxpemF0aW9uc1xuICAgICAgdmFyIGNvc3QgPSBbXTtcbiAgICAgIHZhciBwcmVkZWNlc3NvciA9IFtdO1xuICAgICAgdmFyIHByZWRFZGdlID0gW107XG4gICAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBpZiAobm9kZXNbaV0uaWQoKSA9PT0gc291cmNlLmlkKCkpIHtcbiAgICAgICAgICBjb3N0W2ldID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3N0W2ldID0gSW5maW5pdHk7XG4gICAgICAgIH0gXG4gICAgICAgIHByZWRlY2Vzc29yW2ldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFZGdlcyByZWxheGF0aW9uICAgICAgXG4gICAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKykge1xuICAgICAgICAgIHZhciBzb3VyY2VJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2VdLnNvdXJjZSgpLmlkKCldO1xuICAgICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2VdLnRhcmdldCgpLmlkKCldOyAgICBcbiAgICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoZWRnZXNbZV0sIFtlZGdlc1tlXV0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciB0ZW1wID0gY29zdFtzb3VyY2VJbmRleF0gKyB3ZWlnaHQ7XG4gICAgICAgICAgaWYgKHRlbXAgPCBjb3N0W3RhcmdldEluZGV4XSkge1xuICAgICAgICAgICAgY29zdFt0YXJnZXRJbmRleF0gPSB0ZW1wO1xuICAgICAgICAgICAgcHJlZGVjZXNzb3JbdGFyZ2V0SW5kZXhdID0gc291cmNlSW5kZXg7XG4gICAgICAgICAgICBwcmVkRWRnZVt0YXJnZXRJbmRleF0gPSBlZGdlc1tlXTtcbiAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlICdyZXZlcnNlJyBlZGdlXG4gICAgICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBjb3N0W3RhcmdldEluZGV4XSArIHdlaWdodDtcbiAgICAgICAgICAgIGlmICh0ZW1wIDwgY29zdFtzb3VyY2VJbmRleF0pIHtcbiAgICAgICAgICAgICAgY29zdFtzb3VyY2VJbmRleF0gPSB0ZW1wO1xuICAgICAgICAgICAgICBwcmVkZWNlc3Nvcltzb3VyY2VJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgICAgICAgcHJlZEVkZ2Vbc291cmNlSW5kZXhdID0gZWRnZXNbZV07XG4gICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmxhZykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9ICAgICAgXG4gICAgICAgICAgICBcbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGVzXG4gICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS50YXJnZXQoKS5pZCgpXTsgICAgXG4gICAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2VdLCBbZWRnZXNbZV1dKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY29zdFtzb3VyY2VJbmRleF0gKyB3ZWlnaHQgPCBjb3N0W3RhcmdldEluZGV4XSkge1xuICAgICAgICAgICAgJCQudXRpbC5lcnJvcihcIkVycm9yOiBncmFwaCBjb250YWlucyBhIG5lZ2F0aXZlIHdlaWd0aCBjeWNsZSFcIik7IFxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aFRvOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgIGRpc3RhbmNlVG86IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogdHJ1ZX07XG4gICAgICAgICAgfVxuICAgICAgICB9ICAgICBcbiAgICAgIH1cblxuICAgICAgLy8gQnVpbGQgcmVzdWx0IG9iamVjdCAgICAgICBcbiAgICAgIHZhciBwb3NpdGlvbjJpZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHBvc2l0aW9uMmlkLnB1c2gobm9kZXNbaV0uaWQoKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIFxuICAgICAgdmFyIHJlcyA9IHsgICAgICAgXG4gICAgICAgIGRpc3RhbmNlVG8gOiBmdW5jdGlvbih0bykge1xuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcodG8pKSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKHRvKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvc3RbaWQycG9zaXRpb25bdG9JZF1dO1xuICAgICAgICB9LCBcblxuICAgICAgICBwYXRoVG8gOiBmdW5jdGlvbih0bykge1xuXG4gICAgICAgICAgdmFyIHJlY29uc3RydWN0UGF0aEF1eCA9IGZ1bmN0aW9uKHByZWRlY2Vzc29yLCBmcm9tUG9zLCB0b1BvcywgcG9zaXRpb24yaWQsIGFjdW1QYXRoLCBwcmVkRWRnZSkge1xuICAgICAgICAgICAgZm9yKDs7KXtcbiAgICAgICAgICAgICAgLy8gQWRkIHRvSWQgdG8gcGF0aFxuICAgICAgICAgICAgICBhY3VtUGF0aC5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZChwb3NpdGlvbjJpZFt0b1Bvc10pICk7XG4gICAgICAgICAgICAgIGFjdW1QYXRoLnB1c2goIHByZWRFZGdlW3RvUG9zXSApO1xuXG4gICAgICAgICAgICAgIGlmIChmcm9tUG9zID09PSB0b1Bvcykge1xuICAgICAgICAgICAgICAgIC8vIHJlYWNoZWQgc3RhcnRpbmcgbm9kZVxuICAgICAgICAgICAgICAgIHJldHVybiBhY3VtUGF0aDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIElmIG5vIHBhdGggZXhpc3RzLCBkaXNjYXJ0IGFjdW11bGF0ZWQgcGF0aCBhbmQgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgICB2YXIgcHJlZFBvcyA9IHByZWRlY2Vzc29yW3RvUG9zXTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVkUG9zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRvUG9zID0gcHJlZFBvcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlcih0bylbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcGF0aCA9IFtdO1xuXG4gICAgICAgICAgLy8gVGhpcyByZXR1cm5zIGEgcmV2ZXJzZWQgcGF0aCBcbiAgICAgICAgICB2YXIgcmVzID0gIHJlY29uc3RydWN0UGF0aEF1eChwcmVkZWNlc3NvciwgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvbltzb3VyY2UuaWQoKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvblt0b0lkXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjJpZCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZEVkZ2UpO1xuXG4gICAgICAgICAgLy8gR2V0IGl0IGluIHRoZSBjb3JyZWN0IG9yZGVyIGFuZCByZXR1cm4gaXRcbiAgICAgICAgICBpZiAocmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlcy5yZXZlcnNlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKGN5LCByZXMpOyAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH0sIFxuXG4gICAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcmVzO1xuXG4gICAgfSwgLy8gYmVsbG1hbkZvcmRcblxuXG4gICAgLy8gQ29tcHV0ZXMgdGhlIG1pbmltdW0gY3V0IG9mIGFuIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgICAvLyBSZXR1cm5zIHRoZSBjb3JyZWN0IGFuc3dlciB3aXRoIGhpZ2ggcHJvYmFiaWxpdHlcbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vICAgY3V0IDogbGlzdCBvZiBJRHMgb2YgZWRnZXMgaW4gdGhlIGN1dCxcbiAgICAvLyAgIHBhcnRpdGlvbjE6IGxpc3Qgb2YgSURzIG9mIG5vZGVzIGluIG9uZSBwYXJ0aXRpb25cbiAgICAvLyAgIHBhcnRpdGlvbjI6IGxpc3Qgb2YgSURzIG9mIG5vZGVzIGluIHRoZSBvdGhlciBwYXJ0aXRpb25cbiAgICBrYXJnZXJTdGVpbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBcbiAgICAgIC8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBGdW5jdGlvbiB3aGljaCBjb2xhcHNlcyAyIChtZXRhKSBub2RlcyBpbnRvIG9uZVxuICAgICAgLy8gVXBkYXRlcyB0aGUgcmVtYWluaW5nIGVkZ2UgbGlzdHNcbiAgICAgIC8vIFJlY2VpdmVzIGFzIGEgcGFyYW1hdGVyIHRoZSBlZGdlIHdoaWNoIGNhdXNlcyB0aGUgY29sbGFwc2VcbiAgICAgIHZhciBjb2xhcHNlID0gZnVuY3Rpb24oZWRnZUluZGV4LCBub2RlTWFwLCByZW1haW5pbmdFZGdlcykge1xuICAgICAgICB2YXIgZWRnZUluZm8gPSByZW1haW5pbmdFZGdlc1tlZGdlSW5kZXhdO1xuICAgICAgICB2YXIgc291cmNlSW4gPSBlZGdlSW5mb1sxXTtcbiAgICAgICAgdmFyIHRhcmdldEluID0gZWRnZUluZm9bMl07XG4gICAgICAgIHZhciBwYXJ0aXRpb24xID0gbm9kZU1hcFtzb3VyY2VJbl07XG4gICAgICAgIHZhciBwYXJ0aXRpb24yID0gbm9kZU1hcFt0YXJnZXRJbl07XG5cbiAgICAgICAgLy8gRGVsZXRlIGFsbCBlZGdlcyBiZXR3ZWVuIHBhcnRpdGlvbjEgYW5kIHBhcnRpdGlvbjJcbiAgICAgICAgdmFyIG5ld0VkZ2VzID0gcmVtYWluaW5nRWRnZXMuZmlsdGVyKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgICAgICBpZiAobm9kZU1hcFtlZGdlWzFdXSA9PT0gcGFydGl0aW9uMSAmJiBub2RlTWFwW2VkZ2VbMl1dID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlTWFwW2VkZ2VbMV1dID09PSBwYXJ0aXRpb24yICYmIG5vZGVNYXBbZWRnZVsyXV0gPT09IHBhcnRpdGlvbjEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQWxsIGVkZ2VzIHBvaW50aW5nIHRvIHBhcnRpdGlvbjIgc2hvdWxkIG5vdyBwb2ludCB0byBwYXJ0aXRpb24xXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG5ld0VkZ2VzW2ldO1xuICAgICAgICAgIGlmIChlZGdlWzFdID09PSBwYXJ0aXRpb24yKSB7IC8vIENoZWNrIHNvdXJjZVxuICAgICAgICAgICAgbmV3RWRnZXNbaV0gPSBlZGdlLnNsaWNlKDApO1xuICAgICAgICAgICAgbmV3RWRnZXNbaV1bMV0gPSBwYXJ0aXRpb24xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWRnZVsyXSA9PT0gcGFydGl0aW9uMikgeyAvLyBDaGVjayB0YXJnZXRcbiAgICAgICAgICAgIG5ld0VkZ2VzW2ldID0gZWRnZS5zbGljZSgwKTtcbiAgICAgICAgICAgIG5ld0VkZ2VzW2ldWzJdID0gcGFydGl0aW9uMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIFxuICAgICAgICAvLyBNb3ZlIGFsbCBub2RlcyBmcm9tIHBhcnRpdGlvbjIgdG8gcGFydGl0aW9uMVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVNYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobm9kZU1hcFtpXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgICAgICAgbm9kZU1hcFtpXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmV3RWRnZXM7XG4gICAgICB9O1xuXG5cbiAgICAgIC8vIENvbnRyYWN0cyBhIGdyYXBoIHVudGlsIHdlIHJlYWNoIGEgY2VydGFpbiBudW1iZXIgb2YgbWV0YSBub2Rlc1xuICAgICAgdmFyIGNvbnRyYWN0VW50aWwgPSBmdW5jdGlvbihtZXRhTm9kZU1hcCwgXG4gICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdFZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgIHNpemUsIFxuICAgICAgICAgICAgICAgICAgICAgc2l6ZUxpbWl0KSB7XG4gICAgICAgIC8vIFN0b3AgY29uZGl0aW9uXG4gICAgICAgIGlmIChzaXplIDw9IHNpemVMaW1pdCkge1xuICAgICAgICAgIHJldHVybiByZW1haW5pbmdFZGdlcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hvb3NlIGFuIGVkZ2UgcmFuZG9tbHlcbiAgICAgICAgdmFyIGVkZ2VJbmRleCA9IE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiByZW1haW5pbmdFZGdlcy5sZW5ndGgpKTtcblxuICAgICAgICAvLyBDb2xhcHNlIGdyYXBoIGJhc2VkIG9uIGVkZ2VcbiAgICAgICAgdmFyIG5ld0VkZ2VzID0gY29sYXBzZShlZGdlSW5kZXgsIG1ldGFOb2RlTWFwLCByZW1haW5pbmdFZGdlcyk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgXG4gICAgICAgICAgICAgICAgICAgbmV3RWRnZXMsIFxuICAgICAgICAgICAgICAgICAgIHNpemUgLSAxLCBcbiAgICAgICAgICAgICAgICAgICBzaXplTGltaXQpOyAgICAgICAgXG4gICAgICB9O1xuXG5cbiAgICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICAgIC8vIGRlYnVnIC0gb3B0aW9uYWxcbiAgICAgIC8vIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcga2FyZ2VyU3RlaW4uLi5cIik7IFxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbihlKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9KTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcbiAgICAgIHZhciBudW1JdGVyID0gTWF0aC5jZWlsKE1hdGgucG93KE1hdGgubG9nKG51bU5vZGVzKSAvIE1hdGguTE4yLCAyKSk7XG4gICAgICB2YXIgc3RvcFNpemUgPSBNYXRoLmZsb29yKG51bU5vZGVzIC8gTWF0aC5zcXJ0KDIpKTtcblxuICAgICAgaWYgKG51bU5vZGVzIDwgMikge1xuICAgICAgICAkJC51dGlsLmVycm9yKFwiQXQgbGVhc3QgMiBub2RlcyBhcmUgcmVxdWlyZWQgZm9yIEthcmdlclN0ZWluZyBhbGdvcml0aG0hXCIpOyBcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIG51bWVyaWNhbCBpZGVudGlmaWVycyBmb3IgZWFjaCBub2RlXG4gICAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgICAvLyBmb3IgcmV2ZXJzZSBtYXBwaW5nLCBzaW1wbHkgdXNlIG5vZGVzIGFycmF5XG4gICAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyBzdG9yZSBlZGdlIGRlc3RpbmF0aW9uIGFzIGluZGV4ZXNcbiAgICAgIC8vIEZvcm1hdCBmb3IgZWFjaCBlZGdlIChlZGdlIGluZGV4LCBzb3VyY2Ugbm9kZSBpbmRleCwgdGFyZ2V0IG5vZGUgaW5kZXgpXG4gICAgICB2YXIgZWRnZUluZGV4ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKykge1xuICAgICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgICBlZGdlSW5kZXhlcy5wdXNoKFtpLCBpZDJwb3NpdGlvbltlLnNvdXJjZSgpLmlkKCldLCBpZDJwb3NpdGlvbltlLnRhcmdldCgpLmlkKCldXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHdpbGwgc3RvcmUgdGhlIGJlc3QgY3V0IGZvdW5kIGhlcmVcbiAgICAgIHZhciBtaW5DdXRTaXplID0gSW5maW5pdHk7XG4gICAgICB2YXIgbWluQ3V0OyAgICAgXG5cbiAgICAgIC8vIEluaXRpYWwgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgICAgdmFyIG9yaWdpbmFsTWV0YU5vZGUgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBvcmlnaW5hbE1ldGFOb2RlLnB1c2goaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1haW4gbG9vcFxuICAgICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPD0gbnVtSXRlcjsgaXRlcisrKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgICAgICB2YXIgbWV0YU5vZGVNYXAgPSBvcmlnaW5hbE1ldGFOb2RlLnNsaWNlKDApO1xuXG4gICAgICAgIC8vIENvbnRyYWN0IHVudGlsIHN0b3AgcG9pbnQgKHN0b3BTaXplIG5vZGVzKVxuICAgICAgICB2YXIgZWRnZXNTdGF0ZSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VJbmRleGVzLCBudW1Ob2Rlcywgc3RvcFNpemUpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgY29sYXBzZWQgbm9kZXMgc3RhdGVcbiAgICAgICAgdmFyIG1ldGFOb2RlTWFwMiA9IG1ldGFOb2RlTWFwLnNsaWNlKDApO1xuXG4gICAgICAgIC8vIFJ1biAyIGl0ZXJhdGlvbnMgc3RhcnRpbmcgaW4gdGhlIHN0b3Agc3RhdGVcbiAgICAgICAgdmFyIHJlczEgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlc1N0YXRlLCBzdG9wU2l6ZSwgMik7XG4gICAgICAgIHZhciByZXMyID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcDIsIGVkZ2VzU3RhdGUsIHN0b3BTaXplLCAyKTtcblxuICAgICAgICAvLyBJcyBhbnkgb2YgdGhlIDIgcmVzdWx0cyB0aGUgYmVzdCBjdXQgc28gZmFyP1xuICAgICAgICBpZiAocmVzMS5sZW5ndGggPD0gcmVzMi5sZW5ndGggJiYgcmVzMS5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczEubGVuZ3RoO1xuICAgICAgICAgIG1pbkN1dCA9IFtyZXMxLCBtZXRhTm9kZU1hcF07XG4gICAgICAgIH0gZWxzZSBpZiAocmVzMi5sZW5ndGggPD0gcmVzMS5sZW5ndGggJiYgcmVzMi5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczIubGVuZ3RoO1xuICAgICAgICAgIG1pbkN1dCA9IFtyZXMyLCBtZXRhTm9kZU1hcDJdO1xuICAgICAgICB9XG4gICAgICB9IC8vIGVuZCBvZiBtYWluIGxvb3BcblxuICAgICAgXG4gICAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG4gICAgICB2YXIgcmVzRWRnZXMgPSAobWluQ3V0WzBdKS5tYXAoZnVuY3Rpb24oZSl7IHJldHVybiBlZGdlc1tlWzBdXTsgfSk7XG4gICAgICB2YXIgcGFydGl0aW9uMSA9IFtdO1xuICAgICAgdmFyIHBhcnRpdGlvbjIgPSBbXTtcblxuICAgICAgLy8gdHJhdmVyc2UgbWV0YU5vZGVNYXAgZm9yIGJlc3QgY3V0XG4gICAgICB2YXIgd2l0bmVzc05vZGVQYXJ0aXRpb24gPSBtaW5DdXRbMV1bMF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkN1dFsxXS5sZW5ndGg7IGkrKykgeyBcbiAgICAgICAgdmFyIHBhcnRpdGlvbklkID0gbWluQ3V0WzFdW2ldOyBcbiAgICAgICAgaWYgKHBhcnRpdGlvbklkID09PSB3aXRuZXNzTm9kZVBhcnRpdGlvbikge1xuICAgICAgICAgIHBhcnRpdGlvbjEucHVzaChub2Rlc1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydGl0aW9uMi5wdXNoKG5vZGVzW2ldKTtcbiAgICAgICAgfSAgICAgICBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgY3V0OiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgcmVzRWRnZXMpLFxuICAgICAgICBwYXJ0aXRpb24xOiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgcGFydGl0aW9uMSksXG4gICAgICAgIHBhcnRpdGlvbjI6IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBwYXJ0aXRpb24yKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG5cbiAgICAvLyBcbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gICBkYW1waW5nRmFjdG9yOiBvcHRpb25hbFxuICAgIC8vICAgcHJlY2lzaW9uOiBvcHRpb25hbFxuICAgIC8vICAgaXRlcmF0aW9ucyA6IG9wdGlvbmFsXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vICByYW5rIDogZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBwYWdlUmFuayBvZiBhIGdpdmVuIG5vZGUgKG9iamVjdCBvciBzZWxlY3RvciBzdHJpbmcpXG4gICAgcGFnZVJhbms6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgXG4gICAgICB2YXIgbm9ybWFsaXplVmVjdG9yID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB2ZWN0b3IubGVuZ3RoO1xuXG4gICAgICAgIC8vIEZpcnN0LCBnZXQgc3VtIG9mIGFsbCBlbGVtZW50c1xuICAgICAgICB2YXIgdG90YWwgPSAwOyBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRvdGFsICs9IHZlY3RvcltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdywgZGl2aWRlIGVhY2ggYnkgdGhlIHN1bSBvZiBhbGwgZWxlbWVudHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZlY3RvcltpXSA9IHZlY3RvcltpXSAvIHRvdGFsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgaWYgKGRlYnVnKSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfTtcbiAgICAgIFxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgLy8gaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBcbiAgICAgIC8vICAgb3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgcGFnZVJhbmsuLi5cIik7IFxuXG4gICAgICAvLyBkYW1waW5nRmFjdG9yIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgXG4gICAgICAgIG9wdGlvbnMuZGFtcGluZ2ZhY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkYW1waW5nRmFjdG9yID0gb3B0aW9ucy5kYW1waW5nRmFjdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRhbXBpbmdGYWN0b3IgPSAwLjg7IC8vIERlZmF1bHQgZGFtcGluZyBmYWN0b3JcbiAgICAgIH1cblxuICAgICAgLy8gZGVzaXJlZCBwcmVjaXNpb24gLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBcbiAgICAgICAgb3B0aW9ucy5wcmVjaXNpb24gIT0gbnVsbCkge1xuICAgICAgICB2YXIgZXBzaWxvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVwc2lsb24gPSAwLjAwMDAwMTsgLy8gRGVmYXVsdCBwcmVjaXNpb25cbiAgICAgIH1cblxuICAgICAgLy8gTWF4IG51bWJlciBvZiBpdGVyYXRpb25zIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgXG4gICAgICAgIG9wdGlvbnMuaXRlcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBudW1JdGVyID0gb3B0aW9ucy5pdGVyYXRpb25zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG51bUl0ZXIgPSAyMDA7IC8vIERlZmF1bHQgbnVtYmVyIG9mIGl0ZXJhdGlvbnNcbiAgICAgIH1cblxuICAgICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgXG4gICAgICAgIG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgXG4gICAgICAgICQkLmlzLmZuKG9wdGlvbnMud2VpZ2h0KSkgeyAgICAgICBcbiAgICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKGUpIHtyZXR1cm4gMTt9OyBcbiAgICAgIH1cblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oZSl7IHJldHVybiAhZS5pc0xvb3AoKTsgfSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgIC8vIENyZWF0ZSBudW1lcmljYWwgaWRlbnRpZmllcnMgZm9yIGVhY2ggbm9kZVxuICAgICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgICAgLy8gZm9yIHJldmVyc2UgbWFwcGluZywgc2ltcGx5IHVzZSBub2RlcyBhcnJheVxuICAgICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb25zdHJ1Y3QgdHJhbnNwb3NlZCBhZGphY2VuY3kgbWF0cml4XG4gICAgICAvLyBGaXJzdCBsZXRzIGhhdmUgYSB6ZXJvZWQgbWF0cml4IG9mIHRoZSByaWdodCBzaXplXG4gICAgICAvLyBXZSdsbCBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIHN1bSBvZiBlYWNoIGNvbHVtblxuICAgICAgdmFyIG1hdHJpeCA9IFtdO1xuICAgICAgdmFyIGNvbHVtblN1bSA9IFtdO1xuICAgICAgdmFyIGFkZGl0aW9uYWxQcm9iID0gKDEgLSBkYW1waW5nRmFjdG9yKSAvIG51bU5vZGVzO1xuXG4gICAgICAvLyBDcmVhdGUgbnVsbCBtYXRyaWNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykgeyBcbiAgICAgICAgdmFyIG5ld1JvdyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICBuZXdSb3cucHVzaCgwLjApO1xuICAgICAgICB9XG4gICAgICAgIG1hdHJpeC5wdXNoKG5ld1Jvdyk7XG4gICAgICAgIGNvbHVtblN1bS5wdXNoKDAuMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdywgcHJvY2VzcyBlZGdlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBzID0gaWQycG9zaXRpb25bZWRnZS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgdmFyIHQgPSBpZDJwb3NpdGlvbltlZGdlLnRhcmdldCgpLmlkKCldO1xuICAgICAgICB2YXIgdyA9IHdlaWdodEZuLmFwcGx5KGVkZ2UsIFtlZGdlXSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgbWF0cml4XG4gICAgICAgIG1hdHJpeFt0XVtzXSArPSB3O1xuXG4gICAgICAgIC8vIFVwZGF0ZSBjb2x1bW4gc3VtXG4gICAgICAgIGNvbHVtblN1bVtzXSArPSB3OyBcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGFkZGl0aW9uYWwgcHJvYmFiaWxpdHkgYmFzZWQgb24gZGFtcGluZyBmYWN0b3JcbiAgICAgIC8vIEFsc28sIHRha2UgaW50byBhY2NvdW50IGNvbHVtbnMgdGhhdCBoYXZlIHN1bSA9IDBcbiAgICAgIHZhciBwID0gMS4wIC8gbnVtTm9kZXMgKyBhZGRpdGlvbmFsUHJvYjsgLy8gU2hvcnRoYW5kXG4gICAgICAvLyBUcmF2ZXJzZSBtYXRyaXgsIGNvbHVtbiBieSBjb2x1bW5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykgeyBcbiAgICAgICAgaWYgKGNvbHVtblN1bVtqXSA9PT0gMCkge1xuICAgICAgICAgIC8vIE5vICdsaW5rcycgb3V0IGZyb20gbm9kZSBqdGgsIGFzc3VtZSBlcXVhbCBwcm9iYWJpbGl0eSBmb3IgZWFjaCBwb3NzaWJsZSBub2RlXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb2RlIGp0aCBoYXMgb3V0Z29pbmcgbGluaywgY29tcHV0ZSBub3JtYWxpemVkIHByb2JhYmlsaXRpZXNcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IG1hdHJpeFtpXVtqXSAvIGNvbHVtblN1bVtqXSArIGFkZGl0aW9uYWxQcm9iO1xuICAgICAgICAgIH0gICAgICAgICBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb21wdXRlIGRvbWluYW50IGVpZ2VudmVjdG9yIHVzaW5nIHBvd2VyIG1ldGhvZFxuICAgICAgdmFyIGVpZ2VudmVjdG9yID0gW107XG4gICAgICB2YXIgbnVsbFZlY3RvciA9IFtdO1xuICAgICAgdmFyIHByZXZpb3VzO1xuXG4gICAgICAvLyBTdGFydCB3aXRoIGEgdmVjdG9yIG9mIGFsbCAxJ3NcbiAgICAgIC8vIEFsc28sIGluaXRpYWxpemUgYSBudWxsIHZlY3RvciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgc2hvcnRoYW5kXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgZWlnZW52ZWN0b3IucHVzaCgxLjApO1xuICAgICAgICBudWxsVmVjdG9yLnB1c2goMC4wKTtcbiAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPCBudW1JdGVyOyBpdGVyKyspIHtcbiAgICAgICAgLy8gTmV3IGFycmF5IHdpdGggYWxsIDAnc1xuICAgICAgICB2YXIgdGVtcCA9IG51bGxWZWN0b3Iuc2xpY2UoMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBNdWx0aXBseSBtYXRyaXggd2l0aCBwcmV2aW91cyByZXN1bHRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7ICAgICAgICBcbiAgICAgICAgICAgIHRlbXBbaV0gKz0gbWF0cml4W2ldW2pdICogZWlnZW52ZWN0b3Jbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplVmVjdG9yKHRlbXApO1xuICAgICAgICBwcmV2aW91cyA9IGVpZ2VudmVjdG9yO1xuICAgICAgICBlaWdlbnZlY3RvciA9IHRlbXA7XG5cbiAgICAgICAgdmFyIGRpZmYgPSAwO1xuICAgICAgICAvLyBDb21wdXRlIGRpZmZlcmVuY2UgKHNxdWFyZWQgbW9kdWxlKSBvZiBib3RoIHZlY3RvcnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgZGlmZiArPSBNYXRoLnBvdyhwcmV2aW91c1tpXSAtIGVpZ2VudmVjdG9yW2ldLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgZGlmZmVyZW5jZSBpcyBsZXNzIHRoYW4gdGhlIGRlc2lyZWQgdGhyZXNob2xkLCBzdG9wIGl0ZXJhdGluZ1xuICAgICAgICBpZiAoZGlmZiA8IGVwc2lsb24pIHtcbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIlN0b3BlZCBhdCBpdGVyYXRpb24gJXNcIiwgaXRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgLy8gbG9nRGVidWcoXCJSZXN1bHQ6XFxuXCIgKyBlaWdlbnZlY3Rvcik7XG5cbiAgICAgIC8vIENvbnN0cnVjdCByZXN1bHRcbiAgICAgIHZhciByZXMgPSB7XG4gICAgICAgIHJhbmsgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSAoY3kuZmlsdGVyKG5vZGUpWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpcyBhIG5vZGUgb2JqZWN0XG4gICAgICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZWlnZW52ZWN0b3JbaWQycG9zaXRpb25bbm9kZUlkXV07XG4gICAgICAgIH1cbiAgICAgIH07XG5cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCAvLyBwYWdlUmFua1xuXG5cbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gICB3ZWlnaHQ6IGZ1bmN0aW9uKCBlZGdlICl7fSAvLyBzcGVjaWZpZXMgd2VpZ2h0IHRvIHVzZSBmb3IgYGVkZ2VgL2B0aGlzYC4gSWYgbm90IHByZXNlbnQsIGl0IHdpbGwgYmUgYXN1bWVkIGEgd2VpZ2h0IG9mIDEgZm9yIGFsbCBlZGdlc1xuICAgIC8vICAgZGlyZWN0ZWQgLy8gZGVmYXVsdCBmYWxzZVxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyBpZiBkaXJlY3RlZFxuICAgIC8vICAgaW5kZWdyZWUgOiBmdW5jdGlvbihub2RlKSAvLyBSZXR1cm5zIHRoZSBub3JtYWxpemVkIGluZGVncmVlIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgLy8gICBvdXRkZWdyZWU6IGZ1bmN0aW9uKG5vZGUpIC8vIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgb3V0ZGVncmVlIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgLy8gaWYgdW5kaXJlY3RlZFxuICAgIC8vICAgZGVncmVlIDogZnVuY3Rpb24obm9kZSkgLy8gUmV0dXJucyB0aGUgbm9ybWFsaXplZCBkZWdyZWUgb2YgdGhlIGdpdmVuIG5vZGVcbiAgICBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyAgIGlmIChkZWJ1Zykge1xuICAgICAgLy8gICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH07XG5cbiAgICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICAgIC8vIGRlYnVnIC0gb3B0aW9uYWxcbiAgICAgIC8vIGlmIChvcHRpb25zLmRlYnVnICE9IG51bGwpIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgLy8gfVxuXG4gICAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gbG9nRGVidWcoXCJTdGFydGluZyBkZWdyZWUgY2VudHJhbGl0eS4uLlwiKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICB2YXIgZGVncmVlcyA9IHt9O1xuICAgICAgICB2YXIgbWF4RGVncmVlID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eSBcbiAgICAgICAgICB2YXIgY3VyckRlZ3JlZSA9IHRoaXMuZGVncmVlQ2VudHJhbGl0eSgkJC51dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge3Jvb3Q6IG5vZGV9KSk7XG4gICAgICAgICAgaWYgKG1heERlZ3JlZSA8IGN1cnJEZWdyZWUuZGVncmVlKVxuICAgICAgICAgICAgbWF4RGVncmVlID0gY3VyckRlZ3JlZS5kZWdyZWU7XG5cbiAgICAgICAgICBkZWdyZWVzW25vZGUuaWQoKV0gPSBjdXJyRGVncmVlLmRlZ3JlZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVncmVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVncmVlc1tub2RlXSAvIG1heERlZ3JlZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW5kZWdyZWVzID0ge307XG4gICAgICAgIHZhciBvdXRkZWdyZWVzID0ge307XG4gICAgICAgIHZhciBtYXhJbmRlZ3JlZSA9IDA7XG4gICAgICAgIHZhciBtYXhPdXRkZWdyZWUgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5IFxuICAgICAgICAgIHZhciBjdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KCQkLnV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zLCB7cm9vdDogbm9kZX0pKTtcblxuICAgICAgICAgIGlmIChtYXhJbmRlZ3JlZSA8IGN1cnJEZWdyZWUuaW5kZWdyZWUpXG4gICAgICAgICAgICBtYXhJbmRlZ3JlZSA9IGN1cnJEZWdyZWUuaW5kZWdyZWU7XG5cbiAgICAgICAgICBpZiAobWF4T3V0ZGVncmVlIDwgY3VyckRlZ3JlZS5vdXRkZWdyZWUpXG4gICAgICAgICAgICBtYXhPdXRkZWdyZWUgPSBjdXJyRGVncmVlLm91dGRlZ3JlZTtcblxuICAgICAgICAgIGluZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgICBvdXRkZWdyZWVzW25vZGUuaWQoKV0gPSBjdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZWdyZWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSAoY3kuZmlsdGVyKG5vZGUpWzBdKS5pZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbmRlZ3JlZXNbbm9kZV0gLyBtYXhJbmRlZ3JlZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG91dGRlZ3JlZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dGRlZ3JlZXNbbm9kZV0gLyBtYXhPdXRkZWdyZWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICB9LCAvLyBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZFxuXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIE9wc2FobCdzIHBhcGVyIFwiTm9kZSBjZW50cmFsaXR5IGluIHdlaWdodGVkIG5ldHdvcmtzOiBHZW5lcmFsaXppbmcgZGVncmVlIGFuZCBzaG9ydGVzdCBwYXRoc1wiIGNoZWNrIHRoZSBoZWFkaW5nIDIgXCJEZWdyZWVcIlxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIG5vZGUgOiBmb2NhbCBub2RlXG4gICAgLy8gICB3ZWlnaHQ6IGZ1bmN0aW9uKCBlZGdlICl7fSAvLyBzcGVjaWZpZXMgd2VpZ2h0IHRvIHVzZSBmb3IgYGVkZ2VgL2B0aGlzYC4gSWYgbm90IHByZXNlbnQsIGl0IHdpbGwgYmUgYXN1bWVkIGEgd2VpZ2h0IG9mIDEgZm9yIGFsbCBlZGdlc1xuICAgIC8vICAgYWxwaGEgOiBhbHBoYSB2YWx1ZSBmb3IgdGhlIGFsZ29yaXRobSAoQmVuY2htYXJrIHZhbHVlcyBvZiBhbHBoYTogMCAtPiBkaXNyZWdhcmRzIHRoZSB3ZWlnaHRzIGZvY3VzZXMgb24gbnVtYmVyIG9mIGVkZ2VzXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxIC0+IGRpc3JlZ2FyZHMgdGhlIG51bWJlciBvZiBlZGdlcyBmb2N1c2VzIG9uIHRvdGFsIGFtb3VudCBvZiB3ZWlnaHQgXG4gICAgLy8gICBkaXJlY3RlZCAvLyBkZWZhdWx0IGZhbHNlXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vIGlmIGRpcmVjdGVkXG4gICAgLy8gICBpbmRlZ3JlZSA6IGluZGVncmVlIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgLy8gICBvdXRkZWdyZWU6IG91dGRlZ3JlZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vIGlmIHVuZGlyZWN0ZWRcbiAgICAvLyAgIGRlZ3JlZSA6IGRlZ3JlZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIGRlZ3JlZUNlbnRyYWxpdHk6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIGNhbGxpbmdFbGVzID0gdGhpcztcblxuICAgICAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gbG9nRGVidWcoXCJTdGFydGluZyBkZWdyZWUgY2VudHJhbGl0eS4uLlwiKTtcblxuICAgICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5yb290ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHJvb3QgPSAkJC5pcy5zdHJpbmcob3B0aW9ucy5yb290KSA/IHRoaXMuZmlsdGVyKG9wdGlvbnMucm9vdClbMF0gOiBvcHRpb25zLnJvb3RbMF07XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiU291cmNlIG5vZGU6ICVzXCIsIHJvb3QuaWQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZWlnaHQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgJCQuaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7XG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gYWxwaGEgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuYWxwaGEgIT0gbnVsbCAmJiAkJC5pcy5udW1iZXIob3B0aW9ucy5hbHBoYSkpIHtcbiAgICAgICAgdmFyIGFscGhhID0gb3B0aW9ucy5hbHBoYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFscGhhID0gMDtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgIHZhciBjb25uRWRnZXMgPSByb290LmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKCBjYWxsaW5nRWxlcyApO1xuICAgICAgICB2YXIgayA9IGNvbm5FZGdlcy5sZW5ndGg7XG4gICAgICAgIHZhciBzID0gMDtcblxuICAgICAgICAvLyBOb3csIHN1bSBlZGdlIHdlaWdodHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGNvbm5FZGdlc1tpXTtcbiAgICAgICAgICBzICs9IHdlaWdodEZuLmFwcGx5KGVkZ2UsIFtlZGdlXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlZ3JlZTogTWF0aC5wb3coaywgMSAtIGFscGhhKSAqIE1hdGgucG93KHMsIGFscGhhKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGluY29taW5nID0gcm9vdC5jb25uZWN0ZWRFZGdlcygnZWRnZVt0YXJnZXQgPSBcIicgKyByb290LmlkKCkgKyAnXCJdJykuaW50ZXJzZWN0aW9uKCBjYWxsaW5nRWxlcyApO1xuICAgICAgICB2YXIgb3V0Z29pbmcgPSByb290LmNvbm5lY3RlZEVkZ2VzKCdlZGdlW3NvdXJjZSA9IFwiJyArIHJvb3QuaWQoKSArICdcIl0nKS5pbnRlcnNlY3Rpb24oIGNhbGxpbmdFbGVzICk7XG4gICAgICAgIHZhciBrX2luID0gaW5jb21pbmcubGVuZ3RoO1xuICAgICAgICB2YXIga19vdXQgPSBvdXRnb2luZy5sZW5ndGg7XG4gICAgICAgIHZhciBzX2luID0gMDtcbiAgICAgICAgdmFyIHNfb3V0ID0gMDtcblxuICAgICAgICAvLyBOb3csIHN1bSBpbmNvbWluZyBlZGdlIHdlaWdodHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNvbWluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gaW5jb21pbmdbaV07XG4gICAgICAgICAgc19pbiArPSB3ZWlnaHRGbi5hcHBseShlZGdlLCBbZWRnZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93LCBzdW0gb3V0Z29pbmcgZWRnZSB3ZWlnaHRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0Z29pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG91dGdvaW5nW2ldO1xuICAgICAgICAgIHNfb3V0ICs9IHdlaWdodEZuLmFwcGx5KGVkZ2UsIFtlZGdlXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGVncmVlOiBNYXRoLnBvdyhrX2luLCAxIC0gYWxwaGEpICogTWF0aC5wb3coc19pbiwgYWxwaGEpLFxuICAgICAgICAgIG91dGRlZ3JlZTogTWF0aC5wb3coa19vdXQsIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzX291dCwgYWxwaGEpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgLy8gZGVncmVlQ2VudHJhbGl0eVxuXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGRpcmVjdGVkIC8vIGRlZmF1bHQgZmFsc2VcbiAgICAvLyAgIGhhcm1vbmljIC8vIHVzZSBoYXJtb25pYyBtZWFuIGluc3RlYWQgb2YgYXJpdGhtZXRpYyBtZWFuXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vICAgY2xvc2VuZXNzIDogZnVuY3Rpb24obm9kZSkgLy8gUmV0dXJucyB0aGUgbm9ybWFsaXplZCBjbG9zZW5lc3Mgb2YgdGhlIGdpdmVuIG5vZGVcbiAgICBjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyAgIGlmIChkZWJ1Zykge1xuICAgICAgLy8gICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH07XG5cbiAgICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICAgIC8vIGRlYnVnIC0gb3B0aW9uYWxcbiAgICAgIC8vIGlmIChvcHRpb25zLmRlYnVnICE9IG51bGwpIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgLy8gfVxuXG4gICAgICAvLyBsb2dEZWJ1ZyhcIlN0YXJ0aW5nIGNsb3NlbmVzcyBjZW50cmFsaXR5Li4uXCIpO1xuXG4gICAgICB2YXIgaGFybW9uaWMgPSBvcHRpb25zLmhhcm1vbmljO1xuICAgICAgaWYoIGhhcm1vbmljID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgaGFybW9uaWMgPSB0cnVlO1xuICAgICAgfVxuIFxuICAgICAgdmFyIGNsb3NlbmVzc2VzID0ge307XG4gICAgICB2YXIgbWF4Q2xvc2VuZXNzID0gMDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBmdyA9IHRoaXMuZmxveWRXYXJzaGFsbCh7IHdlaWdodDogb3B0aW9ucy53ZWlnaHQsIGRpcmVjdGVkOiBvcHRpb25zLmRpcmVjdGVkIH0pO1xuXG4gICAgICAvLyBDb21wdXRlIGNsb3NlbmVzcyBmb3IgZXZlcnkgbm9kZSBhbmQgZmluZCB0aGUgbWF4aW11bSBjbG9zZW5lc3NcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjdXJyQ2xvc2VuZXNzID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChpICE9IGopIHtcbiAgICAgICAgICAgIHZhciBkID0gZncuZGlzdGFuY2Uobm9kZXNbaV0sIG5vZGVzW2pdKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIGhhcm1vbmljICl7XG4gICAgICAgICAgICAgIGN1cnJDbG9zZW5lc3MgKz0gMSAvIGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggIWhhcm1vbmljICl7XG4gICAgICAgICAgY3VyckNsb3NlbmVzcyA9IDEgLyBjdXJyQ2xvc2VuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heENsb3NlbmVzcyA8IGN1cnJDbG9zZW5lc3Mpe1xuICAgICAgICAgIG1heENsb3NlbmVzcyA9IGN1cnJDbG9zZW5lc3M7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9zZW5lc3Nlc1tub2Rlc1tpXS5pZCgpXSA9IGN1cnJDbG9zZW5lc3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsb3NlbmVzczogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2xvc2VuZXNzZXNbbm9kZV0gLyBtYXhDbG9zZW5lc3M7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gICByb290IDogZm9jYWwgbm9kZVxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGRpcmVjdGVkIC8vIGRlZmF1bHQgZmFsc2VcbiAgICAvLyBjbG9zZW5lc3MgPT4gcmV0dXJuZWQgdmFsdWUgYnkgdGhlIGZ1bmN0aW9uLiBDbG9zZW5lc3MgdmFsdWUgb2YgdGhlIGdpdmVuIG5vZGUuXG4gICAgY2xvc2VuZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyAgIGlmIChkZWJ1Zykge1xuICAgICAgLy8gICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH07XG5cbiAgICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICAgIC8vIGRlYnVnIC0gb3B0aW9uYWxcbiAgICAgIC8vIGlmIChvcHRpb25zLmRlYnVnICE9IG51bGwpIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgLy8gfVxuXG4gICAgICAvLyBsb2dEZWJ1ZyhcIlN0YXJ0aW5nIGNsb3NlbmVzcyBjZW50cmFsaXR5Li4uXCIpO1xuXG4gICAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgICAgaWYgKG9wdGlvbnMucm9vdCAhPSBudWxsKSB7XG4gICAgICAgIGlmICgkJC5pcy5zdHJpbmcob3B0aW9ucy5yb290KSkge1xuICAgICAgICAgIC8vIHVzZSBpdCBhcyBhIHNlbGVjdG9yLCBlLmcuIFwiI3Jvb3RJRFxuICAgICAgICAgIHZhciByb290ID0gdGhpcy5maWx0ZXIob3B0aW9ucy5yb290KVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IG9wdGlvbnMucm9vdFswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlNvdXJjZSBub2RlOiAlc1wiLCByb290LmlkKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCQudXRpbC5lcnJvcihcIm9wdGlvbnMucm9vdCByZXF1aXJlZFwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gd2VpZ2h0IC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmICQkLmlzLmZuKG9wdGlvbnMud2VpZ2h0KSkge1xuICAgICAgICB2YXIgd2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgd2VpZ2h0ID0gZnVuY3Rpb24oKXtyZXR1cm4gMTt9O1xuICAgICAgfVxuXG4gICAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsICYmICQkLmlzLmJvb2wob3B0aW9ucy5kaXJlY3RlZCkpIHtcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgaGFybW9uaWMgPSBvcHRpb25zLmhhcm1vbmljO1xuICAgICAgaWYoIGhhcm1vbmljID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgaGFybW9uaWMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBuZWVkIGRpc3RhbmNlIGZyb20gdGhpcyBub2RlIHRvIGV2ZXJ5IG90aGVyIG5vZGVcbiAgICAgIHZhciBkaWprc3RyYSA9IHRoaXMuZGlqa3N0cmEoe1xuICAgICAgICByb290OiByb290LFxuICAgICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQ6IGRpcmVjdGVkXG4gICAgICB9KTtcbiAgICAgIHZhciB0b3RhbERpc3RhbmNlID0gMDtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChub2Rlc1tpXS5pZCgpICE9IHJvb3QuaWQoKSl7XG4gICAgICAgICAgdmFyIGQgPSBkaWprc3RyYS5kaXN0YW5jZVRvKG5vZGVzW2ldKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggaGFybW9uaWMgKXtcbiAgICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gMSAvIGQ7IFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXJtb25pYyA/IHRvdGFsRGlzdGFuY2UgOiAxIC8gdG90YWxEaXN0YW5jZTtcbiAgICB9LCAvLyBjbG9zZW5lc3NDZW50cmFsaXR5XG5cbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHRoZSBhbGdvcml0aG0gaW4gdGhlIHBhcGVyIFwiT24gVmFyaWFudHMgb2YgU2hvcnRlc3QtUGF0aCBCZXR3ZWVubmVzcyBDZW50cmFsaXR5IGFuZCB0aGVpciBHZW5lcmljIENvbXB1dGF0aW9uXCIgYnkgVWxyaWsgQnJhbmRlc1xuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIHdlaWdodDogZnVuY3Rpb24oIGVkZ2UgKXt9IC8vIHNwZWNpZmllcyB3ZWlnaHQgdG8gdXNlIGZvciBgZWRnZWAvYHRoaXNgLiBJZiBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSBhc3VtZWQgYSB3ZWlnaHQgb2YgMSBmb3IgYWxsIGVkZ2VzXG4gICAgLy8gICBkaXJlY3RlZCAvLyBkZWZhdWx0IGZhbHNlXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vICAgYmV0d2Vlbm5lc3MgOiBmdW5jdGlvbihub2RlKSAvLyBSZXR1cm5zIHRoZSBiZXR3ZWVubmVzcyBjZW50cmFsaXR5IG9mIHRoZSBnaXZlbiBub2RlXG4gICAgLy8gICBiZXR3ZWVubmVzc05vcm1hbGl6ZWQgOiBmdW5jdGlvbihub2RlKSAvLyBSZXR1cm5zIHRoZSBub3JtYWxpemVkIGJldHdlZW5uZXNzIGNlbnRyYWxpdHkgb2YgdGhlIGdpdmVuIG5vZGVcbiAgICBiZXR3ZWVubmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gbG9nRGVidWcoXCJTdGFydGluZyBiZXR3ZWVubmVzcyBjZW50cmFsaXR5Li4uXCIpO1xuXG4gICAgICAvLyBXZWlnaHQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgJCQuaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7XG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgICB2YXIgd2VpZ2h0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHdlaWdodGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIERpcmVjdGVkIC0gZGVmYXVsdCBmYWxzZVxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCAmJiAkJC5pcy5ib29sKG9wdGlvbnMuZGlyZWN0ZWQpKSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByaW9yaXR5SW5zZXJ0ID0gZnVuY3Rpb24gKHF1ZXVlLCBlbGUpIHtcbiAgICAgICAgcXVldWUudW5zaGlmdChlbGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgZFtxdWV1ZVtpXV0gPCBkW3F1ZXVlW2kgKyAxXV0gJiYgaSA8IHF1ZXVlLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIHZhciB0bXAgPSBxdWV1ZVtpXTtcbiAgICAgICAgICBxdWV1ZVtpXSA9IHF1ZXVlW2kgKyAxXTtcbiAgICAgICAgICBxdWV1ZVtpICsgMV0gPSB0bXA7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIC8vIHN0YXJ0aW5nXG4gICAgICB2YXIgViA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBBID0ge307XG4gICAgICB2YXIgQyA9IHt9O1xuXG4gICAgICAvLyBBIGNvbnRhaW5zIHRoZSBuZWlnaGJvcmhvb2RzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgICBBW1ZbaV0uaWQoKV0gPSBWW2ldLm91dGdvZXJzKFwibm9kZVwiKTsgLy8gZ2V0IG91dGdvZXJzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBW1ZbaV0uaWQoKV0gPSBWW2ldLm9wZW5OZWlnaGJvcmhvb2QoXCJub2RlXCIpOyAvLyBnZXQgbmVpZ2hib3JzIG9mIGV2ZXJ5IG5vZGUgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQyBjb250YWlucyB0aGUgYmV0d2Vlbm5lc3MgdmFsdWVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ1tWW2ldLmlkKCldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBWLmxlbmd0aDsgcysrKSB7XG4gICAgICAgIHZhciBTID0gW107IC8vIHN0YWNrXG4gICAgICAgIHZhciBQID0ge307XG4gICAgICAgIHZhciBnID0ge307XG4gICAgICAgIHZhciBkID0ge307XG4gICAgICAgIHZhciBRID0gW107IC8vIHF1ZXVlXG5cbiAgICAgICAgLy8gaW5pdCBkaWN0aW9uYXJpZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgUFtWW2ldLmlkKCldID0gW107XG4gICAgICAgICAgZ1tWW2ldLmlkKCldID0gMDtcbiAgICAgICAgICBkW1ZbaV0uaWQoKV0gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIH1cblxuICAgICAgICBnW1Zbc10uaWQoKV0gPSAxOyAvLyBzaWdtYVxuICAgICAgICBkW1Zbc10uaWQoKV0gPSAwOyAvLyBkaXN0YW5jZSB0byBzXG5cbiAgICAgICAgUS51bnNoaWZ0KFZbc10uaWQoKSk7XG5cbiAgICAgICAgd2hpbGUgKFEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB2ID0gUS5wb3AoKTtcbiAgICAgICAgICBTLnB1c2godik7XG4gICAgICAgICAgaWYgKHdlaWdodGVkKSB7XG4gICAgICAgICAgICBBW3ZdLmZvckVhY2goZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgICAgaWYgKGN5LiQoJyMnICsgdikuZWRnZXNUbyh3KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBjeS4kKCcjJyArIHYpLmVkZ2VzVG8odylbMF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSB3LmVkZ2VzVG8oJyMnICsgdilbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHZhciBlZGdlV2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoZWRnZSwgW2VkZ2VdKTtcblxuICAgICAgICAgICAgICBpZiAoZFt3LmlkKCldID4gZFt2XSArIGVkZ2VXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkW3cuaWQoKV0gPSBkW3ZdICsgZWRnZVdlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoUS5pbmRleE9mKHcuaWQoKSkgPCAwKSB7IC8vaWYgdyBpcyBub3QgaW4gUVxuICAgICAgICAgICAgICAgICAgcHJpb3JpdHlJbnNlcnQoUSwgdy5pZCgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB1cGRhdGUgcG9zaXRpb24gaWYgdyBpcyBpbiBRXG4gICAgICAgICAgICAgICAgICBRLnNwbGljZShRLmluZGV4T2Yody5pZCgpKSwgMSk7XG4gICAgICAgICAgICAgICAgICBwcmlvcml0eUluc2VydChRLCB3LmlkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnW3cuaWQoKV0gPSAwO1xuICAgICAgICAgICAgICAgIFBbdy5pZCgpXSA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkW3cuaWQoKV0gPT0gZFt2XSArIGVkZ2VXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBnW3cuaWQoKV0gPSBnW3cuaWQoKV0gKyBnW3ZdO1xuICAgICAgICAgICAgICAgIFBbdy5pZCgpXS5wdXNoKHYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQVt2XS5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICAgIGlmIChkW3cuaWQoKV0gPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICAgICAgUS51bnNoaWZ0KHcuaWQoKSk7XG4gICAgICAgICAgICAgICAgZFt3LmlkKCldID0gZFt2XSArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRbdy5pZCgpXSA9PSBkW3ZdICsgMSkge1xuICAgICAgICAgICAgICAgIGdbdy5pZCgpXSA9IGdbdy5pZCgpXSArIGdbdl07XG4gICAgICAgICAgICAgICAgUFt3LmlkKCldLnB1c2godik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVbVltpXS5pZCgpXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoUy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHcgPSBTLnBvcCgpO1xuICAgICAgICAgIFBbd10uZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgZVt2XSA9IGVbdl0gKyAoZ1t2XSAvIGdbd10pICogKDEgKyBlW3ddKTtcbiAgICAgICAgICAgIGlmICh3ICE9IFZbc10uaWQoKSlcbiAgICAgICAgICAgICAgQ1t3XSA9IENbd10gKyBlW3ddO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXggPSAwO1xuICAgICAgZm9yICh2YXIga2V5IGluIEMpIHtcbiAgICAgICAgaWYgKG1heCA8IENba2V5XSlcbiAgICAgICAgICBtYXggPSBDW2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIGJldHdlZW5uZXNzOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIENbbm9kZV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmV0d2Vlbm5lc3NOb3JtYWxpemVkOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIENbbm9kZV0gLyBtYXg7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGFsaWFzXG4gICAgICByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpc2VkID0gcmV0LmJldHdlZW5uZXNzTm9ybWFsaXplZDtcblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIGJldHdlZW5uZXNzQ2VudHJhbGl0eVxuICB9KTsgLy8gJCQuZm4uZWxlc1xuXG4gIC8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcbiAgJCQuZWxlc2ZuLmRjID0gJCQuZWxlc2ZuLmRlZ3JlZUNlbnRyYWxpdHk7XG4gICQkLmVsZXNmbi5kY24gPSAkJC5lbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSAkJC5lbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG4gICQkLmVsZXNmbi5jYyA9ICQkLmVsZXNmbi5jbG9zZW5lc3NDZW50cmFsaXR5O1xuICAkJC5lbGVzZm4uY2NuID0gJCQuZWxlc2ZuLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpc2VkID0gJCQuZWxlc2ZuLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkO1xuICAkJC5lbGVzZm4uYmMgPSAkJC5lbGVzZm4uYmV0d2Vlbm5lc3NDZW50cmFsaXR5O1xufSkgKGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oICQkICl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5lbGVzKHtcbiAgICBhbmltYXRlZDogJCQuZGVmaW5lLmFuaW1hdGVkKCksXG4gICAgY2xlYXJRdWV1ZTogJCQuZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgICBkZWxheTogJCQuZGVmaW5lLmRlbGF5KCksXG4gICAgYW5pbWF0ZTogJCQuZGVmaW5lLmFuaW1hdGUoKSxcbiAgICBzdG9wOiAkJC5kZWZpbmUuc3RvcCgpXG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTsgIFxuXG47KGZ1bmN0aW9uKCAkJCApeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICBhZGRDbGFzczogZnVuY3Rpb24oY2xhc3Nlcyl7XG4gICAgICBjbGFzc2VzID0gY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgICAgIFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuICAgICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoY2xzKSApeyBjb250aW51ZTsgfVxuICAgICAgICBcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHNlbGZbal07XG4gICAgICAgICAgdmFyIGhhc0NsYXNzID0gZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXTtcbiAgICAgICAgICBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcblxuICAgICAgICAgIGlmKCAhaGFzQ2xhc3MgKXsgLy8gaWYgZGlkbid0IGFscmVhZHkgaGF2ZSwgYWRkIHRvIGxpc3Qgb2YgY2hhbmdlZFxuICAgICAgICAgICAgY2hhbmdlZC5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgICBpZiggY2hhbmdlZC5sZW5ndGggPiAwICl7XG4gICAgICAgIG5ldyAkJC5Db2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIGNoYW5nZWQpXG4gICAgICAgICAgLnVwZGF0ZVN0eWxlKClcbiAgICAgICAgICAudHJpZ2dlcignY2xhc3MnKVxuICAgICAgICA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oY2xhc3NOYW1lKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgcmV0dXJuICggZWxlICE9IG51bGwgJiYgZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xhc3NOYW1lXSApID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24oY2xhc3Nlc1N0ciwgdG9nZ2xlKXtcbiAgICAgIHZhciBjbGFzc2VzID0gY2xhc3Nlc1N0ci5zcGxpdCgvXFxzKy8pO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNoYW5nZWQgPSBbXTsgLy8gZWxlcyB3aG8gaGFkIGNsYXNzZXMgY2hhbmdlZFxuICAgICAgXG4gICAgICBmb3IoIHZhciBpID0gMCwgaWwgPSBzZWxmLmxlbmd0aDsgaSA8IGlsOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbal07XG5cbiAgICAgICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoY2xzKSApeyBjb250aW51ZTsgfVxuICAgICAgICAgIFxuICAgICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc107XG4gICAgICAgICAgdmFyIHNob3VsZEFkZCA9IHRvZ2dsZSB8fCAodG9nZ2xlID09PSB1bmRlZmluZWQgJiYgIWhhc0NsYXNzKTtcblxuICAgICAgICAgIGlmKCBzaG91bGRBZGQgKXtcbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc10gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiggIWhhc0NsYXNzICl7IGNoYW5nZWQucHVzaChlbGUpOyB9XG4gICAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiByZW1vdmVcbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc10gPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYoIGhhc0NsYXNzICl7IGNoYW5nZWQucHVzaChlbGUpOyB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gLy8gZm9yIGogY2xhc3Nlc1xuICAgICAgfSAvLyBmb3IgaSBlbGVzXG4gICAgICBcbiAgICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuICAgICAgaWYoIGNoYW5nZWQubGVuZ3RoID4gMCApe1xuICAgICAgICBuZXcgJCQuQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCBjaGFuZ2VkKVxuICAgICAgICAgIC51cGRhdGVTdHlsZSgpXG4gICAgICAgICAgLnRyaWdnZXIoJ2NsYXNzJylcbiAgICAgICAgO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzZXMpe1xuICAgICAgY2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjaGFuZ2VkID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gc2VsZltpXTtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tqXTtcbiAgICAgICAgICBpZiggIWNscyB8fCBjbHMgPT09ICcnICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdO1xuICAgICAgICAgIGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc10gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiggaGFzQ2xhc3MgKXsgLy8gdGhlbiB3ZSBjaGFuZ2VkIGl0cyBzZXQgb2YgY2xhc3Nlc1xuICAgICAgICAgICAgY2hhbmdlZC5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgICBpZiggY2hhbmdlZC5sZW5ndGggPiAwICl7XG4gICAgICAgIG5ldyAkJC5Db2xsZWN0aW9uKHNlbGYuX3ByaXZhdGUuY3ksIGNoYW5nZWQpLnVwZGF0ZVN0eWxlKCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYudHJpZ2dlcignY2xhc3MnKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICBmbGFzaENsYXNzOiBmdW5jdGlvbihjbGFzc2VzLCBkdXJhdGlvbil7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmKCBkdXJhdGlvbiA9PSBudWxsICl7XG4gICAgICAgIGR1cmF0aW9uID0gMjUwO1xuICAgICAgfSBlbHNlIGlmKCBkdXJhdGlvbiA9PT0gMCApe1xuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbm90aGluZyB0byBkbyByZWFsbHlcbiAgICAgIH1cblxuICAgICAgc2VsZi5hZGRDbGFzcyggY2xhc3NlcyApO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc2VzICk7XG4gICAgICB9LCBkdXJhdGlvbik7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIGFsbEFyZTogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoc2VsZWN0b3IpLmxlbmd0aCA9PT0gdGhpcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihzZWxlY3RvcikubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgc29tZTogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4oIHRoaXNbaV0sIGksIHRoaXMgKSA6IGZuLmFwcGx5KCB0aGlzQXJnLCBbIHRoaXNbaV0sIGksIHRoaXMgXSApO1xuXG4gICAgICAgIGlmKCByZXQgKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGV2ZXJ5OiBmdW5jdGlvbiggZm4sIHRoaXNBcmcgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbiggdGhpc1tpXSwgaSwgdGhpcyApIDogZm4uYXBwbHkoIHRoaXNBcmcsIFsgdGhpc1tpXSwgaSwgdGhpcyBdICk7XG5cbiAgICAgICAgaWYoICFyZXQgKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHNhbWU6IGZ1bmN0aW9uKCBjb2xsZWN0aW9uICl7XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKTtcblxuICAgICAgLy8gY2hlYXAgZXh0cmEgY2hlY2tcbiAgICAgIGlmKCB0aGlzLmxlbmd0aCAhPT0gY29sbGVjdGlvbi5sZW5ndGggKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3QoIGNvbGxlY3Rpb24gKS5sZW5ndGggPT09IHRoaXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBhbnlTYW1lOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKCBjb2xsZWN0aW9uICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdCggY29sbGVjdGlvbiApLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIGFsbEFyZU5laWdoYm9yczogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoKS5pbnRlcnNlY3QoIGNvbGxlY3Rpb24gKS5sZW5ndGggPT09IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgJCQuZWxlc2ZuLmFsbEFyZU5laWdoYm91cnMgPSAkJC5lbGVzZm4uYWxsQXJlTmVpZ2hib3JzO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBDb21wb3VuZCBmdW5jdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgcGFyZW50OiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBwYXJlbnRzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBwYXJlbnQgPSBjeS5nZXRFbGVtZW50QnlJZCggZWxlLl9wcml2YXRlLmRhdGEucGFyZW50ICk7XG5cbiAgICAgICAgaWYoIHBhcmVudC5zaXplKCkgPiAwICl7XG4gICAgICAgICAgcGFyZW50cy5wdXNoKCBwYXJlbnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBwYXJlbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBwYXJlbnRzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBwYXJlbnRzID0gW107XG5cbiAgICAgIHZhciBlbGVzID0gdGhpcy5wYXJlbnQoKTtcbiAgICAgIHdoaWxlKCBlbGVzLm5vbmVtcHR5KCkgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgcGFyZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZXMgPSBlbGVzLnBhcmVudCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuY3koKSwgcGFyZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgY29tbW9uQW5jZXN0b3JzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBhbmNlc3RvcnM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHBhcmVudHMgPSBlbGUucGFyZW50cygpO1xuICAgICAgICBcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzIHx8IHBhcmVudHM7XG5cbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmludGVyc2VjdCggcGFyZW50cyApOyAvLyBjdXJyZW50IGxpc3QgbXVzdCBiZSBjb21tb24gd2l0aCBjdXJyZW50IGVsZSBwYXJlbnRzIHNldFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYW5jZXN0b3JzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgb3JwaGFuczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5wYXJlbnQoKS5lbXB0eSgpO1xuICAgICAgfSkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBub25vcnBoYW5zOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiggZWxlICl7XG4gICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLnBhcmVudCgpLm5vbmVtcHR5KCk7XG4gICAgICB9KS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIGNoaWxkcmVuOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uY29uY2F0KCBlbGUuX3ByaXZhdGUuY2hpbGRyZW4gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCksIGNoaWxkcmVuLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBzaWJsaW5nczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpLm5vdCggdGhpcyApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgaXNQYXJlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNDaGlsZDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBlbGUucGFyZW50KCkubGVuZ3RoICE9PSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXNjZW5kYW50czogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gYWRkKCBlbGVzICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWxlICk7XG5cbiAgICAgICAgICBpZiggZWxlLmNoaWxkcmVuKCkubm9uZW1wdHkoKSApe1xuICAgICAgICAgICAgYWRkKCBlbGUuY2hpbGRyZW4oKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZGQoIHRoaXMuY2hpbGRyZW4oKSApO1xuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuY3koKSwgZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gICQkLmVsZXNmbi5hbmNlc3RvcnMgPSAkJC5lbGVzZm4ucGFyZW50cztcbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBib3JkZXJXaWR0aE11bHRpcGxpZXIgPSAyICogMC41O1xuICB2YXIgYm9yZGVyV2lkdGhBZGp1c3RtZW50ID0gMDtcblxuICAkJC5mbi5lbGVzKHtcblxuICAgIGRhdGE6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAgICdpZCc6IHRydWUsXG4gICAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICAgIH0sXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVtb3ZlRGF0YTogJCQuZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGV2ZW50OiAnZGF0YScsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAgICdpZCc6IHRydWUsXG4gICAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICAgIH0sXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgc2NyYXRjaDogJCQuZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gICAgfSksXG5cbiAgICByZW1vdmVTY3JhdGNoOiAkJC5kZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgICAgZXZlbnQ6ICdzY3JhdGNoJyxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gICAgfSksXG5cbiAgICByc2NyYXRjaDogJCQuZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gICAgfSksXG5cbiAgICByZW1vdmVSc2NyYXRjaDogJCQuZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gICAgfSksXG5cbiAgICBpZDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcG9zaXRpb246ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAncG9zaXRpb24nLFxuICAgICAgYmluZGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAncnRyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICAgICAgb25TZXQ6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICAgIHZhciB1cGRhdGVkRWxlcyA9IGVsZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgdXBkYXRlZEVsZXMucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICB9LFxuICAgICAgY2FuU2V0OiBmdW5jdGlvbiggZWxlICl7XG4gICAgICAgIHJldHVybiAhZWxlLmxvY2tlZCgpO1xuICAgICAgfVxuICAgIH0pLFxuXG4gICAgLy8gcG9zaXRpb24gYnV0IG5vIG5vdGlmaWNhdGlvbiB0byByZW5kZXJlclxuICAgIHNpbGVudFBvc2l0aW9uOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ3Bvc2l0aW9uJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgICB2YWxpZEtleXM6IFsneCcsICd5J10sXG4gICAgICBvblNldDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgICAgZWxlcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgfSxcbiAgICAgIGNhblNldDogZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICByZXR1cm4gIWVsZS5sb2NrZWQoKTtcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIHBvc2l0aW9uczogZnVuY3Rpb24oIHBvcywgc2lsZW50ICl7XG4gICAgICBpZiggJCQuaXMucGxhaW5PYmplY3QocG9zKSApe1xuICAgICAgICB0aGlzLnBvc2l0aW9uKHBvcyk7XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuZm4ocG9zKSApe1xuICAgICAgICB2YXIgZm4gPSBwb3M7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICB2YXIgcG9zID0gZm4uYXBwbHkoZWxlLCBbaSwgZWxlXSk7XG5cbiAgICAgICAgICBpZiggcG9zICYmICFlbGUubG9ja2VkKCkgKXtcbiAgICAgICAgICAgIHZhciBlbGVQb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgICBlbGVQb3MueCA9IHBvcy54O1xuICAgICAgICAgICAgZWxlUG9zLnkgPSBwb3MueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBkYXRlZEVsZXMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgIHZhciB0b1RyaWdnZXIgPSB1cGRhdGVkRWxlcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRFbGVzICkgOiB0aGlzO1xuXG4gICAgICAgIGlmKCBzaWxlbnQgKXtcbiAgICAgICAgICB0b1RyaWdnZXIudHJpZ2dlcigncG9zaXRpb24nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b1RyaWdnZXIucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHNpbGVudFBvc2l0aW9uczogZnVuY3Rpb24oIHBvcyApe1xuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25zKCBwb3MsIHRydWUgKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlQ29tcG91bmRCb3VuZHM6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgfHwgIWN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApeyByZXR1cm4gY3kuY29sbGVjdGlvbigpOyB9IC8vIHNhdmUgY3ljbGVzIGZvciBub24gY29tcG91bmQgZ3JhcGhzIG9yIHdoZW4gc3R5bGUgZGlzYWJsZWRcblxuICAgICAgdmFyIHVwZGF0ZWQgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKCBwYXJlbnQgKXtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuKCk7XG4gICAgICAgIHZhciBzdHlsZSA9IHBhcmVudC5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgICAgdmFyIGluY2x1ZGVMYWJlbHMgPSBzdHlsZVsnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnXS52YWx1ZSA9PT0gJ2luY2x1ZGUnO1xuICAgICAgICB2YXIgYmIgPSBjaGlsZHJlbi5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IGluY2x1ZGVMYWJlbHMsIGluY2x1ZGVFZGdlczogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSB7XG4gICAgICAgICAgdG9wOiBzdHlsZVsncGFkZGluZy10b3AnXS5weFZhbHVlLFxuICAgICAgICAgIGJvdHRvbTogc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10ucHhWYWx1ZSxcbiAgICAgICAgICBsZWZ0OiBzdHlsZVsncGFkZGluZy1sZWZ0J10ucHhWYWx1ZSxcbiAgICAgICAgICByaWdodDogc3R5bGVbJ3BhZGRpbmctcmlnaHQnXS5weFZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwb3MgPSBwYXJlbnQuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIHZhciBkaWRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiggc3R5bGVbJ3dpZHRoJ10udmFsdWUgPT09ICdhdXRvJyApe1xuICAgICAgICAgIHBhcmVudC5fcHJpdmF0ZS5hdXRvV2lkdGggPSBiYi53ICsgcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodDtcbiAgICAgICAgICBwb3MueCA9IChiYi54MSArIGJiLngyIC0gcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodCkvMjtcbiAgICAgICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHN0eWxlWydoZWlnaHQnXS52YWx1ZSA9PT0gJ2F1dG8nICl7XG4gICAgICAgICAgcGFyZW50Ll9wcml2YXRlLmF1dG9IZWlnaHQgPSBiYi5oICsgcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcbiAgICAgICAgICBwb3MueSA9IChiYi55MSArIGJiLnkyIC0gcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbSkvMjtcbiAgICAgICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGRpZFVwZGF0ZSApe1xuICAgICAgICAgIHVwZGF0ZWQucHVzaCggcGFyZW50ICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ28gdXAsIGxldmVsIGJ5IGxldmVsXG4gICAgICB2YXIgZWxlcyA9IHRoaXMucGFyZW50KCk7XG4gICAgICB3aGlsZSggZWxlcy5ub25lbXB0eSgpICl7XG5cbiAgICAgICAgLy8gdXBkYXRlIGVhY2ggcGFyZW50IG5vZGUgaW4gdGhpcyBsZXZlbFxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICAgIHVwZGF0ZSggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuZXh0IGxldmVsXG4gICAgICAgIGVsZXMgPSBlbGVzLnBhcmVudCgpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXR1cm4gY2hhbmdlZFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgdXBkYXRlZCApO1xuICAgIH0sXG5cbiAgICAvLyBnZXQvc2V0IHRoZSByZW5kZXJlZCAoaS5lLiBvbiBzY3JlZW4pIHBvc2l0b24gb2YgdGhlIGVsZW1lbnRcbiAgICByZW5kZXJlZFBvc2l0aW9uOiBmdW5jdGlvbiggZGltLCB2YWwgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgcnBvcyA9ICQkLmlzLnBsYWluT2JqZWN0KCBkaW0gKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBzZXR0aW5nID0gcnBvcyAhPT0gdW5kZWZpbmVkIHx8ICggdmFsICE9PSB1bmRlZmluZWQgJiYgJCQuaXMuc3RyaW5nKGRpbSkgKTtcblxuICAgICAgaWYoIGVsZSAmJiBlbGUuaXNOb2RlKCkgKXsgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgICBpZiggc2V0dGluZyApe1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb25bZGltXSA9ICggdmFsIC0gcGFuW2RpbV0gKS96b29tO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCBycG9zICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiAoIHJwb3MueCAtIHBhbi54ICkgL3pvb20sXG4gICAgICAgICAgICAgICAgeTogKCBycG9zLnkgLSBwYW4ueSApIC96b29tXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZ2V0dGluZ1xuICAgICAgICAgIHZhciBwb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgcnBvcyA9IHtcbiAgICAgICAgICAgIHg6IHBvcy54ICogem9vbSArIHBhbi54LFxuICAgICAgICAgICAgeTogcG9zLnkgKiB6b29tICsgcGFuLnlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYoIGRpbSA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHJwb3M7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICAgIHJldHVybiBycG9zWyBkaW0gXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiggIXNldHRpbmcgKXtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgLy8gZ2V0L3NldCB0aGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhcmVudFxuICAgIHJlbGF0aXZlUG9zaXRpb246IGZ1bmN0aW9uKCBkaW0sIHZhbCApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICB2YXIgcHBvcyA9ICQkLmlzLnBsYWluT2JqZWN0KCBkaW0gKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBzZXR0aW5nID0gcHBvcyAhPT0gdW5kZWZpbmVkIHx8ICggdmFsICE9PSB1bmRlZmluZWQgJiYgJCQuaXMuc3RyaW5nKGRpbSkgKTtcbiAgICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgICBpZiggZWxlICYmIGVsZS5pc05vZGUoKSApeyAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICAgIGlmKCBzZXR0aW5nICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gZWxlLnBhcmVudCgpIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcblxuICAgICAgICAgICAgaWYoIGhhc1BhcmVudCApe1xuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSByZWxhdGl2ZVRvUGFyZW50ID8gcGFyZW50Ll9wcml2YXRlLnBvc2l0aW9uIDogeyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb25bZGltXSA9IHZhbCArIG9yaWdpbltkaW1dO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCBwcG9zICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBwcG9zLnggKyBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgICB5OiBwcG9zLnkgKyBvcmlnaW4ueSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIGdldHRpbmdcbiAgICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gZWxlLnBhcmVudCgpIDogbnVsbDtcbiAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICYmIHBhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICAgIHZhciByZWxhdGl2ZVRvUGFyZW50ID0gaGFzUGFyZW50O1xuXG4gICAgICAgICAgaWYoIGhhc1BhcmVudCApe1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcmlnaW4gPSByZWxhdGl2ZVRvUGFyZW50ID8gcGFyZW50Ll9wcml2YXRlLnBvc2l0aW9uIDogeyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgICBwcG9zID0ge1xuICAgICAgICAgICAgeDogcG9zLnggLSBvcmlnaW4ueCxcbiAgICAgICAgICAgIHk6IHBvcy55IC0gb3JpZ2luLnlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYoIGRpbSA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHBwb3M7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICAgIHJldHVybiBwcG9zWyBkaW0gXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiggIXNldHRpbmcgKXtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgLy8gY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IGEgbnVtZXJpY2FsIHZhbHVlIGZvciB0aGUgd2lkdGggb2YgdGhlIG5vZGUvZWRnZVxuICAgIHdpZHRoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICB2YXIgdyA9IGVsZS5fcHJpdmF0ZS5zdHlsZS53aWR0aDtcbiAgICAgICAgICByZXR1cm4gdy5zdHJWYWx1ZSA9PT0gJ2F1dG8nID8gZWxlLl9wcml2YXRlLmF1dG9XaWR0aCA6IHcucHhWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvdXRlcldpZHRoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGguc3RyVmFsdWUgPT09ICdhdXRvJyA/IGVsZS5fcHJpdmF0ZS5hdXRvV2lkdGggOiBzdHlsZS53aWR0aC5weFZhbHVlO1xuICAgICAgICAgIHZhciBib3JkZXIgPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10gPyBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZSAqIGJvcmRlcldpZHRoTXVsdGlwbGllciArIGJvcmRlcldpZHRoQWRqdXN0bWVudCA6IDA7XG5cbiAgICAgICAgICByZXR1cm4gd2lkdGggKyBib3JkZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyZWRXaWR0aDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHZhciB3aWR0aCA9IGVsZS53aWR0aCgpO1xuICAgICAgICByZXR1cm4gd2lkdGggKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXJlZE91dGVyV2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgb3dpZHRoID0gZWxlLm91dGVyV2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIG93aWR0aCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgdGhlIGhlaWdodCBvZiB0aGUgbm9kZVxuICAgIGhlaWdodDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgICAgaWYoIGVsZSAmJiBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICAgIHZhciBoID0gZWxlLl9wcml2YXRlLnN0eWxlLmhlaWdodDtcbiAgICAgICAgICByZXR1cm4gaC5zdHJWYWx1ZSA9PT0gJ2F1dG8nID8gZWxlLl9wcml2YXRlLmF1dG9IZWlnaHQgOiBoLnB4VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb3V0ZXJIZWlnaHQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IGVsZS5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodC5zdHJWYWx1ZSA9PT0gJ2F1dG8nID8gZWxlLl9wcml2YXRlLmF1dG9IZWlnaHQgOiBzdHlsZS5oZWlnaHQucHhWYWx1ZTtcbiAgICAgICAgICB2YXIgYm9yZGVyID0gc3R5bGVbJ2JvcmRlci13aWR0aCddID8gc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWUgKiBib3JkZXJXaWR0aE11bHRpcGxpZXIgKyBib3JkZXJXaWR0aEFkanVzdG1lbnQgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlaWdodCArIGJvcmRlcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyZWRIZWlnaHQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSAmJiBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsZS5oZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIGhlaWdodCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcmVkT3V0ZXJIZWlnaHQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSAmJiBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgdmFyIG9oZWlnaHQgPSBlbGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIG9oZWlnaHQgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXJlZEJvdW5kaW5nQm94OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIGJiID0gdGhpcy5ib3VuZGluZ0JveCggb3B0aW9ucyApO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG5cbiAgICAgIHZhciB4MSA9IGJiLngxICogem9vbSArIHBhbi54O1xuICAgICAgdmFyIHgyID0gYmIueDIgKiB6b29tICsgcGFuLng7XG4gICAgICB2YXIgeTEgPSBiYi55MSAqIHpvb20gKyBwYW4ueTtcbiAgICAgIHZhciB5MiA9IGJiLnkyICogem9vbSArIHBhbi55O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHc6IHgyIC0geDEsXG4gICAgICAgIGg6IHkyIC0geTFcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIGdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50cyAoaW4gcmF3IG1vZGVsIHBvc2l0aW9uKVxuICAgIGJvdW5kaW5nQm94OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGN5ID0gZWxlcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBjeV9wID0gY3kuX3ByaXZhdGU7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3lfcC5zdHlsZUVuYWJsZWQ7XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICB2YXIgaW5jbHVkZU5vZGVzID0gb3B0aW9ucy5pbmNsdWRlTm9kZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmluY2x1ZGVOb2RlcztcbiAgICAgIHZhciBpbmNsdWRlRWRnZXMgPSBvcHRpb25zLmluY2x1ZGVFZGdlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuaW5jbHVkZUVkZ2VzO1xuICAgICAgdmFyIGluY2x1ZGVMYWJlbHMgPSBvcHRpb25zLmluY2x1ZGVMYWJlbHMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmluY2x1ZGVMYWJlbHM7XG5cbiAgICAgIC8vIHJlY2FsY3VsYXRlIHByb2plY3Rpb25zIGV0Y1xuICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICBjeV9wLnJlbmRlcmVyLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSggdGhpcyApO1xuICAgICAgfVxuXG4gICAgICB2YXIgeDEgPSBJbmZpbml0eTtcbiAgICAgIHZhciB4MiA9IC1JbmZpbml0eTtcbiAgICAgIHZhciB5MSA9IEluZmluaXR5O1xuICAgICAgdmFyIHkyID0gLUluZmluaXR5O1xuXG4gICAgICAvLyBmaW5kIGJvdW5kcyBvZiBlbGVtZW50c1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuICAgICAgICB2YXIgZGlzcGxheSA9IHN0eWxlRW5hYmxlZCA/IF9wLnN0eWxlWydkaXNwbGF5J10udmFsdWUgOiAnZWxlbWVudCc7XG4gICAgICAgIHZhciBpc05vZGUgPSBfcC5ncm91cCA9PT0gJ25vZGVzJztcbiAgICAgICAgdmFyIGV4MSwgZXgyLCBleTEsIGV5MiwgeCwgeTtcbiAgICAgICAgdmFyIGluY2x1ZGVkRWxlID0gZmFsc2U7XG5cbiAgICAgICAgaWYoIGRpc3BsYXkgPT09ICdub25lJyApeyBjb250aW51ZTsgfSAvLyB0aGVuIGVsZSBkb2Vzbid0IHRha2UgdXAgc3BhY2VcblxuICAgICAgICBpZiggaXNOb2RlICYmIGluY2x1ZGVOb2RlcyApe1xuICAgICAgICAgIGluY2x1ZGVkRWxlID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcbiAgICAgICAgICB4ID0gcG9zLng7XG4gICAgICAgICAgeSA9IHBvcy55O1xuICAgICAgICAgIHZhciB3ID0gZWxlLm91dGVyV2lkdGgoKTtcbiAgICAgICAgICB2YXIgaGFsZlcgPSB3LzI7XG4gICAgICAgICAgdmFyIGggPSBlbGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgICB2YXIgaGFsZkggPSBoLzI7XG5cbiAgICAgICAgICAvLyBoYW5kbGUgbm9kZSBkaW1lbnNpb25zXG4gICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgZXgxID0geCAtIGhhbGZXO1xuICAgICAgICAgIGV4MiA9IHggKyBoYWxmVztcbiAgICAgICAgICBleTEgPSB5IC0gaGFsZkg7XG4gICAgICAgICAgZXkyID0geSArIGhhbGZIO1xuXG4gICAgICAgICAgeDEgPSBleDEgPCB4MSA/IGV4MSA6IHgxO1xuICAgICAgICAgIHgyID0gZXgyID4geDIgPyBleDIgOiB4MjtcbiAgICAgICAgICB5MSA9IGV5MSA8IHkxID8gZXkxIDogeTE7XG4gICAgICAgICAgeTIgPSBleTIgPiB5MiA/IGV5MiA6IHkyO1xuXG4gICAgICAgIH0gZWxzZSBpZiggZWxlLmlzRWRnZSgpICYmIGluY2x1ZGVFZGdlcyApe1xuICAgICAgICAgIGluY2x1ZGVkRWxlID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBuMSA9IF9wLnNvdXJjZTtcbiAgICAgICAgICB2YXIgbjFfcCA9IG4xLl9wcml2YXRlO1xuICAgICAgICAgIHZhciBuMXBvcyA9IG4xX3AucG9zaXRpb247XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIG4yID0gX3AudGFyZ2V0O1xuICAgICAgICAgIHZhciBuMl9wID0gbjIuX3ByaXZhdGU7XG4gICAgICAgICAgdmFyIG4ycG9zID0gbjJfcC5wb3NpdGlvbjtcbiAgICAgICAgICBcblxuICAgICAgICAgIC8vIGhhbmRsZSBlZGdlIGRpbWVuc2lvbnMgKHJvdWdoIGJveCBlc3RpbWF0ZSlcbiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgZXgxID0gbjFwb3MueDtcbiAgICAgICAgICBleDIgPSBuMnBvcy54O1xuICAgICAgICAgIGV5MSA9IG4xcG9zLnk7XG4gICAgICAgICAgZXkyID0gbjJwb3MueTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggZXgxID4gZXgyICl7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGV4MTtcbiAgICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGV5MSA+IGV5MiApe1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBleTE7XG4gICAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgICBleTIgPSB0ZW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgxID0gZXgxIDwgeDEgPyBleDEgOiB4MTtcbiAgICAgICAgICB4MiA9IGV4MiA+IHgyID8gZXgyIDogeDI7XG4gICAgICAgICAgeTEgPSBleTEgPCB5MSA/IGV5MSA6IHkxO1xuICAgICAgICAgIHkyID0gZXkyID4geTIgPyBleTIgOiB5MjtcblxuICAgICAgICAgIC8vIGhhbmRsZSBwb2ludHMgYWxvbmcgZWRnZSAoc2FuaXR5IGNoZWNrKVxuICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICAgICAgdmFyIGJwdHMgPSByc3R5bGUuYmV6aWVyUHRzIHx8IFtdO1xuXG4gICAgICAgICAgICB2YXIgdyA9IHN0eWxlWyd3aWR0aCddLnB4VmFsdWU7XG4gICAgICAgICAgICB2YXIgd0hhbGYgPSB3LzI7XG5cbiAgICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYnB0cy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgICB2YXIgYnB0ID0gYnB0c1tqXTtcblxuICAgICAgICAgICAgICBleDEgPSBicHQueCAtIHdIYWxmO1xuICAgICAgICAgICAgICBleDIgPSBicHQueCArIHdIYWxmO1xuICAgICAgICAgICAgICBleTEgPSBicHQueSAtIHdIYWxmO1xuICAgICAgICAgICAgICBleTIgPSBicHQueSArIHdIYWxmO1xuXG4gICAgICAgICAgICAgIHgxID0gZXgxIDwgeDEgPyBleDEgOiB4MTtcbiAgICAgICAgICAgICAgeDIgPSBleDIgPiB4MiA/IGV4MiA6IHgyO1xuICAgICAgICAgICAgICB5MSA9IGV5MSA8IHkxID8gZXkxIDogeTE7XG4gICAgICAgICAgICAgIHkyID0gZXkyID4geTIgPyBleTIgOiB5MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gcHJlY2lzZSBoYXlzdGFja3MgKHNhbml0eSBjaGVjaylcbiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgJiYgc3R5bGVbJ2N1cnZlLXN0eWxlJ10uc3RyVmFsdWUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgICAgICAgIHZhciBocHRzID0gX3AucnNjcmF0Y2guaGF5c3RhY2tQdHM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4MSA9IGhwdHNbMF07XG4gICAgICAgICAgICBleTEgPSBocHRzWzFdO1xuICAgICAgICAgICAgZXgyID0gaHB0c1syXTtcbiAgICAgICAgICAgIGV5MiA9IGhwdHNbM107XG5cbiAgICAgICAgICAgIGlmKCBleDEgPiBleDIgKXtcbiAgICAgICAgICAgICAgdmFyIHRlbXAgPSBleDE7XG4gICAgICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICAgICAgZXgyID0gdGVtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIGV5MSA+IGV5MiApe1xuICAgICAgICAgICAgICB2YXIgdGVtcCA9IGV5MTtcbiAgICAgICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgICAgICBleTIgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4MSA9IGV4MSA8IHgxID8gZXgxIDogeDE7XG4gICAgICAgICAgICB4MiA9IGV4MiA+IHgyID8gZXgyIDogeDI7XG4gICAgICAgICAgICB5MSA9IGV5MSA8IHkxID8gZXkxIDogeTE7XG4gICAgICAgICAgICB5MiA9IGV5MiA+IHkyID8gZXkyIDogeTI7ICBcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSAvLyBlZGdlc1xuICAgICAgICAgICAgXG5cbiAgICAgICAgLy8gaGFuZGxlIGxhYmVsIGRpbWVuc2lvbnNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICBpZiggc3R5bGVFbmFibGVkICl7XG5cbiAgICAgICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgICAgdmFyIHJzdHlsZSA9IGVsZS5fcHJpdmF0ZS5yc3R5bGU7XG4gICAgICAgICAgdmFyIGxhYmVsID0gc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcbiAgICAgICAgICB2YXIgZm9udFNpemUgPSBzdHlsZVsnZm9udC1zaXplJ107XG4gICAgICAgICAgdmFyIGhhbGlnbiA9IHN0eWxlWyd0ZXh0LWhhbGlnbiddO1xuICAgICAgICAgIHZhciB2YWxpZ24gPSBzdHlsZVsndGV4dC12YWxpZ24nXTtcbiAgICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJzdHlsZS5sYWJlbFdpZHRoO1xuICAgICAgICAgIHZhciBsYWJlbEhlaWdodCA9IHJzdHlsZS5sYWJlbEhlaWdodDtcbiAgICAgICAgICB2YXIgbGFiZWxYID0gcnN0eWxlLmxhYmVsWDtcbiAgICAgICAgICB2YXIgbGFiZWxZID0gcnN0eWxlLmxhYmVsWTtcblxuICAgICAgICAgIGlmKCBpbmNsdWRlZEVsZSAmJiBpbmNsdWRlTGFiZWxzICYmIGxhYmVsICYmIGZvbnRTaXplICYmIGxhYmVsSGVpZ2h0ICE9IG51bGwgJiYgbGFiZWxXaWR0aCAhPSBudWxsICYmIGxhYmVsWCAhPSBudWxsICYmIGxhYmVsWSAhPSBudWxsICYmIGhhbGlnbiAmJiB2YWxpZ24gKXtcbiAgICAgICAgICAgIHZhciBsaCA9IGxhYmVsSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGx3ID0gbGFiZWxXaWR0aDtcbiAgICAgICAgICAgIHZhciBseDEsIGx4MiwgbHkxLCBseTI7XG5cbiAgICAgICAgICAgIGlmKCBlbGUuaXNFZGdlKCkgKXtcbiAgICAgICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHcvMjtcbiAgICAgICAgICAgICAgbHgyID0gbGFiZWxYICsgbHcvMjtcbiAgICAgICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGgvMjtcbiAgICAgICAgICAgICAgbHkyID0gbGFiZWxZICsgbGgvMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN3aXRjaCggaGFsaWduLnZhbHVlICl7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICBseDEgPSBsYWJlbFggLSBsdztcbiAgICAgICAgICAgICAgICAgIGx4MiA9IGxhYmVsWDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3LzI7XG4gICAgICAgICAgICAgICAgICBseDIgPSBsYWJlbFggKyBsdy8yO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICBseDEgPSBsYWJlbFg7XG4gICAgICAgICAgICAgICAgICBseDIgPSBsYWJlbFggKyBsdztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3dpdGNoKCB2YWxpZ24udmFsdWUgKXtcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGg7XG4gICAgICAgICAgICAgICAgICBseTIgPSBsYWJlbFk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaC8yO1xuICAgICAgICAgICAgICAgICAgbHkyID0gbGFiZWxZICsgbGgvMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgIGx5MSA9IGxhYmVsWTtcbiAgICAgICAgICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeDEgPSBseDEgPCB4MSA/IGx4MSA6IHgxO1xuICAgICAgICAgICAgeDIgPSBseDIgPiB4MiA/IGx4MiA6IHgyO1xuICAgICAgICAgICAgeTEgPSBseTEgPCB5MSA/IGx5MSA6IHkxO1xuICAgICAgICAgICAgeTIgPSBseTIgPiB5MiA/IGx5MiA6IHkyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBzdHlsZSBlbmFibGVkXG4gICAgICB9IC8vIGZvclxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHc6IHgyIC0geDEsXG4gICAgICAgIGg6IHkyIC0geTFcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gIHZhciBmbiA9ICQkLmVsZXNmbjtcbiAgZm4uYXR0ciA9IGZuLmRhdGE7XG4gIGZuLnJlbW92ZUF0dHIgPSBmbi5yZW1vdmVEYXRhO1xuICBmbi5tb2RlbFBvc2l0aW9uID0gZm4ucG9pbnQgPSBmbi5wb3NpdGlvbjtcbiAgZm4ubW9kZWxQb3NpdGlvbnMgPSBmbi5wb2ludHMgPSBmbi5wb3NpdGlvbnM7XG4gIGZuLnJlbmRlcmVkUG9pbnQgPSBmbi5yZW5kZXJlZFBvc2l0aW9uO1xuICBmbi5yZWxhdGl2ZVBvaW50ID0gZm4ucmVsYXRpdmVQb3NpdGlvbjtcbiAgZm4uYm91bmRpbmdib3ggPSBmbi5ib3VuZGluZ0JveDtcbiAgZm4ucmVuZGVyZWRCb3VuZGluZ2JveCA9IGZuLnJlbmRlcmVkQm91bmRpbmdCb3g7XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbiggJCQgKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gUmVndWxhciBkZWdyZWUgZnVuY3Rpb25zICh3b3JrcyBvbiBzaW5nbGUgZWxlbWVudClcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgZnVuY3Rpb24gZGVmaW5lRGVncmVlRnVuY3Rpb24oY2FsbGJhY2spe1xuICAgIHJldHVybiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmKCBpbmNsdWRlTG9vcHMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICBpbmNsdWRlTG9vcHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggc2VsZi5sZW5ndGggPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgICAgIGlmKCBzZWxmLmlzTm9kZSgpICYmICFzZWxmLnJlbW92ZWQoKSApe1xuICAgICAgICB2YXIgZGVncmVlID0gMDtcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxmWzBdO1xuICAgICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2ldO1xuXG4gICAgICAgICAgaWYoICFpbmNsdWRlTG9vcHMgJiYgZWRnZS5pc0xvb3AoKSApe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVncmVlICs9IGNhbGxiYWNrKCBub2RlLCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBkZWdyZWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbihub2RlLCBlZGdlKXtcbiAgICAgIGlmKCBlZGdlLnNvdXJjZSgpLnNhbWUoIGVkZ2UudGFyZ2V0KCkgKSApe1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH0pLFxuXG4gICAgaW5kZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uKG5vZGUsIGVkZ2Upe1xuICAgICAgaWYoIGVkZ2UudGFyZ2V0KCkuc2FtZShub2RlKSApe1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0pLFxuXG4gICAgb3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbihub2RlLCBlZGdlKXtcbiAgICAgIGlmKCBlZGdlLnNvdXJjZSgpLnNhbWUobm9kZSkgKXtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9KVxuICB9KTtcbiAgXG4gIFxuICAvLyBDb2xsZWN0aW9uIGRlZ3JlZSBzdGF0c1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICBmdW5jdGlvbiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbihkZWdyZWVGbiwgY2FsbGJhY2spe1xuICAgIHJldHVybiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgICB2YXIgcmV0O1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIGRlZ3JlZSA9IGVsZVtkZWdyZWVGbl0oIGluY2x1ZGVMb29wcyApO1xuICAgICAgICBpZiggZGVncmVlICE9PSB1bmRlZmluZWQgJiYgKHJldCA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrKGRlZ3JlZSwgcmV0KSkgKXtcbiAgICAgICAgICByZXQgPSBkZWdyZWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9XG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICBtaW5EZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICAgIH0pLFxuXG4gICAgbWF4RGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtYXgpe1xuICAgICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgICB9KSxcblxuICAgIG1pbkluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICAgIH0pLFxuXG4gICAgbWF4SW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uKGRlZ3JlZSwgbWF4KXtcbiAgICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gICAgfSksXG5cbiAgICBtaW5PdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdvdXRkZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICAgIH0pLFxuXG4gICAgbWF4T3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtYXgpe1xuICAgICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgICB9KVxuICB9KTtcbiAgXG4gICQkLmZuLmVsZXMoe1xuICAgIHRvdGFsRGVncmVlOiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHRvdGFsICs9IG5vZGVzW2ldLmRlZ3JlZSggaW5jbHVkZUxvb3BzICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuICBcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAvLyBGdW5jdGlvbnMgZm9yIGJpbmRpbmcgJiB0cmlnZ2VyaW5nIGV2ZW50c1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICBvbjogJCQuZGVmaW5lLm9uKCksIC8vIC5vbiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBkYXRhXSwgaGFuZGxlcilcbiAgICBvbmU6ICQkLmRlZmluZS5vbih7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSksXG4gICAgb25jZTogJCQuZGVmaW5lLm9uKHsgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogdHJ1ZSB9KSxcbiAgICBvZmY6ICQkLmRlZmluZS5vZmYoKSwgLy8gLm9mZiggZXZlbnRzIFssIHNlbGVjdG9yXSBbLCBoYW5kbGVyXSApXG4gICAgdHJpZ2dlcjogJCQuZGVmaW5lLnRyaWdnZXIoKSwgLy8gLnRyaWdnZXIoIGV2ZW50cyBbLCBleHRyYVBhcmFtc10gKVxuXG4gICAgcnRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50LCBleHRyYVBhcmFtcyl7IC8vIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgaWYoIHRoaXMubGVuZ3RoID09PSAwICl7IHJldHVybjsgfSAvLyBlbXB0eSBjb2xsZWN0aW9ucyBkb24ndCBuZWVkIHRvIG5vdGlmeSBhbnl0aGluZ1xuXG4gICAgICAvLyBub3RpZnkgcmVuZGVyZXJcbiAgICAgIHRoaXMuY3koKS5ub3RpZnkoe1xuICAgICAgICB0eXBlOiBldmVudCxcbiAgICAgICAgY29sbGVjdGlvbjogdGhpc1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHRoaXMudHJpZ2dlcihldmVudCwgZXh0cmFQYXJhbXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcblxuICAvLyBhbGlhc2VzOlxuICAkJC5kZWZpbmUuZXZlbnRBbGlhc2VzT24oICQkLmVsZXNmbiApO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5lbGVzKHtcbiAgICBub2RlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmlzTm9kZSgpO1xuICAgICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuXG4gICAgZWRnZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xuICAgICAgICByZXR1cm4gZWxlbWVudC5pc0VkZ2UoKTtcbiAgICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIGZpbHRlcjogZnVuY3Rpb24oIGZpbHRlciApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIFxuICAgICAgaWYoICQkLmlzLmZuKGZpbHRlcikgKXtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICBpZiggZmlsdGVyLmFwcGx5KGVsZSwgW2ksIGVsZV0pICl7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oY3ksIGVsZW1lbnRzKTtcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcoZmlsdGVyKSB8fCAkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKGZpbHRlcikgKXtcbiAgICAgICAgcmV0dXJuIG5ldyAkJC5TZWxlY3RvcihmaWx0ZXIpLmZpbHRlcih0aGlzKTtcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmKCBmaWx0ZXIgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSApOyAvLyBpZiBub3QgaGFuZGxlZCBieSBhYm92ZSwgZ2l2ZSAnZW0gYW4gZW1wdHkgY29sbGVjdGlvblxuICAgIH0sXG5cbiAgICBub3Q6IGZ1bmN0aW9uKCB0b1JlbW92ZSApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgaWYoICF0b1JlbW92ZSApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICBcbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyggdG9SZW1vdmUgKSApe1xuICAgICAgICAgIHRvUmVtb3ZlID0gdGhpcy5maWx0ZXIoIHRvUmVtb3ZlICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgdmFyIHJlbW92ZSA9IHRvUmVtb3ZlLl9wcml2YXRlLmlkc1sgZWxlbWVudC5pZCgpIF07XG4gICAgICAgICAgaWYoICFyZW1vdmUgKXtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZW1lbnQgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzICk7XG4gICAgICB9XG4gICAgICBcbiAgICB9LFxuXG4gICAgYWJzb2x1dGVDb21wbGVtZW50OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgcmV0dXJuIGN5LmVsZW1lbnRzKCkubm90KCB0aGlzICk7XG4gICAgfSxcblxuICAgIGludGVyc2VjdDogZnVuY3Rpb24oIG90aGVyICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgXG4gICAgICAvLyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZCwgdGhlbiBmaWx0ZXIgYnkgaXQgaW5zdGVhZFxuICAgICAgaWYoICQkLmlzLnN0cmluZyhvdGhlcikgKXtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gb3RoZXI7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgICB2YXIgY29sMiA9IG90aGVyO1xuICAgICAgdmFyIGNvbDFTbWFsbGVyID0gdGhpcy5sZW5ndGggPCBvdGhlci5sZW5ndGg7XG4gICAgICAvLyB2YXIgaWRzMSA9IGNvbDFTbWFsbGVyID8gY29sMS5fcHJpdmF0ZS5pZHMgOiBjb2wyLl9wcml2YXRlLmlkcztcbiAgICAgIHZhciBpZHMyID0gY29sMVNtYWxsZXIgPyBjb2wyLl9wcml2YXRlLmlkcyA6IGNvbDEuX3ByaXZhdGUuaWRzO1xuICAgICAgdmFyIGNvbCA9IGNvbDFTbWFsbGVyID8gY29sMSA6IGNvbDI7XG4gICAgICBcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBpZCA9IGNvbFtpXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgZWxlID0gaWRzMlsgaWQgXTtcblxuICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZWxlbWVudHMgKTtcbiAgICB9LFxuXG4gICAgeG9yOiBmdW5jdGlvbiggb3RoZXIgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcob3RoZXIpICl7XG4gICAgICAgIG90aGVyID0gY3kuJCggb3RoZXIgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgICB2YXIgY29sMiA9IG90aGVyO1xuICAgICAgXG4gICAgICB2YXIgYWRkID0gZnVuY3Rpb24oIGNvbCwgb3RoZXIgKXtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBjb2xbaV07XG4gICAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5fcHJpdmF0ZS5pZHNbIGlkIF07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoICFpbk90aGVyICl7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfTtcblxuICAgICAgYWRkKCBjb2wxLCBjb2wyICk7XG4gICAgICBhZGQoIGNvbDIsIGNvbDEgKTtcblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZWxlbWVudHMgKTtcbiAgICB9LCAgXG5cbiAgICBkaWZmOiBmdW5jdGlvbiggb3RoZXIgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcob3RoZXIpICl7XG4gICAgICAgIG90aGVyID0gY3kuJCggb3RoZXIgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSBbXTtcbiAgICAgIHZhciByaWdodCA9IFtdO1xuICAgICAgdmFyIGJvdGggPSBbXTtcbiAgICAgIHZhciBjb2wxID0gdGhpcztcbiAgICAgIHZhciBjb2wyID0gb3RoZXI7XG5cbiAgICAgIHZhciBhZGQgPSBmdW5jdGlvbiggY29sLCBvdGhlciwgcmV0RWxlcyApe1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgICB2YXIgaW5PdGhlciA9IG90aGVyLl9wcml2YXRlLmlkc1sgaWQgXTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggaW5PdGhlciApe1xuICAgICAgICAgICAgYm90aC5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0RWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfTtcblxuICAgICAgYWRkKCBjb2wxLCBjb2wyLCBsZWZ0ICk7XG4gICAgICBhZGQoIGNvbDIsIGNvbDEsIHJpZ2h0ICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgbGVmdCwgeyB1bmlxdWU6IHRydWUgfSApLFxuICAgICAgICByaWdodDogbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCByaWdodCwgeyB1bmlxdWU6IHRydWUgfSApLFxuICAgICAgICBib3RoOiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGJvdGgsIHsgdW5pcXVlOiB0cnVlIH0gKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgYWRkOiBmdW5jdGlvbiggdG9BZGQgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7ICAgIFxuICAgICAgXG4gICAgICBpZiggIXRvQWRkICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKHRvQWRkKSApe1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgICAgdG9BZGQgPSBjeS5lbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgZWxlbWVudHMucHVzaCggdGhpc1tpXSApO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrICl7XG5cbiAgICAgICAgdmFyIGFkZCA9ICF0aGlzLl9wcml2YXRlLmlkc1sgdG9BZGRbaV0uaWQoKSBdO1xuICAgICAgICBpZiggYWRkICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggdG9BZGRbaV0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oY3ksIGVsZW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gaW4gcGxhY2UgbWVyZ2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKCB0b0FkZCApe1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciBjeSA9IF9wLmN5OyAgICBcbiAgICAgIFxuICAgICAgaWYoICF0b0FkZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoICQkLmlzLnN0cmluZyh0b0FkZCkgKXtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICAgIHRvQWRkID0gY3kuZWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB0b0FkZEVsZSA9IHRvQWRkW2ldO1xuICAgICAgICB2YXIgaWQgPSB0b0FkZEVsZS5pZCgpO1xuICAgICAgICB2YXIgYWRkID0gIV9wLmlkc1sgaWQgXTtcblxuICAgICAgICBpZiggYWRkICl7XG4gICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sZW5ndGgrKztcblxuICAgICAgICAgIHRoaXNbIGluZGV4IF0gPSB0b0FkZEVsZTtcbiAgICAgICAgICBfcC5pZHNbIGlkIF0gPSB0b0FkZEVsZTtcbiAgICAgICAgICBfcC5pbmRleGVzWyBpZCBdID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIHJlbW92ZSBzaW5nbGUgZWxlIGluIHBsYWNlIGluIGNhbGxpbmcgY29sbGVjdGlvblxuICAgIHVubWVyZ2VPbmU6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIGVsZSA9IGVsZVswXTtcblxuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIGkgPSBfcC5pbmRleGVzWyBpZCBdO1xuXG4gICAgICBpZiggaSA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBubyBuZWVkIHRvIHJlbW92ZVxuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgZWxlXG4gICAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgX3AuaWRzWyBpZCBdID0gdW5kZWZpbmVkO1xuICAgICAgX3AuaW5kZXhlc1sgaWQgXSA9IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIHVubWVyZ2VkTGFzdEVsZSA9IGkgPT09IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgICAgLy8gcmVwbGFjZSBlbXB0eSBzcG90IHdpdGggbGFzdCBlbGUgaW4gY29sbGVjdGlvblxuICAgICAgaWYoIHRoaXMubGVuZ3RoID4gMSAmJiAhdW5tZXJnZWRMYXN0RWxlICl7XG4gICAgICAgIHZhciBsYXN0RWxlSSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGxhc3RFbGUgPSB0aGlzWyBsYXN0RWxlSSBdO1xuXG4gICAgICAgIHRoaXNbIGxhc3RFbGVJIF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNbaV0gPSBsYXN0RWxlO1xuICAgICAgICBfcC5pbmRleGVzWyBsYXN0RWxlLmlkKCkgXSA9IGk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBjb2xsZWN0aW9uIGlzIG5vdyAxIGVsZSBzbWFsbGVyXG4gICAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gcmVtb3ZlIGVsZXMgaW4gcGxhY2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gICAgdW5tZXJnZTogZnVuY3Rpb24oIHRvUmVtb3ZlICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5OyAgICBcbiAgICAgIFxuICAgICAgaWYoICF0b1JlbW92ZSApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYoICQkLmlzLnN0cmluZyh0b1JlbW92ZSkgKXtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdG9SZW1vdmU7XG4gICAgICAgIHRvUmVtb3ZlID0gY3kuZWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHRoaXMudW5tZXJnZU9uZSggdG9SZW1vdmVbaV0gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIG1hcDogZnVuY3Rpb24oIG1hcEZuLCB0aGlzQXJnICl7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBtYXBGbi5hcHBseSggdGhpc0FyZywgW2VsZSwgaSwgZWxlc10gKSA6IG1hcEZuKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgICBhcnIucHVzaCggcmV0ICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHN0ZEZpbHRlcjogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgICB2YXIgZmlsdGVyRWxlcyA9IFtdO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgaW5jbHVkZSA9IHRoaXNBcmcgPyBmbi5hcHBseSggdGhpc0FyZywgW2VsZSwgaSwgZWxlc10gKSA6IGZuKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgICBpZiggaW5jbHVkZSApe1xuICAgICAgICAgIGZpbHRlckVsZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZmlsdGVyRWxlcyApO1xuICAgIH0sXG5cbiAgICBtYXg6IGZ1bmN0aW9uKCB2YWxGbiwgdGhpc0FyZyApe1xuICAgICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICAgIHZhciBtYXhFbGU7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApIDogdmFsRm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICAgIGlmKCB2YWwgPiBtYXggKXtcbiAgICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgICAgbWF4RWxlID0gZWxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBtYXgsXG4gICAgICAgIGVsZTogbWF4RWxlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBtaW46IGZ1bmN0aW9uKCB2YWxGbiwgdGhpc0FyZyApe1xuICAgICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgICAgdmFyIG1pbkVsZTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgdmFsID0gdGhpc0FyZyA/IHZhbEZuLmFwcGx5KCB0aGlzQXJnLCBbIGVsZSwgaSwgZWxlcyBdICkgOiB2YWxGbiggZWxlLCBpLCBlbGVzICk7XG5cbiAgICAgICAgaWYoIHZhbCA8IG1pbiApe1xuICAgICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgICBtaW5FbGUgPSBlbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG1pbixcbiAgICAgICAgZWxlOiBtaW5FbGVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gIHZhciBmbiA9ICQkLmVsZXNmbjtcbiAgZm5bJ3UnXSA9IGZuWyd8J10gPSBmblsnKyddID0gZm4udW5pb24gPSBmbi5vciA9IGZuLmFkZDtcbiAgZm5bJ1xcXFwnXSA9IGZuWychJ10gPSBmblsnLSddID0gZm4uZGlmZmVyZW5jZSA9IGZuLnJlbGF0aXZlQ29tcGxlbWVudCA9IGZuLm5vdDtcbiAgZm5bJ24nXSA9IGZuWycmJ10gPSBmblsnLiddID0gZm4uYW5kID0gZm4uaW50ZXJzZWN0aW9uID0gZm4uaW50ZXJzZWN0O1xuICBmblsnXiddID0gZm5bJygrKSddID0gZm5bJygtKSddID0gZm4uc3ltbWV0cmljRGlmZmVyZW5jZSA9IGZuLnN5bWRpZmYgPSBmbi54b3I7XG4gIGZuLmZuRmlsdGVyID0gZm4uZmlsdGVyRm4gPSBmbi5zdGRGaWx0ZXI7XG4gIGZuLmNvbXBsZW1lbnQgPSBmbi5hYnNjb21wID0gZm4uYWJzb2x1dGVDb21wbGVtZW50O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgaXNOb2RlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ25vZGVzJztcbiAgICB9LFxuXG4gICAgaXNFZGdlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ2VkZ2VzJztcbiAgICB9LFxuXG4gICAgaXNMb29wOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKS5pZCgpID09PSB0aGlzLnRhcmdldCgpLmlkKCk7XG4gICAgfSxcblxuICAgIGlzU2ltcGxlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKS5pZCgpICE9PSB0aGlzLnRhcmdldCgpLmlkKCk7XG4gICAgfSxcblxuICAgIGdyb3VwOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gRnVuY3Rpb25zIGZvciBpdGVyYXRpbmcgb3ZlciBjb2xsZWN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICBlYWNoOiBmdW5jdGlvbihmbil7XG4gICAgICBpZiggJCQuaXMuZm4oZm4pICl7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgcmV0ID0gZm4uYXBwbHkoIGVsZSwgWyBpLCBlbGUgXSApO1xuXG4gICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXsgYnJlYWs7IH0gLy8gZXhpdCBlYWNoIGVhcmx5IG9uIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oZm4sIHRoaXNBcmcpe1xuICAgICAgaWYoICQkLmlzLmZuKGZuKSApe1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IGZuLmFwcGx5KCB0aGlzQXJnLCBbIGVsZSwgaSwgdGhpcyBdICkgOiBmbiggZWxlLCBpLCB0aGlzICk7XG5cbiAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApeyBicmVhazsgfSAvLyBleGl0IGVhY2ggZWFybHkgb24gcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgIFxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBhcnJheS5wdXNoKCB0aGlzW2ldICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpe1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICB2YXIgdGhpc1NpemUgPSB0aGlzLmxlbmd0aDtcbiAgICAgIFxuICAgICAgaWYoIGVuZCA9PSBudWxsICl7XG4gICAgICAgIGVuZCA9IHRoaXNTaXplO1xuICAgICAgfVxuXG4gICAgICBpZiggc3RhcnQgPT0gbnVsbCApe1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBzdGFydCA8IDAgKXtcbiAgICAgICAgc3RhcnQgPSB0aGlzU2l6ZSArIHN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiggZW5kIDwgMCApe1xuICAgICAgICBlbmQgPSB0aGlzU2l6ZSArIGVuZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm9yKHZhciBpID0gc3RhcnQ7IGkgPj0gMCAmJiBpIDwgZW5kICYmIGkgPCB0aGlzU2l6ZTsgaSsrKXtcbiAgICAgICAgYXJyYXkucHVzaCggdGhpc1tpXSApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24odGhpcy5jeSgpLCBhcnJheSk7XG4gICAgfSxcblxuICAgIHNpemU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIGVxOiBmdW5jdGlvbihpKXtcbiAgICAgIHJldHVybiB0aGlzW2ldIHx8IG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCkgKTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpc1swXSB8fCBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpICk7XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpc1sgdGhpcy5sZW5ndGggLSAxIF0gfHwgbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuY3koKSApO1xuICAgIH0sXG5cbiAgICBlbXB0eTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcbiAgICB9LFxuXG4gICAgbm9uZW1wdHk6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gIXRoaXMuZW1wdHkoKTtcbiAgICB9LFxuXG4gICAgc29ydDogZnVuY3Rpb24oIHNvcnRGbiApe1xuICAgICAgaWYoICEkJC5pcy5mbiggc29ydEZuICkgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTsgICAgICBcbiAgICAgIHZhciBzb3J0ZWQgPSB0aGlzLnRvQXJyYXkoKS5zb3J0KCBzb3J0Rm4gKTtcblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBzb3J0ZWQpO1xuICAgIH0sXG5cbiAgICBzb3J0QnlaSW5kZXg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5zb3J0KCAkJC5Db2xsZWN0aW9uLnpJbmRleFNvcnQgKTtcbiAgICB9LFxuXG4gICAgekRlcHRoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICBpZiggIWVsZSApeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICAgIC8vIHZhciBjeSA9IGVsZS5jeSgpO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIGdyb3VwID0gX3AuZ3JvdXA7XG5cbiAgICAgIGlmKCBncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICB2YXIgZGVwdGggPSBfcC5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkuc2l6ZSgpIDogMDtcbiAgICAgICAgXG4gICAgICAgIGlmKCAhZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTsgLy8gY2hpbGRsZXNzIG5vZGVzIGFsd2F5cyBvbiB0b3BcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgICAgdmFyIHNyY0RlcHRoID0gc3JjLnpEZXB0aCgpO1xuICAgICAgICB2YXIgdGd0RGVwdGggPSB0Z3QuekRlcHRoKCk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KCBzcmNEZXB0aCwgdGd0RGVwdGgsIDAgKTsgLy8gZGVwdGggb2YgZGVlcGVzdCBwYXJlbnRcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gICQkLkNvbGxlY3Rpb24uekluZGV4U29ydCA9IGZ1bmN0aW9uKGEsIGIpe1xuICAgIHZhciBjeSA9IGEuY3koKTtcbiAgICB2YXIgYV9wID0gYS5fcHJpdmF0ZTtcbiAgICB2YXIgYl9wID0gYi5fcHJpdmF0ZTtcbiAgICB2YXIgekRpZmYgPSBhX3Auc3R5bGVbJ3otaW5kZXgnXS52YWx1ZSAtIGJfcC5zdHlsZVsnei1pbmRleCddLnZhbHVlO1xuICAgIHZhciBkZXB0aEEgPSAwO1xuICAgIHZhciBkZXB0aEIgPSAwO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBhSXNOb2RlID0gYV9wLmdyb3VwID09PSAnbm9kZXMnO1xuICAgIHZhciBhSXNFZGdlID0gYV9wLmdyb3VwID09PSAnZWRnZXMnO1xuICAgIHZhciBiSXNOb2RlID0gYl9wLmdyb3VwID09PSAnbm9kZXMnO1xuICAgIHZhciBiSXNFZGdlID0gYl9wLmdyb3VwID09PSAnZWRnZXMnO1xuXG4gICAgLy8gbm8gbmVlZCB0byBjYWxjdWxhdGUgZWxlbWVudCBkZXB0aCBpZiB0aGVyZSBpcyBubyBjb21wb3VuZCBub2RlXG4gICAgaWYoIGhhc0NvbXBvdW5kTm9kZXMgKXtcbiAgICAgIGRlcHRoQSA9IGEuekRlcHRoKCk7XG4gICAgICBkZXB0aEIgPSBiLnpEZXB0aCgpO1xuICAgIH1cblxuICAgIHZhciBkZXB0aERpZmYgPSBkZXB0aEEgLSBkZXB0aEI7XG4gICAgdmFyIHNhbWVEZXB0aCA9IGRlcHRoRGlmZiA9PT0gMDtcblxuICAgIGlmKCBzYW1lRGVwdGggKXtcbiAgICAgIFxuICAgICAgaWYoIGFJc05vZGUgJiYgYklzRWRnZSApeyAgICAgIFxuICAgICAgICByZXR1cm4gMTsgLy8gJ2EnIGlzIGEgbm9kZSwgaXQgc2hvdWxkIGJlIGRyYXduIGxhdGVyICAgICAgIFxuICAgICAgXG4gICAgICB9IGVsc2UgaWYoIGFJc0VkZ2UgJiYgYklzTm9kZSApe1xuICAgICAgICByZXR1cm4gLTE7IC8vICdhJyBpcyBhbiBlZGdlLCBpdCBzaG91bGQgYmUgZHJhd24gZmlyc3RcblxuICAgICAgfSBlbHNlIHsgLy8gYm90aCBub2RlcyBvciBib3RoIGVkZ2VzICAgICAgICBcbiAgICAgICAgaWYoIHpEaWZmID09PSAwICl7IC8vIHNhbWUgei1pbmRleCA9PiBjb21wYXJlIGluZGljZXMgaW4gdGhlIGNvcmUgKG9yZGVyIGFkZGVkIHRvIGdyYXBoIHcvIGxhc3Qgb24gdG9wKVxuICAgICAgICAgIHJldHVybiBhX3AuaW5kZXggLSBiX3AuaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHpEaWZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXG4gICAgLy8gZWxlbWVudHMgb24gZGlmZmVyZW50IGxldmVsXG4gICAgfSBlbHNlIHsgICAgICBcbiAgICAgIHJldHVybiBkZXB0aERpZmY7IC8vIGRlZXBlciBlbGVtZW50IHNob3VsZCBiZSBkcmF3biBsYXRlclxuICAgIH1cblxuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIEZ1bmN0aW9ucyBmb3IgbGF5b3V0cyBvbiBub2Rlc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAkJC5mbi5lbGVzKHtcblxuICAgIC8vIHVzaW5nIHN0YW5kYXJkIGxheW91dCBvcHRpb25zLCBhcHBseSBwb3NpdGlvbiBmdW5jdGlvbiAody8gb3Igdy9vIGFuaW1hdGlvbilcbiAgICBsYXlvdXRQb3NpdGlvbnM6IGZ1bmN0aW9uKCBsYXlvdXQsIG9wdGlvbnMsIGZuICl7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIGxhc3ROb2RlID0gaSA9PT0gbm9kZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgIHZhciBuZXdQb3MgPSBmbi5jYWxsKCBub2RlLCBpLCBub2RlICk7XG4gICAgICAgICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgICAgICAgIGlmKCAhJCQuaXMubnVtYmVyKHBvcy54KSB8fCAhJCQuaXMubnVtYmVyKHBvcy55KSApe1xuICAgICAgICAgICAgbm9kZS5zaWxlbnRQb3NpdGlvbih7IHg6IDAsIHk6IDAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZS5hbmltYXRlKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdQb3NcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIHN0ZXA6ICFsYXN0Tm9kZSA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogIWxhc3ROb2RlID8gdW5kZWZpbmVkIDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgaWYoIG9wdGlvbnMuem9vbSAhPSBudWxsICl7XG4gICAgICAgICAgICAgICAgY3kuem9vbSggb3B0aW9ucy56b29tICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiggb3B0aW9ucy5wYW4gKXtcbiAgICAgICAgICAgICAgICBjeS5wYW4oIG9wdGlvbnMucGFuICk7XG4gICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgICAgICAgY3kuZml0KCBvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2Rlcy5wb3NpdGlvbnMoIGZuICk7XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgY3kuZml0KCBvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuem9vbSAhPSBudWxsICl7XG4gICAgICAgICAgY3kuem9vbSggb3B0aW9ucy56b29tICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggb3B0aW9ucy5wYW4gKXtcbiAgICAgICAgICBjeS5wYW4oIG9wdGlvbnMucGFuICk7XG4gICAgICAgIH0gXG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgICAgXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBsYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGN5LmxheW91dCggJCQudXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgZWxlczogdGhpc1xuICAgICAgfSkgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG1ha2VMYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIHJldHVybiBjeS5tYWtlTGF5b3V0KCAkJC51dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBlbGVzOiB0aGlzXG4gICAgICB9KSApO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBhbGlhc2VzOlxuICAkJC5lbGVzZm4uY3JlYXRlTGF5b3V0ID0gJCQuZWxlc2ZuLm1ha2VMYXlvdXQ7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuXG4gICAgLy8gZnVsbHkgdXBkYXRlcyAocmVjYWxjdWxhdGVzKSB0aGUgc3R5bGUgZm9yIHRoZSBlbGVtZW50c1xuICAgIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgaWYoIGN5Ll9wcml2YXRlLmJhdGNoaW5nU3R5bGUgKXtcbiAgICAgICAgdmFyIGJFbGVzID0gY3kuX3ByaXZhdGUuYmF0Y2hTdHlsZUVsZXM7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICBpZiggIWJFbGVzLmlkc1sgZWxlLl9wcml2YXRlLmlkIF0gKXtcbiAgICAgICAgICAgIGJFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZyBhbmQgZXhpdCBlYXJseSB3aGVuIGJhdGNoaW5nXG4gICAgICB9XG5cbiAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgIHN0eWxlLmFwcGx5KCB0aGlzICk7XG5cbiAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG5cbiAgICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9Ob3RpZnkudHJpZ2dlcignc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIGp1c3QgdXBkYXRlIHRoZSBtYXBwZXJzIGluIHRoZSBlbGVtZW50cycgc3R5bGVzOyBjaGVhcGVyIHRoYW4gZWxlcy51cGRhdGVTdHlsZSgpXG4gICAgdXBkYXRlTWFwcGVyczogZnVuY3Rpb24oIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIG5vdGlmeVJlbmRlcmVyID0gbm90aWZ5UmVuZGVyZXIgfHwgbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBzdHlsZS51cGRhdGVNYXBwZXJzKCB0aGlzICk7XG5cbiAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG5cbiAgICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9Ob3RpZnkudHJpZ2dlcignc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIGdldCB0aGUgc3BlY2lmaWVkIGNzcyBwcm9wZXJ0eSBhcyBhIHJlbmRlcmVkIHZhbHVlIChpLmUuIG9uLXNjcmVlbiB2YWx1ZSlcbiAgICAvLyBvciBnZXQgdGhlIHdob2xlIHJlbmRlcmVkIHN0eWxlIGlmIG5vIHByb3BlcnR5IHNwZWNpZmllZCAoTkIgZG9lc24ndCBhbGxvdyBzZXR0aW5nKVxuICAgIHJlbmRlcmVkQ3NzOiBmdW5jdGlvbiggcHJvcGVydHkgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgdmFyIHJlbnN0eWxlID0gZWxlLmN5KCkuc3R5bGUoKS5nZXRSZW5kZXJlZFN0eWxlKCBlbGUgKTtcblxuICAgICAgICBpZiggcHJvcGVydHkgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHJldHVybiByZW5zdHlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVuc3R5bGVbIHByb3BlcnR5IF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcmVhZCB0aGUgY2FsY3VsYXRlZCBjc3Mgc3R5bGUgb2YgdGhlIGVsZW1lbnQgb3Igb3ZlcnJpZGUgdGhlIHN0eWxlICh2aWEgYSBieXBhc3MpXG4gICAgY3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIFxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG5cbiAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChuYW1lKSApeyAvLyB0aGVuIGV4dGVuZCB0aGUgYnlwYXNzXG4gICAgICAgIHZhciBwcm9wcyA9IG5hbWU7XG4gICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKCB0aGlzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMgKTtcblxuICAgICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG4gICAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhuYW1lKSApe1xuICBcbiAgICAgICAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLnN0eWxlWyBuYW1lIF0uc3RyVmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gc2V0IHRoZSBieXBhc3Mgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICBzdHlsZS5hcHBseUJ5cGFzcyggdGhpcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG5cbiAgICAgICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICAgICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYoIG5hbWUgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlLmdldFJhd1N0eWxlKCBlbGUgKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICByZW1vdmVDc3M6IGZ1bmN0aW9uKCBuYW1lcyApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgaWYoIG5hbWVzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICBzdHlsZS5yZW1vdmVBbGxCeXBhc3NlcyggZWxlLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lcyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICBzdHlsZS5yZW1vdmVCeXBhc3NlcyggZWxlLCBuYW1lcywgdXBkYXRlVHJhbnNpdGlvbnMgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgIHZhciB0b05vdGlmeSA9IHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkQ29tcG91bmRzICkgOiB0aGlzO1xuICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnZWxlbWVudCcpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgdmlzaWJsZTogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgc3R5bGVbJ3Zpc2liaWxpdHknXS52YWx1ZSAhPT0gJ3Zpc2libGUnXG4gICAgICAgICAgfHwgc3R5bGVbJ2Rpc3BsYXknXS52YWx1ZSAhPT0gJ2VsZW1lbnQnXG4gICAgICAgICl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgICAgaWYoICFoYXNDb21wb3VuZE5vZGVzICl7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgICB2YXIgcGFyZW50cyA9IGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkgOiBudWxsO1xuXG4gICAgICAgICAgaWYoIHBhcmVudHMgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tpXTtcbiAgICAgICAgICAgICAgdmFyIHBTdHlsZSA9IHBhcmVudC5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgICAgICAgICAgdmFyIHBWaXMgPSBwU3R5bGVbJ3Zpc2liaWxpdHknXS52YWx1ZTtcbiAgICAgICAgICAgICAgdmFyIHBEaXMgPSBwU3R5bGVbJ2Rpc3BsYXknXS52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiggcFZpcyAhPT0gJ3Zpc2libGUnIHx8IHBEaXMgIT09ICdlbGVtZW50JyApe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlO1xuICAgICAgICAgIHZhciB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgICAgICAgcmV0dXJuIHNyYy52aXNpYmxlKCkgJiYgdGd0LnZpc2libGUoKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSxcblxuICAgIGhpZGRlbjogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWZmZWN0aXZlT3BhY2l0eTogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIDE7IH1cblxuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gX3Auc3R5bGUub3BhY2l0eS52YWx1ZTtcblxuICAgICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXsgcmV0dXJuIHBhcmVudE9wYWNpdHk7IH1cblxuICAgICAgICB2YXIgcGFyZW50cyA9ICFfcC5kYXRhLnBhcmVudCA/IG51bGwgOiBlbGUucGFyZW50cygpO1xuICAgICAgICBcbiAgICAgICAgaWYoIHBhcmVudHMgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBwYXJlbnQuX3ByaXZhdGUuc3R5bGUub3BhY2l0eS52YWx1ZTtcblxuICAgICAgICAgICAgcGFyZW50T3BhY2l0eSA9IG9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRPcGFjaXR5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFuc3BhcmVudDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgaWYoICFoYXNDb21wb3VuZE5vZGVzICl7XG4gICAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZS5vcGFjaXR5LnZhbHVlID09PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpID09PSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzRnVsbEF1dG9QYXJlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgYXV0b1cgPSBlbGUuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10udmFsdWUgPT09ICdhdXRvJztcbiAgICAgICAgdmFyIGF1dG9IID0gZWxlLl9wcml2YXRlLnN0eWxlWydoZWlnaHQnXS52YWx1ZSA9PT0gJ2F1dG8nO1xuXG4gICAgICAgIHJldHVybiBlbGUuaXNQYXJlbnQoKSAmJiBhdXRvVyAmJiBhdXRvSDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYmFja2dyb3VuZGluZzogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmJhY2tncm91bmRpbmcgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuXG4gIH0pO1xuXG5cbiAgJCQuZWxlc2ZuLmJ5cGFzcyA9ICQkLmVsZXNmbi5zdHlsZSA9ICQkLmVsZXNmbi5jc3M7XG4gICQkLmVsZXNmbi5yZW5kZXJlZFN0eWxlID0gJCQuZWxlc2ZuLnJlbmRlcmVkQ3NzO1xuICAkJC5lbGVzZm4ucmVtb3ZlQnlwYXNzID0gJCQuZWxlc2ZuLnJlbW92ZVN0eWxlID0gJCQuZWxlc2ZuLnJlbW92ZUNzcztcbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gQ29sbGVjdGlvbiBmdW5jdGlvbnMgdGhhdCB0b2dnbGUgYSBib29sZWFuIHZhbHVlXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gIFxuICBmdW5jdGlvbiBkZWZpbmVTd2l0Y2hGdW5jdGlvbihwYXJhbXMpe1xuICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgY2hhbmdlZEVsZXMgPSBbXTtcbiAgICAgIFxuICAgICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggZGF0YSwgaGFuZGxlciApXG4gICAgICBpZiggYXJncy5sZW5ndGggPT09IDIgKXtcbiAgICAgICAgdmFyIGRhdGEgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgICAgIHRoaXMuYmluZCggcGFyYW1zLmV2ZW50LCBkYXRhLCBoYW5kbGVyICk7XG4gICAgICB9IFxuICAgICAgXG4gICAgICAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBoYW5kbGVyIClcbiAgICAgIGVsc2UgaWYoIGFyZ3MubGVuZ3RoID09PSAxICl7XG4gICAgICAgIHZhciBoYW5kbGVyID0gYXJnc1swXTtcbiAgICAgICAgdGhpcy5iaW5kKCBwYXJhbXMuZXZlbnQsIGhhbmRsZXIgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCgpXG4gICAgICBlbHNlIGlmKCBhcmdzLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgYWJsZSA9ICFwYXJhbXMuYWJsZUZpZWxkIHx8IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYWJsZUZpZWxkXTtcbiAgICAgICAgICB2YXIgY2hhbmdlZCA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdICE9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICAgIGlmKCBwYXJhbXMub3ZlcnJpZGVBYmxlICl7XG4gICAgICAgICAgICB2YXIgb3ZlcnJpZGVBYmxlID0gcGFyYW1zLm92ZXJyaWRlQWJsZShlbGUpO1xuXG4gICAgICAgICAgICBpZiggb3ZlcnJpZGVBYmxlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgICAgYWJsZSA9IG92ZXJyaWRlQWJsZTtcblxuICAgICAgICAgICAgICBpZiggIW92ZXJyaWRlQWJsZSApeyByZXR1cm4gdGhpczsgfSAvLyB0byBzYXZlIGN5Y2xlcyBhc3N1bWUgbm90IGFibGUgZm9yIGFsbCBvbiBvdmVycmlkZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBhYmxlICl7XG4gICAgICAgICAgICBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSA9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICAgICAgaWYoIGNoYW5nZWQgKXtcbiAgICAgICAgICAgICAgY2hhbmdlZEVsZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYW5nZWRDb2xsID0gJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpLCBjaGFuZ2VkRWxlcyApO1xuICAgICAgICBjaGFuZ2VkQ29sbC51cGRhdGVTdHlsZSgpOyAvLyBjaGFuZ2Ugb2Ygc3RhdGUgPT4gcG9zc2libGUgY2hhbmdlIG9mIHN0eWxlXG4gICAgICAgIGNoYW5nZWRDb2xsLnRyaWdnZXIoIHBhcmFtcy5ldmVudCApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG4gIFxuICBmdW5jdGlvbiBkZWZpbmVTd2l0Y2hTZXQoIHBhcmFtcyApe1xuICAgICQkLmVsZXNmblsgcGFyYW1zLmZpZWxkIF0gPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgaWYoIHBhcmFtcy5vdmVycmlkZUZpZWxkICl7XG4gICAgICAgICAgdmFyIHZhbCA9IHBhcmFtcy5vdmVycmlkZUZpZWxkKGVsZSk7XG5cbiAgICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZVsgcGFyYW1zLmZpZWxkIF07XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAkJC5lbGVzZm5bIHBhcmFtcy5vbiBdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgICAgZXZlbnQ6IHBhcmFtcy5vbixcbiAgICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgJCQuZWxlc2ZuWyBwYXJhbXMub2ZmIF0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgICBldmVudDogcGFyYW1zLm9mZixcbiAgICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBcbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ2xvY2tlZCcsXG4gICAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24oZWxlKXtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvbG9jaygpID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG9uOiAnbG9jaycsXG4gICAgb2ZmOiAndW5sb2NrJ1xuICB9KTtcbiAgXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdncmFiYmFibGUnLFxuICAgIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uKGVsZSl7XG4gICAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3VuZ3JhYmlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ2dyYWJpZnknLFxuICAgIG9mZjogJ3VuZ3JhYmlmeSdcbiAgfSk7XG4gIFxuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnc2VsZWN0ZWQnLFxuICAgIGFibGVGaWVsZDogJ3NlbGVjdGFibGUnLFxuICAgIG92ZXJyaWRlQWJsZTogZnVuY3Rpb24oZWxlKXtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb246ICdzZWxlY3QnLFxuICAgIG9mZjogJ3Vuc2VsZWN0J1xuICB9KTtcbiAgXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbihlbGUpe1xuICAgICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ3NlbGVjdGlmeScsXG4gICAgb2ZmOiAndW5zZWxlY3RpZnknXG4gIH0pO1xuXG4gICQkLmVsZXNmbi5kZXNlbGVjdCA9ICQkLmVsZXNmbi51bnNlbGVjdDtcbiAgXG4gICQkLmVsZXNmbi5ncmFiYmVkID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyYWJiZWQ7XG4gICAgfVxuICB9O1xuXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdhY3RpdmUnLFxuICAgIG9uOiAnYWN0aXZhdGUnLFxuICAgIG9mZjogJ3VuYWN0aXZhdGUnXG4gIH0pO1xuXG4gICQkLmVsZXNmbi5pbmFjdGl2ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuICFlbGUuX3ByaXZhdGUuYWN0aXZlO1xuICAgIH1cbiAgfTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gREFHIGZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIC8vIGdldCB0aGUgcm9vdCBub2RlcyBpbiB0aGUgREFHXG4gICAgcm9vdHM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIHJvb3RzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNFZGdlc1BvaW50aW5nSW4gPSBlbGUuY29ubmVjdGVkRWRnZXMoZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCd0YXJnZXQnKSA9PT0gZWxlLmlkKCkgJiYgdGhpcy5kYXRhKCdzb3VyY2UnKSAhPT0gZWxlLmlkKCk7XG4gICAgICAgIH0pLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgaWYoICFoYXNFZGdlc1BvaW50aW5nSW4gKXtcbiAgICAgICAgICByb290cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIHJvb3RzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgdGhlIGxlYWYgbm9kZXMgaW4gdGhlIERBR1xuICAgIGxlYXZlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgbGVhdmVzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNFZGdlc1BvaW50aW5nT3V0ID0gZWxlLmNvbm5lY3RlZEVkZ2VzKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgnc291cmNlJykgPT09IGVsZS5pZCgpICYmIHRoaXMuZGF0YSgndGFyZ2V0JykgIT09IGVsZS5pZCgpO1xuICAgICAgICB9KS5sZW5ndGggPiAwO1xuXG4gICAgICAgIGlmKCAhaGFzRWRnZXNQb2ludGluZ091dCApe1xuICAgICAgICAgIGxlYXZlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIGxlYXZlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgLy8gbm9ybWFsbHkgY2FsbGVkIGNoaWxkcmVuIGluIGdyYXBoIHRoZW9yeVxuICAgIC8vIHRoZXNlIG5vZGVzID1lZGdlcz0+IG91dGdvaW5nIG5vZGVzXG4gICAgb3V0Z29lcnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIG9FbGVzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIGVsZUlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgZWRnZXMgPSBlbGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICAgIHZhciBzcmNJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS5zb3VyY2U7XG4gICAgICAgICAgdmFyIHRndElkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnRhcmdldDtcblxuICAgICAgICAgIGlmKCBzcmNJZCA9PT0gZWxlSWQgJiYgdGd0SWQgIT09IGVsZUlkICl7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlLnRhcmdldCgpWzBdICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgb0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIC8vIGFrYSBEQUcgZGVzY2VuZGFudHNcbiAgICBzdWNjZXNzb3JzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBzRWxlcyA9IFtdO1xuICAgICAgdmFyIHNFbGVzSWRzID0ge307XG5cbiAgICAgIGZvcig7Oyl7XG4gICAgICAgIHZhciBvdXRnb2VycyA9IGVsZXMub3V0Z29lcnMoKTtcblxuICAgICAgICBpZiggb3V0Z29lcnMubGVuZ3RoID09PSAwICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgbm8gb3V0Z29lcnMgbGVmdFxuXG4gICAgICAgIHZhciBuZXdPdXRnb2VycyA9IGZhbHNlO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG91dGdvZXJzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIG91dGdvZXIgPSBvdXRnb2Vyc1tpXTtcbiAgICAgICAgICB2YXIgb3V0Z29lcklkID0gb3V0Z29lci5pZCgpO1xuXG4gICAgICAgICAgaWYoICFzRWxlc0lkc1sgb3V0Z29lcklkIF0gKXtcbiAgICAgICAgICAgIHNFbGVzSWRzWyBvdXRnb2VySWQgXSA9IHRydWU7XG4gICAgICAgICAgICBzRWxlcy5wdXNoKCBvdXRnb2VyICk7XG4gICAgICAgICAgICBuZXdPdXRnb2VycyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFuZXdPdXRnb2VycyApeyBicmVhazsgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIG91dGdvZXJzIGFscmVhZHlcblxuICAgICAgICBlbGVzID0gb3V0Z29lcnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgc0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIC8vIG5vcm1hbGx5IGNhbGxlZCBwYXJlbnRzIGluIGdyYXBoIHRoZW9yeVxuICAgIC8vIHRoZXNlIG5vZGVzIDw9ZWRnZXM9IGluY29taW5nIG5vZGVzXG4gICAgaW5jb21lcnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIG9FbGVzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIGVsZUlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgZWRnZXMgPSBlbGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICAgIHZhciBzcmNJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS5zb3VyY2U7XG4gICAgICAgICAgdmFyIHRndElkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnRhcmdldDtcblxuICAgICAgICAgIGlmKCB0Z3RJZCA9PT0gZWxlSWQgJiYgc3JjSWQgIT09IGVsZUlkICl7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlLnNvdXJjZSgpWzBdICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgb0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIC8vIGFrYSBEQUcgYW5jZXN0b3JzXG4gICAgcHJlZGVjZXNzb3JzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBwRWxlcyA9IFtdO1xuICAgICAgdmFyIHBFbGVzSWRzID0ge307XG5cbiAgICAgIGZvcig7Oyl7XG4gICAgICAgIHZhciBpbmNvbWVycyA9IGVsZXMuaW5jb21lcnMoKTtcblxuICAgICAgICBpZiggaW5jb21lcnMubGVuZ3RoID09PSAwICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgbm8gaW5jb21lcnMgbGVmdFxuXG4gICAgICAgIHZhciBuZXdJbmNvbWVycyA9IGZhbHNlO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGluY29tZXJzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGluY29tZXIgPSBpbmNvbWVyc1tpXTtcbiAgICAgICAgICB2YXIgaW5jb21lcklkID0gaW5jb21lci5pZCgpO1xuXG4gICAgICAgICAgaWYoICFwRWxlc0lkc1sgaW5jb21lcklkIF0gKXtcbiAgICAgICAgICAgIHBFbGVzSWRzWyBpbmNvbWVySWQgXSA9IHRydWU7XG4gICAgICAgICAgICBwRWxlcy5wdXNoKCBpbmNvbWVyICk7XG4gICAgICAgICAgICBuZXdJbmNvbWVycyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFuZXdJbmNvbWVycyApeyBicmVhazsgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIGluY29tZXJzIGFscmVhZHlcblxuICAgICAgICBlbGVzID0gaW5jb21lcnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgcEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuICB9KTtcblxuXG4gIC8vIE5laWdoYm91cmhvb2QgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgbmVpZ2hib3Job29kOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXsgLy8gZm9yIGFsbCBub2Rlc1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgICAgLy8gZm9yIGVhY2ggY29ubmVjdGVkIGVkZ2UsIGFkZCB0aGUgZWRnZSBhbmQgdGhlIG90aGVyIG5vZGVcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG4gICAgICAgICAgdmFyIG90aGVyTm9kZSA9IGVkZ2UuY29ubmVjdGVkTm9kZXMoKS5ub3Qobm9kZSk7XG5cbiAgICAgICAgICAvLyBuZWVkIGNoZWNrIGluIGNhc2Ugb2YgbG9vcFxuICAgICAgICAgIGlmKCBvdGhlck5vZGUubGVuZ3RoID4gMCApe1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaCggb3RoZXJOb2RlWzBdICk7IC8vIGFkZCBub2RlIDEgaG9wIGF3YXlcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gYWRkIGNvbm5lY3RlZCBlZGdlXG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZVswXSApO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuICggbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBjbG9zZWROZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCgpLmFkZCggdGhpcyApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgb3Blbk5laWdoYm9yaG9vZDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCBzZWxlY3RvciApO1xuICAgIH1cbiAgfSk7ICBcblxuICAvLyBhbGlhc2VzXG4gICQkLmVsZXNmbi5uZWlnaGJvdXJob29kID0gJCQuZWxlc2ZuLm5laWdoYm9yaG9vZDtcbiAgJCQuZWxlc2ZuLmNsb3NlZE5laWdoYm91cmhvb2QgPSAkJC5lbGVzZm4uY2xvc2VkTmVpZ2hib3Job29kO1xuICAkJC5lbGVzZm4ub3Blbk5laWdoYm91cmhvb2QgPSAkJC5lbGVzZm4ub3Blbk5laWdoYm9yaG9vZDtcblxuXG4gIC8vIEVkZ2UgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgc291cmNlOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIHNyYztcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3JjICYmIHNlbGVjdG9yID8gc3JjLmZpbHRlciggc2VsZWN0b3IgKSA6IHNyYztcbiAgICB9LFxuXG4gICAgdGFyZ2V0OiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIHRndDtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGd0ICYmIHNlbGVjdG9yID8gdGd0LmZpbHRlciggc2VsZWN0b3IgKSA6IHRndDtcbiAgICB9LFxuXG4gICAgc291cmNlczogZGVmaW5lU291cmNlRnVuY3Rpb24oe1xuICAgICAgYXR0cjogJ3NvdXJjZSdcbiAgICB9KSxcblxuICAgIHRhcmdldHM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICAgIGF0dHI6ICd0YXJnZXQnXG4gICAgfSlcbiAgfSk7XG4gIFxuICBmdW5jdGlvbiBkZWZpbmVTb3VyY2VGdW5jdGlvbiggcGFyYW1zICl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZVsgcGFyYW1zLmF0dHIgXTtcblxuICAgICAgICBpZiggc3JjICl7XG4gICAgICAgICAgc291cmNlcy5wdXNoKCBzcmMgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBzb3VyY2VzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH07XG4gIH1cblxuICAkJC5mbi5lbGVzKHtcbiAgICBlZGdlc1dpdGg6IGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKCksXG5cbiAgICBlZGdlc1RvOiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbih7XG4gICAgICB0aGlzSXM6ICdzb3VyY2UnXG4gICAgfSlcbiAgfSk7XG4gIFxuICBmdW5jdGlvbiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbiggcGFyYW1zICl7XG4gICAgXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG90aGVyTm9kZXMpe1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHAgPSBwYXJhbXMgfHwge307XG5cbiAgICAgIC8vIGdldCBlbGVtZW50cyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZFxuICAgICAgaWYoICQkLmlzLnN0cmluZyhvdGhlck5vZGVzKSApe1xuICAgICAgICBvdGhlck5vZGVzID0gY3kuJCggb3RoZXJOb2RlcyApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgdGhpc0lkcyA9IHRoaXMuX3ByaXZhdGUuaWRzO1xuICAgICAgdmFyIG90aGVySWRzID0gb3RoZXJOb2Rlcy5fcHJpdmF0ZS5pZHM7XG4gICAgICBcbiAgICAgIGZvciggdmFyIGggPSAwOyBoIDwgb3RoZXJOb2Rlcy5sZW5ndGg7IGgrKyApe1xuICAgICAgICB2YXIgZWRnZXMgPSBvdGhlck5vZGVzW2hdLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgICBcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgICAgdmFyIGZvdW5kSWQ7XG4gICAgICAgICAgdmFyIGVkZ2VEYXRhID0gZWRnZS5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICAgIHZhciB0aGlzVG9PdGhlciA9IHRoaXNJZHNbIGVkZ2VEYXRhLnNvdXJjZSBdICYmIG90aGVySWRzWyBlZGdlRGF0YS50YXJnZXQgXTtcbiAgICAgICAgICB2YXIgb3RoZXJUb1RoaXMgPSBvdGhlcklkc1sgZWRnZURhdGEuc291cmNlIF0gJiYgdGhpc0lkc1sgZWRnZURhdGEudGFyZ2V0IF07XG4gICAgICAgICAgdmFyIGVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciA9IHRoaXNUb090aGVyIHx8IG90aGVyVG9UaGlzO1xuXG4gICAgICAgICAgaWYoICFlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIGlmKCBwLnRoaXNJcyApe1xuICAgICAgICAgICAgaWYoIHAudGhpc0lzID09PSAnc291cmNlJyAmJiAhdGhpc1RvT3RoZXIgKXsgY29udGludWU7IH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIHAudGhpc0lzID09PSAndGFyZ2V0JyAmJiAhb3RoZXJUb1RoaXMgKXsgY29udGludWU7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICk7XG4gICAgfTtcbiAgfVxuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgY29ubmVjdGVkRWRnZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIHJldEVsZXMgPSBbXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICBcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IGVsZXNbaV07XG4gICAgICAgIGlmKCAhbm9kZS5pc05vZGUoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07ICAgICAgICAgIFxuICAgICAgICAgIHJldEVsZXMucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHJldEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIGNvbm5lY3RlZE5vZGVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciByZXRFbGVzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlbGVzW2ldO1xuICAgICAgICBpZiggIWVkZ2UuaXNFZGdlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgICByZXRFbGVzLnB1c2goIGVkZ2Uuc291cmNlKClbMF0gKTtcbiAgICAgICAgcmV0RWxlcy5wdXNoKCBlZGdlLnRhcmdldCgpWzBdICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHJldEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIHBhcmFsbGVsRWRnZXM6IGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbigpLFxuXG4gICAgY29kaXJlY3RlZEVkZ2VzOiBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oe1xuICAgICAgY29kaXJlY3RlZDogdHJ1ZVxuICAgIH0pXG4gIH0pO1xuICBcbiAgZnVuY3Rpb24gZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHBhcmFtcyl7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgY29kaXJlY3RlZDogZmFsc2VcbiAgICB9O1xuICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICBcbiAgICByZXR1cm4gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgICAgLy8gbG9vayBhdCBhbGwgdGhlIGVkZ2VzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlMSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgc3JjMSA9IGVkZ2UxLnNvdXJjZSgpWzBdO1xuICAgICAgICB2YXIgc3JjaWQxID0gc3JjMS5pZCgpO1xuICAgICAgICB2YXIgdGd0MSA9IGVkZ2UxLnRhcmdldCgpWzBdO1xuICAgICAgICB2YXIgdGd0aWQxID0gdGd0MS5pZCgpO1xuICAgICAgICB2YXIgc3JjRWRnZXMxID0gc3JjMS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgICAvLyBsb29rIGF0IGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc3JjIG5vZGUgb2YgdGhpcyBlZGdlXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgc3JjRWRnZXMxLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVkZ2UyID0gc3JjRWRnZXMxW2pdO1xuICAgICAgICAgIHZhciBlZGdlMmRhdGEgPSBlZGdlMi5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICAgIHZhciB0Z3RpZDIgPSBlZGdlMmRhdGEudGFyZ2V0O1xuICAgICAgICAgIHZhciBzcmNpZDIgPSBlZGdlMmRhdGEuc291cmNlO1xuXG4gICAgICAgICAgdmFyIGNvZGlyZWN0ZWQgPSB0Z3RpZDIgPT09IHRndGlkMSAmJiBzcmNpZDIgPT09IHNyY2lkMTtcbiAgICAgICAgICB2YXIgb3BwZGlyZWN0ZWQgPSBzcmNpZDEgPT09IHRndGlkMiAmJiB0Z3RpZDEgPT09IHNyY2lkMjtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggKHAuY29kaXJlY3RlZCAmJiBjb2RpcmVjdGVkKSB8fCAoIXAuY29kaXJlY3RlZCAmJiAoY29kaXJlY3RlZCB8fCBvcHBkaXJlY3RlZCkpICl7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlZGdlMiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9O1xuICBcbiAgfVxuXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuXG4gICAgZml0OiBmdW5jdGlvbigpe30sXG4gICAgY2VudGVyOiBmdW5jdGlvbigpe31cblxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uICgkJCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKiAgTWluIGFuZCBNYXggaGVhcCBwcmVkZWZhdWx0cyAqL1xuICBcbiAgJCQuTWluaGVhcCA9IGZ1bmN0aW9uIChjeSwgZWxlcywgdmFsdWVGbikge1xuICAgIHJldHVybiBuZXcgJCQuSGVhcChjeSwgZWxlcywgJCQuSGVhcC5taW5IZWFwQ29tcGFyYXRvciwgdmFsdWVGbik7XG4gIH07XG5cbiAgJCQuTWF4aGVhcCA9IGZ1bmN0aW9uIChjeSwgZWxlcywgdmFsdWVGbikge1xuICAgIHJldHVybiBuZXcgJCQuSGVhcChjeSwgZWxlcywgJCQuSGVhcC5tYXhIZWFwQ29tcGFyYXRvciwgdmFsdWVGbik7XG4gIH07XG4gIFxuICAkJC5IZWFwID0gZnVuY3Rpb24gKGN5LCBlbGVzLCBjb21wYXJhdG9yLCB2YWx1ZUZuKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBlbGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlb2YgdmFsdWVGbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdmFsdWVGbiA9ICQkLkhlYXAuaWRGbjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSGVhcCA9IFtdLFxuICAgICAgcG9pbnRlcnMgPSB7fSxcbiAgICAgIGVsZW1lbnRzID0gW10sXG4gICAgICBpID0gMCxcbiAgICAgIGlkLFxuICAgICAgaGVhcCxcbiAgICAgIGVsZXNMZW47XG5cbiAgICBlbGVzID0gdGhpcy5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbihlbGVzLCBjeSk7XG4gICAgZWxlc0xlbiA9IGVsZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGVsZXNMZW47IGkgKz0gMSkge1xuICAgICAgc291cmNlSGVhcC5wdXNoKHZhbHVlRm4uY2FsbChjeSwgZWxlc1tpXSwgaSwgZWxlcykpO1xuXG4gICAgICBpZCA9IGVsZXNbaV0uaWQoKTtcbiAgICAgIFxuICAgICAgaWYgKHBvaW50ZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICB0aHJvdyBcIkVSUk9SOiBNdWx0aXBsZSBpdGVtcyB3aXRoIHRoZSBzYW1lIGlkIGZvdW5kOiBcIiArIGlkO1xuICAgICAgfVxuICAgICAgXG4gICAgICBwb2ludGVyc1tpZF0gPSBpO1xuICAgICAgZWxlbWVudHMucHVzaChpZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIGhlYXA6IHNvdXJjZUhlYXAsXG4gICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICBjb21wYXJhdG9yOiBjb21wYXJhdG9yLFxuICAgICAgZXh0cmFjdG9yOiB2YWx1ZUZuLFxuICAgICAgbGVuZ3RoOiBlbGVzTGVuXG4gICAgfTtcblxuICAgIGZvciAoaSA9IE1hdGguZmxvb3IoZWxlc0xlbiAvIDIpOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaGVhcCA9IHRoaXMuaGVhcGlmeShpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhcDtcbiAgfTtcblxuICAvKiBzdGF0aWMgbWV0aG9kcyAqL1xuICAkJC5IZWFwLmlkRm4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLmlkKCk7XG4gIH07XG5cbiAgJCQuSGVhcC5taW5IZWFwQ29tcGFyYXRvciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPj0gYjtcbiAgfTtcblxuICAkJC5IZWFwLm1heEhlYXBDb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8PSBiO1xuICB9O1xuXG4gICQkLmZuLmhlYXAgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIGZuTWFwICl7XG4gICAgICB2YXIgZm4gPSBmbk1hcFtuYW1lXTtcbiAgICAgICQkLkhlYXAucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG5cbiAgJCQuaGVhcGZuID0gJCQuSGVhcC5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbiAgLyogb2JqZWN0IG1ldGhvZHMgKi9cbiAgJCQuaGVhcGZuLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubGVuZ3RoO1xuICB9O1xuXG4gICQkLmhlYXBmbi5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChlbGVzLCBjeSkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYodHlwZW9mIGN5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgfVxuXG4gICAgaWYgKCQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oZWxlcykpIHtcbiAgICAgIHJlc3VsdCA9IGVsZXM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdEFycmF5ID0gW10sXG4gICAgICAgIHNvdXJjZUVsZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIFtlbGVzXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlRWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBzb3VyY2VFbGVzW2ldLFxuICAgICAgICAgIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICBpZihlbGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlc3VsdEFycmF5LnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBuZXcgJCQuQ29sbGVjdGlvbihjeSwgcmVzdWx0QXJyYXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgJCQuaGVhcGZuLmlzSGVhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLl9wcml2YXRlLmhlYXAsXG4gICAgICBhcnJsZW4gPSBhcnJheS5sZW5ndGgsXG4gICAgICBpLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgbENoZWNrLFxuICAgICAgckNoZWNrLFxuICAgICAgY29tcGFyYXRvciA9IHRoaXMuX3ByaXZhdGUuY29tcGFyYXRvcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnJsZW47IGkgKz0gMSkge1xuICAgICAgbGVmdCA9IDIgKiBpICsgMTtcbiAgICAgIHJpZ2h0ID0gbGVmdCArIDE7XG4gICAgICBsQ2hlY2sgPSBsZWZ0IDwgYXJybGVuID8gY29tcGFyYXRvcihhcnJheVtsZWZ0XSwgYXJyYXlbaV0pIDogdHJ1ZTtcbiAgICAgIHJDaGVjayA9IHJpZ2h0IDwgYXJybGVuID8gY29tcGFyYXRvcihhcnJheVtyaWdodF0sIGFycmF5W2ldKSA6IHRydWU7XG5cbiAgICAgIGlmICghbENoZWNrIHx8ICFyQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gICQkLmhlYXBmbi5oZWFwU3dhcCA9IGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgdmFyIGhlYXAgPSB0aGlzLl9wcml2YXRlLmhlYXAsXG4gICAgICBwb2ludGVycyA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnMsXG4gICAgICBlbGVtZW50cyA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHMsXG4gICAgICBzd2FwVmFsdWUgPSBoZWFwW2ldLFxuICAgICAgc3dhcEVsZW1zID0gZWxlbWVudHNbaV0sXG4gICAgICBpZEkgPSBlbGVtZW50c1tpXSxcbiAgICAgIGlkSiA9IGVsZW1lbnRzW2pdO1xuXG4gICAgaGVhcFtpXSA9IGhlYXBbal07XG4gICAgZWxlbWVudHNbaV0gPSBlbGVtZW50c1tqXTtcblxuICAgIHBvaW50ZXJzW2lkSV0gPSBqO1xuICAgIHBvaW50ZXJzW2lkSl0gPSBpO1xuXG4gICAgaGVhcFtqXSA9IHN3YXBWYWx1ZTtcbiAgICBlbGVtZW50c1tqXSA9IHN3YXBFbGVtcztcbiAgfTtcblxuICAkJC5oZWFwZm4uaGVhcGlmeSA9IGZ1bmN0aW9uIChpLCByb290VG9MZWFmKSB7XG4gICAgdmFyIHRyZWVMZW4gPSAwLFxuICAgICAgY29uZEhlYXAgPSBmYWxzZSxcbiAgICAgIGFycmF5LFxuICAgICAgY3VycmVudCxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGJlc3QsXG4gICAgICBjb21wYXJhdG9yLFxuICAgICAgcGFyZW50O1xuICAgIFxuICAgIGlmICh0eXBlb2Ygcm9vdFRvTGVhZiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcm9vdFRvTGVhZiA9IHRydWU7XG4gICAgfVxuXG4gICAgYXJyYXkgPSB0aGlzLl9wcml2YXRlLmhlYXA7XG4gICAgdHJlZUxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBjb21wYXJhdG9yID0gdGhpcy5fcHJpdmF0ZS5jb21wYXJhdG9yO1xuICAgIGN1cnJlbnQgPSBpO1xuXG4gICAgd2hpbGUgKCFjb25kSGVhcCkge1xuXG4gICAgICBpZiAocm9vdFRvTGVhZikge1xuICAgICAgICBsZWZ0ID0gMiAqIGN1cnJlbnQgKyAxO1xuICAgICAgICByaWdodCA9IGxlZnQgKyAxO1xuICAgICAgICBiZXN0ID0gY3VycmVudDtcbiAgICAgICAgXG4gICAgICAgIGlmIChsZWZ0IDwgdHJlZUxlbiAmJiAhY29tcGFyYXRvcihhcnJheVtsZWZ0XSwgYXJyYXlbYmVzdF0pKSB7XG4gICAgICAgICAgYmVzdCA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChyaWdodCA8IHRyZWVMZW4gJiYgIWNvbXBhcmF0b3IoYXJyYXlbcmlnaHRdLCBhcnJheVtiZXN0XSkpIHtcbiAgICAgICAgICBiZXN0ID0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbmRIZWFwID0gYmVzdCA9PT0gY3VycmVudDtcbiAgICAgICAgXG4gICAgICAgIGlmICghY29uZEhlYXApIHtcbiAgICAgICAgICB0aGlzLmhlYXBTd2FwKGJlc3QsIGN1cnJlbnQpO1xuICAgICAgICAgIGN1cnJlbnQgPSBiZXN0O1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IE1hdGguZmxvb3IoKGN1cnJlbnQgLSAxKSAvIDIpO1xuICAgICAgICBiZXN0ID0gY3VycmVudDtcbiAgICAgICAgY29uZEhlYXAgPSBwYXJlbnQgPCAwIHx8IGNvbXBhcmF0b3IoYXJyYXlbYmVzdF0sIGFycmF5W3BhcmVudF0pO1xuXG4gICAgICAgIGlmICghY29uZEhlYXApIHtcbiAgICAgICAgICB0aGlzLmhlYXBTd2FwKGJlc3QsIHBhcmVudCk7XG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSAvLyB3aGlsZVxuICB9O1xuXG4gIC8qIGNvbGxlY3Rpb25PckVsZW1lbnQgKi9cbiAgJCQuaGVhcGZuLmluc2VydCA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbihlbGVzKSxcbiAgICAgIGVsc2l6ZSA9IGVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBlbGluZGV4LFxuICAgICAgZWx2YWx1ZSxcbiAgICAgIGVsaWQsXG4gICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGVsc2l6ZTsgaSArPSAxKSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBlbGluZGV4ID0gdGhpcy5fcHJpdmF0ZS5oZWFwLmxlbmd0aDtcbiAgICAgIGVsdmFsdWUgPSB0aGlzLl9wcml2YXRlLmV4dHJhY3RvcihlbGVtZW50KTtcbiAgICAgIGVsaWQgPSBlbGVtZW50LmlkKCk7XG5cbiAgICAgIGlmICh0aGlzLl9wcml2YXRlLnBvaW50ZXJzLmhhc093blByb3BlcnR5KGVsaWQpKSB7XG4gICAgICAgIHRocm93IFwiRVJST1I6IE11bHRpcGxlIGl0ZW1zIHdpdGggdGhlIHNhbWUgaWQgZm91bmQ6IFwiICsgZWxpZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwLnB1c2goZWx2YWx1ZSk7XG4gICAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLnB1c2goZWxpZCk7XG4gICAgICB0aGlzLl9wcml2YXRlLnBvaW50ZXJzW2VsaWRdID0gZWxpbmRleDtcbiAgICAgIHRoaXMuaGVhcGlmeShlbGluZGV4LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZS5sZW5ndGggPSB0aGlzLl9wcml2YXRlLmhlYXAubGVuZ3RoO1xuICB9O1xuXG4gICQkLmhlYXBmbi5nZXRWYWx1ZUJ5SWQgPSBmdW5jdGlvbiAoZWxlbWVudElkKSB7XG4gICAgaWYgKHRoaXMuX3ByaXZhdGUucG9pbnRlcnMuaGFzT3duUHJvcGVydHkoZWxlbWVudElkKSkge1xuICAgICAgdmFyIGVsZW1lbnRJbmRleCA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbZWxlbWVudElkXTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaGVhcFtlbGVtZW50SW5kZXhdO1xuICAgIH1cbiAgfTtcbiAgXG4gICQkLmhlYXBmbi5jb250YWlucyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbihlbGVzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBlbGVtZW50SWQgPSBlbGVtZW50c1tpXS5pZCgpO1xuXG4gICAgICBpZighdGhpcy5fcHJpdmF0ZS5wb2ludGVycy5oYXNPd25Qcm9wZXJ0eShlbGVtZW50SWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgXG4gICQkLmhlYXBmbi50b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ByaXZhdGUubGVuZ3RoID4gMCkge1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdGhpcy5fcHJpdmF0ZS5oZWFwWzBdLFxuICAgICAgICBpZDogdGhpcy5fcHJpdmF0ZS5lbGVtZW50c1swXVxuICAgICAgfTtcblxuICAgIH1cbiAgfTtcblxuICAkJC5oZWFwZm4ucG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9wcml2YXRlLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB0b3AgPSB0aGlzLnRvcCgpLFxuICAgICAgICBsYXN0SW5kZXggPSB0aGlzLl9wcml2YXRlLmxlbmd0aCAtIDEsXG4gICAgICAgIHJlbW92ZUNhbmRpZGF0ZSxcbiAgICAgICAgcmVtb3ZlVmFsdWUsXG4gICAgICAgIHJlbUlkO1xuXG4gICAgICB0aGlzLmhlYXBTd2FwKDAsIGxhc3RJbmRleCk7XG5cbiAgICAgIHJlbW92ZUNhbmRpZGF0ZSA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHNbbGFzdEluZGV4XTtcbiAgICAgIHJlbW92ZVZhbHVlID0gdGhpcy5fcHJpdmF0ZS5oZWFwW2xhc3RJbmRleF07XG4gICAgICByZW1JZCA9IHJlbW92ZUNhbmRpZGF0ZTtcblxuICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwLnBvcCgpO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5wb3AoKTtcbiAgICAgIHRoaXMuX3ByaXZhdGUubGVuZ3RoID0gdGhpcy5fcHJpdmF0ZS5oZWFwLmxlbmd0aDtcbiAgICAgIHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbcmVtSWRdID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLmhlYXBpZnkoMCk7XG4gICAgICByZXR1cm4gdG9wO1xuICAgIH1cbiAgfTtcblxuICAkJC5oZWFwZm4uZmluZERpcmVjdGlvbkhlYXBpZnkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgcGFyZW50ID0gTWF0aC5mbG9vcigoaW5kZXggLSAxKSAvIDIpLFxuICAgICAgYXJyYXkgPSB0aGlzLl9wcml2YXRlLmhlYXAsXG4gICAgICBjb25kSGVhcCA9IHBhcmVudCA8IDAgfHwgdGhpcy5fcHJpdmF0ZS5jb21wYXJhdG9yKGFycmF5W2luZGV4XSwgYXJyYXlbcGFyZW50XSk7XG5cbiAgICB0aGlzLmhlYXBpZnkoaW5kZXgsIGNvbmRIZWFwKTtcbiAgfTtcblxuICAvKiBlZGl0IGlzIGEgbmV3IHZhbHVlIG9yIGZ1bmN0aW9uICovXG4gIC8vIG9ubHkgdmFsdWVzIGluIGhlYXAgYXJlIHVwZGF0ZWQuIGVsZW1lbnRzIHRoZW1zZWx2ZXMgYXJlIG5vdCFcbiAgJCQuaGVhcGZuLmVkaXQgPSBmdW5jdGlvbiAoZWxlcywgZWRpdCkge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZ2V0QXJndW1lbnRBc0NvbGxlY3Rpb24oZWxlcyk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGVsZW1lbnRJZCA9IGVsZW1lbnRzW2ldLmlkKCksXG4gICAgICAgIGVsZW1lbnRJbmRleCA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbZWxlbWVudElkXSxcbiAgICAgICAgZWxlbWVudFZhbHVlID0gdGhpcy5fcHJpdmF0ZS5oZWFwW2VsZW1lbnRJbmRleF07XG4gICAgICBcbiAgICAgIGlmICgkJC5pcy5udW1iZXIoZWRpdCkpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwW2VsZW1lbnRJbmRleF0gPSBlZGl0O1xuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAoJCQuaXMuZm4oZWRpdCkpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwW2VsZW1lbnRJbmRleF0gPSBlZGl0LmNhbGwodGhpcy5fcHJpdmF0ZS5jeSwgZWxlbWVudFZhbHVlLCBlbGVtZW50SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbmREaXJlY3Rpb25IZWFwaWZ5KGVsZW1lbnRJbmRleCk7XG4gICAgfVxuICB9O1xuXG4gICQkLmhlYXBmbi5yZW1vdmUgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZ2V0QXJndW1lbnRBc0NvbGxlY3Rpb24oZWxlcyk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGVsZW1lbnRJZCA9IGVsZW1lbnRzW2ldLmlkKCksXG4gICAgICAgIGVsZW1lbnRJbmRleCA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbZWxlbWVudElkXSxcbiAgICAgICAgbGFzdEluZGV4ID0gdGhpcy5fcHJpdmF0ZS5sZW5ndGggLSAxLFxuICAgICAgICByZW1vdmVDYW5kaWRhdGUsXG4gICAgICAgIHJlbW92ZVZhbHVlLFxuICAgICAgICByZW1JZDtcblxuICAgICAgaWYgKGVsZW1lbnRJbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgIHRoaXMuaGVhcFN3YXAoZWxlbWVudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVDYW5kaWRhdGUgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzW2xhc3RJbmRleF07XG4gICAgICByZW1vdmVWYWx1ZSA9IHRoaXMuX3ByaXZhdGUuaGVhcFtsYXN0SW5kZXhdO1xuICAgICAgcmVtSWQgPSByZW1vdmVDYW5kaWRhdGU7XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUuaGVhcC5wb3AoKTtcbiAgICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMucG9wKCk7XG4gICAgICB0aGlzLl9wcml2YXRlLmxlbmd0aCA9IHRoaXMuX3ByaXZhdGUuaGVhcC5sZW5ndGg7XG4gICAgICB0aGlzLl9wcml2YXRlLnBvaW50ZXJzW3JlbUlkXSA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5maW5kRGlyZWN0aW9uSGVhcGlmeShlbGVtZW50SW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVWYWx1ZTtcbiAgfTtcblxufSkoY3l0b3NjYXBlKTtcbi8qXG4gIFRoZSBjYW52YXMgcmVuZGVyZXIgd2FzIHdyaXR0ZW4gYnkgWXVlIERvbmcuXG5cbiAgTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiovXG5cbihmdW5jdGlvbigkJCkgeyAndXNlIHN0cmljdCc7XG5cbiAgQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUyA9IDM7XG4gIC8vXG4gIENhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1ggPSAwO1xuICBDYW52YXNSZW5kZXJlci5EUkFHID0gMTtcbiAgQ2FudmFzUmVuZGVyZXIuTk9ERSA9IDI7XG5cbiAgQ2FudmFzUmVuZGVyZXIuQlVGRkVSX0NPVU5UID0gMztcbiAgLy9cbiAgQ2FudmFzUmVuZGVyZXIuVEVYVFVSRV9CVUZGRVIgPSAwO1xuICBDYW52YXNSZW5kZXJlci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFID0gMTtcbiAgQ2FudmFzUmVuZGVyZXIuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyA9IDI7XG5cbiAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIob3B0aW9ucykgeyAgXG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgICBcbiAgICAgIHNlbGVjdDogW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMF0sIC8vIENvb3JkaW5hdGVzIGZvciBzZWxlY3Rpb24gYm94LCBwbHVzIGVuYWJsZWQgZmxhZyBcbiAgICAgIHJlbmRlcmVyOiB0aGlzLCBjeTogb3B0aW9ucy5jeSwgY29udGFpbmVyOiBvcHRpb25zLmN5LmNvbnRhaW5lcigpLFxuICAgICAgXG4gICAgICBjYW52YXNlczogbmV3IEFycmF5KENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlMpLFxuICAgICAgY29udGV4dHM6IG5ldyBBcnJheShDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTKSxcbiAgICAgIGNhbnZhc05lZWRzUmVkcmF3OiBuZXcgQXJyYXkoQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUyksXG4gICAgICBcbiAgICAgIGJ1ZmZlckNhbnZhc2VzOiBuZXcgQXJyYXkoQ2FudmFzUmVuZGVyZXIuQlVGRkVSX0NPVU5UKSxcbiAgICAgIGJ1ZmZlckNvbnRleHRzOiBuZXcgQXJyYXkoQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUylcblxuICAgIH07XG4gICAgXG4gICAgLy8tLVBvaW50ZXItcmVsYXRlZCBkYXRhXG4gICAgdGhpcy5ob3ZlckRhdGEgPSB7ZG93bjogbnVsbCwgbGFzdDogbnVsbCwgXG4gICAgICAgIGRvd25UaW1lOiBudWxsLCB0cmlnZ2VyTW9kZTogbnVsbCwgXG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSwgXG4gICAgICAgIGluaXRpYWxQYW46IFtudWxsLCBudWxsXSwgY2FwdHVyZTogZmFsc2V9O1xuICAgIFxuICAgIHRoaXMudGltZW91dERhdGEgPSB7cGFuVGltZW91dDogbnVsbH07XG4gICAgXG4gICAgdGhpcy5kcmFnRGF0YSA9IHtwb3NzaWJsZURyYWdFbGVtZW50czogW119O1xuICAgIFxuICAgIHRoaXMudG91Y2hEYXRhID0ge3N0YXJ0OiBudWxsLCBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgLy8gVGhlc2UgMyBmaWVsZHMgcmVsYXRlZCB0byB0YXAsIHRhcGhvbGQgZXZlbnRzXG4gICAgICAgIHN0YXJ0UG9zaXRpb246IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICAgICAgc2luZ2xlVG91Y2hTdGFydFRpbWU6IG51bGwsXG4gICAgICAgIHNpbmdsZVRvdWNoTW92ZWQ6IHRydWUsXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgbm93OiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sIFxuICAgICAgICBlYXJsaWVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0gfTtcbiAgICAvLy0tXG4gICAgXG4gICAgLy8tLVdoZWVsLXJlbGF0ZWQgZGF0YSBcbiAgICB0aGlzLnpvb21EYXRhID0ge2ZyZWVUb1pvb206IGZhbHNlLCBsYXN0UG9pbnRlclg6IG51bGx9O1xuICAgIC8vLS1cbiAgICBcbiAgICB0aGlzLnJlZHJhd3MgPSAwO1xuICAgIHRoaXMuc2hvd0ZwcyA9IG9wdGlvbnMuc2hvd0ZwcztcblxuICAgIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgICBcbiAgICB0aGlzLmRhdGEuY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIGNvbnRhaW5lclN0eWxlID0gdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZTtcbiAgICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgY29udGFpbmVyU3R5bGUuekluZGV4ID0gJzAnO1xuICAgIGNvbnRhaW5lclN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICB0aGlzLmRhdGEuY29udGFpbmVyLmFwcGVuZENoaWxkKCB0aGlzLmRhdGEuY2FudmFzQ29udGFpbmVyICk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgICAgdGhpcy5kYXRhLmNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB0aGlzLmRhdGEuY29udGV4dHNbaV0gPSB0aGlzLmRhdGEuY2FudmFzZXNbaV0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHRoaXMuZGF0YS5jYW52YXNlc1tpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB0aGlzLmRhdGEuY2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIGkpO1xuICAgICAgdGhpcy5kYXRhLmNhbnZhc2VzW2ldLnN0eWxlLnpJbmRleCA9IFN0cmluZyhDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTIC0gaSk7XG4gICAgICB0aGlzLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZGF0YS5jYW52YXNlc1tpXSk7XG4gICAgICBcbiAgICAgIHRoaXMuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tpXSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmRhdGEudG9wQ2FudmFzID0gdGhpcy5kYXRhLmNhbnZhc2VzWzBdO1xuXG4gICAgdGhpcy5kYXRhLmNhbnZhc2VzW0NhbnZhc1JlbmRlcmVyLk5PREVdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDYW52YXNSZW5kZXJlci5OT0RFICsgJy1ub2RlJyk7XG4gICAgdGhpcy5kYXRhLmNhbnZhc2VzW0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YICsgJy1zZWxlY3Rib3gnKTtcbiAgICB0aGlzLmRhdGEuY2FudmFzZXNbQ2FudmFzUmVuZGVyZXIuRFJBR10uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENhbnZhc1JlbmRlcmVyLkRSQUcgKyAnLWRyYWcnKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENhbnZhc1JlbmRlcmVyLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgICB0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDb250ZXh0c1tpXSA9IHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnYnVmZmVyJyArIGkpO1xuICAgICAgdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnpJbmRleCA9IFN0cmluZygtaSAtIDEpO1xuICAgICAgdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIC8vdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgICB0aGlzLmhpZGVMYWJlbHNPblZpZXdwb3J0ID0gb3B0aW9ucy5oaWRlTGFiZWxzT25WaWV3cG9ydDtcbiAgICB0aGlzLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICB0aGlzLndoZWVsU2Vuc2l0aXZpdHkgPSBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgdGhpcy5tb3Rpb25CbHVyRW5hYmxlZCA9IG9wdGlvbnMubW90aW9uQmx1cjsgLy8gb24gYnkgZGVmYXVsdFxuICAgIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyA9IG9wdGlvbnMucGl4ZWxSYXRpbztcbiAgICB0aGlzLm1vdGlvbkJsdXIgPSB0cnVlOyAvLyBmb3IgaW5pdGlhbCBraWNrIG9mZlxuICAgIHRoaXMubW90aW9uQmx1ck9wYWNpdHkgPSBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5O1xuICAgIHRoaXMubW90aW9uQmx1clRyYW5zcGFyZW5jeSA9IDEgLSB0aGlzLm1vdGlvbkJsdXJPcGFjaXR5O1xuICAgIHRoaXMubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICAgIHRoaXMubWJQeFJCbHVycnkgPSAxOyAvLzAuODtcbiAgICB0aGlzLm1pbk1iTG93UXVhbEZyYW1lcyA9IDQ7XG4gICAgdGhpcy5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhcmVkRm9yTW90aW9uQmx1ciA9IFtdO1xuICAgIHRoaXMuZGVza3RvcFRhcFRocmVzaG9sZCA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgICB0aGlzLmRlc2t0b3BUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkICogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICAgIHRoaXMudG91Y2hUYXBUaHJlc2hvbGQgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICAgIHRoaXMudG91Y2hUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCAqIG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gICAgdGhpcy50YXBob2xkRHVyYXRpb24gPSA1MDA7XG5cbiAgICB0aGlzLmxvYWQoKTtcbiAgfVxuXG4gIENhbnZhc1JlbmRlcmVyLnBhbk9yQm94U2VsZWN0RGVsYXkgPSA0MDA7XG5cbiAgLy8gd2hldGhlciB0byB1c2UgUGF0aDJEIGNhY2hpbmcgZm9yIGRyYXdpbmdcbiAgdmFyIHBhdGhzSW1wbGQgPSB0eXBlb2YgUGF0aDJEICE9PSAndW5kZWZpbmVkJztcbiAgQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBwYXRoc0ltcGxkO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgdHlwZXM7XG5cbiAgICBpZiggJCQuaXMuYXJyYXkoIHBhcmFtcy50eXBlICkgKXtcbiAgICAgIHR5cGVzID0gcGFyYW1zLnR5cGU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZXMgPSBbIHBhcmFtcy50eXBlIF07XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcblxuICAgICAgc3dpdGNoKCB0eXBlICl7XG4gICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICBjYXNlICdsb2FkJzpcbiAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVzQ2FjaGUoKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUVkZ2VzQ2FjaGUoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2aWV3cG9ydCc6XG4gICAgICAgICAgdGhpcy5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRaU29ydGVkRWxlcygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiggdHlwZSA9PT0gJ2xvYWQnIHx8IHR5cGUgPT09ICdyZXNpemUnICl7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgICAgIHRoaXMubWF0Y2hDYW52YXNTaXplKHRoaXMuZGF0YS5jb250YWluZXIpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yXG4gICAgXG4gICAgdGhpcy5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlO1xuXG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJpbmRpbmdzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbaV07XG4gICAgICB2YXIgYiA9IGJpbmRpbmc7XG5cbiAgICAgIGIudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoYi5ldmVudCwgYi5oYW5kbGVyLCBiLnVzZUNhcHR1cmUpO1xuICAgIH1cblxuICAgIGlmKCB0aGlzLnJlbW92ZU9ic2VydmVyICl7XG4gICAgICB0aGlzLnJlbW92ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBpZiggdGhpcy5sYWJlbENhbGNEaXYgKXtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5sYWJlbENhbGNEaXYpO1xuICAgIH1cbiAgfTtcblxuICBcblxuICAvLyBjb3B5IHRoZSBtYXRoIGZ1bmN0aW9ucyBpbnRvIHRoZSByZW5kZXJlciBwcm90b3R5cGVcbiAgLy8gdW5mb3J0dW5hdGVseSB0aGVzZSBmdW5jdGlvbnMgYXJlIHVzZWQgaW50ZXJzcGVyc2VkIHQvbyB0aGUgY29kZVxuICAvLyBhbmQgdGhpcyBtYWtlcyBzdXJlIHRoaW5ncyB3b3JrIGp1c3QgaW4gY2FzZSBhIHJlZiB3YXMgbWlzc2VkIGluIHJlZmFjdG9yaW5nXG4gIC8vIFRPRE8gcmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxuICBmb3IoIHZhciBmbk5hbWUgaW4gJCQubWF0aCApe1xuICAgIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZVsgZm5OYW1lIF0gPSAkJC5tYXRoWyBmbk5hbWUgXTtcbiAgfVxuICBcbiAgXG4gICQkKCdyZW5kZXJlcicsICdjYW52YXMnLCBDYW52YXNSZW5kZXJlcik7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIHJlbmRGdW5jID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuICB2YXIgYXJyb3dTaGFwZXMgPSBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlcyA9IHt9O1xuXG4gIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVIZWlnaHQgPSAwLjM7XG5cbiAgLy8gQ29udHJhY3QgZm9yIGFycm93IHNoYXBlczpcbiAgLy8gMCwgMCBpcyBhcnJvdyB0aXBcbiAgLy8gKDAsIDEpIGlzIGRpcmVjdGlvbiB0b3dhcmRzIG5vZGVcbiAgLy8gKDEsIDApIGlzIHJpZ2h0XG4gIC8vXG4gIC8vIGZ1bmN0aW9uYWwgYXBpOlxuICAvLyBjb2xsaWRlOiBjaGVjayB4LCB5IGluIHNoYXBlXG4gIC8vIHJvdWdoQ29sbGlkZTogY2FsbGVkIGJlZm9yZSBjb2xsaWRlLCBubyBmYWxzZSBuZWdhdGl2ZXNcbiAgLy8gZHJhdzogZHJhd1xuICAvLyBzcGFjaW5nOiBkaXN0KGFycm93VGlwLCBub2RlQm91bmRhcnkpXG4gIC8vIGdhcDogZGlzdChlZGdlVGlwLCBub2RlQm91bmRhcnkpLCBlZGdlVGlwIG1heSAhPSBhcnJvd1RpcFxuXG4gIHZhciBiYkNvbGxpZGUgPSBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpe1xuICAgIHZhciB4MSA9IGNlbnRlclggLSB3aWR0aC8yO1xuICAgIHZhciB4MiA9IGNlbnRlclggKyB3aWR0aC8yO1xuICAgIHZhciB5MSA9IGNlbnRlclkgLSBoZWlnaHQvMjtcbiAgICB2YXIgeTIgPSBjZW50ZXJZICsgaGVpZ2h0LzI7XG5cbiAgICByZXR1cm4gKHgxIDw9IHggJiYgeCA8PSB4MikgJiYgKHkxIDw9IHkgJiYgeSA8PSB5Mik7XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbil7XG4gICAgYW5nbGUgPSAtYW5nbGU7IC8vIGIvYyBvZiBub3RhdGlvbiB1c2VkIGluIGFycm93IGRyYXcgZm5cblxuICAgIHZhciB4Um90YXRlZCA9IHggKiBNYXRoLmNvcyhhbmdsZSkgLSB5ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciB5Um90YXRlZCA9IHggKiBNYXRoLnNpbihhbmdsZSkgKyB5ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIFxuICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuXG4gICAgdmFyIHhUcmFuc2xhdGVkID0geFNjYWxlZCArIHRyYW5zbGF0aW9uLng7XG4gICAgdmFyIHlUcmFuc2xhdGVkID0geVNjYWxlZCArIHRyYW5zbGF0aW9uLnk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhUcmFuc2xhdGVkLFxuICAgICAgeTogeVRyYW5zbGF0ZWRcbiAgICB9O1xuICB9O1xuXG4gIGFycm93U2hhcGVzWydhcnJvdyddID0ge1xuICAgIF9wb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4zLFxuICAgICAgMCwgMCxcbiAgICAgIDAuMTUsIC0wLjNcbiAgICBdLFxuICAgIFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydhcnJvdyddLl9wb2ludHM7XG4gICAgICBcbi8vICAgICAgY29uc29sZS5sb2coXCJjb2xsaWRlKCk6IFwiICsgZGlyZWN0aW9uKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgICB4LCB5LCBwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snYXJyb3cnXS5fcG9pbnRzO1xuICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggcG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSAqIDI7XG4gICAgfVxuICB9O1xuXG4gIGFycm93U2hhcGVzWyd0cmlhbmdsZSddID0gYXJyb3dTaGFwZXNbJ2Fycm93J107XG4gIFxuICBhcnJvd1NoYXBlc1sndHJpYW5nbGUtYmFja2N1cnZlJ10gPSB7XG4gICAgX2N0cmxQdDogWyAwLCAtMC4xNSBdLFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlJ10uX3BvaW50cztcbiAgICAgIFxuLy8gICAgICBjb25zb2xlLmxvZyhcImNvbGxpZGUoKTogXCIgKyBkaXJlY3Rpb24pO1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICAgIHgsIHksIHBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWyd0cmlhbmdsZSddLl9wb2ludHM7XG4gICAgICB2YXIgZmlyc3RQdDtcbiAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgICBpZiggaSA9PT0gMCApe1xuICAgICAgICAgIGZpcnN0UHQgPSBwdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3RybFB0ID0gdGhpcy5fY3RybFB0O1xuICAgICAgdmFyIGN0cmxQdFRyYW5zID0gdHJhbnNmb3JtKCBjdHJsUHRbMF0sIGN0cmxQdFsxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyggY3RybFB0VHJhbnMueCwgY3RybFB0VHJhbnMueSwgZmlyc3RQdC54LCBmaXJzdFB0LnkgKTtcbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICogMjtcbiAgICB9XG4gIH07XG4gIFxuXG4gIGFycm93U2hhcGVzWyd0cmlhbmdsZS10ZWUnXSA9IHtcbiAgICBfcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zLFxuICAgICAgLTAuMTUsIC0wLjNcbiAgICBdLFxuXG4gICAgX3BvaW50c1RlZTogW1xuICAgICAgLTAuMTUsIC0wLjQsXG4gICAgICAtMC4xNSwgLTAuNSxcbiAgICAgIDAuMTUsIC0wLjUsXG4gICAgICAwLjE1LCAtMC40XG4gICAgXSxcbiAgICBcbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0cmlQdHMgPSBhcnJvd1NoYXBlc1sndHJpYW5nbGUtdGVlJ10uX3BvaW50cztcbiAgICAgIHZhciB0ZWVQdHMgPSBhcnJvd1NoYXBlc1sndHJpYW5nbGUtdGVlJ10uX3BvaW50c1RlZTtcbiAgICAgIFxuICAgICAgdmFyIGluc2lkZSA9ICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRlZVB0cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSBcbiAgICAgICAgfHwgJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdHJpUHRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuXG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgdHJpUHRzID0gYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlLXRlZSddLl9wb2ludHM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHRyaVB0c1sgaSAqIDIgXSwgIHRyaVB0c1sgaSAqIDIgKyAxIF0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuICAgICAgICBcbiAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlZVB0cyA9IGFycm93U2hhcGVzWyd0cmlhbmdsZS10ZWUnXS5fcG9pbnRzVGVlO1xuICAgICAgdmFyIGZpcnN0VGVlUHQgPSB0cmFuc2Zvcm0oIHRlZVB0c1swXSwgdGVlUHRzWzFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKCBmaXJzdFRlZVB0LngsIGZpcnN0VGVlUHQueSApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlZVB0cy5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHRlZVB0c1sgaSAqIDIgXSwgIHRlZVB0c1sgaSAqIDIgKyAxIF0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuICAgICAgICBcbiAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICogMjtcbiAgICB9XG4gIH07XG5cbiAgYXJyb3dTaGFwZXNbJ2hhbGYtdHJpYW5nbGUtb3ZlcnNob3QnXSA9IHtcbiAgICBfcG9pbnRzOiBbXG4gICAgICAwLCAtMC4yNSxcbiAgICAgIC0wLjUsIC0wLjI1LFxuICAgICAgMC41LCAwLjI1XG4gICAgXSxcbiAgICBcbiAgICBsZWF2ZVBhdGhPcGVuOiB0cnVlLFxuICAgIG1hdGNoRWRnZVdpZHRoOiB0cnVlLFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5fcG9pbnRzO1xuICAgICAgXG4vLyAgICAgIGNvbnNvbGUubG9nKFwiY29sbGlkZSgpOiBcIiArIGRpcmVjdGlvbik7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgICAgeCwgeSwgcG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5fcG9pbnRzO1xuICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggcG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKiAyO1xuICAgIH1cbiAgfTtcblxuICBhcnJvd1NoYXBlc1snbm9uZSddID0ge1xuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gIFxuICBhcnJvd1NoYXBlc1snY2lyY2xlJ10gPSB7XG4gICAgX2Jhc2VSYWRpdXM6IDAuMTUsXG4gICAgXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICAvLyBUcmFuc2Zvcm0geCwgeSB0byBnZXQgbm9uLXJvdGF0ZWQgZWxsaXBzZVxuICAgICAgXG4gICAgICBpZiAod2lkdGggIT0gaGVpZ2h0KSB7ICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IChoZWlnaHQgKyBwYWRkaW5nKSAvICh3aWR0aCArIHBhZGRpbmcpO1xuICAgICAgICB5IC89IGFzcGVjdFJhdGlvO1xuICAgICAgICBjZW50ZXJZIC89IGFzcGVjdFJhdGlvO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdyhjZW50ZXJYIC0geCwgMikgXG4gICAgICAgICAgKyBNYXRoLnBvdyhjZW50ZXJZIC0geSwgMikgPD0gTWF0aC5wb3coKHdpZHRoICsgcGFkZGluZylcbiAgICAgICAgICAgICogYXJyb3dTaGFwZXNbJ2NpcmNsZSddLl9iYXNlUmFkaXVzLCAyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKE1hdGgucG93KGNlbnRlclggLSB4LCAyKSBcbiAgICAgICAgICArIE1hdGgucG93KGNlbnRlclkgLSB5LCAyKSA8PSBNYXRoLnBvdygod2lkdGggKyBwYWRkaW5nKVxuICAgICAgICAgICAgKiBhcnJvd1NoYXBlc1snY2lyY2xlJ10uX2Jhc2VSYWRpdXMsIDIpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgY29udGV4dC5hcmModHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgYXJyb3dTaGFwZXNbJ2NpcmNsZSddLl9iYXNlUmFkaXVzICogc2l6ZSwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiByZW5kRnVuYy5nZXRBcnJvd1dpZHRoKGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSlcbiAgICAgICAgKiBhcnJvd1NoYXBlc1snY2lyY2xlJ10uX2Jhc2VSYWRpdXM7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKiAyO1xuICAgIH1cbiAgfTtcbiAgXG4gIGFycm93U2hhcGVzWydpbmhpYml0b3InXSA9IHtcbiAgICBfcG9pbnRzOiBbXG4gICAgICAtMC4yNSwgMCxcbiAgICAgIC0wLjI1LCAtMC4xLFxuICAgICAgMC4yNSwgLTAuMSxcbiAgICAgIDAuMjUsIDBcbiAgICBdLFxuICAgIFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydpbmhpYml0b3InXS5fcG9pbnRzO1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICAgIHgsIHksIHBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydpbmhpYml0b3InXS5fcG9pbnRzO1xuICAgICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCBwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9O1xuXG4gIGFycm93U2hhcGVzWyd0ZWUnXSA9IGFycm93U2hhcGVzWydpbmhpYml0b3InXTtcblxuICBhcnJvd1NoYXBlc1snc3F1YXJlJ10gPSB7XG4gICAgX3BvaW50czogW1xuICAgICAgLTAuMTUsIDAuMDAsXG4gICAgICAwLjE1LCAwLjAwLFxuICAgICAgMC4xNSwgLTAuMyxcbiAgICAgIC0wLjE1LCAtMC4zXG4gICAgXSxcbiAgICBcbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snc3F1YXJlJ10uX3BvaW50cztcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgICB4LCB5LCBwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snc3F1YXJlJ10uX3BvaW50cztcbiAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKiAyO1xuICAgIH1cbiAgfTtcblxuICBhcnJvd1NoYXBlc1snZGlhbW9uZCddID0ge1xuICAgIF9wb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4xNSxcbiAgICAgIDAsIC0wLjMsXG4gICAgICAwLjE1LCAtMC4xNSxcbiAgICAgIDAsIDBcbiAgICBdLFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ2RpYW1vbmQnXS5fcG9pbnRzO1xuICAgICAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgICB4LCB5LCBwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG4gICAgfSxcblxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ2RpYW1vbmQnXS5fcG9pbnRzO1xuICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggcG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWU7XG4gICAgfVxuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcblxuICBDUnAuZ2V0Q2FjaGVkTm9kZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTsgdmFyIGN5ID0gdGhpcy5kYXRhLmN5O1xuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGRhdGEuY2FjaGUuY2FjaGVkTm9kZXMgPT0gbnVsbCkge1xuICAgICAgZGF0YS5jYWNoZS5jYWNoZWROb2RlcyA9IGN5Lm5vZGVzKCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkYXRhLmNhY2hlLmNhY2hlZE5vZGVzO1xuICB9O1xuICBcbiAgQ1JwLnVwZGF0ZU5vZGVzQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTsgdmFyIGN5ID0gdGhpcy5kYXRhLmN5O1xuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgZGF0YS5jYWNoZS5jYWNoZWROb2RlcyA9IGN5Lm5vZGVzKCk7XG4gIH07XG4gIFxuICBDUnAuZ2V0Q2FjaGVkRWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTsgdmFyIGN5ID0gdGhpcy5kYXRhLmN5O1xuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGRhdGEuY2FjaGUuY2FjaGVkRWRnZXMgPT0gbnVsbCkge1xuICAgICAgZGF0YS5jYWNoZS5jYWNoZWRFZGdlcyA9IGN5LmVkZ2VzKCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkYXRhLmNhY2hlLmNhY2hlZEVkZ2VzO1xuICB9O1xuICBcbiAgQ1JwLnVwZGF0ZUVkZ2VzQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTsgdmFyIGN5ID0gdGhpcy5kYXRhLmN5O1xuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgZGF0YS5jYWNoZS5jYWNoZWRFZGdlcyA9IGN5LmVkZ2VzKCk7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgLy8gUHJvamVjdCBtb3VzZVxuICBDUnAucHJvamVjdEludG9WaWV3cG9ydCA9IGZ1bmN0aW9uKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICB2YXIgb2Zmc2V0cyA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICB2YXIgb2Zmc2V0VG9wID0gb2Zmc2V0c1sxXTtcbiAgICBcbiAgICB2YXIgeCA9IGNsaWVudFggLSBvZmZzZXRMZWZ0OyBcbiAgICB2YXIgeSA9IGNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgXG4gICAgeCAtPSB0aGlzLmRhdGEuY3kucGFuKCkueDsgeSAtPSB0aGlzLmRhdGEuY3kucGFuKCkueTsgeCAvPSB0aGlzLmRhdGEuY3kuem9vbSgpOyB5IC89IHRoaXMuZGF0YS5jeS56b29tKCk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfTtcblxuICBDUnAuZmluZENvbnRhaW5lckNsaWVudENvb3JkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmRhdGEuY29udGFpbmVyO1xuXG4gICAgdmFyIGJiID0gdGhpcy5jb250YWluZXJCQiA9IHRoaXMuY29udGFpbmVyQkIgfHwgY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgcmV0dXJuIFtiYi5sZWZ0LCBiYi50b3AsIGJiLnJpZ2h0IC0gYmIubGVmdCwgYmIuYm90dG9tIC0gYmIudG9wXTtcbiAgfTtcblxuICBDUnAuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmNvbnRhaW5lckJCID0gbnVsbDtcbiAgfTtcblxuICAvLyBGaW5kIG5lYXJlc3QgZWxlbWVudFxuICBDUnAuZmluZE5lYXJlc3RFbGVtZW50ID0gZnVuY3Rpb24oeCwgeSwgdmlzaWJsZUVsZW1lbnRzT25seSwgaXNUb3VjaCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICAgIHZhciBuZWFyID0gW107XG4gICAgdmFyIHpvb20gPSB0aGlzLmRhdGEuY3kuem9vbSgpO1xuICAgIHZhciBoYXNDb21wb3VuZHMgPSB0aGlzLmRhdGEuY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBlZGdlVGhyZXNob2xkID0gKGlzVG91Y2ggPyAyNCA6IDgpIC8gem9vbTtcbiAgICB2YXIgbm9kZVRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrTm9kZShub2RlKXtcbiAgICAgIHZhciB3aWR0aCA9IG5vZGUub3V0ZXJXaWR0aCgpICsgMipub2RlVGhyZXNob2xkO1xuICAgICAgdmFyIGhlaWdodCA9IG5vZGUub3V0ZXJIZWlnaHQoKSArIDIqbm9kZVRocmVzaG9sZDtcbiAgICAgIHZhciBodyA9IHdpZHRoLzI7XG4gICAgICB2YXIgaGggPSBoZWlnaHQvMjtcbiAgICAgIHZhciBwb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICBpZihcbiAgICAgICAgcG9zLnggLSBodyA8PSB4ICYmIHggPD0gcG9zLnggKyBodyAvLyBiYiBjaGVjayB4XG4gICAgICAgICAgJiZcbiAgICAgICAgcG9zLnkgLSBoaCA8PSB5ICYmIHkgPD0gcG9zLnkgKyBoaCAvLyBiYiBjaGVjayB5XG4gICAgICApe1xuICAgICAgICB2YXIgdmlzaWJsZSA9ICF2aXNpYmxlRWxlbWVudHNPbmx5IHx8ICggbm9kZS52aXNpYmxlKCkgJiYgIW5vZGUudHJhbnNwYXJlbnQoKSApO1xuXG4gICAgICAgIC8vIGV4aXQgZWFybHkgaWYgaW52aXNpYmxlIGVkZ2UgYW5kIG11c3QgYmUgdmlzaWJsZVxuICAgICAgICBpZiggdmlzaWJsZUVsZW1lbnRzT25seSAmJiAhdmlzaWJsZSApe1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaGFwZSA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbIHNlbGYuZ2V0Tm9kZVNoYXBlKG5vZGUpIF07XG4gICAgICAgIHZhciBib3JkZXJXTyA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWUgLyAyO1xuXG4gICAgICAgIGlmKFxuICAgICAgICAgIHNoYXBlLmNoZWNrUG9pbnQoeCwgeSwgMCwgd2lkdGgsIGhlaWdodCwgcG9zLngsIHBvcy55KVxuICAgICAgICApe1xuICAgICAgICAgIG5lYXIucHVzaCggbm9kZSApO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0VkZ2UoZWRnZSl7XG4gICAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIHN0eWxlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciB3aWR0aCA9IHN0eWxlWyd3aWR0aCddLnB4VmFsdWUvMiArIGVkZ2VUaHJlc2hvbGQ7IC8vIG1vcmUgbGlrZSBhIGRpc3RhbmNlIHJhZGl1cyBmcm9tIGNlbnRyZVxuICAgICAgdmFyIHdpZHRoU3EgPSB3aWR0aCAqIHdpZHRoO1xuICAgICAgdmFyIHdpZHRoMiA9IHdpZHRoICogMjtcbiAgICAgIHZhciBzcmMgPSBlZGdlLl9wcml2YXRlLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSBlZGdlLl9wcml2YXRlLnRhcmdldDtcbiAgICAgIHZhciBpbkVkZ2VCQiA9IGZhbHNlO1xuICAgICAgdmFyIHNxRGlzdDtcblxuICAgICAgLy8gZXhpdCBlYXJseSBpZiBpbnZpc2libGUgZWRnZSBhbmQgbXVzdCBiZSB2aXNpYmxlXG4gICAgICB2YXIgcGFzc2VkVmlzaWJpbGl0eUNoZWNrO1xuICAgICAgdmFyIHBhc3Nlc1Zpc2liaWxpdHlDaGVjayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCBwYXNzZWRWaXNpYmlsaXR5Q2hlY2sgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHJldHVybiBwYXNzZWRWaXNpYmlsaXR5Q2hlY2s7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIXZpc2libGVFbGVtZW50c09ubHkgKXtcbiAgICAgICAgICBwYXNzZWRWaXNpYmlsaXR5Q2hlY2sgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZpc2libGUgPSBlZGdlLnZpc2libGUoKSAmJiAhZWRnZS50cmFuc3BhcmVudCgpO1xuICAgICAgICBpZiggdmlzaWJsZSApe1xuICAgICAgICAgIHBhc3NlZFZpc2liaWxpdHlDaGVjayA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBwYXNzZWRWaXNpYmlsaXR5Q2hlY2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgICAgaWYoXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIChpbkVkZ2VCQiA9ICQkLm1hdGguaW5CZXppZXJWaWNpbml0eSh4LCB5LCBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuY3AyYXgsIHJzLmNwMmF5LCBycy5zZWxmRWRnZU1pZFgsIHJzLnNlbGZFZGdlTWlkWSwgd2lkdGhTcSkpXG4gICAgICAgICAgICAgICAgJiYgcGFzc2VzVmlzaWJpbGl0eUNoZWNrKCkgJiZcbiAgICAgICAgICAgICAgKCB3aWR0aFNxID4gKHNxRGlzdCA9ICQkLm1hdGguc3FEaXN0YW5jZVRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5jcDJheCwgcnMuY3AyYXksIHJzLnNlbGZFZGdlTWlkWCwgcnMuc2VsZkVkZ2VNaWRZKSkgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB8fFxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAoaW5FZGdlQkIgPSAkJC5tYXRoLmluQmV6aWVyVmljaW5pdHkoeCwgeSwgcnMuc2VsZkVkZ2VNaWRYLCBycy5zZWxmRWRnZU1pZFksIHJzLmNwMmN4LCBycy5jcDJjeSwgcnMuZW5kWCwgcnMuZW5kWSwgd2lkdGhTcSkpXG4gICAgICAgICAgICAgICAgJiYgcGFzc2VzVmlzaWJpbGl0eUNoZWNrKCkgJiZcbiAgICAgICAgICAgICAgKCB3aWR0aFNxID4gKHNxRGlzdCA9ICQkLm1hdGguc3FEaXN0YW5jZVRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHJzLnNlbGZFZGdlTWlkWCwgcnMuc2VsZkVkZ2VNaWRZLCBycy5jcDJjeCwgcnMuY3AyY3ksIHJzLmVuZFgsIHJzLmVuZFkpKSApXG4gICAgICAgICAgICApXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICB2YXIgcmFkaXVzID0gc3R5bGVbJ2hheXN0YWNrLXJhZGl1cyddLnZhbHVlO1xuICAgICAgICB2YXIgaGFsZlJhZGl1cyA9IHJhZGl1cy8yOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgICAgIHZhciB0Z3RQb3MgPSB0Z3QuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIHZhciB0Z3RXID0gdGd0LndpZHRoKCk7XG4gICAgICAgIHZhciB0Z3RIID0gdGd0LmhlaWdodCgpO1xuICAgICAgICB2YXIgc3JjUG9zID0gc3JjLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgc3JjVyA9IHNyYy53aWR0aCgpO1xuICAgICAgICB2YXIgc3JjSCA9IHNyYy5oZWlnaHQoKTtcblxuICAgICAgICB2YXIgc3RhcnRYID0gc3JjUG9zLnggKyBycy5zb3VyY2UueCAqIHNyY1cgKiBoYWxmUmFkaXVzO1xuICAgICAgICB2YXIgc3RhcnRZID0gc3JjUG9zLnkgKyBycy5zb3VyY2UueSAqIHNyY0ggKiBoYWxmUmFkaXVzO1xuICAgICAgICB2YXIgZW5kWCA9IHRndFBvcy54ICsgcnMudGFyZ2V0LnggKiB0Z3RXICogaGFsZlJhZGl1cztcbiAgICAgICAgdmFyIGVuZFkgPSB0Z3RQb3MueSArIHJzLnRhcmdldC55ICogdGd0SCAqIGhhbGZSYWRpdXM7XG5cbiAgICAgICAgaWYoIFxuICAgICAgICAgIChpbkVkZ2VCQiA9ICQkLm1hdGguaW5MaW5lVmljaW5pdHkoeCwgeSwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIHdpZHRoMikpXG4gICAgICAgICAgICAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJlxuICAgICAgICAgIHdpZHRoU3EgPiAoIHNxRGlzdCA9ICQkLm1hdGguc3FEaXN0YW5jZVRvRmluaXRlTGluZSggeCwgeSwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFkgKSApXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgICBpZihcbiAgICAgICAgICAoaW5FZGdlQkIgPSAkJC5tYXRoLmluTGluZVZpY2luaXR5KHgsIHksIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5lbmRYLCBycy5lbmRZLCB3aWR0aDIpKVxuICAgICAgICAgICAgJiYgcGFzc2VzVmlzaWJpbGl0eUNoZWNrKCkgJiZcbiAgICAgICAgICB3aWR0aFNxID4gKCBzcURpc3QgPSAkJC5tYXRoLnNxRGlzdGFuY2VUb0Zpbml0ZUxpbmUoeCwgeSwgcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmVuZFgsIHJzLmVuZFkpIClcbiAgICAgICAgKXtcbiAgICAgICAgICBuZWFyLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuICAgICAgXG4gICAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJykge1xuICAgICAgICBpZihcbiAgICAgICAgICAoaW5FZGdlQkIgPSAkJC5tYXRoLmluQmV6aWVyVmljaW5pdHkoeCwgeSwgcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmNwMngsIHJzLmNwMnksIHJzLmVuZFgsIHJzLmVuZFksIHdpZHRoU3EpKVxuICAgICAgICAgICAgJiYgcGFzc2VzVmlzaWJpbGl0eUNoZWNrKCkgJiZcbiAgICAgICAgICAod2lkdGhTcSA+IChzcURpc3QgPSAkJC5tYXRoLnNxRGlzdGFuY2VUb1F1YWRyYXRpY0Jlemllcih4LCB5LCBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuY3AyeCwgcnMuY3AyeSwgcnMuZW5kWCwgcnMuZW5kWSkpIClcbiAgICAgICAgKXtcbiAgICAgICAgICBuZWFyLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBpZiB3ZSdyZSBjbG9zZSB0byB0aGUgZWRnZSBidXQgZGlkbid0IGhpdCBpdCwgbWF5YmUgd2UgaGl0IGl0cyBhcnJvd3NcbiAgICAgIGlmKCBpbkVkZ2VCQiAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJiBuZWFyLmxlbmd0aCA9PT0gMCB8fCBuZWFyW25lYXIubGVuZ3RoIC0gMV0gIT09IGVkZ2UgKXtcbiAgICAgICAgdmFyIHNyY1NoYXBlID0gQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbIHN0eWxlWydzb3VyY2UtYXJyb3ctc2hhcGUnXS52YWx1ZSBdO1xuICAgICAgICB2YXIgdGd0U2hhcGUgPSBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1sgc3R5bGVbJ3RhcmdldC1hcnJvdy1zaGFwZSddLnZhbHVlIF07XG5cbiAgICAgICAgdmFyIHNyYyA9IHNyYyB8fCBlZGdlLl9wcml2YXRlLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IHRndCB8fCBlZGdlLl9wcml2YXRlLnRhcmdldDtcblxuICAgICAgICB2YXIgdGd0UG9zID0gdGd0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgc3JjUG9zID0gc3JjLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAgIHZhciBzcmNBclcgPSBzZWxmLmdldEFycm93V2lkdGgoIHN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKTtcbiAgICAgICAgdmFyIHNyY0FySCA9IHNlbGYuZ2V0QXJyb3dIZWlnaHQoIHN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKTtcblxuICAgICAgICB2YXIgdGd0QXJXID0gc3JjQXJXO1xuICAgICAgICB2YXIgdGd0QXJIID0gc3JjQXJIO1xuXG4gICAgICAgIGlmKFxuICAgICAgICAgIChcbiAgICAgICAgICAgIHNyY1NoYXBlLnJvdWdoQ29sbGlkZSh4LCB5LCBycy5hcnJvd1N0YXJ0WCwgcnMuYXJyb3dTdGFydFksIHNyY0FyVywgc3JjQXJILCBbcnMuYXJyb3dTdGFydFggLSBzcmNQb3MueCwgcnMuYXJyb3dTdGFydFkgLSBzcmNQb3MueV0sIGVkZ2VUaHJlc2hvbGQpXG4gICAgICAgICAgICAgICYmIFxuICAgICAgICAgICAgc3JjU2hhcGUuY29sbGlkZSh4LCB5LCBycy5hcnJvd1N0YXJ0WCwgcnMuYXJyb3dTdGFydFksIHNyY0FyVywgc3JjQXJILCBbcnMuYXJyb3dTdGFydFggLSBzcmNQb3MueCwgcnMuYXJyb3dTdGFydFkgLSBzcmNQb3MueV0sIGVkZ2VUaHJlc2hvbGQpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgfHxcbiAgICAgICAgICAoXG4gICAgICAgICAgICB0Z3RTaGFwZS5yb3VnaENvbGxpZGUoeCwgeSwgcnMuYXJyb3dFbmRYLCBycy5hcnJvd0VuZFksIHRndEFyVywgdGd0QXJILCBbcnMuYXJyb3dFbmRYIC0gdGd0UG9zLngsIHJzLmFycm93RW5kWSAtIHRndFBvcy55XSwgZWRnZVRocmVzaG9sZClcbiAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgIHRndFNoYXBlLmNvbGxpZGUoeCwgeSwgcnMuYXJyb3dFbmRYLCBycy5hcnJvd0VuZFksIHRndEFyVywgdGd0QXJILCBbcnMuYXJyb3dFbmRYIC0gdGd0UG9zLngsIHJzLmFycm93RW5kWSAtIHRndFBvcy55XSwgZWRnZVRocmVzaG9sZClcbiAgICAgICAgICApXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGNvbXBvdW5kIGdyYXBocywgaGl0dGluZyBlZGdlIG1heSBhY3R1YWxseSB3YW50IGEgY29ubmVjdGVkIG5vZGUgaW5zdGVhZCAoYi9jIGVkZ2UgbWF5IGhhdmUgZ3JlYXRlciB6LWluZGV4IHByZWNlZGVuY2UpXG4gICAgICBpZiggaGFzQ29tcG91bmRzICYmICBuZWFyLmxlbmd0aCA+IDAgJiYgbmVhclsgbmVhci5sZW5ndGggLSAxIF0gPT09IGVkZ2UgKXtcbiAgICAgICAgY2hlY2tOb2RlKCBzcmMgKTtcbiAgICAgICAgY2hlY2tOb2RlKCB0Z3QgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gZWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApeyAvLyByZXZlcnNlIG9yZGVyIGZvciBwcmVjZWRlbmNlXG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgaWYoIG5lYXIubGVuZ3RoID4gMCApeyBicmVhazsgfSAvLyBzaW5jZSB3ZSBjaGVjayBpbiB6LW9yZGVyLCBmaXJzdCBmb3VuZCBpcyB0b3AgYW5kIGJlc3QgcmVzdWx0ID0+IGV4aXQgZWFybHlcblxuICAgICAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJyApeyBcbiAgICAgICAgY2hlY2tOb2RlKCBlbGVzW2ldICk7XG5cbiAgICAgIH0gZWxzZSAgeyAvLyB0aGVuIGVkZ2VcbiAgICAgICAgY2hlY2tFZGdlKCBlbGVzW2ldICk7XG4gICAgICB9XG5cbiAgICB9XG4gIFxuICAgIFxuICAgIGlmKCBuZWFyLmxlbmd0aCA+IDAgKXtcbiAgICAgIHJldHVybiBuZWFyWyBuZWFyLmxlbmd0aCAtIDEgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9OyBcblxuICAvLyAnR2l2ZSBtZSBldmVyeXRoaW5nIGZyb20gdGhpcyBib3gnXG4gIENScC5nZXRBbGxJbkJveCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5nZXRDYWNoZWROb2RlcygpO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgICB2YXIgYm94ID0gW107XG4gICAgXG4gICAgdmFyIHgxYyA9IE1hdGgubWluKHgxLCB4Mik7XG4gICAgdmFyIHgyYyA9IE1hdGgubWF4KHgxLCB4Mik7XG4gICAgdmFyIHkxYyA9IE1hdGgubWluKHkxLCB5Mik7XG4gICAgdmFyIHkyYyA9IE1hdGgubWF4KHkxLCB5Mik7IFxuXG4gICAgeDEgPSB4MWM7IFxuICAgIHgyID0geDJjOyBcbiAgICB5MSA9IHkxYzsgXG4gICAgeTIgPSB5MmM7IFxuXG4gICAgdmFyIGhldXI7XG4gICAgXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwb3MgPSBub2Rlc1tpXS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIHZhciBuU2hhcGUgPSB0aGlzLmdldE5vZGVTaGFwZShub2Rlc1tpXSk7XG4gICAgICB2YXIgdyA9IHRoaXMuZ2V0Tm9kZVdpZHRoKG5vZGVzW2ldKTtcbiAgICAgIHZhciBoID0gdGhpcy5nZXROb2RlSGVpZ2h0KG5vZGVzW2ldKTtcbiAgICAgIHZhciBib3JkZXIgPSBub2Rlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZSAvIDI7XG4gICAgICB2YXIgc2hhcGVPYmogPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzWyBuU2hhcGUgXTtcblxuICAgICAgaWYgKCBzaGFwZU9iai5pbnRlcnNlY3RCb3goeDEsIHkxLCB4MiwgeTIsIHcsIGgsIHBvcy54LCBwb3MueSwgYm9yZGVyKSApe1xuICAgICAgICBib3gucHVzaChub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcnMgPSBlZGdlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgICAgaWYgKGVkZ2VzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmVkZ2VUeXBlID09ICdzZWxmJykge1xuICAgICAgICBpZiAoKGhldXIgPSAkJC5tYXRoLmJveEluQmV6aWVyVmljaW5pdHkoeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgIHJzLmNwMmF4LCBycy5jcDJheSxcbiAgICAgICAgICAgIHJzLmVuZFgsIHJzLmVuZFksIGVkZ2VzW2ldLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpKVxuICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgKGhldXIgPT0gMiB8fCAoaGV1ciA9PSAxICYmICQkLm1hdGguY2hlY2tCZXppZXJJbkJveCh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICAgIHJzLmNwMmF4LCBycy5jcDJheSxcbiAgICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpKVxuICAgICAgICAgICAgICAgIHx8XG4gICAgICAgICAgKGhldXIgPSAkJC5tYXRoLmJveEluQmV6aWVyVmljaW5pdHkoeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgIHJzLmNwMmN4LCBycy5jcDJjeSxcbiAgICAgICAgICAgIHJzLmVuZFgsIHJzLmVuZFksIGVkZ2VzW2ldLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpKVxuICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgKGhldXIgPT0gMiB8fCAoaGV1ciA9PSAxICYmICQkLm1hdGguY2hlY2tCZXppZXJJbkJveCh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICAgIHJzLmNwMmN4LCBycy5jcDJjeSxcbiAgICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpKVxuICAgICAgICAgIClcbiAgICAgICAgeyBib3gucHVzaChlZGdlc1tpXSk7IH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09ICdiZXppZXInICYmXG4gICAgICAgIChoZXVyID0gJCQubWF0aC5ib3hJbkJlemllclZpY2luaXR5KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICBycy5jcDJ4LCBycy5jcDJ5LFxuICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpXG4gICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAoaGV1ciA9PSAyIHx8IChoZXVyID09IDEgJiYgJCQubWF0aC5jaGVja0JlemllckluQm94KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgICAgcnMuY3AyeCwgcnMuY3AyeSxcbiAgICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpKSlcbiAgICAgICAgeyBib3gucHVzaChlZGdlc1tpXSk7IH1cbiAgICBcbiAgICAgIGlmIChycy5lZGdlVHlwZSA9PSAnc3RyYWlnaHQnICYmXG4gICAgICAgIChoZXVyID0gJCQubWF0aC5ib3hJbkJlemllclZpY2luaXR5KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICBycy5zdGFydFggKiAwLjUgKyBycy5lbmRYICogMC41LCBcbiAgICAgICAgICAgIHJzLnN0YXJ0WSAqIDAuNSArIHJzLmVuZFkgKiAwLjUsIFxuICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpXG4gICAgICAgICAgICAgICYmIC8qIGNvbnNvbGUubG9nKCd0ZXN0JywgaGV1cikgPT0gdW5kZWZpbmVkICYmICovXG4gICAgICAgICAgICAoaGV1ciA9PSAyIHx8IChoZXVyID09IDEgJiYgJCQubWF0aC5jaGVja1N0cmFpZ2h0RWRnZUluQm94KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpKSlcbiAgICAgICAgeyBib3gucHVzaChlZGdlc1tpXSk7IH1cblxuXG4gICAgICBpZiAocnMuZWRnZVR5cGUgPT0gJ2hheXN0YWNrJyl7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlc1tpXS50YXJnZXQoKVswXTtcbiAgICAgICAgdmFyIHRndFBvcyA9IHRndC5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgc3JjID0gZWRnZXNbaV0uc291cmNlKClbMF07XG4gICAgICAgIHZhciBzcmNQb3MgPSBzcmMucG9zaXRpb24oKTtcblxuICAgICAgICB2YXIgc3RhcnRYID0gc3JjUG9zLnggKyBycy5zb3VyY2UueDtcbiAgICAgICAgdmFyIHN0YXJ0WSA9IHNyY1Bvcy55ICsgcnMuc291cmNlLnk7XG4gICAgICAgIHZhciBlbmRYID0gdGd0UG9zLnggKyBycy50YXJnZXQueDtcbiAgICAgICAgdmFyIGVuZFkgPSB0Z3RQb3MueSArIHJzLnRhcmdldC55O1xuXG4gICAgICAgIHZhciBzdGFydEluQm94ID0gKHgxIDw9IHN0YXJ0WCAmJiBzdGFydFggPD0geDIpICYmICh5MSA8PSBzdGFydFkgJiYgc3RhcnRZIDw9IHkyKTtcbiAgICAgICAgdmFyIGVuZEluQm94ID0gKHgxIDw9IGVuZFggJiYgZW5kWCA8PSB4MikgJiYgKHkxIDw9IGVuZFkgJiYgZW5kWSA8PSB5Mik7XG5cbiAgICAgICAgaWYoIHN0YXJ0SW5Cb3ggJiYgZW5kSW5Cb3ggKXtcbiAgICAgICAgICBib3gucHVzaCggZWRnZXNbaV0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBib3g7XG4gIH07XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSB3aWR0aCBpcyBzZXQgdG8gYXV0byxcbiAgICogcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGF1dG9XaWR0aCBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIG5vZGUgICAgICAgICAgYSBub2RlXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIHdpZHRoIG9mIHRoZSBub2RlXG4gICAqL1xuICBDUnAuZ2V0Tm9kZVdpZHRoID0gZnVuY3Rpb24obm9kZSlcbiAge1xuICAgIHJldHVybiBub2RlLndpZHRoKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZ2l2ZW4gbm9kZS4gSWYgdGhlIGhlaWdodCBpcyBzZXQgdG8gYXV0byxcbiAgICogcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGF1dG9IZWlnaHQgZmllbGQuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlICAgICAgICAgIGEgbm9kZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICB3aWR0aCBvZiB0aGUgbm9kZVxuICAgKi9cbiAgQ1JwLmdldE5vZGVIZWlnaHQgPSBmdW5jdGlvbihub2RlKVxuICB7XG4gICAgcmV0dXJuIG5vZGUuaGVpZ2h0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNoYXBlIG9mIHRoZSBnaXZlbiBub2RlLiBJZiB0aGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSBnaXZlbiBub2RlXG4gICAqIGlzIHNldCB0byBhdXRvLCB0aGUgbm9kZSBpcyBjb25zaWRlcmVkIHRvIGJlIGEgY29tcG91bmQuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlICAgICAgICAgIGEgbm9kZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBzaGFwZSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgQ1JwLmdldE5vZGVTaGFwZSA9IGZ1bmN0aW9uKG5vZGUpXG4gIHtcbiAgICAvLyBUT0RPIG9ubHkgYWxsb3cgcmVjdGFuZ2xlIGZvciBhIGNvbXBvdW5kIG5vZGU/XG4vLyAgICBpZiAobm9kZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS52YWx1ZSA9PSAnYXV0bycgfHxcbi8vICAgICAgICBub2RlLl9wcml2YXRlLnN0eWxlWydoZWlnaHQnXS52YWx1ZSA9PSAnYXV0bycpXG4vLyAgICB7XG4vLyAgICAgIHJldHVybiAncmVjdGFuZ2xlJztcbi8vICAgIH1cblxuICAgIHZhciBzaGFwZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3NoYXBlJ10udmFsdWU7XG5cbiAgICBpZiggbm9kZS5pc1BhcmVudCgpICl7XG4gICAgICBpZiggc2hhcGUgPT09ICdyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAncm91bmRyZWN0YW5nbGUnICl7XG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAncmVjdGFuZ2xlJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hhcGU7XG4gIH07XG5cblxuICBDUnAuZ2V0Tm9kZVBhZGRpbmcgPSBmdW5jdGlvbihub2RlKVxuICB7XG4gICAgdmFyIGxlZnQgPSBub2RlLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLWxlZnQnXS5weFZhbHVlO1xuICAgIHZhciByaWdodCA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctcmlnaHQnXS5weFZhbHVlO1xuICAgIHZhciB0b3AgPSBub2RlLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLXRvcCddLnB4VmFsdWU7XG4gICAgdmFyIGJvdHRvbSA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10ucHhWYWx1ZTtcblxuICAgIGlmIChpc05hTihsZWZ0KSlcbiAgICB7XG4gICAgICBsZWZ0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4ocmlnaHQpKVxuICAgIHtcbiAgICAgIHJpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4odG9wKSlcbiAgICB7XG4gICAgICB0b3AgPSAwO1xuICAgIH1cblxuICAgIGlmIChpc05hTihib3R0b20pKVxuICAgIHtcbiAgICAgIGJvdHRvbSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtsZWZ0IDogbGVmdCxcbiAgICAgIHJpZ2h0IDogcmlnaHQsXG4gICAgICB0b3AgOiB0b3AsXG4gICAgICBib3R0b20gOiBib3R0b219O1xuICB9O1xuXG4gIENScC56T3JkZXJTb3J0ID0gJCQuQ29sbGVjdGlvbi56SW5kZXhTb3J0O1xuXG4gIENScC51cGRhdGVDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcyggdHJ1ZSApO1xuICB9O1xuXG4gIENScC5nZXRDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uKCBmb3JjZVJlY2FsYyApe1xuICAgIHZhciBsYXN0Tm9kZXMgPSB0aGlzLmxhc3RaT3JkZXJDYWNoZWROb2RlcztcbiAgICB2YXIgbGFzdEVkZ2VzID0gdGhpcy5sYXN0Wk9yZGVyQ2FjaGVkRWRnZXM7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5nZXRDYWNoZWROb2RlcygpO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgICB2YXIgZWxlcyA9IFtdO1xuXG4gICAgaWYoIGZvcmNlUmVjYWxjIHx8ICFsYXN0Tm9kZXMgfHwgIWxhc3RFZGdlcyB8fCBsYXN0Tm9kZXMgIT09IG5vZGVzIHx8IGxhc3RFZGdlcyAhPT0gZWRnZXMgKXsgXG4gICAgICAvL2NvbnNvbGUudGltZSgnY2FjaGV6b3JkZXInKVxuICAgICAgXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCBub2Rlc1tpXS52aXNpYmxlKCkgJiYgIW5vZGVzW2ldLnRyYW5zcGFyZW50KCkgKXtcbiAgICAgICAgICBlbGVzLnB1c2goIG5vZGVzW2ldICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBpZiggZWRnZXNbaV0udmlzaWJsZSgpICYmICFlZGdlc1tpXS50cmFuc3BhcmVudCgpICl7XG4gICAgICAgICAgZWxlcy5wdXNoKCBlZGdlc1tpXSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsZXMuc29ydCggdGhpcy56T3JkZXJTb3J0ICk7XG4gICAgICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gZWxlcztcbiAgICAgIC8vY29uc29sZS5sb2coJ21ha2UgY2FjaGUnKVxuXG4gICAgICAvL2NvbnNvbGUudGltZUVuZCgnY2FjaGV6b3JkZXInKVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcbiAgICAgIC8vY29uc29sZS5sb2coJ3JlYWQgY2FjaGUnKVxuICAgIH1cblxuICAgIHRoaXMubGFzdFpPcmRlckNhY2hlZE5vZGVzID0gbm9kZXM7XG4gICAgdGhpcy5sYXN0Wk9yZGVyQ2FjaGVkRWRnZXMgPSBlZGdlcztcblxuICAgIHJldHVybiBlbGVzO1xuICB9O1xuXG4gIENScC5wcm9qZWN0QmV6aWVyID0gZnVuY3Rpb24oZWRnZSl7XG4gICAgdmFyIHFiZXppZXJBdCA9ICQkLm1hdGgucWJlemllckF0O1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGJwdHMgPSBlZGdlLl9wcml2YXRlLnJzdHlsZS5iZXppZXJQdHMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHB1c2hCZXppZXJQdHMocHRzKXtcbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC4wNSApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuMDUgKVxuICAgICAgfSk7XG5cbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC4yNSApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuMjUgKVxuICAgICAgfSk7XG5cbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC40ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC40IClcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbWlkID0ge1xuICAgICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuNSApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuNSApXG4gICAgICB9O1xuXG4gICAgICBicHRzLnB1c2goIG1pZCApO1xuXG4gICAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyApe1xuICAgICAgICBycy5taWRYID0gcnMuc2VsZkVkZ2VNaWRYO1xuICAgICAgICBycy5taWRZID0gcnMuc2VsZkVkZ2VNaWRZO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMubWlkWCA9IG1pZC54O1xuICAgICAgICBycy5taWRZID0gbWlkLnk7XG4gICAgICB9XG5cbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC42ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC42IClcbiAgICAgIH0pO1xuXG4gICAgICBicHRzLnB1c2goe1xuICAgICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuNzUgKSxcbiAgICAgICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjc1IClcbiAgICAgIH0pO1xuXG4gICAgICBicHRzLnB1c2goe1xuICAgICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuOTUgKSxcbiAgICAgICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjk1IClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnICl7XG4gICAgICBwdXNoQmV6aWVyUHRzKCBbcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmNwMmF4LCBycy5jcDJheSwgcnMuc2VsZkVkZ2VNaWRYLCBycy5zZWxmRWRnZU1pZFldICk7XG4gICAgICBwdXNoQmV6aWVyUHRzKCBbcnMuc2VsZkVkZ2VNaWRYLCBycy5zZWxmRWRnZU1pZFksIHJzLmNwMmN4LCBycy5jcDJjeSwgcnMuZW5kWCwgcnMuZW5kWV0gKTtcbiAgICB9IGVsc2UgaWYoIHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyApe1xuICAgICAgcHVzaEJlemllclB0cyggW3JzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5jcDJ4LCBycy5jcDJ5LCBycy5lbmRYLCBycy5lbmRZXSApO1xuICAgIH1cbiAgfTtcblxuICBDUnAucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uID0gZnVuY3Rpb24oIG5vZGUgKXsgXG4gICAgdmFyIGNvbnRlbnQgPSBub2RlLl9wcml2YXRlLnN0eWxlWydjb250ZW50J10uc3RyVmFsdWU7XG4gICAgaWYoICFjb250ZW50IHx8IGNvbnRlbnQubWF0Y2goL15cXHMrJC8pICl7IHJldHVybjsgfVxuXG4gICAgdmFyIHRleHRYLCB0ZXh0WTtcbiAgICB2YXIgbm9kZVdpZHRoID0gbm9kZS5vdXRlcldpZHRoKCk7XG4gICAgdmFyIG5vZGVIZWlnaHQgPSBub2RlLm91dGVySGVpZ2h0KCk7XG4gICAgdmFyIG5vZGVQb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgIHZhciB0ZXh0SGFsaWduID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsndGV4dC1oYWxpZ24nXS5zdHJWYWx1ZTtcbiAgICB2YXIgdGV4dFZhbGlnbiA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3RleHQtdmFsaWduJ10uc3RyVmFsdWU7XG4gICAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgcnN0eWxlID0gbm9kZS5fcHJpdmF0ZS5yc3R5bGU7XG5cbiAgICBzd2l0Y2goIHRleHRIYWxpZ24gKXtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICB0ZXh0WCA9IG5vZGVQb3MueCAtIG5vZGVXaWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIHRleHRYID0gbm9kZVBvcy54ICsgbm9kZVdpZHRoIC8gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6IC8vIGUuZy4gY2VudGVyXG4gICAgICAgIHRleHRYID0gbm9kZVBvcy54O1xuICAgIH1cblxuICAgIHN3aXRjaCggdGV4dFZhbGlnbiApe1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgdGV4dFkgPSBub2RlUG9zLnkgLSBub2RlSGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHRleHRZID0gbm9kZVBvcy55ICsgbm9kZUhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OiAvLyBlLmcuIG1pZGRsZVxuICAgICAgICB0ZXh0WSA9IG5vZGVQb3MueTtcbiAgICB9XG4gIFxuICAgIHJzLmxhYmVsWCA9IHRleHRYO1xuICAgIHJzLmxhYmVsWSA9IHRleHRZO1xuICAgIHJzdHlsZS5sYWJlbFggPSB0ZXh0WDtcbiAgICByc3R5bGUubGFiZWxZID0gdGV4dFk7XG5cbiAgICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKCBub2RlICk7XG4gIH07XG5cbiAgQ1JwLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgdmFyIGNvbnRlbnQgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydjb250ZW50J10uc3RyVmFsdWU7XG4gICAgaWYoICFjb250ZW50IHx8IGNvbnRlbnQubWF0Y2goL15cXHMrJC8pICl7IHJldHVybjsgfVxuXG4gICAgdmFyIHRleHRYLCB0ZXh0WTsgIFxuICAgIHZhciBlZGdlQ2VudGVyWCwgZWRnZUNlbnRlclk7XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICAvL3ZhciBzdHlsZSA9IF9wLnN0eWxlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgXG4gICAgaWYgKHJzLmVkZ2VUeXBlID09ICdzZWxmJykge1xuICAgICAgZWRnZUNlbnRlclggPSBycy5zZWxmRWRnZU1pZFg7XG4gICAgICBlZGdlQ2VudGVyWSA9IHJzLnNlbGZFZGdlTWlkWTtcbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09ICdzdHJhaWdodCcpIHtcbiAgICAgIGVkZ2VDZW50ZXJYID0gKHJzLnN0YXJ0WCArIHJzLmVuZFgpIC8gMjtcbiAgICAgIGVkZ2VDZW50ZXJZID0gKHJzLnN0YXJ0WSArIHJzLmVuZFkpIC8gMjtcbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09ICdiZXppZXInKSB7XG4gICAgICBlZGdlQ2VudGVyWCA9ICQkLm1hdGgucWJlemllckF0KCBycy5zdGFydFgsIHJzLmNwMngsIHJzLmVuZFgsIDAuNSApO1xuICAgICAgZWRnZUNlbnRlclkgPSAkJC5tYXRoLnFiZXppZXJBdCggcnMuc3RhcnRZLCBycy5jcDJ5LCBycy5lbmRZLCAwLjUgKTtcbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09ICdoYXlzdGFjaycpIHtcbiAgICAgIC8vIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICAvLyB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgLy8gdmFyIHNyY1BvcyA9IHNyYy5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIC8vIHZhciB0Z3RQb3MgPSB0Z3QuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB2YXIgcHRzID0gcnMuaGF5c3RhY2tQdHM7XG5cbiAgICAgIGVkZ2VDZW50ZXJYID0gKCBwdHNbMF0gKyBwdHNbMl0gKS8yO1xuICAgICAgZWRnZUNlbnRlclkgPSAoIHB0c1sxXSArIHB0c1szXSApLzI7XG4gICAgfVxuICAgIFxuICAgIHRleHRYID0gZWRnZUNlbnRlclg7XG4gICAgdGV4dFkgPSBlZGdlQ2VudGVyWTtcblxuICAgIC8vIGFkZCBjZW50ZXIgcG9pbnQgdG8gc3R5bGUgc28gYm91bmRpbmcgYm94IGNhbGN1bGF0aW9ucyBjYW4gdXNlIGl0XG4gICAgcnMubGFiZWxYID0gdGV4dFg7XG4gICAgcnMubGFiZWxZID0gdGV4dFk7XG4gICAgcnN0eWxlLmxhYmVsWCA9IHRleHRYO1xuICAgIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcblxuICAgIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoIGVkZ2UgKTtcbiAgfTtcblxuICBDUnAuYXBwbHlMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciByc3R5bGUgPSBlbGUuX3ByaXZhdGUucnN0eWxlO1xuXG4gICAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dCggZWxlICk7XG4gICAgdmFyIGxhYmVsRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKCBlbGUsIHRleHQgKTtcbiBcbiAgICByc3R5bGUubGFiZWxXaWR0aCA9IGxhYmVsRGltcy53aWR0aDtcbiAgICBycy5sYWJlbFdpZHRoID0gbGFiZWxEaW1zLndpZHRoO1xuIFxuICAgIHJzdHlsZS5sYWJlbEhlaWdodCA9IGxhYmVsRGltcy5oZWlnaHQ7XG4gICAgcnMubGFiZWxIZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0O1xuICB9O1xuXG4gIENScC5nZXRMYWJlbFRleHQgPSBmdW5jdGlvbiggZWxlICl7IFxuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgdGV4dCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuICAgIHZhciB0ZXh0VHJhbnNmb3JtID0gc3R5bGVbJ3RleHQtdHJhbnNmb3JtJ10udmFsdWU7XG4gICAgdmFyIHJzY3JhdGNoID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIFxuICAgIGlmICh0ZXh0VHJhbnNmb3JtID09ICdub25lJykge1xuICAgIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAndXBwZXJjYXNlJykge1xuICAgICAgdGV4dCA9IHRleHQudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ2xvd2VyY2FzZScpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYoIHN0eWxlWyd0ZXh0LXdyYXAnXS52YWx1ZSA9PT0gJ3dyYXAnICl7XG4gICAgICAvL2NvbnNvbGUubG9nKCd3cmFwJyk7IFxuICAgICAgXG4gICAgICAvLyBzYXZlIHJlY2FsYyBpZiB0aGUgbGFiZWwgaXMgdGhlIHNhbWUgYXMgYmVmb3JlXG4gICAgICBpZiggcnNjcmF0Y2gubGFiZWxXcmFwS2V5ID09PSByc2NyYXRjaC5sYWJlbEtleSApeyBcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3dyYXAgY2FjaGUgaGl0Jyk7XG4gICAgICAgIHJldHVybiByc2NyYXRjaC5sYWJlbFdyYXBDYWNoZWRUZXh0O1xuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coJ3dyYXAgY2FjaGUgbWlzcycpO1xuXG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBtYXhXID0gc3R5bGVbJ3RleHQtbWF4LXdpZHRoJ10ucHhWYWx1ZTtcbiAgICAgIHZhciB3cmFwcGVkTGluZXMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKyApe1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xdO1xuICAgICAgICB2YXIgbGluZURpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyggZWxlLCBsaW5lLCAnbGluZT0nICsgbGluZSApO1xuICAgICAgICB2YXIgbGluZVcgPSBsaW5lRGltcy53aWR0aDtcblxuICAgICAgICBpZiggbGluZVcgPiBtYXhXICl7IC8vIGxpbmUgaXMgdG9vIGxvbmdcbiAgICAgICAgICB2YXIgd29yZHMgPSBsaW5lLnNwbGl0KC9cXHMrLyk7IC8vIE5COiBhc3N1bWUgY29sbGFwc2VkIHdoaXRlc3BhY2UgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB2YXIgc3VibGluZSA9ICcnO1xuXG4gICAgICAgICAgZm9yKCB2YXIgdyA9IDA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKyApe1xuICAgICAgICAgICAgdmFyIHdvcmQgPSB3b3Jkc1t3XTtcbiAgICAgICAgICAgIHZhciB0ZXN0TGluZSA9IHN1YmxpbmUubGVuZ3RoID09PSAwID8gd29yZCA6IHN1YmxpbmUgKyAnICcgKyB3b3JkO1xuICAgICAgICAgICAgdmFyIHRlc3REaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoIGVsZSwgdGVzdExpbmUsICd0ZXN0TGluZT0nICsgdGVzdExpbmUgKTtcbiAgICAgICAgICAgIHZhciB0ZXN0VyA9IHRlc3REaW1zLndpZHRoO1xuXG4gICAgICAgICAgICBpZiggdGVzdFcgPD0gbWF4VyApeyAvLyB3b3JkIGZpdHMgb24gY3VycmVudCBsaW5lXG4gICAgICAgICAgICAgIHN1YmxpbmUgKz0gd29yZCArICcgJztcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHdvcmQgc3RhcnRzIG5ldyBsaW5lXG4gICAgICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKCBzdWJsaW5lICk7XG4gICAgICAgICAgICAgIHN1YmxpbmUgPSB3b3JkICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHRleHQsIHB1dCBpdCBpbiBhIHdyYXBwZWQgbGluZVxuICAgICAgICAgIGlmKCAhc3VibGluZS5tYXRjaCgvXlxccyskLykgKXtcbiAgICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKCBzdWJsaW5lICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBsaW5lIGlzIGFscmVhZHkgc2hvcnQgZW5vdWdoXG4gICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goIGxpbmUgKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcblxuICAgICAgcnNjcmF0Y2gubGFiZWxXcmFwQ2FjaGVkTGluZXMgPSB3cmFwcGVkTGluZXM7XG4gICAgICByc2NyYXRjaC5sYWJlbFdyYXBDYWNoZWRUZXh0ID0gdGV4dCA9IHdyYXBwZWRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgIHJzY3JhdGNoLmxhYmVsV3JhcEtleSA9IHJzY3JhdGNoLmxhYmVsS2V5O1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyh0ZXh0KVxuICAgIH0gLy8gaWYgd3JhcFxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG5cbiAgQ1JwLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uKCBlbGUsIHRleHQsIGV4dHJhS2V5ICl7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgZlN0eWxlID0gc3R5bGVbJ2ZvbnQtc3R5bGUnXS5zdHJWYWx1ZTtcbiAgICB2YXIgc2l6ZSA9IHN0eWxlWydmb250LXNpemUnXS5weFZhbHVlICsgJ3B4JztcbiAgICB2YXIgZmFtaWx5ID0gc3R5bGVbJ2ZvbnQtZmFtaWx5J10uc3RyVmFsdWU7XG4gICAgLy8gdmFyIHZhcmlhbnQgPSBzdHlsZVsnZm9udC12YXJpYW50J10uc3RyVmFsdWU7XG4gICAgdmFyIHdlaWdodCA9IHN0eWxlWydmb250LXdlaWdodCddLnN0clZhbHVlO1xuXG4gICAgdmFyIGNhY2hlS2V5ID0gZWxlLl9wcml2YXRlLmxhYmVsS2V5O1xuXG4gICAgaWYoIGV4dHJhS2V5ICl7XG4gICAgICBjYWNoZUtleSArPSAnJEAkJyArIGV4dHJhS2V5O1xuICAgIH1cblxuICAgIHZhciBjYWNoZSA9IHIubGFiZWxEaW1DYWNoZSB8fCAoci5sYWJlbERpbUNhY2hlID0ge30pO1xuXG4gICAgaWYoIGNhY2hlW2NhY2hlS2V5XSApe1xuICAgICAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGl2ID0gdGhpcy5sYWJlbENhbGNEaXY7XG5cbiAgICBpZiggIWRpdiApe1xuICAgICAgZGl2ID0gdGhpcy5sYWJlbENhbGNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuICAgIH1cblxuICAgIHZhciBkcyA9IGRpdi5zdHlsZTtcblxuICAgIC8vIGZyb20gZWxlIHN0eWxlXG4gICAgZHMuZm9udEZhbWlseSA9IGZhbWlseTtcbiAgICBkcy5mb250U3R5bGUgPSBmU3R5bGU7XG4gICAgZHMuZm9udFNpemUgPSBzaXplO1xuICAgIC8vIGRzLmZvbnRWYXJpYW50ID0gdmFyaWFudDtcbiAgICBkcy5mb250V2VpZ2h0ID0gd2VpZ2h0O1xuXG4gICAgLy8gZm9yY2VkIHN0eWxlXG4gICAgZHMucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRzLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgZHMudG9wID0gJy05OTk5cHgnO1xuICAgIGRzLnpJbmRleCA9ICctMSc7XG4gICAgZHMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIGRzLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgZHMucGFkZGluZyA9ICcwJztcbiAgICBkcy5saW5lSGVpZ2h0ID0gJzEnO1xuXG4gICAgaWYoIHN0eWxlWyd0ZXh0LXdyYXAnXS52YWx1ZSA9PT0gJ3dyYXAnICl7XG4gICAgICBkcy53aGl0ZVNwYWNlID0gJ3ByZSc7IC8vIHNvIG5ld2xpbmVzIGFyZSB0YWtlbiBpbnRvIGFjY291bnRcbiAgICB9IGVsc2Uge1xuICAgICAgZHMud2hpdGVTcGFjZSA9ICdub3JtYWwnO1xuICAgIH1cblxuICAgIC8vIHB1dCBsYWJlbCBjb250ZW50IGluIGRpdlxuICAgIGRpdi50ZXh0Q29udGVudCA9IHRleHQ7XG5cbiAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICB3aWR0aDogZGl2LmNsaWVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBkaXYuY2xpZW50SGVpZ2h0XG4gICAgfTtcblxuICAgIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG4gIH07ICBcblxuICBDUnAucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgICB2YXIgZWRnZXMgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgaGFuZGxlZEVkZ2UgPSB7fTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICAgIHZhciBpZCA9IF9wLmRhdGEuaWQ7XG4gICAgICB2YXIgYmJTdHlsZVNhbWUgPSBycy5ib3VuZGluZ0JveEtleSAhPSBudWxsICYmIF9wLmJvdW5kaW5nQm94S2V5ID09PSBycy5ib3VuZGluZ0JveEtleTtcbiAgICAgIHZhciBsYWJlbFN0eWxlU2FtZSA9IHJzLmxhYmVsS2V5ICE9IG51bGwgJiYgX3AubGFiZWxLZXkgPT09IHJzLmxhYmVsS2V5O1xuICAgICAgdmFyIHN0eWxlU2FtZSA9IGJiU3R5bGVTYW1lICYmIGxhYmVsU3R5bGVTYW1lO1xuXG4gICAgICBpZiggZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBvc1NhbWUgPSByc3R5bGUubm9kZVggIT0gbnVsbCAmJiByc3R5bGUubm9kZVkgIT0gbnVsbCAmJiBwb3MueCA9PT0gcnN0eWxlLm5vZGVYICYmIHBvcy55ID09PSByc3R5bGUubm9kZVk7XG4gICAgICAgIHZhciB3U2FtZSA9IHJzdHlsZS5ub2RlVyAhPSBudWxsICYmIHJzdHlsZS5ub2RlVyA9PT0gc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZTtcbiAgICAgICAgdmFyIGhTYW1lID0gcnN0eWxlLm5vZGVIICE9IG51bGwgJiYgcnN0eWxlLm5vZGVIID09PSBzdHlsZVsnaGVpZ2h0J10ucHhWYWx1ZTtcblxuICAgICAgICBpZiggIXBvc1NhbWUgfHwgIXN0eWxlU2FtZSB8fCAhd1NhbWUgfHwgIWhTYW1lICl7XG4gICAgICAgICAgbm9kZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICByc3R5bGUubm9kZVggPSBwb3MueDtcbiAgICAgICAgcnN0eWxlLm5vZGVZID0gcG9zLnk7XG4gICAgICAgIHJzdHlsZS5ub2RlVyA9IHN0eWxlWyd3aWR0aCddLnB4VmFsdWU7XG4gICAgICAgIHJzdHlsZS5ub2RlSCA9IHN0eWxlWydoZWlnaHQnXS5weFZhbHVlO1xuICAgICAgfSBlbHNlIHsgLy8gZWRnZXNcblxuICAgICAgICB2YXIgc3JjUG9zID0gZWxlLl9wcml2YXRlLnNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHRndFBvcyA9IGVsZS5fcHJpdmF0ZS50YXJnZXQuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIHZhciBzcmNTYW1lID0gcnN0eWxlLnNyY1ggIT0gbnVsbCAmJiByc3R5bGUuc3JjWSAhPSBudWxsICYmIHNyY1Bvcy54ID09PSByc3R5bGUuc3JjWCAmJiBzcmNQb3MueSA9PT0gcnN0eWxlLnNyY1k7XG4gICAgICAgIHZhciB0Z3RTYW1lID0gcnN0eWxlLnRndFggIT0gbnVsbCAmJiByc3R5bGUudGd0WSAhPSBudWxsICYmIHRndFBvcy54ID09PSByc3R5bGUudGd0WCAmJiB0Z3RQb3MueSA9PT0gcnN0eWxlLnRndFk7XG4gICAgICAgIHZhciBwb3NpdGlvbnNTYW1lID0gc3JjU2FtZSAmJiB0Z3RTYW1lO1xuXG4gICAgICAgIGlmKCAhcG9zaXRpb25zU2FtZSB8fCAhc3R5bGVTYW1lICl7XG4gICAgICAgICAgdmFyIGN1cnZlVHlwZSA9IF9wLnN0eWxlWydjdXJ2ZS1zdHlsZSddLnZhbHVlO1xuXG4gICAgICAgICAgaWYoIGN1cnZlVHlwZSA9PT0gJ2JlemllcicgKXtcbiAgICAgICAgICAgIGlmKCAhaGFuZGxlZEVkZ2VbIGlkIF0gKXtcbiAgICAgICAgICAgICAgZWRnZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgICAgIGhhbmRsZWRFZGdlWyBpZCBdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICB2YXIgcGFyYWxsZWxFZGdlcyA9IGVsZS5wYXJhbGxlbEVkZ2VzKCk7XG4gICAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcGFyYWxsZWxFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICAgIHZhciBwRWRnZSA9IHBhcmFsbGVsRWRnZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHBJZCA9IHBFZGdlLl9wcml2YXRlLmRhdGEuaWQ7XG5cbiAgICAgICAgICAgICAgICBpZiggIWhhbmRsZWRFZGdlWyBwSWQgXSApe1xuICAgICAgICAgICAgICAgICAgZWRnZXMucHVzaCggcEVkZ2UgKTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZWRFZGdlWyBwSWQgXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkZ2VzLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiBwb3NpdGlvbnMgZGlmZlxuXG4gICAgICAgIC8vIHVwZGF0ZSByc3R5bGUgcG9zaXRpb25zXG4gICAgICAgIHJzdHlsZS5zcmNYID0gc3JjUG9zLng7XG4gICAgICAgIHJzdHlsZS5zcmNZID0gc3JjUG9zLnk7XG4gICAgICAgIHJzdHlsZS50Z3RYID0gdGd0UG9zLng7XG4gICAgICAgIHJzdHlsZS50Z3RZID0gdGd0UG9zLnk7XG5cbiAgICAgIH0gLy8gaWYgZWRnZXNcblxuICAgICAgcnMuYm91bmRpbmdCb3hLZXkgPSBfcC5ib3VuZGluZ0JveEtleTtcbiAgICAgIHJzLmxhYmVsS2V5ID0gX3AubGFiZWxLZXk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyggZWRnZXMgKTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlTGFiZWxQcm9qZWN0aW9ucyggbm9kZXMsIGVkZ2VzICk7XG4gIH07XG5cbiAgQ1JwLnJlY2FsY3VsYXRlTGFiZWxQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uKCBub2RlcywgZWRnZXMgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiggbm9kZXNbaV0gKTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbiggZWRnZXNbaV0gKTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24oIGVkZ2VzICl7XG4gICAgdGhpcy5maW5kRWRnZUNvbnRyb2xQb2ludHMoIGVkZ2VzICk7XG4gIH07XG5cblxuICAvLyBGaW5kIGVkZ2UgY29udHJvbCBwb2ludHNcbiAgQ1JwLmZpbmRFZGdlQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKGVkZ2VzKSB7XG4gICAgaWYoICFlZGdlcyB8fCBlZGdlcy5sZW5ndGggPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgY3kgPSB0aGlzLmRhdGEuY3k7XG4gICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgaGFzaFRhYmxlID0ge307XG4gICAgdmFyIHBhaXJJZHMgPSBbXTtcbiAgICB2YXIgaGF5c3RhY2tFZGdlcyA9IFtdO1xuXG4gICAgLy8gY3JlYXRlIGEgdGFibGUgb2YgZWRnZSAoc3JjLCB0Z3QpID0+IGxpc3Qgb2YgZWRnZXMgYmV0d2VlbiB0aGVtXG4gICAgdmFyIHBhaXJJZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICB2YXIgc3R5bGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIGVkZ2VJc1VuYnVuZGxlZCA9IHN0eWxlWydjdXJ2ZS1zdHlsZSddLnZhbHVlID09PSAndW5idW5kbGVkLWJlemllcic7XG5cbiAgICAgIC8vIGlnbm9yZSBlZGdlcyB3aG8gYXJlIG5vdCB0byBiZSBkaXNwbGF5ZWRcbiAgICAgIC8vIHRoZXkgc2hvdWxkbid0IHRha2UgdXAgc3BhY2VcbiAgICAgIGlmKCBzdHlsZS5kaXNwbGF5LnZhbHVlID09PSAnbm9uZScgKXtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCBzdHlsZVsnY3VydmUtc3R5bGUnXS52YWx1ZSA9PT0gJ2hheXN0YWNrJyApe1xuICAgICAgICBoYXlzdGFja0VkZ2VzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcmNJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS5zb3VyY2U7XG4gICAgICB2YXIgdGd0SWQgPSBlZGdlLl9wcml2YXRlLmRhdGEudGFyZ2V0O1xuXG4gICAgICBwYWlySWQgPSBzcmNJZCA+IHRndElkID9cbiAgICAgICAgdGd0SWQgKyAnLScgKyBzcmNJZCA6XG4gICAgICAgIHNyY0lkICsgJy0nICsgdGd0SWQgO1xuXG4gICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgIHBhaXJJZCA9ICd1bmJ1bmRsZWQnICsgZWRnZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzaFRhYmxlW3BhaXJJZF0gPT0gbnVsbCkge1xuICAgICAgICBoYXNoVGFibGVbcGFpcklkXSA9IFtdO1xuICAgICAgICBwYWlySWRzLnB1c2goIHBhaXJJZCApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBoYXNoVGFibGVbcGFpcklkXS5wdXNoKCBlZGdlICk7XG5cbiAgICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgaGFzaFRhYmxlW3BhaXJJZF0uaGFzVW5idW5kbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3JjLCB0Z3QsIHNyY1BvcywgdGd0UG9zLCBzcmNXLCBzcmNILCB0Z3RXLCB0Z3RILCBzcmNTaGFwZSwgdGd0U2hhcGUsIHNyY0JvcmRlciwgdGd0Qm9yZGVyO1xuICAgIHZhciB2ZWN0b3JOb3JtSW52ZXJzZTtcbiAgICB2YXIgYmFkQmV6aWVyO1xuICAgIFxuICAgIC8vIGZvciBlYWNoIHBhaXIgKHNyYywgdGd0KSwgY3JlYXRlIHRoZSBjdHJsIHB0c1xuICAgIC8vIE5lc3RlZCBmb3IgbG9vcCBpcyBPSzsgdG90YWwgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZm9yIGJvdGggbG9vcHMgPSBlZGdlQ291bnQgIFxuICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcGFpcklkcy5sZW5ndGg7IHArKykge1xuICAgICAgcGFpcklkID0gcGFpcklkc1twXTtcbiAgICAgIHZhciBwYWlyRWRnZXMgPSBoYXNoVGFibGVbcGFpcklkXTtcbiAgICBcbiAgICAgIC8vIGZvciBlYWNoIHBhaXIgaWQsIHRoZSBlZGdlcyBzaG91bGQgYmUgc29ydGVkIGJ5IGluZGV4XG4gICAgICBwYWlyRWRnZXMuc29ydChmdW5jdGlvbihlZGdlMSwgZWRnZTIpe1xuICAgICAgICByZXR1cm4gZWRnZTEuX3ByaXZhdGUuaW5kZXggLSBlZGdlMi5fcHJpdmF0ZS5pbmRleDtcbiAgICAgIH0pO1xuXG4gICAgICBzcmMgPSBwYWlyRWRnZXNbMF0uX3ByaXZhdGUuc291cmNlO1xuICAgICAgdGd0ID0gcGFpckVkZ2VzWzBdLl9wcml2YXRlLnRhcmdldDtcblxuICAgICAgLy8gbWFrZSBzdXJlIHNyYy90Z3QgZGlzdGluY3Rpb24gaXMgY29uc2lzdGVudFxuICAgICAgLy8gKHNyYy90Z3QgaW4gdGhpcyBjYXNlIGFyZSBqdXN0IGZvciBjdHJscHRzIGFuZCBkb24ndCBhY3R1YWxseSBoYXZlIHRvIGJlIHRydWUgc3JjL3RndClcbiAgICAgIGlmKCBzcmMuX3ByaXZhdGUuZGF0YS5pZCA+IHRndC5fcHJpdmF0ZS5kYXRhLmlkICl7XG4gICAgICAgIHZhciB0ZW1wID0gc3JjO1xuICAgICAgICBzcmMgPSB0Z3Q7XG4gICAgICAgIHRndCA9IHRlbXA7XG4gICAgICB9XG5cbiAgICAgIHNyY1BvcyA9IHNyYy5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIHRndFBvcyA9IHRndC5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgc3JjVyA9IHRoaXMuZ2V0Tm9kZVdpZHRoKHNyYyk7XG4gICAgICBzcmNIID0gdGhpcy5nZXROb2RlSGVpZ2h0KHNyYyk7XG5cbiAgICAgIHRndFcgPSB0aGlzLmdldE5vZGVXaWR0aCh0Z3QpO1xuICAgICAgdGd0SCA9IHRoaXMuZ2V0Tm9kZUhlaWdodCh0Z3QpO1xuXG4gICAgICBzcmNTaGFwZSA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbIHRoaXMuZ2V0Tm9kZVNoYXBlKHNyYykgXTtcbiAgICAgIHRndFNoYXBlID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1sgdGhpcy5nZXROb2RlU2hhcGUodGd0KSBdO1xuXG4gICAgICBzcmNCb3JkZXIgPSBzcmMuX3ByaXZhdGUuc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWU7XG4gICAgICB0Z3RCb3JkZXIgPSB0Z3QuX3ByaXZhdGUuc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWU7XG5cbiAgICAgIGJhZEJlemllciA9IGZhbHNlO1xuICAgICAgXG5cbiAgICAgIGlmKCAocGFpckVkZ2VzLmxlbmd0aCA+IDEgJiYgc3JjICE9PSB0Z3QpIHx8IHBhaXJFZGdlcy5oYXNVbmJ1bmRsZWQgKXtcblxuICAgICAgICAvLyBwdCBvdXRzaWRlIHNyYyBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcbiAgICAgICAgdmFyIHNyY091dHNpZGUgPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICAgIHNyY1Bvcy54LFxuICAgICAgICAgIHNyY1Bvcy55LFxuICAgICAgICAgIHNyY1csXG4gICAgICAgICAgc3JjSCxcbiAgICAgICAgICB0Z3RQb3MueCxcbiAgICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgICBzcmNCb3JkZXIgLyAyXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gcHQgb3V0c2lkZSB0Z3Qgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG4gICAgICAgIHZhciB0Z3RPdXRzaWRlID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICB0Z3RQb3MueCxcbiAgICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgICB0Z3RXLFxuICAgICAgICAgIHRndEgsXG4gICAgICAgICAgc3JjUG9zLngsXG4gICAgICAgICAgc3JjUG9zLnksXG4gICAgICAgICAgdGd0Qm9yZGVyIC8gMlxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBtaWRwdFNyY1B0cyA9IHtcbiAgICAgICAgICB4MTogc3JjT3V0c2lkZVswXSxcbiAgICAgICAgICB4MjogdGd0T3V0c2lkZVswXSxcbiAgICAgICAgICB5MTogc3JjT3V0c2lkZVsxXSxcbiAgICAgICAgICB5MjogdGd0T3V0c2lkZVsxXVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkeSA9ICggdGd0T3V0c2lkZVsxXSAtIHNyY091dHNpZGVbMV0gKTtcbiAgICAgICAgdmFyIGR4ID0gKCB0Z3RPdXRzaWRlWzBdIC0gc3JjT3V0c2lkZVswXSApO1xuICAgICAgICB2YXIgbCA9IE1hdGguc3FydCggZHgqZHggKyBkeSpkeSApO1xuXG4gICAgICAgIHZhciB2ZWN0b3IgPSB7XG4gICAgICAgICAgeDogZHgsXG4gICAgICAgICAgeTogZHlcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciB2ZWN0b3JOb3JtID0ge1xuICAgICAgICAgIHg6IHZlY3Rvci54L2wsXG4gICAgICAgICAgeTogdmVjdG9yLnkvbFxuICAgICAgICB9O1xuICAgICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHtcbiAgICAgICAgICB4OiAtdmVjdG9yTm9ybS55LFxuICAgICAgICAgIHk6IHZlY3Rvck5vcm0ueFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIHNyYyBpbnRlcnNlY3Rpb24gaXMgaW5zaWRlIHRndCBvciB0Z3QgaW50ZXJzZWN0aW9uIGlzIGluc2lkZSBzcmMsIHRoZW4gbm8gY3RybCBwdHMgdG8gZHJhd1xuICAgICAgICBpZiggXG4gICAgICAgICAgdGd0U2hhcGUuY2hlY2tQb2ludCggc3JjT3V0c2lkZVswXSwgc3JjT3V0c2lkZVsxXSwgdGd0Qm9yZGVyLzIsIHRndFcsIHRndEgsIHRndFBvcy54LCB0Z3RQb3MueSApICB8fFxuICAgICAgICAgIHNyY1NoYXBlLmNoZWNrUG9pbnQoIHRndE91dHNpZGVbMF0sIHRndE91dHNpZGVbMV0sIHNyY0JvcmRlci8yLCBzcmNXLCBzcmNILCBzcmNQb3MueCwgc3JjUG9zLnkgKSBcbiAgICAgICAgKXtcbiAgICAgICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHt9O1xuICAgICAgICAgIGJhZEJlemllciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBlZGdlO1xuICAgICAgdmFyIHJzO1xuICAgICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZGdlID0gcGFpckVkZ2VzW2ldO1xuICAgICAgICBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICAgIFxuICAgICAgICB2YXIgZWRnZUluZGV4MSA9IHJzLmxhc3RFZGdlSW5kZXg7XG4gICAgICAgIHZhciBlZGdlSW5kZXgyID0gaTtcblxuICAgICAgICB2YXIgbnVtRWRnZXMxID0gcnMubGFzdE51bUVkZ2VzO1xuICAgICAgICB2YXIgbnVtRWRnZXMyID0gcGFpckVkZ2VzLmxlbmd0aDtcblxuICAgICAgICB2YXIgZVN0eWxlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgICAgdmFyIHN0ZXBTaXplID0gZVN0eWxlWydjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSddLnB4VmFsdWU7XG4gICAgICAgIHZhciBzdGVwRGlzdCA9IGVTdHlsZVsnY29udHJvbC1wb2ludC1kaXN0YW5jZSddICE9PSB1bmRlZmluZWQgPyBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnXS5weFZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgc3RlcFdlaWdodCA9IGVTdHlsZVsnY29udHJvbC1wb2ludC13ZWlnaHQnXS52YWx1ZTtcbiAgICAgICAgdmFyIGVkZ2VJc1VuYnVuZGxlZCA9IGVTdHlsZVsnY3VydmUtc3R5bGUnXS52YWx1ZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInO1xuICAgICAgICBcbiAgICAgICAgdmFyIHN3YXBwZWREaXJlY3Rpb24gPSBlZGdlLl9wcml2YXRlLnNvdXJjZSAhPT0gc3JjO1xuXG4gICAgICAgIGlmKCBzd2FwcGVkRGlyZWN0aW9uICYmIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICAgIHN0ZXBEaXN0ICo9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNyY1gxID0gcnMubGFzdFNyY0N0bFB0WDtcbiAgICAgICAgdmFyIHNyY1gyID0gc3JjUG9zLng7XG4gICAgICAgIHZhciBzcmNZMSA9IHJzLmxhc3RTcmNDdGxQdFk7XG4gICAgICAgIHZhciBzcmNZMiA9IHNyY1Bvcy55O1xuICAgICAgICB2YXIgc3JjVzEgPSBycy5sYXN0U3JjQ3RsUHRXO1xuICAgICAgICB2YXIgc3JjVzIgPSBzcmMub3V0ZXJXaWR0aCgpO1xuICAgICAgICB2YXIgc3JjSDEgPSBycy5sYXN0U3JjQ3RsUHRIO1xuICAgICAgICB2YXIgc3JjSDIgPSBzcmMub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgICB2YXIgdGd0WDEgPSBycy5sYXN0VGd0Q3RsUHRYO1xuICAgICAgICB2YXIgdGd0WDIgPSB0Z3RQb3MueDtcbiAgICAgICAgdmFyIHRndFkxID0gcnMubGFzdFRndEN0bFB0WTtcbiAgICAgICAgdmFyIHRndFkyID0gdGd0UG9zLnk7XG4gICAgICAgIHZhciB0Z3RXMSA9IHJzLmxhc3RUZ3RDdGxQdFc7XG4gICAgICAgIHZhciB0Z3RXMiA9IHRndC5vdXRlcldpZHRoKCk7XG4gICAgICAgIHZhciB0Z3RIMSA9IHJzLmxhc3RUZ3RDdGxQdEg7XG4gICAgICAgIHZhciB0Z3RIMiA9IHRndC5vdXRlckhlaWdodCgpO1xuXG4gICAgICAgIHZhciB3aWR0aDEgPSBycy5sYXN0VztcbiAgICAgICAgdmFyIHdpZHRoMiA9IGVTdHlsZVsnY29udHJvbC1wb2ludC1zdGVwLXNpemUnXS5weFZhbHVlO1xuXG4gICAgICAgIGlmKCBiYWRCZXppZXIgKXtcbiAgICAgICAgICBycy5iYWRCZXppZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJzLmJhZEJlemllciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHNyY1gxID09PSBzcmNYMiAmJiBzcmNZMSA9PT0gc3JjWTIgJiYgc3JjVzEgPT09IHNyY1cyICYmIHNyY0gxID09PSBzcmNIMlxuICAgICAgICAmJiAgdGd0WDEgPT09IHRndFgyICYmIHRndFkxID09PSB0Z3RZMiAmJiB0Z3RXMSA9PT0gdGd0VzIgJiYgdGd0SDEgPT09IHRndEgyXG4gICAgICAgICYmICB3aWR0aDEgPT09IHdpZHRoMlxuICAgICAgICAmJiAgKChlZGdlSW5kZXgxID09PSBlZGdlSW5kZXgyICYmIG51bUVkZ2VzMSA9PT0gbnVtRWRnZXMyKSB8fCBlZGdlSXNVbmJ1bmRsZWQpICl7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2VkZ2UgY3RybCBwdCBjYWNoZSBISVQnKVxuICAgICAgICAgIGNvbnRpbnVlOyAvLyB0aGVuIHRoZSBjb250cm9sIHBvaW50cyBoYXZlbid0IGNoYW5nZWQgYW5kIHdlIGNhbiBza2lwIGNhbGN1bGF0aW5nIHRoZW1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBycy5sYXN0U3JjQ3RsUHRYID0gc3JjWDI7XG4gICAgICAgICAgcnMubGFzdFNyY0N0bFB0WSA9IHNyY1kyO1xuICAgICAgICAgIHJzLmxhc3RTcmNDdGxQdFcgPSBzcmNXMjtcbiAgICAgICAgICBycy5sYXN0U3JjQ3RsUHRIID0gc3JjSDI7XG4gICAgICAgICAgcnMubGFzdFRndEN0bFB0WCA9IHRndFgyO1xuICAgICAgICAgIHJzLmxhc3RUZ3RDdGxQdFkgPSB0Z3RZMjtcbiAgICAgICAgICBycy5sYXN0VGd0Q3RsUHRXID0gdGd0VzI7XG4gICAgICAgICAgcnMubGFzdFRndEN0bFB0SCA9IHRndEgyO1xuICAgICAgICAgIHJzLmxhc3RFZGdlSW5kZXggPSBlZGdlSW5kZXgyO1xuICAgICAgICAgIHJzLmxhc3ROdW1FZGdlcyA9IG51bUVkZ2VzMjtcbiAgICAgICAgICBycy5sYXN0V2lkdGggPSB3aWR0aDI7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2VkZ2UgY3RybCBwdCBjYWNoZSBNSVNTJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGYtZWRnZVxuICAgICAgICBpZiAoIHNyYyA9PT0gdGd0ICkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgcnMuZWRnZVR5cGUgPSAnc2VsZic7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGogPSBpO1xuICAgICAgICAgIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gICAgICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICBsb29wRGlzdCA9IHN0ZXBEaXN0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE5ldyAtLSBmaXggZm9yIGxhcmdlIG5vZGVzXG4gICAgICAgICAgcnMuY3AyYXggPSBzcmNQb3MueDtcbiAgICAgICAgICBycy5jcDJheSA9IHNyY1Bvcy55IC0gKDEgKyBNYXRoLnBvdyhzcmNILCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpO1xuICAgICAgICAgIFxuICAgICAgICAgIHJzLmNwMmN4ID0gc3JjUG9zLnggLSAoMSArIE1hdGgucG93KHNyY1csIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSk7XG4gICAgICAgICAgcnMuY3AyY3kgPSBzcmNQb3MueTtcbiAgICAgICAgICBcbiAgICAgICAgICBycy5zZWxmRWRnZU1pZFggPSAocnMuY3AyYXggKyBycy5jcDJjeCkgLyAyLjA7XG4gICAgICAgICAgcnMuc2VsZkVkZ2VNaWRZID0gKHJzLmNwMmF5ICsgcnMuY3AyY3kpIC8gMi4wO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29tcG91bmQgZWRnZVxuICAgICAgICB9IGVsc2UgaWYoXG4gICAgICAgICAgaGFzQ29tcG91bmRzICYmXG4gICAgICAgICAgKCBzcmMuaXNQYXJlbnQoKSB8fCBzcmMuaXNDaGlsZCgpIHx8IHRndC5pc1BhcmVudCgpIHx8IHRndC5pc0NoaWxkKCkgKSAmJlxuICAgICAgICAgICggc3JjLnBhcmVudHMoKS5hbnlTYW1lKHRndCkgfHwgdGd0LnBhcmVudHMoKS5hbnlTYW1lKHNyYykgKVxuICAgICAgICApe1xuXG4gICAgICAgICAgcnMuZWRnZVR5cGUgPSAnY29tcG91bmQnO1xuXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGUgbGluZSBhcHByb3hpbWF0aW9uIGRvZXNuJ3QgYXBwbHkgZm9yIGNvbXBvdW5kIGJlemllcnNcbiAgICAgICAgICAvLyAobG9vcC9zZWxmIGVkZ2VzIGFyZSBhbHJlYWR5IGVsaWRlZCBiL2Mgb2YgY2hlYXAgc3JjPT10Z3QgY2hlY2spXG4gICAgICAgICAgcnMuYmFkQmV6aWVyID0gZmFsc2U7XG5cbiAgICAgICAgICB2YXIgaiA9IGk7XG4gICAgICAgICAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgICAgICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIGxvb3BEaXN0ID0gc3RlcERpc3Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGxvb3BXID0gNTA7XG5cbiAgICAgICAgICB2YXIgbG9vcGFQb3MgPSB7XG4gICAgICAgICAgICB4OiBzcmNQb3MueCAtIHNyY1cvMixcbiAgICAgICAgICAgIHk6IHNyY1Bvcy55IC0gc3JjSC8yXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBsb29wYlBvcyA9IHtcbiAgICAgICAgICAgIHg6IHRndFBvcy54IC0gdGd0Vy8yLFxuICAgICAgICAgICAgeTogdGd0UG9zLnkgLSB0Z3RILzJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIG1pbkNvbXBvdW5kU3RyZXRjaCA9IDE7XG5cbiAgICAgICAgICBycy5jcDJheCA9IGxvb3BhUG9zLng7XG4gICAgICAgICAgcnMuY29tcG91bmRTdHJldGNoQSA9IE1hdGgubWF4KCBtaW5Db21wb3VuZFN0cmV0Y2gsIE1hdGgubG9nKHNyY1cgKiAwLjAxKSApOyAvLyBhdm9pZHMgY2FzZXMgd2l0aCBpbXBvc3NpYmxlIGJlemllcnNcbiAgICAgICAgICBycy5jcDJheSA9IGxvb3BhUG9zLnkgLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogcnMuY29tcG91bmRTdHJldGNoQTtcbiAgICAgICAgICBcbiAgICAgICAgICBycy5jb21wb3VuZFN0cmV0Y2hCID0gTWF0aC5tYXgoIG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2codGd0VyAqIDAuMDEpICk7IC8vIGF2b2lkcyBjYXNlcyB3aXRoIGltcG9zc2libGUgYmV6aWVyc1xuICAgICAgICAgIHJzLmNwMmN4ID0gbG9vcGJQb3MueCAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBycy5jb21wb3VuZFN0cmV0Y2hCO1xuICAgICAgICAgIHJzLmNwMmN5ID0gbG9vcGJQb3MueTtcbiAgICAgICAgICBcbiAgICAgICAgICBycy5zZWxmRWRnZU1pZFggPSAocnMuY3AyYXggKyBycy5jcDJjeCkgLyAyLjA7XG4gICAgICAgICAgcnMuc2VsZkVkZ2VNaWRZID0gKHJzLmNwMmF5ICsgcnMuY3AyY3kpIC8gMi4wO1xuXG4gICAgICAgIC8vIFN0cmFpZ2h0IGVkZ2VcbiAgICAgICAgfSBlbHNlIGlmIChwYWlyRWRnZXMubGVuZ3RoICUgMiA9PT0gMVxuICAgICAgICAgICYmIGkgPT09IE1hdGguZmxvb3IocGFpckVkZ2VzLmxlbmd0aCAvIDIpXG4gICAgICAgICAgJiYgIWVkZ2VJc1VuYnVuZGxlZCApIHtcbiAgICAgICAgICBcbiAgICAgICAgICBycy5lZGdlVHlwZSA9ICdzdHJhaWdodCc7XG4gICAgICAgICAgXG4gICAgICAgIC8vIEJlemllciBlZGdlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vcm1TdGVwRGlzdCA9ICgwLjUgLSBwYWlyRWRnZXMubGVuZ3RoIC8gMiArIGkpICogc3RlcFNpemU7XG4gICAgICAgICAgdmFyIG1hblN0ZXBEaXN0O1xuICAgICAgICAgIHZhciBzaWduID0gJCQubWF0aC5zaWdudW0oIG5vcm1TdGVwRGlzdCApO1xuXG4gICAgICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICAgICAgbWFuU3RlcERpc3QgPSBzdGVwRGlzdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFuU3RlcERpc3QgPSBzdGVwRGlzdCAhPT0gdW5kZWZpbmVkID8gc2lnbiAqIHN0ZXBEaXN0IDogdW5kZWZpbmVkOyBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGlzdGFuY2VGcm9tTWlkcG9pbnQgPSBtYW5TdGVwRGlzdCAhPT0gdW5kZWZpbmVkID8gbWFuU3RlcERpc3QgOiBub3JtU3RlcERpc3Q7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIHcxID0gKDEgLSBzdGVwV2VpZ2h0KTtcbiAgICAgICAgICB2YXIgdzIgPSBzdGVwV2VpZ2h0O1xuXG4gICAgICAgICAgaWYoIHN3YXBwZWREaXJlY3Rpb24gKXtcbiAgICAgICAgICAgIHcxID0gc3RlcFdlaWdodDtcbiAgICAgICAgICAgIHcyID0gKDEgLSBzdGVwV2VpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgICAgICAgIHg6IG1pZHB0U3JjUHRzLngxICogdzEgKyBtaWRwdFNyY1B0cy54MiAqIHcyLFxuICAgICAgICAgICAgeTogbWlkcHRTcmNQdHMueTEgKiB3MSArIG1pZHB0U3JjUHRzLnkyICogdzJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcnMuZWRnZVR5cGUgPSAnYmV6aWVyJztcbiAgICAgICAgICBcbiAgICAgICAgICBycy5jcDJ4ID0gYWRqdXN0ZWRNaWRwdC54ICsgdmVjdG9yTm9ybUludmVyc2UueCAqIGRpc3RhbmNlRnJvbU1pZHBvaW50O1xuICAgICAgICAgIHJzLmNwMnkgPSBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQ7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coZWRnZSwgbWlkUG9pbnRYLCBkaXNwbGFjZW1lbnRYLCBkaXN0YW5jZUZyb21NaWRwb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIGVuZHB0cyBmb3IgZWRnZVxuICAgICAgICB0aGlzLmZpbmRFbmRwb2ludHMoIGVkZ2UgKTtcblxuICAgICAgICB2YXIgYmFkU3RhcnQgPSAhJCQuaXMubnVtYmVyKCBycy5zdGFydFggKSB8fCAhJCQuaXMubnVtYmVyKCBycy5zdGFydFkgKTtcbiAgICAgICAgdmFyIGJhZEFTdGFydCA9ICEkJC5pcy5udW1iZXIoIHJzLmFycm93U3RhcnRYICkgfHwgISQkLmlzLm51bWJlciggcnMuYXJyb3dTdGFydFkgKTtcbiAgICAgICAgdmFyIGJhZEVuZCA9ICEkJC5pcy5udW1iZXIoIHJzLmVuZFggKSB8fCAhJCQuaXMubnVtYmVyKCBycy5lbmRZICk7XG4gICAgICAgIHZhciBiYWRBRW5kID0gISQkLmlzLm51bWJlciggcnMuYXJyb3dFbmRYICkgfHwgISQkLmlzLm51bWJlciggcnMuYXJyb3dFbmRZICk7XG5cbiAgICAgICAgdmFyIG1pbkNwQURpc3RGYWN0b3IgPSAzO1xuICAgICAgICB2YXIgYXJyb3dXID0gdGhpcy5nZXRBcnJvd1dpZHRoKCBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKSAqIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVIZWlnaHQ7XG4gICAgICAgIHZhciBtaW5DcEFEaXN0ID0gbWluQ3BBRGlzdEZhY3RvciAqIGFycm93VztcbiAgICAgICAgdmFyIHN0YXJ0QUNwRGlzdCA9ICQkLm1hdGguZGlzdGFuY2UoIHsgeDogcnMuY3AyeCwgeTogcnMuY3AyeSB9LCB7IHg6IHJzLnN0YXJ0WCwgeTogcnMuc3RhcnRZIH0gKTtcbiAgICAgICAgdmFyIGNsb3NlU3RhcnRBQ3AgPSBzdGFydEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuICAgICAgICB2YXIgZW5kQUNwRGlzdCA9ICQkLm1hdGguZGlzdGFuY2UoIHsgeDogcnMuY3AyeCwgeTogcnMuY3AyeSB9LCB7IHg6IHJzLmVuZFgsIHk6IHJzLmVuZFkgfSApO1xuICAgICAgICB2YXIgY2xvc2VFbmRBQ3AgPSBlbmRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcblxuICAgICAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdiZXppZXInICl7XG4gICAgICAgICAgdmFyIG92ZXJsYXBwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiggYmFkU3RhcnQgfHwgYmFkQVN0YXJ0IHx8IGNsb3NlU3RhcnRBQ3AgKXtcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSBzcmMgY2VudHJlIHRvIG91dHNpZGUgdGhlIHNyYyBzaGFwZVxuICAgICAgICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuICAgICAgICAgICAgdmFyIGNwRCA9IHsgLy8gZGVsdGFcbiAgICAgICAgICAgICAgeDogcnMuY3AyeCAtIHNyY1Bvcy54LFxuICAgICAgICAgICAgICB5OiBycy5jcDJ5IC0gc3JjUG9zLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY3BMID0gTWF0aC5zcXJ0KCBjcEQueCpjcEQueCArIGNwRC55KmNwRC55ICk7IC8vIGxlbmd0aCBvZiBsaW5lXG4gICAgICAgICAgICB2YXIgY3BNID0geyAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgICAgICAgIHg6IGNwRC54IC8gY3BMLFxuICAgICAgICAgICAgICB5OiBjcEQueSAvIGNwTFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcbiAgICAgICAgICAgIHZhciBjcFByb2ogPSB7IC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgICAgICAgeDogcnMuY3AyeCArIGNwTS54ICogMiAqIHJhZGl1cyxcbiAgICAgICAgICAgICAgeTogcnMuY3AyeSArIGNwTS55ICogMiAqIHJhZGl1c1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHNyY0N0cmxQdEludG4gPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICAgICAgICBzcmNQb3MueCxcbiAgICAgICAgICAgICAgc3JjUG9zLnksXG4gICAgICAgICAgICAgIHNyY1csXG4gICAgICAgICAgICAgIHNyY0gsXG4gICAgICAgICAgICAgIGNwUHJvai54LFxuICAgICAgICAgICAgICBjcFByb2oueSxcbiAgICAgICAgICAgICAgc3JjQm9yZGVyIC8gMlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYoIGNsb3NlU3RhcnRBQ3AgKXtcbiAgICAgICAgICAgICAgcnMuY3AyeCA9IHJzLmNwMnggKyBjcE0ueCAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTsgXG4gICAgICAgICAgICAgIHJzLmNwMnkgPSBycy5jcDJ5ICsgY3BNLnkgKiAobWluQ3BBRGlzdCAtIHN0YXJ0QUNwRGlzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBycy5jcDJ4ID0gc3JjQ3RybFB0SW50blswXSArIGNwTS54ICogbWluQ3BBRGlzdDsgXG4gICAgICAgICAgICAgIHJzLmNwMnkgPSBzcmNDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBiYWRFbmQgfHwgYmFkQUVuZCB8fCBjbG9zZUVuZEFDcCApe1xuICAgICAgICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHRndCBjZW50cmUgdG8gb3V0c2lkZSB0aGUgdGd0IHNoYXBlXG4gICAgICAgICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG4gICAgICAgICAgICB2YXIgY3BEID0geyAvLyBkZWx0YVxuICAgICAgICAgICAgICB4OiBycy5jcDJ4IC0gdGd0UG9zLngsXG4gICAgICAgICAgICAgIHk6IHJzLmNwMnkgLSB0Z3RQb3MueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjcEwgPSBNYXRoLnNxcnQoIGNwRC54KmNwRC54ICsgY3BELnkqY3BELnkgKTsgLy8gbGVuZ3RoIG9mIGxpbmVcbiAgICAgICAgICAgIHZhciBjcE0gPSB7IC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgICAgICAgeDogY3BELnggLyBjcEwsXG4gICAgICAgICAgICAgIHk6IGNwRC55IC8gY3BMXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuICAgICAgICAgICAgdmFyIGNwUHJvaiA9IHsgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICAgICAgICB4OiBycy5jcDJ4ICsgY3BNLnggKiAyICogcmFkaXVzLFxuICAgICAgICAgICAgICB5OiBycy5jcDJ5ICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdGd0Q3RybFB0SW50biA9IHRndFNoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgICAgICAgIHRndFBvcy54LFxuICAgICAgICAgICAgICB0Z3RQb3MueSxcbiAgICAgICAgICAgICAgdGd0VyxcbiAgICAgICAgICAgICAgdGd0SCxcbiAgICAgICAgICAgICAgY3BQcm9qLngsXG4gICAgICAgICAgICAgIGNwUHJvai55LFxuICAgICAgICAgICAgICB0Z3RCb3JkZXIgLyAyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiggY2xvc2VFbmRBQ3AgKXtcbiAgICAgICAgICAgICAgcnMuY3AyeCA9IHJzLmNwMnggKyBjcE0ueCAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7IFxuICAgICAgICAgICAgICBycy5jcDJ5ID0gcnMuY3AyeSArIGNwTS55ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJzLmNwMnggPSB0Z3RDdHJsUHRJbnRuWzBdICsgY3BNLnggKiBtaW5DcEFEaXN0OyBcbiAgICAgICAgICAgICAgcnMuY3AyeSA9IHRndEN0cmxQdEludG5bMV0gKyBjcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggb3ZlcmxhcHBpbmcgKXtcbiAgICAgICAgICAgIC8vIHJlY2FsYyBlbmRwdHNcbiAgICAgICAgICAgIHRoaXMuZmluZEVuZHBvaW50cyggZWRnZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyApe1xuICAgICAgICAgIHJzLm1pZFggPSAoIHNyY1gyICsgdGd0WDIgKS8yO1xuICAgICAgICAgIHJzLm1pZFkgPSAoIHNyY1kyICsgdGd0WTIgKS8yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJvamVjdCB0aGUgZWRnZSBpbnRvIHJzdHlsZVxuICAgICAgICB0aGlzLnByb2plY3RCZXppZXIoIGVkZ2UgKTtcbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb24oIGVkZ2UgKTtcblxuICAgICAgfVxuICAgIH1cbiAgICAgIFxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgaGF5c3RhY2tFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVkZ2UgPSBoYXlzdGFja0VkZ2VzW2ldO1xuICAgICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICAgIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICAgICAgdmFyIHJzID0gcnNjcmF0Y2g7XG5cbiAgICAgIGlmKCAhcnNjcmF0Y2guaGF5c3RhY2sgKXtcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuXG4gICAgICAgIHJzY3JhdGNoLnNvdXJjZSA9IHtcbiAgICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuXG4gICAgICAgIHJzY3JhdGNoLnRhcmdldCA9IHtcbiAgICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIH07XG5cbiAgICAgIH1cblxuICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICB2YXIgc3JjUG9zID0gc3JjLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdmFyIHRndFBvcyA9IHRndC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIHZhciBzcmNXID0gc3JjLndpZHRoKCk7XG4gICAgICB2YXIgdGd0VyA9IHRndC53aWR0aCgpO1xuICAgICAgdmFyIHNyY0ggPSBzcmMuaGVpZ2h0KCk7XG4gICAgICB2YXIgdGd0SCA9IHRndC5oZWlnaHQoKTtcbiAgICAgIHZhciByYWRpdXMgPSBzdHlsZVsnaGF5c3RhY2stcmFkaXVzJ10udmFsdWU7XG4gICAgICB2YXIgaGFsZlJhZGl1cyA9IHJhZGl1cy8yOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgICBycy5oYXlzdGFja1B0cyA9IFtcbiAgICAgICAgcnMuc291cmNlLnggKiBzcmNXICogaGFsZlJhZGl1cyArIHNyY1Bvcy54LFxuICAgICAgICBycy5zb3VyY2UueSAqIHNyY0ggKiBoYWxmUmFkaXVzICsgc3JjUG9zLnksXG4gICAgICAgIHJzLnRhcmdldC54ICogdGd0VyAqIGhhbGZSYWRpdXMgKyB0Z3RQb3MueCxcbiAgICAgICAgcnMudGFyZ2V0LnkgKiB0Z3RIICogaGFsZlJhZGl1cyArIHRndFBvcy55XG4gICAgICBdO1xuXG4gICAgICAvLyBhbHdheXMgb3ZlcnJpZGUgYXMgaGF5c3RhY2sgaW4gY2FzZSBzZXQgdG8gZGlmZmVyZW50IHR5cGUgcHJldmlvdXNseVxuICAgICAgcnNjcmF0Y2guZWRnZVR5cGUgPSAnaGF5c3RhY2snO1xuICAgICAgcnNjcmF0Y2guaGF5c3RhY2sgPSB0cnVlO1xuXG4gICAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbiggZWRnZSApO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNoVGFibGU7XG4gIH07XG5cbiAgQ1JwLmZpbmRFbmRwb2ludHMgPSBmdW5jdGlvbihlZGdlKSB7XG4gICAgdmFyIGludGVyc2VjdDtcblxuICAgIHZhciBzb3VyY2UgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgIHZhciB0YXJnZXQgPSBlZGdlLnRhcmdldCgpWzBdO1xuICAgIFxuICAgIHZhciB0Z3RBclNoYXBlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZVsndGFyZ2V0LWFycm93LXNoYXBlJ10udmFsdWU7XG4gICAgdmFyIHNyY0FyU2hhcGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydzb3VyY2UtYXJyb3ctc2hhcGUnXS52YWx1ZTtcblxuICAgIHZhciB0Z3RCb3JkZXJXID0gdGFyZ2V0Ll9wcml2YXRlLnN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlO1xuICAgIHZhciBzcmNCb3JkZXJXID0gc291cmNlLl9wcml2YXRlLnN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlO1xuXG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICBcbiAgICBpZiAocnMuZWRnZVR5cGUgPT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09ICdjb21wb3VuZCcpIHtcbiAgICAgIFxuICAgICAgdmFyIGNwID0gW3JzLmNwMmN4LCBycy5jcDJjeV07XG4gICAgICBcbiAgICAgIGludGVyc2VjdCA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUodGFyZ2V0KV0uaW50ZXJzZWN0TGluZShcbiAgICAgICAgdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uLngsXG4gICAgICAgIHRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgICB0aGlzLmdldE5vZGVXaWR0aCh0YXJnZXQpLFxuICAgICAgICB0aGlzLmdldE5vZGVIZWlnaHQodGFyZ2V0KSxcbiAgICAgICAgY3BbMF0sXG4gICAgICAgIGNwWzFdLCBcbiAgICAgICAgdGd0Qm9yZGVyVyAvIDJcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHZhciBhcnJvd0VuZCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5zcGFjaW5nKGVkZ2UpKTtcbiAgICAgIHZhciBlZGdlRW5kID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSk7XG4gICAgICBcbiAgICAgIHJzLmVuZFggPSBlZGdlRW5kWzBdO1xuICAgICAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG4gICAgICBcbiAgICAgIHJzLmFycm93RW5kWCA9IGFycm93RW5kWzBdO1xuICAgICAgcnMuYXJyb3dFbmRZID0gYXJyb3dFbmRbMV07XG4gICAgICBcbiAgICAgIHZhciBjcCA9IFtycy5jcDJheCwgcnMuY3AyYXldO1xuXG4gICAgICBpbnRlcnNlY3QgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoXG4gICAgICAgIHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICBzb3VyY2UuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgdGhpcy5nZXROb2RlV2lkdGgoc291cmNlKSxcbiAgICAgICAgdGhpcy5nZXROb2RlSGVpZ2h0KHNvdXJjZSksXG4gICAgICAgIGNwWzBdLCAvL2hhbGZQb2ludFgsXG4gICAgICAgIGNwWzFdLCAvL2hhbGZQb2ludFlcbiAgICAgICAgc3JjQm9yZGVyVyAvIDJcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHZhciBhcnJvd1N0YXJ0ID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLnNwYWNpbmcoZWRnZSkpO1xuICAgICAgdmFyIGVkZ2VTdGFydCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5nYXAoZWRnZSkpO1xuICAgICAgXG4gICAgICBycy5zdGFydFggPSBlZGdlU3RhcnRbMF07XG4gICAgICBycy5zdGFydFkgPSBlZGdlU3RhcnRbMV07XG5cblxuICAgICAgcnMuYXJyb3dTdGFydFggPSBhcnJvd1N0YXJ0WzBdO1xuICAgICAgcnMuYXJyb3dTdGFydFkgPSBhcnJvd1N0YXJ0WzFdO1xuICAgICAgXG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PSAnc3RyYWlnaHQnKSB7XG4gICAgXG4gICAgICBpbnRlcnNlY3QgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHRhcmdldCldLmludGVyc2VjdExpbmUoXG4gICAgICAgIHRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgdGhpcy5nZXROb2RlV2lkdGgodGFyZ2V0KSxcbiAgICAgICAgdGhpcy5nZXROb2RlSGVpZ2h0KHRhcmdldCksXG4gICAgICAgIHNvdXJjZS5wb3NpdGlvbigpLngsXG4gICAgICAgIHNvdXJjZS5wb3NpdGlvbigpLnksXG4gICAgICAgIHRndEJvcmRlclcgLyAyKTtcbiAgICAgICAgXG4gICAgICBpZiAoaW50ZXJzZWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBycy5ub0Fycm93UGxhY2VtZW50ID0gdHJ1ZTtcbiAgICAgICAgLy8gcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMubm9BcnJvd1BsYWNlbWVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgYXJyb3dFbmQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LFxuICAgICAgICBbc291cmNlLnBvc2l0aW9uKCkueCwgc291cmNlLnBvc2l0aW9uKCkueV0sXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLnNwYWNpbmcoZWRnZSkpO1xuICAgICAgdmFyIGVkZ2VFbmQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LFxuICAgICAgICBbc291cmNlLnBvc2l0aW9uKCkueCwgc291cmNlLnBvc2l0aW9uKCkueV0sXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSk7XG5cbiAgICAgIHJzLmVuZFggPSBlZGdlRW5kWzBdO1xuICAgICAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG4gICAgICBcbiAgICAgIHJzLmFycm93RW5kWCA9IGFycm93RW5kWzBdO1xuICAgICAgcnMuYXJyb3dFbmRZID0gYXJyb3dFbmRbMV07XG4gICAgXG4gICAgICBpbnRlcnNlY3QgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoXG4gICAgICAgIHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICBzb3VyY2UuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgdGhpcy5nZXROb2RlV2lkdGgoc291cmNlKSxcbiAgICAgICAgdGhpcy5nZXROb2RlSGVpZ2h0KHNvdXJjZSksXG4gICAgICAgIHRhcmdldC5wb3NpdGlvbigpLngsXG4gICAgICAgIHRhcmdldC5wb3NpdGlvbigpLnksXG4gICAgICAgIHNyY0JvcmRlclcgLyAyKTtcbiAgICAgIFxuICAgICAgaWYgKGludGVyc2VjdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcnMubm9BcnJvd1BsYWNlbWVudCA9IHRydWU7XG4gICAgICAgLy8gcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMubm9BcnJvd1BsYWNlbWVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKlxuICAgICAgY29uc29sZS5sb2coXCIxOiBcIlxuICAgICAgICArIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLFxuICAgICAgICAgIHNyY0FyU2hhcGUpO1xuICAgICAgKi9cbiAgICAgIHZhciBhcnJvd1N0YXJ0ID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCxcbiAgICAgICAgW3RhcmdldC5wb3NpdGlvbigpLngsIHRhcmdldC5wb3NpdGlvbigpLnldLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5zcGFjaW5nKGVkZ2UpKTtcbiAgICAgIHZhciBlZGdlU3RhcnQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LFxuICAgICAgICBbdGFyZ2V0LnBvc2l0aW9uKCkueCwgdGFyZ2V0LnBvc2l0aW9uKCkueV0sXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLmdhcChlZGdlKSk7XG5cbiAgICAgIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgICAgIHJzLnN0YXJ0WSA9IGVkZ2VTdGFydFsxXTtcbiAgICAgIFxuICAgICAgcnMuYXJyb3dTdGFydFggPSBhcnJvd1N0YXJ0WzBdO1xuICAgICAgcnMuYXJyb3dTdGFydFkgPSBhcnJvd1N0YXJ0WzFdO1xuICAgICAgXG4gICAgICBpZiggISQkLmlzLm51bWJlcihycy5zdGFydFgpIHx8ICEkJC5pcy5udW1iZXIocnMuc3RhcnRZKSB8fCAhJCQuaXMubnVtYmVyKHJzLmVuZFgpIHx8ICEkJC5pcy5udW1iZXIocnMuZW5kWSkgKXtcbiAgICAgICAgcnMuYmFkTGluZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5iYWRMaW5lID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAgICAgICBcbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09ICdiZXppZXInKSB7XG4gICAgICAvLyBpZiggd2luZG93LmJhZEFycm93KSBkZWJ1Z2dlcjtcbiAgICAgIHZhciBjcCA9IFtycy5jcDJ4LCBycy5jcDJ5XTtcbiAgICAgIFxuICAgICAgaW50ZXJzZWN0ID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1tcbiAgICAgICAgdGhpcy5nZXROb2RlU2hhcGUodGFyZ2V0KV0uaW50ZXJzZWN0TGluZShcbiAgICAgICAgdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uLngsXG4gICAgICAgIHRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgICB0aGlzLmdldE5vZGVXaWR0aCh0YXJnZXQpLFxuICAgICAgICB0aGlzLmdldE5vZGVIZWlnaHQodGFyZ2V0KSxcbiAgICAgICAgY3BbMF0sIC8vaGFsZlBvaW50WCxcbiAgICAgICAgY3BbMV0sIC8vaGFsZlBvaW50WVxuICAgICAgICB0Z3RCb3JkZXJXIC8gMlxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLypcbiAgICAgIGNvbnNvbGUubG9nKFwiMjogXCJcbiAgICAgICAgKyBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXSxcbiAgICAgICAgICBzcmNBclNoYXBlKTtcbiAgICAgICovXG4gICAgICB2YXIgYXJyb3dFbmQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uc3BhY2luZyhlZGdlKSk7XG4gICAgICB2YXIgZWRnZUVuZCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5nYXAoZWRnZSkpO1xuICAgICAgXG4gICAgICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgICAgIHJzLmVuZFkgPSBlZGdlRW5kWzFdO1xuICAgICAgXG4gICAgICBycy5hcnJvd0VuZFggPSBhcnJvd0VuZFswXTtcbiAgICAgIHJzLmFycm93RW5kWSA9IGFycm93RW5kWzFdO1xuICAgICAgXG4gICAgICBpbnRlcnNlY3QgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW1xuICAgICAgICB0aGlzLmdldE5vZGVTaGFwZShzb3VyY2UpXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICBzb3VyY2UuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgc291cmNlLl9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVdpZHRoKHNvdXJjZSksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUhlaWdodChzb3VyY2UpLFxuICAgICAgICBjcFswXSwgLy9oYWxmUG9pbnRYLFxuICAgICAgICBjcFsxXSwgLy9oYWxmUG9pbnRZXG4gICAgICAgIHNyY0JvcmRlclcgLyAyXG4gICAgICApO1xuICAgICAgXG4gICAgICB2YXIgYXJyb3dTdGFydCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICAgICAgaW50ZXJzZWN0LCBcbiAgICAgICAgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLnNwYWNpbmcoZWRnZSlcbiAgICAgICk7XG4gICAgICB2YXIgZWRnZVN0YXJ0ID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKFxuICAgICAgICBpbnRlcnNlY3QsIFxuICAgICAgICBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uZ2FwKGVkZ2UpXG4gICAgICApO1xuICAgIFxuICAgICAgcnMuc3RhcnRYID0gZWRnZVN0YXJ0WzBdO1xuICAgICAgcnMuc3RhcnRZID0gZWRnZVN0YXJ0WzFdO1xuICAgICAgXG4gICAgICBycy5hcnJvd1N0YXJ0WCA9IGFycm93U3RhcnRbMF07XG4gICAgICBycy5hcnJvd1N0YXJ0WSA9IGFycm93U3RhcnRbMV07XG4gICAgICBcbiAgICAgIC8vIGlmKCBpc05hTihycy5zdGFydFgpIHx8IGlzTmFOKHJzLnN0YXJ0WSkgKXtcbiAgICAgIC8vICAgZGVidWdnZXI7XG4gICAgICAvLyB9XG5cbiAgICB9IGVsc2UgaWYgKHJzLmlzQXJjRWRnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICAvLyBGaW5kIGFkamFjZW50IGVkZ2VzXG4gIENScC5maW5kRWRnZXMgPSBmdW5jdGlvbihub2RlU2V0KSB7XG4gICAgXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRDYWNoZWRFZGdlcygpO1xuICAgIFxuICAgIHZhciBoYXNoVGFibGUgPSB7fTtcbiAgICB2YXIgYWRqYWNlbnRFZGdlcyA9IFtdO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZVNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaGFzaFRhYmxlW25vZGVTZXRbaV0uX3ByaXZhdGUuZGF0YS5pZF0gPSBub2RlU2V0W2ldO1xuICAgIH1cbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaGFzaFRhYmxlW2VkZ2VzW2ldLl9wcml2YXRlLmRhdGEuc291cmNlXVxuICAgICAgICB8fCBoYXNoVGFibGVbZWRnZXNbaV0uX3ByaXZhdGUuZGF0YS50YXJnZXRdKSB7XG4gICAgICAgIFxuICAgICAgICBhZGphY2VudEVkZ2VzLnB1c2goZWRnZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYWRqYWNlbnRFZGdlcztcbiAgfTtcblxuICBDUnAuZ2V0QXJyb3dXaWR0aCA9IENScC5nZXRBcnJvd0hlaWdodCA9IGZ1bmN0aW9uKGVkZ2VXaWR0aCkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgfHwge307XG5cbiAgICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbZWRnZVdpZHRoXTtcbiAgICBpZiggY2FjaGVkVmFsICl7XG4gICAgICByZXR1cm4gY2FjaGVkVmFsO1xuICAgIH1cblxuICAgIGNhY2hlZFZhbCA9ICBNYXRoLm1heChNYXRoLnBvdyhlZGdlV2lkdGggKiAxMy4zNywgMC45KSwgMjkpO1xuICAgIGNhY2hlW2VkZ2VXaWR0aF0gPSBjYWNoZWRWYWw7XG5cbiAgICByZXR1cm4gY2FjaGVkVmFsO1xuICB9O1xuXG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5cbi8vIERyYXcgZWRnZVxuICBDUnAuZHJhd0VkZ2UgPSBmdW5jdGlvbihjb250ZXh0LCBlZGdlLCBkcmF3T3ZlcmxheUluc3RlYWQpIHtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciB1c2VQYXRocyA9IENhbnZhc1JlbmRlcmVyLnVzZVBhdGhzKCk7XG5cbiAgICAvLyBpZiBiZXppZXIgY3RybCBwdHMgY2FuIG5vdCBiZSBjYWxjdWxhdGVkLCB0aGVuIGRpZVxuICAgIGlmKCBycy5iYWRCZXppZXIgfHwgKCAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSAmJiBpc05hTihycy5zdGFydFgpKSApeyAvLyBleHRyYSBpc05hTigpIGZvciBzYWZhcmkgNy4xIGIvYyBpdCBtYW5nbGVzIGN0cmxwdCBjYWxjc1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gICAgXG4gICAgLy8gRWRnZSBsaW5lIHdpZHRoXG4gICAgaWYgKHN0eWxlWyd3aWR0aCddLnB4VmFsdWUgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvdmVybGF5UGFkZGluZyA9IHN0eWxlWydvdmVybGF5LXBhZGRpbmcnXS5weFZhbHVlO1xuICAgIHZhciBvdmVybGF5T3BhY2l0eSA9IHN0eWxlWydvdmVybGF5LW9wYWNpdHknXS52YWx1ZTtcbiAgICB2YXIgb3ZlcmxheUNvbG9yID0gc3R5bGVbJ292ZXJsYXktY29sb3InXS52YWx1ZTtcblxuICAgIC8vIEVkZ2UgY29sb3IgJiBvcGFjaXR5XG4gICAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCApe1xuXG4gICAgICBpZiggb3ZlcmxheU9wYWNpdHkgPT09IDAgKXsgLy8gZXhpdCBlYXJseSBpZiBubyBvdmVybGF5XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdHJva2VTdHlsZShjb250ZXh0LCBvdmVybGF5Q29sb3JbMF0sIG92ZXJsYXlDb2xvclsxXSwgb3ZlcmxheUNvbG9yWzJdLCBvdmVybGF5T3BhY2l0eSk7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAncm91bmQnO1xuXG4gICAgICBpZiggZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaC5lZGdlVHlwZSA9PSAnc2VsZicgJiYgIXVzZVBhdGhzICl7XG4gICAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JztcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGluZUNvbG9yID0gc3R5bGVbJ2xpbmUtY29sb3InXS52YWx1ZTtcblxuICAgICAgdGhpcy5zdHJva2VTdHlsZShjb250ZXh0LCBsaW5lQ29sb3JbMF0sIGxpbmVDb2xvclsxXSwgbGluZUNvbG9yWzJdLCBzdHlsZS5vcGFjaXR5LnZhbHVlKTtcbiAgICAgIFxuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnOyBcbiAgICB9XG4gICAgXG4gICAgdmFyIHN0YXJ0Tm9kZSwgZW5kTm9kZSwgc291cmNlLCB0YXJnZXQ7XG4gICAgc291cmNlID0gc3RhcnROb2RlID0gZWRnZS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgdGFyZ2V0ID0gZW5kTm9kZSA9IGVkZ2UuX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgLy8gdmFyIHRhcmdldFBvcyA9IHRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAvLyB2YXIgdGFyZ2V0VyA9IHRhcmdldC53aWR0aCgpO1xuICAgIC8vIHZhciB0YXJnZXRIID0gdGFyZ2V0LmhlaWdodCgpO1xuICAgIC8vIHZhciBzb3VyY2VQb3MgPSBzb3VyY2UuX3ByaXZhdGUucG9zaXRpb247XG4gICAgLy8gdmFyIHNvdXJjZVcgPSBzb3VyY2Uud2lkdGgoKTtcbiAgICAvLyB2YXIgc291cmNlSCA9IHNvdXJjZS5oZWlnaHQoKTtcblxuXG4gICAgdmFyIGVkZ2VXaWR0aCA9IHN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKyAoZHJhd092ZXJsYXlJbnN0ZWFkID8gMiAqIG92ZXJsYXlQYWRkaW5nIDogMCk7XG4gICAgdmFyIGxpbmVTdHlsZSA9IGRyYXdPdmVybGF5SW5zdGVhZCA/ICdzb2xpZCcgOiBzdHlsZVsnbGluZS1zdHlsZSddLnZhbHVlO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gZWRnZVdpZHRoO1xuICAgIFxuICAgIHZhciBzaGFkb3dCbHVyID0gc3R5bGVbJ3NoYWRvdy1ibHVyJ10ucHhWYWx1ZTtcbiAgICB2YXIgc2hhZG93T3BhY2l0eSA9IHN0eWxlWydzaGFkb3ctb3BhY2l0eSddLnZhbHVlO1xuICAgIHZhciBzaGFkb3dDb2xvciA9IHN0eWxlWydzaGFkb3ctY29sb3InXS52YWx1ZTtcbiAgICB2YXIgc2hhZG93T2Zmc2V0WCA9IHN0eWxlWydzaGFkb3ctb2Zmc2V0LXgnXS5weFZhbHVlO1xuICAgIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGVbJ3NoYWRvdy1vZmZzZXQteSddLnB4VmFsdWU7XG5cbiAgICB0aGlzLnNoYWRvd1N0eWxlKGNvbnRleHQsICBzaGFkb3dDb2xvciwgZHJhd092ZXJsYXlJbnN0ZWFkID8gMCA6IHNoYWRvd09wYWNpdHksIHNoYWRvd0JsdXIsIHNoYWRvd09mZnNldFgsIHNoYWRvd09mZnNldFkpO1xuICAgIFxuICAgIC8vIGlmKCBycy5lZGdlVHlwZSAhPT0gJ2hheXN0YWNrJyApe1xuICAgIC8vICAgdGhpcy5maW5kRW5kcG9pbnRzKGVkZ2UpO1xuICAgIC8vIH1cbiAgICBcbiAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgIC8vIHZhciByYWRpdXMgPSBzdHlsZVsnaGF5c3RhY2stcmFkaXVzJ10udmFsdWU7XG4gICAgICAvLyB2YXIgaGFsZlJhZGl1cyA9IHJhZGl1cy8yOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgICB0aGlzLmRyYXdTdHlsZWRFZGdlKFxuICAgICAgICBlZGdlLCBcbiAgICAgICAgY29udGV4dCwgXG4gICAgICAgIHJzLmhheXN0YWNrUHRzLFxuICAgICAgICBsaW5lU3R5bGUsXG4gICAgICAgIGVkZ2VXaWR0aFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIFxuICAgICAgdmFyIGRldGFpbHMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIHBvaW50cyA9IFtkZXRhaWxzLnN0YXJ0WCwgZGV0YWlscy5zdGFydFksIGRldGFpbHMuY3AyYXgsXG4gICAgICAgIGRldGFpbHMuY3AyYXksIGRldGFpbHMuc2VsZkVkZ2VNaWRYLCBkZXRhaWxzLnNlbGZFZGdlTWlkWSxcbiAgICAgICAgZGV0YWlscy5zZWxmRWRnZU1pZFgsIGRldGFpbHMuc2VsZkVkZ2VNaWRZLFxuICAgICAgICBkZXRhaWxzLmNwMmN4LCBkZXRhaWxzLmNwMmN5LCBkZXRhaWxzLmVuZFgsIGRldGFpbHMuZW5kWV07XG5cbiAgICAgIHRoaXMuZHJhd1N0eWxlZEVkZ2UoZWRnZSwgY29udGV4dCwgcG9pbnRzLCBsaW5lU3R5bGUsIGVkZ2VXaWR0aCk7XG4gICAgICBcbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgICBcbiAgICAgIHZhciBub2RlRGlyZWN0aW9uWCA9IGVuZE5vZGUuX3ByaXZhdGUucG9zaXRpb24ueCAtIHN0YXJ0Tm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54O1xuICAgICAgdmFyIG5vZGVEaXJlY3Rpb25ZID0gZW5kTm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi55IC0gc3RhcnROb2RlLl9wcml2YXRlLnBvc2l0aW9uLnk7XG4gICAgICBcbiAgICAgIHZhciBlZGdlRGlyZWN0aW9uWCA9IHJzLmVuZFggLSBycy5zdGFydFg7XG4gICAgICB2YXIgZWRnZURpcmVjdGlvblkgPSBycy5lbmRZIC0gcnMuc3RhcnRZO1xuICAgICAgXG4gICAgICBpZiAobm9kZURpcmVjdGlvblggKiBlZGdlRGlyZWN0aW9uWFxuICAgICAgICArIG5vZGVEaXJlY3Rpb25ZICogZWRnZURpcmVjdGlvblkgPCAwKSB7XG4gICAgICAgIFxuICAgICAgICBycy5zdHJhaWdodEVkZ2VUb29TaG9ydCA9IHRydWU7ICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgZGV0YWlscyA9IHJzO1xuICAgICAgICB0aGlzLmRyYXdTdHlsZWRFZGdlKGVkZ2UsIGNvbnRleHQsIFtkZXRhaWxzLnN0YXJ0WCwgZGV0YWlscy5zdGFydFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMuZW5kWCwgZGV0YWlscy5lbmRZXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlV2lkdGgpO1xuICAgICAgICBcbiAgICAgICAgcnMuc3RyYWlnaHRFZGdlVG9vU2hvcnQgPSBmYWxzZTsgIFxuICAgICAgfSAgXG4gICAgfSBlbHNlIHtcbiAgICAgIFxuICAgICAgdmFyIGRldGFpbHMgPSBycztcbiAgICAgIFxuICAgICAgdGhpcy5kcmF3U3R5bGVkRWRnZShlZGdlLCBjb250ZXh0LCBbZGV0YWlscy5zdGFydFgsIGRldGFpbHMuc3RhcnRZLFxuICAgICAgICBkZXRhaWxzLmNwMngsIGRldGFpbHMuY3AyeSwgZGV0YWlscy5lbmRYLCBkZXRhaWxzLmVuZFldLFxuICAgICAgICBsaW5lU3R5bGUsXG4gICAgICAgIGVkZ2VXaWR0aCk7XG4gICAgICBcbiAgICB9XG4gICAgXG4gICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snICl7XG4gICAgICB0aGlzLmRyYXdBcnJvd2hlYWRzKGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCk7XG4gICAgfSBlbHNlIGlmICggcnMubm9BcnJvd1BsYWNlbWVudCAhPT0gdHJ1ZSAmJiBycy5zdGFydFggIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5kcmF3QXJyb3doZWFkcyhjb250ZXh0LCBlZGdlLCBkcmF3T3ZlcmxheUluc3RlYWQpO1xuICAgIH1cblxuICAgIHRoaXMuc2hhZG93U3R5bGUoY29udGV4dCwgJ3RyYW5zcGFyZW50JywgMCk7IC8vIHJlc2V0IGZvciBuZXh0IGd1eVxuXG4gIH07XG4gIFxuICBcbiAgQ1JwLmRyYXdTdHlsZWRFZGdlID0gZnVuY3Rpb24oXG4gICAgICBlZGdlLCBjb250ZXh0LCBwdHMsIHR5cGUsIHdpZHRoKSB7XG5cbiAgICAvLyAzIHBvaW50cyBnaXZlbiAtPiBhc3N1bWUgQmV6aWVyXG4gICAgLy8gMiAtPiBhc3N1bWUgc3RyYWlnaHRcbiAgICBcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBjYW52YXNDeHQgPSBjb250ZXh0O1xuICAgIHZhciBwYXRoO1xuICAgIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgICB2YXIgdXNlUGF0aHMgPSBDYW52YXNSZW5kZXJlci51c2VQYXRocygpO1xuXG5cbiAgICBpZiggdXNlUGF0aHMgKXtcblxuICAgICAgdmFyIHBhdGhDYWNoZUtleSA9IHB0cztcbiAgICAgIHZhciBrZXlMZW5ndGhNYXRjaGVzID0gcnMucGF0aENhY2hlS2V5ICYmIHBhdGhDYWNoZUtleS5sZW5ndGggPT09IHJzLnBhdGhDYWNoZUtleS5sZW5ndGg7XG4gICAgICB2YXIga2V5TWF0Y2hlcyA9IGtleUxlbmd0aE1hdGNoZXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBrZXlNYXRjaGVzICYmIGkgPCBwYXRoQ2FjaGVLZXkubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIHJzLnBhdGhDYWNoZUtleVtpXSAhPT0gcGF0aENhY2hlS2V5W2ldICl7XG4gICAgICAgICAga2V5TWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBrZXlNYXRjaGVzICl7XG4gICAgICAgIHBhdGggPSBjb250ZXh0ID0gcnMucGF0aENhY2hlO1xuICAgICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIHJzLnBhdGhDYWNoZUtleSA9IHBhdGhDYWNoZUtleTtcbiAgICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmKCBjYW52YXNDeHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICBzd2l0Y2goIHR5cGUgKXtcbiAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goWyAxLCAxIF0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFsgNiwgMyBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoICFwYXRoQ2FjaGVIaXQgKXtcbiAgICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG4gICAgICBjb250ZXh0Lm1vdmVUbyhwdHNbMF0sIHB0c1sxXSk7XG4gICAgICBcbiAgICAgIGlmKCBwdHMubGVuZ3RoID09PSA2ICYmICFycy5iYWRCZXppZXIgKXsgLy8gYmV6aWVyXG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhwdHNbMl0sIHB0c1szXSwgcHRzWzRdLCBwdHNbNV0pO1xuICAgICAgfSBlbHNlIGlmKCBwdHMubGVuZ3RoID09PSAxMiAmJiAhcnMuYmFkQmV6aWVyICl7IC8vIGRvdWJsZSBiZXppZXIgbG9vcFxuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocHRzWzJdLCBwdHNbM10sIHB0c1s0XSwgcHRzWzVdKTtcbiAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHB0c1s4XSwgcHRzWzldLCBwdHNbMTBdLCBwdHNbMTFdKTtcbiAgICAgIH0gZWxzZSBpZiggcHRzLmxlbmd0aCA9PT0gNCAmJiAhcnMuYmFkTGluZSApeyAvLyBsaW5lXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0c1syXSwgcHRzWzNdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0ID0gY2FudmFzQ3h0O1xuICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgY29udGV4dC5zdHJva2UoIHBhdGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIFxuICAgIC8vIHJlc2V0IGFueSBsaW5lIGRhc2hlc1xuICAgIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIF0pO1xuICAgIH1cblxuICB9O1xuXG4gIENScC5kcmF3QXJyb3doZWFkcyA9IGZ1bmN0aW9uKGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCkge1xuICAgIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgKXsgcmV0dXJuOyB9IC8vIGRvbid0IGRvIGFueXRoaW5nIGZvciBvdmVybGF5cyBcblxuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG5cbiAgICAvLyBEaXNwbGFjZW1lbnQgZ2l2ZXMgZGlyZWN0aW9uIGZvciBhcnJvd2hlYWQgb3JpZW50YXRpb25cbiAgICB2YXIgZGlzcFgsIGRpc3BZO1xuICAgIHZhciBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWTtcblxuICAgIHZhciBzcmNQb3MgPSBlZGdlLnNvdXJjZSgpLnBvc2l0aW9uKCk7XG4gICAgdmFyIHRndFBvcyA9IGVkZ2UudGFyZ2V0KCkucG9zaXRpb24oKTtcblxuICAgIGlmKCBpc0hheXN0YWNrICl7XG4gICAgICBzdGFydFggPSBycy5oYXlzdGFja1B0c1swXTtcbiAgICAgIHN0YXJ0WSA9IHJzLmhheXN0YWNrUHRzWzFdO1xuICAgICAgZW5kWCA9IHJzLmhheXN0YWNrUHRzWzJdO1xuICAgICAgZW5kWSA9IHJzLmhheXN0YWNrUHRzWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFggPSBycy5hcnJvd1N0YXJ0WDtcbiAgICAgIHN0YXJ0WSA9IHJzLmFycm93U3RhcnRZO1xuICAgICAgZW5kWCA9IHJzLmFycm93RW5kWDtcbiAgICAgIGVuZFkgPSBycy5hcnJvd0VuZFk7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICBcbiAgICBmdW5jdGlvbiBkcmF3QXJyb3doZWFkKCBwcmVmaXgsIHgsIHksIGRpc3BYLCBkaXNwWSApe1xuICAgICAgdmFyIGFycm93U2hhcGUgPSBzdHlsZVtwcmVmaXggKyAnLWFycm93LXNoYXBlJ10udmFsdWU7XG5cbiAgICAgIGlmKCBhcnJvd1NoYXBlID09PSAnbm9uZScgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cbiAgICAgIHZhciBhcnJvd0NsZWFyRmlsbCA9IHN0eWxlW3ByZWZpeCArICctYXJyb3ctZmlsbCddLnZhbHVlID09PSAnaG9sbG93JyA/ICdib3RoJyA6ICdmaWxsZWQnO1xuICAgICAgdmFyIGFycm93RmlsbCA9IHN0eWxlW3ByZWZpeCArICctYXJyb3ctZmlsbCddLnZhbHVlO1xuXG4gICAgICBpZiggYXJyb3dTaGFwZSA9PT0gJ2hhbGYtdHJpYW5nbGUtb3ZlcnNob3QnICl7XG4gICAgICAgIGFycm93RmlsbCA9ICdob2xsb3cnO1xuICAgICAgICBhcnJvd0NsZWFyRmlsbCA9ICdob2xsb3cnO1xuICAgICAgfVxuXG4gICAgICBpZiggc3R5bGUub3BhY2l0eS52YWx1ZSAhPT0gMSB8fCBhcnJvd0ZpbGwgPT09ICdob2xsb3cnICl7IC8vIHRoZW4gZXh0cmEgY2xlYXIgaXMgbmVlZGVkXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICAgIFxuICAgICAgICBzZWxmLmZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxKTtcbiAgICAgICAgc2VsZi5zdHJva2VTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxKTtcbiAgICAgICAgXG4gICAgICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoIGVkZ2UsIHByZWZpeCwgY29udGV4dCwgXG4gICAgICAgICAgYXJyb3dDbGVhckZpbGwsIHN0eWxlWyd3aWR0aCddLnB4VmFsdWUsIHN0eWxlW3ByZWZpeCArICctYXJyb3ctc2hhcGUnXS52YWx1ZSwgXG4gICAgICAgICAgeCwgeSwgZGlzcFgsIGRpc3BZXG4gICAgICAgICk7XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgICB9IC8vIG90aGVyd2lzZSwgdGhlIG9wYXF1ZSBhcnJvdyBjbGVhcnMgaXQgZm9yIGZyZWUgOilcblxuICAgICAgdmFyIGNvbG9yID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1jb2xvciddLnZhbHVlO1xuICAgICAgc2VsZi5maWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgc3R5bGUub3BhY2l0eS52YWx1ZSk7XG4gICAgICBzZWxmLnN0cm9rZVN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIHN0eWxlLm9wYWNpdHkudmFsdWUpO1xuXG4gICAgICBzZWxmLmRyYXdBcnJvd1NoYXBlKCBlZGdlLCBwcmVmaXgsIGNvbnRleHQsIFxuICAgICAgICBhcnJvd0ZpbGwsIHN0eWxlWyd3aWR0aCddLnB4VmFsdWUsIHN0eWxlW3ByZWZpeCArICctYXJyb3ctc2hhcGUnXS52YWx1ZSwgXG4gICAgICAgIHgsIHksIGRpc3BYLCBkaXNwWVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBkaXNwWCA9IHN0YXJ0WCAtIHNyY1Bvcy54O1xuICAgIGRpc3BZID0gc3RhcnRZIC0gc3JjUG9zLnk7XG5cbiAgICBpZiggIWlzSGF5c3RhY2sgJiYgIWlzTmFOKHN0YXJ0WCkgJiYgIWlzTmFOKHN0YXJ0WSkgJiYgIWlzTmFOKGRpc3BYKSAmJiAhaXNOYU4oZGlzcFkpICl7XG4gICAgICBkcmF3QXJyb3doZWFkKCAnc291cmNlJywgc3RhcnRYLCBzdGFydFksIGRpc3BYLCBkaXNwWSApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdpbmRvdy5iYWRBcnJvdyA9IHRydWU7XG4gICAgICAvLyBkZWJ1Z2dlcjtcbiAgICB9XG4gICAgXG4gICAgdmFyIG1pZFggPSBycy5taWRYO1xuICAgIHZhciBtaWRZID0gcnMubWlkWTtcblxuICAgIGlmKCBpc0hheXN0YWNrICl7XG4gICAgICBtaWRYID0gKCBzdGFydFggKyBlbmRYICkvMjtcbiAgICAgIG1pZFkgPSAoIHN0YXJ0WSArIGVuZFkgKS8yO1xuICAgIH1cblxuICAgIGRpc3BYID0gc3RhcnRYIC0gZW5kWDtcbiAgICBkaXNwWSA9IHN0YXJ0WSAtIGVuZFk7XG5cbiAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdzZWxmJyApe1xuICAgICAgZGlzcFggPSAxO1xuICAgICAgZGlzcFkgPSAtMTtcbiAgICB9XG5cbiAgICBpZiggIWlzTmFOKG1pZFgpICYmICFpc05hTihtaWRZKSApe1xuICAgICAgZHJhd0Fycm93aGVhZCggJ21pZC10YXJnZXQnLCBtaWRYLCBtaWRZLCBkaXNwWCwgZGlzcFkgKTtcbiAgICB9XG5cbiAgICBkaXNwWCAqPSAtMTtcbiAgICBkaXNwWSAqPSAtMTtcblxuICAgIGlmKCAhaXNOYU4obWlkWCkgJiYgIWlzTmFOKG1pZFkpICl7XG4gICAgICBkcmF3QXJyb3doZWFkKCAnbWlkLXNvdXJjZScsIG1pZFgsIG1pZFksIGRpc3BYLCBkaXNwWSApO1xuICAgIH1cbiAgICBcbiAgICBkaXNwWCA9IGVuZFggLSB0Z3RQb3MueDtcbiAgICBkaXNwWSA9IGVuZFkgLSB0Z3RQb3MueTtcbiAgICBcbiAgICBpZiggIWlzSGF5c3RhY2sgJiYgIWlzTmFOKGVuZFgpICYmICFpc05hTihlbmRZKSAmJiAhaXNOYU4oZGlzcFgpICYmICFpc05hTihkaXNwWSkgKXtcbiAgICAgIGRyYXdBcnJvd2hlYWQoICd0YXJnZXQnLCBlbmRYLCBlbmRZLCBkaXNwWCwgZGlzcFkgKTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBEcmF3IGFycm93c2hhcGVcbiAgQ1JwLmRyYXdBcnJvd1NoYXBlID0gZnVuY3Rpb24oZWRnZSwgYXJyb3dUeXBlLCBjb250ZXh0LCBmaWxsLCBlZGdlV2lkdGgsIHNoYXBlLCB4LCB5LCBkaXNwWCwgZGlzcFkpIHtcbiAgICB2YXIgdXNlUGF0aHMgPSBDYW52YXNSZW5kZXJlci51c2VQYXRocygpO1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICAgIHZhciBwYXRoO1xuICAgIHZhciBjYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgICB2YXIgdHJhbnNsYXRpb24gPSB7IHg6IHgsIHk6IHkgfTtcblxuICAgIC8vIE5lZ2F0aXZlIG9mIHRoZSBhbmdsZVxuICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbihkaXNwWSAvIChNYXRoLnNxcnQoZGlzcFggKiBkaXNwWCArIGRpc3BZICogZGlzcFkpKSk7XG4gIFxuICAgIGlmIChkaXNwWCA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtIChNYXRoLlBJIC8gMiArIGFuZ2xlKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHNpemUgPSB0aGlzLmdldEFycm93V2lkdGgoIGVkZ2VXaWR0aCApO1xuICAgIHZhciBzaGFwZUltcGwgPSBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzaGFwZV07XG5cbiAgICAvLyBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcblxuICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgdmFyIHBhdGhDYWNoZUtleSA9IHNpemUgKyAnJCcgKyBzaGFwZSArICckJyArIGFuZ2xlICsgJyQnICsgeCArICckJyArIHk7XG4gICAgICBycy5hcnJvd1BhdGhDYWNoZUtleSA9IHJzLmFycm93UGF0aENhY2hlS2V5IHx8IHt9O1xuICAgICAgcnMuYXJyb3dQYXRoQ2FjaGUgPSBycy5hcnJvd1BhdGhDYWNoZSB8fCB7fTtcblxuICAgICAgdmFyIGFscmVhZHlDYWNoZWQgPSBycy5hcnJvd1BhdGhDYWNoZUtleVthcnJvd1R5cGVdID09PSBwYXRoQ2FjaGVLZXk7XG4gICAgICBpZiggYWxyZWFkeUNhY2hlZCApe1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IHJzLmFycm93UGF0aENhY2hlW2Fycm93VHlwZV07XG4gICAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgcnMuYXJyb3dQYXRoQ2FjaGVLZXlbYXJyb3dUeXBlXSA9IHBhdGhDYWNoZUtleTtcbiAgICAgICAgcnMuYXJyb3dQYXRoQ2FjaGVbYXJyb3dUeXBlXSA9IHBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAgIGlmKCAhcGF0aENhY2hlSGl0ICl7XG4gICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgIH1cbiAgICBcbiAgICBpZiggIXNoYXBlSW1wbC5sZWF2ZVBhdGhPcGVuICYmIGNvbnRleHQuY2xvc2VQYXRoICl7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIGNvbnRleHQgPSBjYW52YXNDb250ZXh0O1xuXG4gICAgaWYoIGZpbGwgPT09ICdmaWxsZWQnIHx8IGZpbGwgPT09ICdib3RoJyApe1xuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIGNvbnRleHQuZmlsbCggcGF0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGZpbGwgPT09ICdob2xsb3cnIHx8IGZpbGwgPT09ICdib3RoJyApe1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSAoIHNoYXBlSW1wbC5tYXRjaEVkZ2VXaWR0aCA/IGVkZ2VXaWR0aCA6IDEgKTtcbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5zdHJva2UoIHBhdGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBcbiAgICB9XG5cbiAgICAvLyBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIENScC5nZXRDYWNoZWRJbWFnZSA9IGZ1bmN0aW9uKHVybCwgb25Mb2FkKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBpbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlIHx8IHt9O1xuXG4gICAgaWYoIGltYWdlQ2FjaGVbdXJsXSAmJiBpbWFnZUNhY2hlW3VybF0uaW1hZ2UgKXtcbiAgICAgIHJldHVybiBpbWFnZUNhY2hlW3VybF0uaW1hZ2U7XG4gICAgfVxuICAgIFxuICAgIHZhciBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXSA9IGltYWdlQ2FjaGVbdXJsXSB8fCB7fTtcblxuICAgIHZhciBpbWFnZSA9IGNhY2hlLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgaW1hZ2Uuc3JjID0gdXJsO1xuICAgIFxuICAgIHJldHVybiBpbWFnZTtcbiAgfTtcbiAgXG4gIENScC5zYWZlRHJhd0ltYWdlID0gZnVuY3Rpb24oIGNvbnRleHQsIGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGggKXtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCBpbWcsIGl4LCBpeSwgaXcsIGloLCB4LCB5LCB3LCBoICk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlO1xuICAgICAgXG4gICAgICByLmRyYXdpbmdJbWFnZSA9IHRydWU7XG4gICAgICBcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuICB9O1xuICBcbiAgQ1JwLmRyYXdJbnNjcmliZWRJbWFnZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGltZywgbm9kZSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgbm9kZVggPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uLng7XG4gICAgdmFyIG5vZGVZID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi55O1xuICAgIHZhciBzdHlsZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIGZpdCA9IHN0eWxlWydiYWNrZ3JvdW5kLWZpdCddLnZhbHVlO1xuICAgIHZhciB4UG9zID0gc3R5bGVbJ2JhY2tncm91bmQtcG9zaXRpb24teCddO1xuICAgIHZhciB5UG9zID0gc3R5bGVbJ2JhY2tncm91bmQtcG9zaXRpb24teSddO1xuICAgIHZhciByZXBlYXQgPSBzdHlsZVsnYmFja2dyb3VuZC1yZXBlYXQnXS52YWx1ZTtcbiAgICB2YXIgbm9kZVcgPSBub2RlLndpZHRoKCk7XG4gICAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBjbGlwID0gc3R5bGVbJ2JhY2tncm91bmQtY2xpcCddLnZhbHVlO1xuICAgIHZhciBzaG91bGRDbGlwID0gY2xpcCA9PT0gJ25vZGUnO1xuICAgIHZhciBpbWdPcGFjaXR5ID0gc3R5bGVbJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSddLnZhbHVlO1xuICAgIFxuICAgIHZhciB3ID0gaW1nLndpZHRoO1xuICAgIHZhciBoID0gaW1nLmhlaWdodDtcbiAgICBcbiAgICBpZiggdyA9PT0gMCB8fCBoID09PSAwICl7XG4gICAgICByZXR1cm47IC8vIG5vIHBvaW50IGluIGRyYXdpbmcgZW1wdHkgaW1hZ2UgKGFuZCBjaHJvbWUgaXMgYnJva2VuIGluIHRoaXMgY2FzZSlcbiAgICB9XG5cbiAgICB2YXIgYmdXID0gc3R5bGVbJ2JhY2tncm91bmQtd2lkdGgnXTtcbiAgICBpZiggYmdXLnZhbHVlICE9PSAnYXV0bycgKXtcbiAgICAgIGlmKCBiZ1cudW5pdHMgPT09ICclJyApe1xuICAgICAgICB3ID0gYmdXLnZhbHVlLzEwMCAqIG5vZGVXO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdyA9IGJnVy5weFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiZ0ggPSBzdHlsZVsnYmFja2dyb3VuZC1oZWlnaHQnXTtcbiAgICBpZiggYmdILnZhbHVlICE9PSAnYXV0bycgKXtcbiAgICAgIGlmKCBiZ0gudW5pdHMgPT09ICclJyApe1xuICAgICAgICBoID0gYmdILnZhbHVlLzEwMCAqIG5vZGVIO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IGJnSC5weFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCB3ID09PSAwIHx8IGggPT09IDAgKXtcbiAgICAgIHJldHVybjsgLy8gbm8gcG9pbnQgaW4gZHJhd2luZyBlbXB0eSBpbWFnZSAoYW5kIGNocm9tZSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlKVxuICAgIH1cblxuICAgIGlmKCBmaXQgPT09ICdjb250YWluJyApe1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5taW4oIG5vZGVXL3csIG5vZGVIL2ggKTtcblxuICAgICAgdyAqPSBzY2FsZTtcbiAgICAgIGggKj0gc2NhbGU7XG5cbiAgICB9IGVsc2UgaWYoIGZpdCA9PT0gJ2NvdmVyJyApe1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5tYXgoIG5vZGVXL3csIG5vZGVIL2ggKTtcblxuICAgICAgdyAqPSBzY2FsZTtcbiAgICAgIGggKj0gc2NhbGU7XG4gICAgfVxuXG4gICAgdmFyIHggPSAobm9kZVggLSBub2RlVy8yKTsgLy8gbGVmdFxuICAgIGlmKCB4UG9zLnVuaXRzID09PSAnJScgKXtcbiAgICAgIHggKz0gKG5vZGVXIC0gdykgKiB4UG9zLnZhbHVlLzEwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCArPSB4UG9zLnB4VmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIHkgPSAobm9kZVkgLSBub2RlSC8yKTsgLy8gdG9wXG4gICAgaWYoIHlQb3MudW5pdHMgPT09ICclJyApe1xuICAgICAgeSArPSAobm9kZUggLSBoKSAqIHlQb3MudmFsdWUvMTAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ICs9IHlQb3MucHhWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiggcnMucGF0aENhY2hlICl7XG4gICAgICB4IC09IG5vZGVYO1xuICAgICAgeSAtPSBub2RlWTtcblxuICAgICAgbm9kZVggPSAwO1xuICAgICAgbm9kZVkgPSAwO1xuICAgIH1cblxuICAgIHZhciBnQWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuXG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGltZ09wYWNpdHk7XG5cbiAgICBpZiggcmVwZWF0ID09PSAnbm8tcmVwZWF0JyApe1xuXG4gICAgICBpZiggc2hvdWxkQ2xpcCApe1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgICBpZiggcnMucGF0aENhY2hlICl7XG4gICAgICAgICAgY29udGV4dC5jbGlwKCBycy5wYXRoQ2FjaGUgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3UGF0aChcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBub2RlWCwgbm9kZVksIFxuICAgICAgICAgICAgbm9kZVcsIG5vZGVIKTtcblxuICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnRleHQuZHJhd0ltYWdlKCBpbWcsIDAsIDAsIGltZy53aWR0aCwgaW1nLmhlaWdodCwgeCwgeSwgdywgaCApO1xuICAgICAgci5zYWZlRHJhd0ltYWdlKCBjb250ZXh0LCBpbWcsIDAsIDAsIGltZy53aWR0aCwgaW1nLmhlaWdodCwgeCwgeSwgdywgaCApO1xuXG4gICAgICBpZiggc2hvdWxkQ2xpcCApe1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oIGltZywgcmVwZWF0ICk7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBhdHRlcm47XG5cbiAgICAgIENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXdQYXRoKFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbm9kZVgsIG5vZGVZLCBcbiAgICAgICAgICBub2RlVywgbm9kZUgpO1xuXG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICB9XG5cbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZ0FscGhhO1xuICAgIFxuICB9O1xuXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcblxuICAvLyBEcmF3IGVkZ2UgdGV4dFxuICBDUnAuZHJhd0VkZ2VUZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgZWRnZSkge1xuICAgIHZhciB0ZXh0ID0gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuXG4gICAgaWYoICF0ZXh0IHx8IHRleHQubWF0Y2goL15cXHMrJC8pICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoIHRoaXMuaGlkZUVkZ2VzT25WaWV3cG9ydCAmJiAodGhpcy5kcmFnRGF0YS5kaWREcmFnIHx8IHRoaXMucGluY2hpbmcgfHwgdGhpcy5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgdGhpcy5kYXRhLndoZWVsIHx8IHRoaXMuc3dpcGVQYW5uaW5nKSApeyByZXR1cm47IH0gLy8gc2F2ZSBjeWNsZXMgb24gcGluY2hpbmdcblxuICAgIHZhciBjb21wdXRlZFNpemUgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydmb250LXNpemUnXS5weFZhbHVlICogZWRnZS5jeSgpLnpvb20oKTtcbiAgICB2YXIgbWluU2l6ZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ21pbi16b29tZWQtZm9udC1zaXplJ10ucHhWYWx1ZTtcblxuICAgIGlmKCBjb21wdXRlZFNpemUgPCBtaW5TaXplICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRleHQgZHJhdyBwb3NpdGlvblxuXG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIFxuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgaWYoICEkJC5pcy5udW1iZXIoIHJzLmxhYmVsWCApIHx8ICEkJC5pcy5udW1iZXIoIHJzLmxhYmVsWSApICl7IHJldHVybjsgfSAvLyBubyBwb3MgPT4gbGFiZWwgY2FuJ3QgYmUgcmVuZGVyZWRcblxuICAgIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIGF1dG9yb3RhdGUgPSBzdHlsZVsnZWRnZS10ZXh0LXJvdGF0aW9uJ10uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJztcbiAgICB2YXIgdGhldGEsIGR4LCBkeTtcblxuICAgIGlmKCBhdXRvcm90YXRlICl7XG4gICAgICBzd2l0Y2goIHJzLmVkZ2VUeXBlICl7XG4gICAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgICBkeCA9IHJzLmhheXN0YWNrUHRzWzJdIC0gcnMuaGF5c3RhY2tQdHNbMF07XG4gICAgICAgICAgZHkgPSBycy5oYXlzdGFja1B0c1szXSAtIHJzLmhheXN0YWNrUHRzWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGR4ID0gcnMuZW5kWCAtIHJzLnN0YXJ0WDtcbiAgICAgICAgICBkeSA9IHJzLmVuZFkgLSBycy5zdGFydFk7XG4gICAgICB9XG5cbiAgICAgIHRoZXRhID0gTWF0aC5hdGFuKCBkeSAvIGR4ICk7XG5cbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHJzLmxhYmVsWCwgcnMubGFiZWxZKTtcbiAgICAgIGNvbnRleHQucm90YXRlKHRoZXRhKTtcblxuICAgICAgdGhpcy5kcmF3VGV4dChjb250ZXh0LCBlZGdlLCAwLCAwKTtcblxuICAgICAgY29udGV4dC5yb3RhdGUoLXRoZXRhKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1ycy5sYWJlbFgsIC1ycy5sYWJlbFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYXdUZXh0KGNvbnRleHQsIGVkZ2UsIHJzLmxhYmVsWCwgcnMubGFiZWxZKTtcbiAgICB9XG5cbiAgfTtcblxuICAvLyBEcmF3IG5vZGUgdGV4dFxuICBDUnAuZHJhd05vZGVUZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgbm9kZSkge1xuICAgIHZhciB0ZXh0ID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuXG4gICAgaWYgKCAhdGV4dCB8fCB0ZXh0Lm1hdGNoKC9eXFxzKyQvKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29tcHV0ZWRTaXplID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnZm9udC1zaXplJ10ucHhWYWx1ZSAqIG5vZGUuY3koKS56b29tKCk7XG4gICAgdmFyIG1pblNpemUgPSBub2RlLl9wcml2YXRlLnN0eWxlWydtaW4tem9vbWVkLWZvbnQtc2l6ZSddLnB4VmFsdWU7XG5cbiAgICBpZiggY29tcHV0ZWRTaXplIDwgbWluU2l6ZSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHRoaXMucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uKCBub2RlICk7XG5cbiAgICB2YXIgdGV4dEhhbGlnbiA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3RleHQtaGFsaWduJ10uc3RyVmFsdWU7XG4gICAgdmFyIHRleHRWYWxpZ24gPSBub2RlLl9wcml2YXRlLnN0eWxlWyd0ZXh0LXZhbGlnbiddLnN0clZhbHVlO1xuICAgIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgaWYoICEkJC5pcy5udW1iZXIoIHJzLmxhYmVsWCApIHx8ICEkJC5pcy5udW1iZXIoIHJzLmxhYmVsWSApICl7IHJldHVybjsgfSAvLyBubyBwb3MgPT4gbGFiZWwgY2FuJ3QgYmUgcmVuZGVyZWRcblxuICAgIHN3aXRjaCggdGV4dEhhbGlnbiApe1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OiAvLyBlLmcuIGNlbnRlclxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIHN3aXRjaCggdGV4dFZhbGlnbiApe1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OiAvLyBlLmcuIGNlbnRlclxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIH1cblxuICAgIHRoaXMuZHJhd1RleHQoY29udGV4dCwgbm9kZSwgcnMubGFiZWxYLCBycy5sYWJlbFkpO1xuICB9O1xuXG4gIENScC5nZXRGb250Q2FjaGUgPSBmdW5jdGlvbihjb250ZXh0KXtcbiAgICB2YXIgY2FjaGU7XG5cbiAgICB0aGlzLmZvbnRDYWNoZXMgPSB0aGlzLmZvbnRDYWNoZXMgfHwgW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMuZm9udENhY2hlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgY2FjaGUgPSB0aGlzLmZvbnRDYWNoZXNbaV07XG5cbiAgICAgIGlmKCBjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0ICl7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWNoZSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9O1xuICAgIHRoaXMuZm9udENhY2hlcy5wdXNoKGNhY2hlKTtcblxuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICAvLyBzZXQgdXAgY2FudmFzIGNvbnRleHQgd2l0aCBmb250XG4gIC8vIHJldHVybnMgdHJhbnNmb3JtZWQgdGV4dCBzdHJpbmdcbiAgQ1JwLnNldHVwVGV4dFN0eWxlID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW1lbnQgKXtcbiAgICAvLyBGb250IHN0eWxlXG4gICAgdmFyIHBhcmVudE9wYWNpdHkgPSBlbGVtZW50LmVmZmVjdGl2ZU9wYWNpdHkoKTtcbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50Ll9wcml2YXRlLnN0eWxlO1xuICAgIHZhciBsYWJlbFN0eWxlID0gc3R5bGVbJ2ZvbnQtc3R5bGUnXS5zdHJWYWx1ZTtcbiAgICB2YXIgbGFiZWxTaXplID0gc3R5bGVbJ2ZvbnQtc2l6ZSddLnB4VmFsdWUgKyAncHgnO1xuICAgIHZhciBsYWJlbEZhbWlseSA9IHN0eWxlWydmb250LWZhbWlseSddLnN0clZhbHVlO1xuICAgIHZhciBsYWJlbFdlaWdodCA9IHN0eWxlWydmb250LXdlaWdodCddLnN0clZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gc3R5bGVbJ3RleHQtb3BhY2l0eSddLnZhbHVlICogc3R5bGVbJ29wYWNpdHknXS52YWx1ZSAqIHBhcmVudE9wYWNpdHk7XG4gICAgdmFyIG91dGxpbmVPcGFjaXR5ID0gc3R5bGVbJ3RleHQtb3V0bGluZS1vcGFjaXR5J10udmFsdWUgKiBvcGFjaXR5O1xuICAgIHZhciBjb2xvciA9IHN0eWxlWydjb2xvciddLnZhbHVlO1xuICAgIHZhciBvdXRsaW5lQ29sb3IgPSBzdHlsZVsndGV4dC1vdXRsaW5lLWNvbG9yJ10udmFsdWU7XG4gICAgdmFyIHNoYWRvd0JsdXIgPSBzdHlsZVsndGV4dC1zaGFkb3ctYmx1ciddLnB4VmFsdWU7XG4gICAgdmFyIHNoYWRvd09wYWNpdHkgPSBzdHlsZVsndGV4dC1zaGFkb3ctb3BhY2l0eSddLnZhbHVlO1xuICAgIHZhciBzaGFkb3dDb2xvciA9IHN0eWxlWyd0ZXh0LXNoYWRvdy1jb2xvciddLnZhbHVlO1xuICAgIHZhciBzaGFkb3dPZmZzZXRYID0gc3R5bGVbJ3RleHQtc2hhZG93LW9mZnNldC14J10ucHhWYWx1ZTtcbiAgICB2YXIgc2hhZG93T2Zmc2V0WSA9IHN0eWxlWyd0ZXh0LXNoYWRvdy1vZmZzZXQteSddLnB4VmFsdWU7XG5cbiAgICB2YXIgZm9udENhY2hlS2V5ID0gZWxlbWVudC5fcHJpdmF0ZS5mb250S2V5O1xuICAgIHZhciBjYWNoZSA9IHRoaXMuZ2V0Rm9udENhY2hlKGNvbnRleHQpO1xuXG4gICAgaWYoIGNhY2hlLmtleSAhPT0gZm9udENhY2hlS2V5ICl7XG4gICAgICBjb250ZXh0LmZvbnQgPSBsYWJlbFN0eWxlICsgJyAnICsgbGFiZWxXZWlnaHQgKyAnICcgKyBsYWJlbFNpemUgKyAnICcgKyBsYWJlbEZhbWlseTtcblxuICAgICAgY2FjaGUua2V5ID0gZm9udENhY2hlS2V5O1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoIGVsZW1lbnQgKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0ZXh0IGRyYXcgcG9zaXRpb24gYmFzZWQgb24gdGV4dCBhbGlnbm1lbnRcblxuICAgIC8vIHNvIHRleHQgb3V0bGluZXMgYXJlbid0IGphZ2dlZFxuICAgIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuXG4gICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG5cbiAgICB0aGlzLnN0cm9rZVN0eWxlKGNvbnRleHQsIG91dGxpbmVDb2xvclswXSwgb3V0bGluZUNvbG9yWzFdLCBvdXRsaW5lQ29sb3JbMl0sIG91dGxpbmVPcGFjaXR5KTtcblxuICAgIHRoaXMuc2hhZG93U3R5bGUoY29udGV4dCwgc2hhZG93Q29sb3IsIHNoYWRvd09wYWNpdHksIHNoYWRvd0JsdXIsIHNoYWRvd09mZnNldFgsIHNoYWRvd09mZnNldFkpO1xuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gcm91bmRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgdmFyIHJhZGl1cyA9IHJhZGl1cyB8fCA1O1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cblxuICAvLyBEcmF3IHRleHRcbiAgQ1JwLmRyYXdUZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgZWxlbWVudCwgdGV4dFgsIHRleHRZKSB7XG4gICAgdmFyIF9wID0gZWxlbWVudC5fcHJpdmF0ZTtcbiAgICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlbWVudC5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gICAgaWYoIHBhcmVudE9wYWNpdHkgPT09IDAgfHwgc3R5bGVbJ3RleHQtb3BhY2l0eSddLnZhbHVlID09PSAwKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgdGV4dCA9IHRoaXMuc2V0dXBUZXh0U3R5bGUoIGNvbnRleHQsIGVsZW1lbnQgKTtcbiAgICB2YXIgaGFsaWduID0gc3R5bGVbJ3RleHQtaGFsaWduJ10udmFsdWU7XG4gICAgdmFyIHZhbGlnbiA9IHN0eWxlWyd0ZXh0LXZhbGlnbiddLnZhbHVlO1xuXG4gICAgaWYoIGVsZW1lbnQuaXNFZGdlKCkgKXtcbiAgICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgaWYgKCB0ZXh0ICE9IG51bGwgJiYgIWlzTmFOKHRleHRYKSAmJiAhaXNOYU4odGV4dFkpKSB7XG4gICAgICB2YXIgYmFja2dyb3VuZE9wYWNpdHkgPSBzdHlsZVsndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknXS52YWx1ZTtcbiAgICAgIHZhciBib3JkZXJPcGFjaXR5ID0gc3R5bGVbJ3RleHQtYm9yZGVyLW9wYWNpdHknXS52YWx1ZTtcbiAgICAgIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBzdHlsZVsndGV4dC1ib3JkZXItd2lkdGgnXS5weFZhbHVlO1xuICAgICAgXG4gICAgICBpZiggYmFja2dyb3VuZE9wYWNpdHkgPiAwIHx8ICh0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwKSApe1xuICAgICAgICB2YXIgbWFyZ2luID0gNCArIHRleHRCb3JkZXJXaWR0aC8yO1xuXG4gICAgICAgIGlmIChlbGVtZW50LmlzTm9kZSgpKSB7XG4gICAgICAgICAgLy9Nb3ZlIHRleHRYLCB0ZXh0WSB0byBpbmNsdWRlIHRoZSBiYWNrZ3JvdW5kIG1hcmdpbnNcbiAgICAgICAgICBpZiAodmFsaWduID09PSAndG9wJykge1xuICAgICAgICAgICAgdGV4dFkgLT0gbWFyZ2luO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgdGV4dFkgKz0gbWFyZ2luO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHRleHRYIC09IG1hcmdpbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgdGV4dFggKz0gbWFyZ2luO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiZ1dpZHRoID0gcnN0eWxlLmxhYmVsV2lkdGg7XG4gICAgICAgIHZhciBiZ0hlaWdodCA9IHJzdHlsZS5sYWJlbEhlaWdodDtcbiAgICAgICAgdmFyIGJnWCA9IHRleHRYO1xuXG4gICAgICAgIGlmIChoYWxpZ24pIHtcbiAgICAgICAgICBpZiAoaGFsaWduID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBiZ1ggPSBiZ1ggLSBiZ1dpZHRoIC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGJnWCA9IGJnWC0gYmdXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmdZID0gdGV4dFk7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpIHtcbiAgICAgICAgICBpZiAodmFsaWduID09ICd0b3AnKSB7XG4gICAgICAgICAgICAgYmdZID0gYmdZIC0gYmdIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWxpZ24gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGJnWSA9IGJnWS0gYmdIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZ1kgPSBiZ1kgLSBiZ0hlaWdodCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3R5bGVbJ2VkZ2UtdGV4dC1yb3RhdGlvbiddLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICAgICAgICB0ZXh0WSA9IDA7XG4gICAgICAgICAgYmdXaWR0aCArPSA0O1xuICAgICAgICAgIGJnWCA9IHRleHRYIC0gYmdXaWR0aCAvIDI7XG4gICAgICAgICAgYmdZID0gdGV4dFkgLSBiZ0hlaWdodCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWRqdXN0IHdpdGggYm9yZGVyIHdpZHRoICYgbWFyZ2luXG4gICAgICAgICAgYmdYIC09IG1hcmdpbjtcbiAgICAgICAgICBiZ1kgLT0gbWFyZ2luO1xuICAgICAgICAgIGJnSGVpZ2h0ICs9IG1hcmdpbioyO1xuICAgICAgICAgIGJnV2lkdGggKz0gbWFyZ2luKjI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggYmFja2dyb3VuZE9wYWNpdHkgPiAwICl7XG4gICAgICAgICAgdmFyIHRleHRGaWxsID0gY29udGV4dC5maWxsU3R5bGU7XG4gICAgICAgICAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZVsndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJ10udmFsdWU7XG5cbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzBdICsgJywnICsgdGV4dEJhY2tncm91bmRDb2xvclsxXSArICcsJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMl0gKyAnLCcgKyBiYWNrZ3JvdW5kT3BhY2l0eSAqIHBhcmVudE9wYWNpdHkgKyAnKSc7XG4gICAgICAgICAgdmFyIHN0eWxlU2hhcGUgPSBzdHlsZVsndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJ10uc3RyVmFsdWU7XG4gICAgICAgICAgaWYgKHN0eWxlU2hhcGUgPT0gJ3JvdW5kcmVjdGFuZ2xlJykge1xuICAgICAgICAgICAgcm91bmRSZWN0KGNvbnRleHQsIGJnWCwgYmdZLCBiZ1dpZHRoLCBiZ0hlaWdodCwgMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoYmdYLGJnWSxiZ1dpZHRoLGJnSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0ZXh0RmlsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwICl7XG4gICAgICAgICAgdmFyIHRleHRTdHJva2UgPSBjb250ZXh0LnN0cm9rZVN0eWxlO1xuICAgICAgICAgIHZhciB0ZXh0TGluZVdpZHRoID0gY29udGV4dC5saW5lV2lkdGg7XG4gICAgICAgICAgdmFyIHRleHRCb3JkZXJDb2xvciA9IHN0eWxlWyd0ZXh0LWJvcmRlci1jb2xvciddLnZhbHVlO1xuICAgICAgICAgIHZhciB0ZXh0Qm9yZGVyU3R5bGUgPSBzdHlsZVsndGV4dC1ib3JkZXItc3R5bGUnXS52YWx1ZTtcblxuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgdGV4dEJvcmRlckNvbG9yWzBdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzFdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzJdICsgJywnICsgYm9yZGVyT3BhY2l0eSAqIHBhcmVudE9wYWNpdHkgKyAnKSc7XG4gICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGg7XG5cbiAgICAgICAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICAgIHN3aXRjaCggdGV4dEJvcmRlclN0eWxlICl7XG4gICAgICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIDEsIDEgXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIDQsIDIgXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGgvNDsgLy8gNTAlIHJlc2VydmVkIGZvciB3aGl0ZSBiZXR3ZWVuIHRoZSB0d28gYm9yZGVyc1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoYmdYLGJnWSxiZ1dpZHRoLGJnSGVpZ2h0KTtcblxuICAgICAgICAgIGlmKCB0ZXh0Qm9yZGVyU3R5bGUgPT09ICdkb3VibGUnICl7XG4gICAgICAgICAgICB2YXIgd2hpdGVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aC8yO1xuXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoYmdYK3doaXRlV2lkdGgsYmdZK3doaXRlV2lkdGgsYmdXaWR0aC13aGl0ZVdpZHRoKjIsYmdIZWlnaHQtd2hpdGVXaWR0aCoyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0TGluZVdpZHRoO1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0ZXh0U3Ryb2tlO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmVXaWR0aCA9IDIgICogc3R5bGVbJ3RleHQtb3V0bGluZS13aWR0aCddLnB4VmFsdWU7IC8vICoyIGIvYyB0aGUgc3Ryb2tlIGlzIGRyYXduIGNlbnRyZWQgb24gdGhlIG1pZGRsZVxuXG4gICAgICBpZiggbGluZVdpZHRoID4gMCApe1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYoIHN0eWxlWyd0ZXh0LXdyYXAnXS52YWx1ZSA9PT0gJ3dyYXAnICl7IC8vY29uc29sZS5sb2coJ2RyYXcgd3JhcCcpO1xuICAgICAgICB2YXIgbGluZXMgPSByc2NyYXRjaC5sYWJlbFdyYXBDYWNoZWRMaW5lcztcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSByc3R5bGUubGFiZWxIZWlnaHQgLyBsaW5lcy5sZW5ndGg7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnbGluZXMnLCBsaW5lcyk7XG5cbiAgICAgICAgc3dpdGNoKCB2YWxpZ24gKXtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgdGV4dFkgLT0gKGxpbmVzLmxlbmd0aCAtIDEpICogbGluZUhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgcmVxdWlyZWRcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgdGV4dFkgLT0gKGxpbmVzLmxlbmd0aCAtIDEpICogbGluZUhlaWdodCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrICl7XG4gICAgICAgICAgaWYoIGxpbmVXaWR0aCA+IDAgKXtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCggbGluZXNbbF0sIHRleHRYLCB0ZXh0WSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoIGxpbmVzW2xdLCB0ZXh0WCwgdGV4dFkgKTtcblxuICAgICAgICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgZm9udFNpemUgPSBzdHlsZVsnZm9udC1zaXplJ10ucHhWYWx1ZTtcbiAgICAgICAgLy8gd3JhcFRleHQoY29udGV4dCwgdGV4dCwgdGV4dFgsIHRleHRZLCBzdHlsZVsndGV4dC1tYXgtd2lkdGgnXS5weFZhbHVlLCBmb250U2l6ZSArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoIGxpbmVXaWR0aCA+IDAgKXtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoIHRleHQsIHRleHRYLCB0ZXh0WSApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5maWxsVGV4dCggdGV4dCwgdGV4dFgsIHRleHRZICk7XG4gICAgICB9XG5cblxuICAgICAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCAndHJhbnNwYXJlbnQnLCAwKTsgLy8gcmVzZXQgZm9yIG5leHQgZ3V5XG4gICAgfVxuICB9O1xuXG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgLy8gRHJhdyBub2RlXG4gIENScC5kcmF3Tm9kZSA9IGZ1bmN0aW9uKGNvbnRleHQsIG5vZGUsIGRyYXdPdmVybGF5SW5zdGVhZCkge1xuXG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBub2RlV2lkdGgsIG5vZGVIZWlnaHQ7XG4gICAgdmFyIHN0eWxlID0gbm9kZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gICAgXG4gICAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcbiAgICB2YXIgY2FudmFzQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuXG4gICAgdmFyIG92ZXJsYXlQYWRkaW5nID0gc3R5bGVbJ292ZXJsYXktcGFkZGluZyddLnB4VmFsdWU7XG4gICAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gc3R5bGVbJ292ZXJsYXktb3BhY2l0eSddLnZhbHVlO1xuICAgIHZhciBvdmVybGF5Q29sb3IgPSBzdHlsZVsnb3ZlcmxheS1jb2xvciddLnZhbHVlO1xuXG4gICAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCAmJiBvdmVybGF5T3BhY2l0eSA9PT0gMCApeyAvLyBleGl0IGVhcmx5IGlmIGRyYXdpbmcgb3ZlcmxheSBidXQgbm9uZSB0byBkcmF3XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudE9wYWNpdHkgPSBub2RlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbiAgICBpZiggcGFyZW50T3BhY2l0eSA9PT0gMCApeyByZXR1cm47IH1cblxuICAgIG5vZGVXaWR0aCA9IHRoaXMuZ2V0Tm9kZVdpZHRoKG5vZGUpO1xuICAgIG5vZGVIZWlnaHQgPSB0aGlzLmdldE5vZGVIZWlnaHQobm9kZSk7XG4gICAgXG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcblxuICAgIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgPT09IHVuZGVmaW5lZCB8fCAhZHJhd092ZXJsYXlJbnN0ZWFkICl7XG5cbiAgICAgIHZhciB1cmwgPSBzdHlsZVsnYmFja2dyb3VuZC1pbWFnZSddLnZhbHVlWzJdIHx8XG4gICAgICAgIHN0eWxlWydiYWNrZ3JvdW5kLWltYWdlJ10udmFsdWVbMV07XG4gICAgICB2YXIgaW1hZ2U7XG5cbiAgICAgIGlmICh1cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBcbiAgICAgICAgLy8gZ2V0IGltYWdlLCBhbmQgaWYgbm90IGxvYWRlZCB0aGVuIGFzayB0byByZWRyYXcgd2hlbiBsYXRlciBsb2FkZWRcbiAgICAgICAgaW1hZ2UgPSB0aGlzLmdldENhY2hlZEltYWdlKHVybCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgci5kcmF3aW5nSW1hZ2UgPSB0cnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdmFyIHByZXZCZ2luZyA9IF9wLmJhY2tncm91bmRpbmc7XG4gICAgICAgIF9wLmJhY2tncm91bmRpbmcgPSAhaW1hZ2UuY29tcGxldGU7XG5cbiAgICAgICAgaWYoIHByZXZCZ2luZyAhPT0gX3AuYmFja2dyb3VuZGluZyApeyAvLyB1cGRhdGUgc3R5bGUgYi9jIDpiYWNrZ3JvdW5kaW5nIHN0YXRlIGNoYW5nZWRcbiAgICAgICAgICBub2RlLnVwZGF0ZVN0eWxlKCBmYWxzZSApO1xuICAgICAgICB9XG4gICAgICB9IFxuXG4gICAgICAvLyBOb2RlIGNvbG9yICYgb3BhY2l0eVxuXG4gICAgICB2YXIgYmdDb2xvciA9IHN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ10udmFsdWU7XG4gICAgICB2YXIgYm9yZGVyQ29sb3IgPSBzdHlsZVsnYm9yZGVyLWNvbG9yJ10udmFsdWU7XG4gICAgICB2YXIgYm9yZGVyU3R5bGUgPSBzdHlsZVsnYm9yZGVyLXN0eWxlJ10udmFsdWU7XG5cbiAgICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIGJnQ29sb3JbMF0sIGJnQ29sb3JbMV0sIGJnQ29sb3JbMl0sIHN0eWxlWydiYWNrZ3JvdW5kLW9wYWNpdHknXS52YWx1ZSAqIHBhcmVudE9wYWNpdHkpO1xuICAgICAgXG4gICAgICB0aGlzLnN0cm9rZVN0eWxlKGNvbnRleHQsIGJvcmRlckNvbG9yWzBdLCBib3JkZXJDb2xvclsxXSwgYm9yZGVyQ29sb3JbMl0sIHN0eWxlWydib3JkZXItb3BhY2l0eSddLnZhbHVlICogcGFyZW50T3BhY2l0eSk7XG4gICAgICBcbiAgICAgIHZhciBzaGFkb3dCbHVyID0gc3R5bGVbJ3NoYWRvdy1ibHVyJ10ucHhWYWx1ZTtcbiAgICAgIHZhciBzaGFkb3dPcGFjaXR5ID0gc3R5bGVbJ3NoYWRvdy1vcGFjaXR5J10udmFsdWU7XG4gICAgICB2YXIgc2hhZG93Q29sb3IgPSBzdHlsZVsnc2hhZG93LWNvbG9yJ10udmFsdWU7XG4gICAgICB2YXIgc2hhZG93T2Zmc2V0WCA9IHN0eWxlWydzaGFkb3ctb2Zmc2V0LXgnXS5weFZhbHVlO1xuICAgICAgdmFyIHNoYWRvd09mZnNldFkgPSBzdHlsZVsnc2hhZG93LW9mZnNldC15J10ucHhWYWx1ZTtcblxuICAgICAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCBzaGFkb3dDb2xvciwgc2hhZG93T3BhY2l0eSwgc2hhZG93Qmx1ciwgc2hhZG93T2Zmc2V0WCwgc2hhZG93T2Zmc2V0WSk7XG5cbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInOyAvLyBzbyBib3JkZXJzIGFyZSBzcXVhcmUgd2l0aCB0aGUgbm9kZSBzaGFwZVxuXG4gICAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgc3dpdGNoKCBib3JkZXJTdHlsZSApe1xuICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgMSwgMSBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyA0LCAyIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFxuICAgICAgdmFyIHN0eWxlU2hhcGUgPSBzdHlsZVsnc2hhcGUnXS5zdHJWYWx1ZTtcblxuICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICB2YXIgcGF0aENhY2hlS2V5ID0gc3R5bGVTaGFwZSArICckJyArIG5vZGVXaWR0aCArJyQnICsgbm9kZUhlaWdodDtcblxuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSggcG9zLngsIHBvcy55ICk7XG5cbiAgICAgICAgaWYoIHJzLnBhdGhDYWNoZUtleSA9PT0gcGF0aENhY2hlS2V5ICl7XG4gICAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5wYXRoQ2FjaGU7XG4gICAgICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgICBycy5wYXRoQ2FjaGVLZXkgPSBwYXRoQ2FjaGVLZXk7XG4gICAgICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggIXBhdGhDYWNoZUhpdCApe1xuXG4gICAgICAgIHZhciBucG9zID0gcG9zO1xuXG4gICAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICAgIG5wb3MgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3UGF0aChcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgbnBvcy54LFxuICAgICAgICAgICAgICBucG9zLnksXG4gICAgICAgICAgICAgIG5vZGVXaWR0aCxcbiAgICAgICAgICAgICAgbm9kZUhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQgPSBjYW52YXNDb250ZXh0O1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCAndHJhbnNwYXJlbnQnLCAwKTsgLy8gcmVzZXQgZm9yIG5leHQgZ3V5XG5cbiAgICAgIGlmICh1cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiggaW1hZ2UuY29tcGxldGUgKXtcbiAgICAgICAgICB0aGlzLmRyYXdJbnNjcmliZWRJbWFnZShjb250ZXh0LCBpbWFnZSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgICBcbiAgICAgIHZhciBkYXJrbmVzcyA9IHN0eWxlWydiYWNrZ3JvdW5kLWJsYWNrZW4nXS52YWx1ZTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlO1xuXG4gICAgICBpZiggdGhpcy5oYXNQaWUobm9kZSkgKXtcbiAgICAgICAgdGhpcy5kcmF3UGllKCBjb250ZXh0LCBub2RlLCBwYXJlbnRPcGFjaXR5ICk7XG5cbiAgICAgICAgLy8gcmVkcmF3IHBhdGggZm9yIGJsYWNrZW4gYW5kIGJvcmRlclxuICAgICAgICBpZiggZGFya25lc3MgIT09IDAgfHwgYm9yZGVyV2lkdGggIT09IDAgKXtcblxuICAgICAgICAgIGlmKCAhdXNlUGF0aHMgKXtcbiAgICAgICAgICAgIENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUobm9kZSldLmRyYXdQYXRoKFxuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgcG9zLngsXG4gICAgICAgICAgICAgICAgcG9zLnksXG4gICAgICAgICAgICAgICAgbm9kZVdpZHRoLFxuICAgICAgICAgICAgICAgIG5vZGVIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggZGFya25lc3MgPiAwICl7XG4gICAgICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIDAsIDAsIDAsIGRhcmtuZXNzKTtcblxuICAgICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiggZGFya25lc3MgPCAwICl7XG4gICAgICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIC1kYXJrbmVzcyk7XG4gICAgICAgIFxuICAgICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCb3JkZXIgd2lkdGgsIGRyYXcgYm9yZGVyXG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG5cbiAgICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoIHBhdGggKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGJvcmRlclN0eWxlID09PSAnZG91YmxlJyApe1xuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWUvMztcblxuICAgICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuXG4gICAgICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCAtcG9zLngsIC1wb3MueSApO1xuICAgICAgfVxuXG4gICAgICAvLyByZXNldCBpbiBjYXNlIHdlIGNoYW5nZWQgdGhlIGJvcmRlciBzdHlsZVxuICAgICAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICAgIH1cblxuICAgIC8vIGRyYXcgdGhlIG92ZXJsYXlcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiggb3ZlcmxheU9wYWNpdHkgPiAwICl7XG4gICAgICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIG92ZXJsYXlDb2xvclswXSwgb3ZlcmxheUNvbG9yWzFdLCBvdmVybGF5Q29sb3JbMl0sIG92ZXJsYXlPcGFjaXR5KTtcblxuICAgICAgICBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddLmRyYXdQYXRoKFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICAgIG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgICBub2RlV2lkdGggKyBvdmVybGF5UGFkZGluZyAqIDIsXG4gICAgICAgICAgbm9kZUhlaWdodCArIG92ZXJsYXlQYWRkaW5nICogMlxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIC8vIGRvZXMgdGhlIG5vZGUgaGF2ZSBhdCBsZWFzdCBvbmUgcGllIHBpZWNlP1xuICBDUnAuaGFzUGllID0gZnVuY3Rpb24obm9kZSl7XG4gICAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG4gICAgXG4gICAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuaGFzUGllO1xuICB9O1xuXG4gIENScC5kcmF3UGllID0gZnVuY3Rpb24oIGNvbnRleHQsIG5vZGUsIG5vZGVPcGFjaXR5ICl7XG4gICAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuICAgIHZhciBwaWVTaXplID0gc3R5bGVbJ3BpZS1zaXplJ107XG4gICAgdmFyIG5vZGVXID0gdGhpcy5nZXROb2RlV2lkdGgoIG5vZGUgKTtcbiAgICB2YXIgbm9kZUggPSB0aGlzLmdldE5vZGVIZWlnaHQoIG5vZGUgKTtcbiAgICB2YXIgeCA9IF9wLnBvc2l0aW9uLng7XG4gICAgdmFyIHkgPSBfcC5wb3NpdGlvbi55O1xuICAgIHZhciByYWRpdXMgPSBNYXRoLm1pbiggbm9kZVcsIG5vZGVIICkgLyAyOyAvLyBtdXN0IGZpdCBpbiBub2RlXG4gICAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuICAgIHZhciB1c2VQYXRocyA9IENhbnZhc1JlbmRlcmVyLnVzZVBhdGhzKCk7XG5cbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIHggPSAwO1xuICAgICAgeSA9IDA7XG4gICAgfVxuXG4gICAgaWYoIHBpZVNpemUudW5pdHMgPT09ICclJyApe1xuICAgICAgcmFkaXVzID0gcmFkaXVzICogcGllU2l6ZS52YWx1ZSAvIDEwMDtcbiAgICB9IGVsc2UgaWYoIHBpZVNpemUucHhWYWx1ZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICByYWRpdXMgPSBwaWVTaXplLnB4VmFsdWUgLyAyO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAxOyBpIDw9ICQkLnN0eWxlLnBpZUJhY2tncm91bmROOyBpKysgKXsgLy8gMS4uTlxuICAgICAgdmFyIHNpemUgPSBzdHlsZVsncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnXS52YWx1ZTtcbiAgICAgIHZhciBjb2xvciA9IHN0eWxlWydwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InXS52YWx1ZTtcbiAgICAgIHZhciBvcGFjaXR5ID0gc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5J10udmFsdWUgKiBub2RlT3BhY2l0eTtcbiAgICAgIHZhciBwZXJjZW50ID0gc2l6ZSAvIDEwMDsgLy8gbWFwIGludGVnZXIgcmFuZ2UgWzAsIDEwMF0gdG8gWzAsIDFdXG4gICAgICB2YXIgYW5nbGVTdGFydCA9IDEuNSAqIE1hdGguUEkgKyAyICogTWF0aC5QSSAqIGxhc3RQZXJjZW50OyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrIGFuZCBnbyBjbG9ja3dpc2VcbiAgICAgIHZhciBhbmdsZURlbHRhID0gMiAqIE1hdGguUEkgKiBwZXJjZW50O1xuICAgICAgdmFyIGFuZ2xlRW5kID0gYW5nbGVTdGFydCArIGFuZ2xlRGVsdGE7XG5cbiAgICAgIC8vIGlnbm9yZSBpZlxuICAgICAgLy8gLSB6ZXJvIHNpemVcbiAgICAgIC8vIC0gd2UncmUgYWxyZWFkeSBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgICAvLyAtIGFkZGluZyB0aGUgY3VycmVudCBzbGljZSB3b3VsZCBnbyBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgICBpZiggc2l6ZSA9PT0gMCB8fCBsYXN0UGVyY2VudCA+PSAxIHx8IGxhc3RQZXJjZW50ICsgcGVyY2VudCA+IDEgKXtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGNvbnRleHQuYXJjKCB4LCB5LCByYWRpdXMsIGFuZ2xlU3RhcnQsIGFuZ2xlRW5kICk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcblxuICAgICAgY29udGV4dC5maWxsKCk7XG5cbiAgICAgIGxhc3RQZXJjZW50ICs9IHBlcmNlbnQ7XG4gICAgfVxuXG4gIH07XG5cbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgQ1IgPSBDYW52YXNSZW5kZXJlcjtcbiAgdmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcblxuICAvLyB2YXIgaXNGaXJlZm94ID0gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcblxuICBDUnAuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKCl7IFxuICAgIHZhciBjb250ZXh0ID0gdGhpcy5kYXRhLmNvbnRleHRzWzBdO1xuXG4gICAgaWYoIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyAhPSBudWxsICl7XG4gICAgICByZXR1cm4gdGhpcy5mb3JjZWRQaXhlbFJhdGlvO1xuICAgIH1cblxuICAgIHZhciBiYWNraW5nU3RvcmUgPSBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGNvbnRleHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAvL2NvbnNvbGUubG9nKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCBiYWNraW5nU3RvcmUpO1xuXG4gICAgLy8gaWYoIGlzRmlyZWZveCApeyAvLyBiZWNhdXNlIGZmIGNhbid0IHNjYWxlIGNhbnZhcyBwcm9wZXJseVxuICAgIC8vICAgcmV0dXJuIDE7XG4gICAgLy8gfVxuXG4gICAgcmV0dXJuICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIGJhY2tpbmdTdG9yZTtcbiAgfTtcblxuICBDUnAucGFpbnRDYWNoZSA9IGZ1bmN0aW9uKGNvbnRleHQpe1xuICAgIHZhciBjYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzID0gdGhpcy5wYWludENhY2hlcyB8fCBbXTtcbiAgICB2YXIgbmVlZFRvQ3JlYXRlQ2FjaGUgPSB0cnVlO1xuICAgIHZhciBjYWNoZTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ldO1xuXG4gICAgICBpZiggY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCApe1xuICAgICAgICBuZWVkVG9DcmVhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggbmVlZFRvQ3JlYXRlQ2FjaGUgKXtcbiAgICAgIGNhY2hlID0ge1xuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICB9O1xuICAgICAgY2FjaGVzLnB1c2goIGNhY2hlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlO1xuICB9O1xuXG4gIENScC5maWxsU3R5bGUgPSBmdW5jdGlvbihjb250ZXh0LCByLCBnLCBiLCBhKXtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICAgIFxuICAgIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAgIC8vIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcblxuICAgIC8vIHZhciBmaWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAgIC8vIGlmKCBjYWNoZS5maWxsU3R5bGUgIT09IGZpbGxTdHlsZSApe1xuICAgIC8vICAgY29udGV4dC5maWxsU3R5bGUgPSBjYWNoZS5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgLy8gfVxuICB9O1xuXG4gIENScC5zdHJva2VTdHlsZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHIsIGcsIGIsIGEpe1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgICBcbiAgICAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG5cbiAgICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG5cbiAgICAvLyB2YXIgc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAgIC8vIGlmKCBjYWNoZS5zdHJva2VTdHlsZSAhPT0gc3Ryb2tlU3R5bGUgKXtcbiAgICAvLyAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjYWNoZS5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgIC8vIH1cbiAgfTtcbiAgXG4gIENScC5zaGFkb3dTdHlsZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNvbG9yLCBvcGFjaXR5LCBibHVyLCBvZmZzZXRYLCBvZmZzZXRZKXtcbiAgICB2YXIgem9vbSA9IHRoaXMuZGF0YS5jeS56b29tKCk7XG5cbiAgICB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG4gICAgXG4gICAgLy8gZG9uJ3QgbWFrZSBleHBlbnNpdmUgY2hhbmdlcyB0byB0aGUgc2hhZG93IHN0eWxlIGlmIGl0J3Mgbm90IHVzZWRcbiAgICBpZiggY2FjaGUuc2hhZG93T3BhY2l0eSA9PT0gMCAmJiBvcGFjaXR5ID09PSAwICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FjaGUuc2hhZG93T3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgICBpZiAob3BhY2l0eSA+IDApIHtcbiAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IGJsdXIgKiB6b29tO1xuICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwicmdiYShcIiArIGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiLFwiICsgY29sb3JbMl0gKyBcIixcIiArIG9wYWNpdHkgKyBcIilcIjtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IG9mZnNldFggKiB6b29tO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gb2Zmc2V0WSAqIHpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXNpemUgY2FudmFzXG4gIENScC5tYXRjaENhbnZhc1NpemUgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgd2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLmdldFBpeGVsUmF0aW8oKTtcbiAgICB2YXIgbWJQeFJhdGlvID0gdGhpcy5tb3Rpb25CbHVyUHhSYXRpbztcblxuICAgIGlmKFxuICAgICAgY29udGFpbmVyID09PSB0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbQ1IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gfHxcbiAgICAgIGNvbnRhaW5lciA9PT0gdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW0NSLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddXG4gICAgKXtcbiAgICAgIHBpeGVsUmF0aW8gPSBtYlB4UmF0aW87XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhc1dpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICAgIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgIHZhciBjYW52YXM7XG5cbiAgICBpZiggY2FudmFzV2lkdGggPT09IHRoaXMuY2FudmFzV2lkdGggJiYgY2FudmFzSGVpZ2h0ID09PSB0aGlzLmNhbnZhc0hlaWdodCApe1xuICAgICAgcmV0dXJuOyAvLyBzYXZlIGN5Y2xlcyBpZiBzYW1lXG4gICAgfVxuXG4gICAgdGhpcy5mb250Q2FjaGVzID0gbnVsbDsgLy8gcmVzaXppbmcgcmVzZXRzIHRoZSBzdHlsZVxuXG4gICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IGRhdGEuY2FudmFzQ29udGFpbmVyO1xuICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBjYW52YXNDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUzsgaSsrKSB7XG5cbiAgICAgIGNhbnZhcyA9IGRhdGEuY2FudmFzZXNbaV07XG4gICAgICBcbiAgICAgIGlmIChjYW52YXMud2lkdGggIT09IGNhbnZhc1dpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGNhbnZhc0hlaWdodCkge1xuICAgICAgICBcbiAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG5cbiAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDYW52YXNSZW5kZXJlci5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgICAgXG4gICAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzW2ldO1xuICAgICAgXG4gICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0dXJlTXVsdCA9IDE7XG4gICAgaWYoIHBpeGVsUmF0aW8gPD0gMSApe1xuICAgICAgY2FudmFzID0gZGF0YS5idWZmZXJDYW52YXNlc1sgQ2FudmFzUmVuZGVyZXIuVEVYVFVSRV9CVUZGRVIgXTtcblxuICAgICAgdGhpcy50ZXh0dXJlTXVsdCA9IDI7XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aCAqIHRoaXMudGV4dHVyZU11bHQ7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0ICogdGhpcy50ZXh0dXJlTXVsdDtcbiAgICB9XG5cbiAgICB0aGlzLmNhbnZhc1dpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgdGhpcy5jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG5cbiAgfTtcblxuICBDUnAucmVuZGVyVG8gPSBmdW5jdGlvbiggY3h0LCB6b29tLCBwYW4sIHB4UmF0aW8gKXtcbiAgICB0aGlzLnJlZHJhdyh7XG4gICAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgICBmb3JjZWRab29tOiB6b29tLFxuICAgICAgZm9yY2VkUGFuOiBwYW4sXG4gICAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgICAgZm9yY2VkUHhSYXRpbzogcHhSYXRpb1xuICAgIH0pO1xuICB9O1xuXG4gIENScC50aW1lVG9SZW5kZXIgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnJlZHJhd1RvdGFsVGltZSAvIHRoaXMucmVkcmF3Q291bnQ7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIubWluUmVkcmF3TGltaXQgPSAxMDAwLzYwOyAvLyBwZW9wbGUgY2FuJ3Qgc2VlIG11Y2ggYmV0dGVyIHRoYW4gNjBmcHNcbiAgQ2FudmFzUmVuZGVyZXIubWF4UmVkcmF3TGltaXQgPSAxMDAwOyAgLy8gZG9uJ3QgY2FwIG1heCBiL2MgaXQncyBtb3JlIGltcG9ydGFudCB0byBiZSByZXNwb25zaXZlIHRoYW4gc21vb3RoXG4gIENhbnZhc1JlbmRlcmVyLm1vdGlvbkJsdXJEZWxheSA9IDEwMDtcblxuICAvLyBSZWRyYXcgZnJhbWVcbiAgQ1JwLnJlZHJhdyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gY29uc29sZS5sb2coJ3JlZHJhdygpJyk7XG5cbiAgICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgICB2YXIgZHJhd0FsbExheWVycyA9IG9wdGlvbnMuZHJhd0FsbExheWVycztcbiAgICB2YXIgZHJhd09ubHlOb2RlTGF5ZXIgPSBvcHRpb25zLmRyYXdPbmx5Tm9kZUxheWVyO1xuICAgIHZhciBmb3JjZWRab29tID0gb3B0aW9ucy5mb3JjZWRab29tO1xuICAgIHZhciBmb3JjZWRQYW4gPSBvcHRpb25zLmZvcmNlZFBhbjtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBvcHRpb25zLmZvcmNlZFB4UmF0aW8gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UGl4ZWxSYXRpbygpIDogb3B0aW9ucy5mb3JjZWRQeFJhdGlvO1xuICAgIHZhciBjeSA9IHIuZGF0YS5jeTsgdmFyIGRhdGEgPSByLmRhdGE7IFxuICAgIHZhciBuZWVkRHJhdyA9IGRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG4gICAgdmFyIHRleHR1cmVEcmF3ID0gci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCAmJiAoci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nKTtcbiAgICB2YXIgbW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1ciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb3Rpb25CbHVyIDogci5tb3Rpb25CbHVyO1xuICAgIHZhciBtYlB4UmF0aW8gPSByLm1vdGlvbkJsdXJQeFJhdGlvO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBpbk5vZGVEcmFnR2VzdHVyZSA9IHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcztcbiAgICB2YXIgaW5Cb3hTZWxlY3Rpb24gPSByLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nID8gdHJ1ZSA6IGZhbHNlO1xuICAgIG1vdGlvbkJsdXIgPSBtb3Rpb25CbHVyICYmICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1ckVuYWJsZWQgJiYgIWluQm94U2VsZWN0aW9uO1xuICAgIHZhciBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IG1vdGlvbkJsdXI7XG5cbiAgICAvLyBjb25zb2xlLmxvZygndGV4dHVyZURyYXc/JywgdGV4dHVyZURyYXcpO1xuXG5cbiAgICBpZiggIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyVGltZW91dCApe1xuICAgICAgY2xlYXJUaW1lb3V0KCByLm1vdGlvbkJsdXJUaW1lb3V0ICk7XG4gICAgfVxuXG4gICAgaWYoICFmb3JjZWRDb250ZXh0ICYmIHRoaXMucmVkcmF3VGltZW91dCApe1xuICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLnJlZHJhd1RpbWVvdXQgKTtcbiAgICB9XG4gICAgdGhpcy5yZWRyYXdUaW1lb3V0ID0gbnVsbDtcblxuICAgIGlmKCB0aGlzLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQgKXsgdGhpcy5hdmVyYWdlUmVkcmF3VGltZSA9IDA7IH1cblxuICAgIHZhciBtaW5SZWRyYXdMaW1pdCA9IENhbnZhc1JlbmRlcmVyLm1pblJlZHJhd0xpbWl0OyBcbiAgICB2YXIgbWF4UmVkcmF3TGltaXQgPSBDYW52YXNSZW5kZXJlci5tYXhSZWRyYXdMaW1pdDtcblxuICAgIHZhciByZWRyYXdMaW1pdCA9IHRoaXMuYXZlcmFnZVJlZHJhd1RpbWU7IC8vIGVzdGltYXRlIHRoZSBpZGVhbCByZWRyYXcgbGltaXQgYmFzZWQgb24gaG93IGZhc3Qgd2UgY2FuIGRyYXdcbiAgICByZWRyYXdMaW1pdCA9IG1pblJlZHJhd0xpbWl0ID4gcmVkcmF3TGltaXQgPyBtaW5SZWRyYXdMaW1pdCA6IHJlZHJhd0xpbWl0O1xuICAgIHJlZHJhd0xpbWl0ID0gcmVkcmF3TGltaXQgPCBtYXhSZWRyYXdMaW1pdCA/IHJlZHJhd0xpbWl0IDogbWF4UmVkcmF3TGltaXQ7XG5cbiAgICAvL2NvbnNvbGUubG9nKCctLVxcbmlkZWFsOiAlaTsgZWZmZWN0aXZlOiAlaScsIHRoaXMuYXZlcmFnZVJlZHJhd1RpbWUsIHJlZHJhd0xpbWl0KTtcblxuICAgIGlmKCB0aGlzLmxhc3REcmF3VGltZSA9PT0gdW5kZWZpbmVkICl7IHRoaXMubGFzdERyYXdUaW1lID0gMDsgfVxuXG4gICAgdmFyIG5vd1RpbWUgPSBEYXRlLm5vdygpO1xuICAgIHZhciB0aW1lRWxhcHNlZCA9IG5vd1RpbWUgLSB0aGlzLmxhc3REcmF3VGltZTtcbiAgICB2YXIgY2FsbEFmdGVyTGltaXQgPSB0aW1lRWxhcHNlZCA+PSByZWRyYXdMaW1pdDtcblxuICAgIGlmKCAhZm9yY2VkQ29udGV4dCAmJiAhci5jbGVhcmluZ01vdGlvbkJsdXIgKXtcbiAgICAgIGlmKCAhY2FsbEFmdGVyTGltaXQgfHwgdGhpcy5jdXJyZW50bHlEcmF3aW5nICl7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLSBza2lwJywgcmVkcmF3TGltaXQpO1xuXG4gICAgICAgIC8vIHdlIGhhdmUgbmV3IHRoaW5ncyB0byBkcmF3IGJ1dCB3ZSdyZSBidXN5LCBzbyB0cnkgYWdhaW4gd2hlbiBwb3NzaWJseSBmcmVlXG4gICAgICAgIHRoaXMucmVkcmF3VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9LCByZWRyYXdMaW1pdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0RHJhd1RpbWUgPSBub3dUaW1lO1xuICAgICAgdGhpcy5jdXJyZW50bHlEcmF3aW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiggbW90aW9uQmx1ciApe1xuICAgICAgaWYoIHIubWJGcmFtZXMgPT0gbnVsbCApe1xuICAgICAgICByLm1iRnJhbWVzID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYoICFyLmRyYXdpbmdJbWFnZSApeyAvLyBpbWFnZSBsb2FkaW5nIGZyYW1lcyBkb24ndCBjb3VudCB0b3dhcmRzIG1vdGlvbiBibHVyIGJsdXJyeSBmcmFtZXNcbiAgICAgICAgci5tYkZyYW1lcysrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggci5tYkZyYW1lcyA8IDMgKXsgLy8gbmVlZCBzZXZlcmFsIGZyYW1lcyBiZWZvcmUgZXZlbiBoaWdoIHF1YWxpdHkgbW90aW9uYmx1clxuICAgICAgICBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBnbyB0byBsb3dlciBxdWFsaXR5IGJsdXJyeSBmcmFtZXMgd2hlbiBzZXZlcmFsIG0vYiBmcmFtZXMgaGF2ZSBiZWVuIHJlbmRlcmVkIChhdm9pZHMgZmxhc2hpbmcpXG4gICAgICBpZiggci5tYkZyYW1lcyA+IHIubWluTWJMb3dRdWFsRnJhbWVzICl7XG4gICAgICAgIC8vci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gICAgICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSByLm1iUHhSQmx1cnJ5O1xuICAgICAgfVxuICAgIH0gXG5cbiAgICAvLyBjb25zb2xlLmxvZygnbWI6ICVzLCBOOiAlcywgcTogJXMnLCBtb3Rpb25CbHVyLCByLm1iRnJhbWVzLCByLm1vdGlvbkJsdXJQeFJhdGlvKTtcblxuICAgIGlmKCByLmNsZWFyaW5nTW90aW9uQmx1ciApe1xuICAgICAgLy9yLmZ1bGxRdWFsaXR5TWIgPSB0cnVlOyAvLyBUT0RPIGVuYWJsZSB3aGVuIGRvZXNuJ3QgY2F1c2Ugc2NhbGVkIGZsYXNoaW5nIGlzc3VlXG5cbiAgICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICAgIH1cblxuXG4gICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnLS0gcmVkcmF3IC0tJylcbiAgICBcbiAgICBmdW5jdGlvbiBkcmF3VG9Db250ZXh0KCl7IFxuICAgICAgLy8gc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIC8vIGNvbnNvbGUucHJvZmlsZSgnZHJhdycgKyBzdGFydFRpbWUpXG4gICAgICBcbiAgICAgIC8vIGIvYyBkcmF3VG9Db250ZXh0KCkgbWF5IGJlIGFzeW5jIHcuci50LiByZWRyYXcoKSwga2VlcCB0cmFjayBvZiBsYXN0IHRleHR1cmUgZnJhbWVcbiAgICAgIC8vIGJlY2F1c2UgYSByb2d1ZSBhc3luYyB0ZXh0dXJlIGZyYW1lIHdvdWxkIGNsZWFyIG5lZWREcmF3XG4gICAgICBpZiggci50ZXh0dXJlRHJhd0xhc3RGcmFtZSAmJiAhdGV4dHVyZURyYXcgKXtcbiAgICAgICAgbmVlZERyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICBuZWVkRHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdkcmF3VG9Db250ZXh0KCknKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnbmVlZERyYXcnLCBuZWVkRHJhd1tDUi5OT0RFXSwgbmVlZERyYXdbQ1IuRFJBR10sIG5lZWREcmF3W0NSLlNFTEVDVF9CT1hdICk7XG5cbiAgICAgIHZhciBlZGdlcyA9IHIuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgICAgIHZhciBjb3JlU3R5bGUgPSBjeS5zdHlsZSgpLl9wcml2YXRlLmNvcmVTdHlsZTtcbiAgICAgIFxuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgZWZmZWN0aXZlWm9vbSA9IGZvcmNlZFpvb20gIT09IHVuZGVmaW5lZCA/IGZvcmNlZFpvb20gOiB6b29tO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIGVmZmVjdGl2ZVBhbiA9IHtcbiAgICAgICAgeDogcGFuLngsXG4gICAgICAgIHk6IHBhbi55XG4gICAgICB9O1xuXG4gICAgICB2YXIgdnAgPSB7XG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIHBhbjoge1xuICAgICAgICAgIHg6IHBhbi54LFxuICAgICAgICAgIHk6IHBhbi55XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcHJldlZwID0gci5wcmV2Vmlld3BvcnQ7XG4gICAgICB2YXIgdmlld3BvcnRJc0RpZmYgPSBwcmV2VnAgPT09IHVuZGVmaW5lZCB8fCB2cC56b29tICE9PSBwcmV2VnAuem9vbSB8fCB2cC5wYW4ueCAhPT0gcHJldlZwLnBhbi54IHx8IHZwLnBhbi55ICE9PSBwcmV2VnAucGFuLnk7XG5cbiAgICAgIC8vIHdlIHdhbnQgdGhlIGxvdyBxdWFsaXR5IG1vdGlvbmJsdXIgb25seSB3aGVuIHRoZSB2aWV3cG9ydCBpcyBiZWluZyBtYW5pcHVsYXRlZCBldGMgKHdoZXJlIGl0J3Mgbm90IG5vdGljZWQpXG4gICAgICBpZiggIXZpZXdwb3J0SXNEaWZmICYmICEoaW5Ob2RlRHJhZ0dlc3R1cmUgJiYgIWhhc0NvbXBvdW5kTm9kZXMpICl7XG4gICAgICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiggZm9yY2VkUGFuICl7XG4gICAgICAgIGVmZmVjdGl2ZVBhbiA9IGZvcmNlZFBhbjtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcGl4ZWwgcmF0aW9cblxuICAgICAgZWZmZWN0aXZlWm9vbSAqPSBwaXhlbFJhdGlvO1xuICAgICAgZWZmZWN0aXZlUGFuLnggKj0gcGl4ZWxSYXRpbztcbiAgICAgIGVmZmVjdGl2ZVBhbi55ICo9IHBpeGVsUmF0aW87XG4gICAgICBcbiAgICAgIHZhciBlbGVzID0ge1xuICAgICAgICBkcmFnOiB7XG4gICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgIGVkZ2VzOiBbXSxcbiAgICAgICAgICBlbGVzOiBbXVxuICAgICAgICB9LFxuICAgICAgICBub25kcmFnOiB7XG4gICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgIGVkZ2VzOiBbXSxcbiAgICAgICAgICBlbGVzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBtYmNsZWFyKCBjb250ZXh0LCB4LCB5LCB3LCBoICl7XG4gICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgICByLmZpbGxTdHlsZSggY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5ICk7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgY2xlYXIpe1xuICAgICAgICB2YXIgZVBhbiwgZVpvb20sIHcsIGg7XG5cbiAgICAgICAgaWYoIC8qIXIuZnVsbFF1YWxpdHlNYiAmJiovICFyLmNsZWFyaW5nTW90aW9uQmx1ciAmJiAoY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1tDUi5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW0NSLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddKSApe1xuICAgICAgICAgIGVQYW4gPSB7XG4gICAgICAgICAgICB4OiBwYW4ueCAqIG1iUHhSYXRpbyxcbiAgICAgICAgICAgIHk6IHBhbi55ICogbWJQeFJhdGlvXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGVab29tID0gem9vbSAqIG1iUHhSYXRpbztcblxuICAgICAgICAgIHcgPSByLmNhbnZhc1dpZHRoICogbWJQeFJhdGlvO1xuICAgICAgICAgIGggPSByLmNhbnZhc0hlaWdodCAqIG1iUHhSYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlUGFuID0gZWZmZWN0aXZlUGFuO1xuICAgICAgICAgIGVab29tID0gZWZmZWN0aXZlWm9vbTtcblxuICAgICAgICAgIHcgPSByLmNhbnZhc1dpZHRoO1xuICAgICAgICAgIGggPSByLmNhbnZhc0hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICAgIGlmKCBjbGVhciA9PT0gJ21vdGlvbkJsdXInICl7IFxuICAgICAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdywgaCk7XG4gICAgICAgIH0gZWxzZSBpZiggIWZvcmNlZENvbnRleHQgJiYgKGNsZWFyID09PSB1bmRlZmluZWQgfHwgY2xlYXIpICl7XG4gICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCAhZHJhd0FsbExheWVycyApe1xuICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCBlUGFuLngsIGVQYW4ueSApO1xuICAgICAgICAgIGNvbnRleHQuc2NhbGUoIGVab29tLCBlWm9vbSApO1xuICAgICAgICB9XG4gICAgICAgIGlmKCBmb3JjZWRQYW4gKXtcbiAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSggZm9yY2VkUGFuLngsIGZvcmNlZFBhbi55ICk7XG4gICAgICAgIH0gXG4gICAgICAgIGlmKCBmb3JjZWRab29tICl7XG4gICAgICAgICAgY29udGV4dC5zY2FsZSggZm9yY2VkWm9vbSwgZm9yY2VkWm9vbSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhdGV4dHVyZURyYXcgKXtcbiAgICAgICAgci50ZXh0dXJlRHJhd0xhc3RGcmFtZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiggdGV4dHVyZURyYXcgKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3RleHR1cmVEcmF3JylcbiAgICAgICAgXG4gICAgICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSB0cnVlO1xuXG4gICAgICAgIHZhciBiYjtcblxuICAgICAgICBpZiggIXIudGV4dHVyZUNhY2hlICl7XG4gICAgICAgICAgci50ZXh0dXJlQ2FjaGUgPSB7fTtcblxuICAgICAgICAgIGJiID0gci50ZXh0dXJlQ2FjaGUuYmIgPSBjeS5lbGVtZW50cygpLmJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgICByLnRleHR1cmVDYWNoZS50ZXh0dXJlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyBDYW52YXNSZW5kZXJlci5URVhUVVJFX0JVRkZFUiBdO1xuXG4gICAgICAgICAgdmFyIGN4dCA9IHIuZGF0YS5idWZmZXJDb250ZXh0c1sgQ2FudmFzUmVuZGVyZXIuVEVYVFVSRV9CVUZGRVIgXTtcblxuICAgICAgICAgIGN4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoICogci50ZXh0dXJlTXVsdCwgci5jYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0KTtcbiAgICAgICAgICBcbiAgICAgICAgICByLnJlZHJhdyh7XG4gICAgICAgICAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgICAgICAgICBkcmF3T25seU5vZGVMYXllcjogdHJ1ZSxcbiAgICAgICAgICAgIGZvcmNlZFB4UmF0aW86IHBpeGVsUmF0aW8gKiByLnRleHR1cmVNdWx0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydCA9IHtcbiAgICAgICAgICAgIHpvb206IGN5Lnpvb20oKSxcbiAgICAgICAgICAgIHBhbjogY3kucGFuKCksXG4gICAgICAgICAgICB3aWR0aDogci5jYW52YXNXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogci5jYW52YXNIZWlnaHRcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdnAubXBhbiA9IHtcbiAgICAgICAgICAgIHg6ICgwIC0gdnAucGFuLngpL3ZwLnpvb20sXG4gICAgICAgICAgICB5OiAoMCAtIHZwLnBhbi55KS92cC56b29tXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5lZWREcmF3W0NSLkRSQUddID0gZmFsc2U7XG4gICAgICAgIG5lZWREcmF3W0NSLk5PREVdID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBkYXRhLmNvbnRleHRzW0NSLk5PREVdO1xuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gci50ZXh0dXJlQ2FjaGUudGV4dHVyZTtcbiAgICAgICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQ7XG4gICAgICAgIGJiID0gci50ZXh0dXJlQ2FjaGUuYmI7XG5cbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgICAgaWYoIG1vdGlvbkJsdXIgKXtcbiAgICAgICAgICBtYmNsZWFyKGNvbnRleHQsIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHNpZGVCZ0NvbG9yID0gY29yZVN0eWxlWydvdXRzaWRlLXRleHR1cmUtYmctY29sb3InXS52YWx1ZTtcbiAgICAgICAgdmFyIG91dHNpZGVCZ09wYWNpdHkgPSBjb3JlU3R5bGVbJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5J10udmFsdWU7XG4gICAgICAgIHIuZmlsbFN0eWxlKCBjb250ZXh0LCBvdXRzaWRlQmdDb2xvclswXSwgb3V0c2lkZUJnQ29sb3JbMV0sIG91dHNpZGVCZ0NvbG9yWzJdLCBvdXRzaWRlQmdPcGFjaXR5ICk7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQgKTtcblxuICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgICAgXG4gICAgICAgIHNldENvbnRleHRUcmFuc2Zvcm0oIGNvbnRleHQsIGZhbHNlICk7XG5cbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoIHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aC92cC56b29tL3BpeGVsUmF0aW8sIHZwLmhlaWdodC92cC56b29tL3BpeGVsUmF0aW8gKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIHRleHR1cmUsIHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aC92cC56b29tL3BpeGVsUmF0aW8sIHZwLmhlaWdodC92cC56b29tL3BpeGVsUmF0aW8gKTtcblxuICAgICAgfSBlbHNlIGlmKCByLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0ICl7IC8vIGNsZWFyIHRoZSBjYWNoZSBzaW5jZSB3ZSBkb24ndCBuZWVkIGl0XG4gICAgICAgIHIudGV4dHVyZUNhY2hlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHZwTWFuaXAgPSAoci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyk7XG4gICAgICB2YXIgaGlkZUVkZ2VzID0gci5oaWRlRWRnZXNPblZpZXdwb3J0ICYmIHZwTWFuaXA7XG4gICAgICB2YXIgaGlkZUxhYmVscyA9IHIuaGlkZUxhYmVsc09uVmlld3BvcnQgJiYgdnBNYW5pcDtcblxuICAgICAgaWYgKG5lZWREcmF3W0NSLkRSQUddIHx8IG5lZWREcmF3W0NSLk5PREVdIHx8IGRyYXdBbGxMYXllcnMgfHwgZHJhd09ubHlOb2RlTGF5ZXIpIHtcbiAgICAgICAgLy9OQiA6IFZFUlkgRVhQRU5TSVZFXG5cbiAgICAgICAgaWYoIGhpZGVFZGdlcyApeyBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByLmZpbmRFZGdlQ29udHJvbFBvaW50cyhlZGdlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgekVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gICAgICAgIHZhciBleHRlbnQgPSBjeS5leHRlbnQoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpFbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IHpFbGVzW2ldO1xuICAgICAgICAgIHZhciBsaXN0O1xuICAgICAgICAgIHZhciBiYiA9IGZvcmNlZENvbnRleHQgPyBudWxsIDogZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgdmFyIGluc2lkZUV4dGVudCA9IGZvcmNlZENvbnRleHQgPyB0cnVlIDogJCQubWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0KCBleHRlbnQsIGJiICk7XG5cbiAgICAgICAgICBpZiggIWluc2lkZUV4dGVudCApeyBjb250aW51ZTsgfSAvLyBubyBuZWVkIHRvIHJlbmRlclxuXG4gICAgICAgICAgaWYgKCBlbGUuX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgKSB7XG4gICAgICAgICAgICBsaXN0ID0gZWxlcy5kcmFnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0ID0gZWxlcy5ub25kcmFnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3QuZWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gZHJhd0VsZW1lbnRzKCBsaXN0LCBjb250ZXh0ICl7XG4gICAgICAgIHZhciBlbGVzID0gbGlzdC5lbGVzO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICAgICAgaWYoIGVsZS5pc05vZGUoKSApe1xuICAgICAgICAgICAgci5kcmF3Tm9kZShjb250ZXh0LCBlbGUpO1xuXG4gICAgICAgICAgICBpZiggIWhpZGVMYWJlbHMgKXtcbiAgICAgICAgICAgICAgci5kcmF3Tm9kZVRleHQoY29udGV4dCwgZWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5kcmF3Tm9kZShjb250ZXh0LCBlbGUsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiggIWhpZGVFZGdlcyApIHtcbiAgICAgICAgICAgIHIuZHJhd0VkZ2UoY29udGV4dCwgZWxlKTtcblxuICAgICAgICAgICAgaWYoICFoaWRlTGFiZWxzICl7XG4gICAgICAgICAgICAgIHIuZHJhd0VkZ2VUZXh0KGNvbnRleHQsIGVsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuZHJhd0VkZ2UoY29udGV4dCwgZWxlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB2YXIgbmVlZE1iQ2xlYXIgPSBbXTtcblxuICAgICAgbmVlZE1iQ2xlYXJbQ1IuTk9ERV0gPSAhbmVlZERyYXdbQ1IuTk9ERV0gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1cltDUi5OT0RFXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcbiAgICAgIGlmKCBuZWVkTWJDbGVhcltDUi5OT0RFXSApeyByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW0NSLk5PREVdID0gdHJ1ZTsgfVxuXG4gICAgICBuZWVkTWJDbGVhcltDUi5EUkFHXSA9ICFuZWVkRHJhd1tDUi5EUkFHXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW0NSLkRSQUddIHx8IHIuY2xlYXJpbmdNb3Rpb25CbHVyO1xuICAgICAgaWYoIG5lZWRNYkNsZWFyW0NSLkRSQUddICl7IHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbQ1IuRFJBR10gPSB0cnVlOyB9XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCctLScpO1xuXG4gICAgICAvLyBpZiggbmVlZERyYXdbQ1IuRFJBR10gJiYgbW90aW9uQmx1ciAmJiBuZWVkRHJhd1tDUi5OT0RFXSAmJiBpbk5vZGVEcmFnR2VzdHVyZSApe1xuICAgICAgLy8gICBjb25zb2xlLmxvZygnTk9ERSBibHVyY2xlYW4nKTtcbiAgICAgIC8vIFxuICAgICAgLy8gICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHNbQ1IuTk9ERV07XG4gICAgICAvLyBcbiAgICAgIC8vICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgdHJ1ZSApO1xuICAgICAgLy8gICBkcmF3RWxlbWVudHMoZWxlcy5ub25kcmFnLCBjb250ZXh0KTtcbiAgICAgIC8vIFxuICAgICAgLy8gICBuZWVkRHJhd1tDUi5OT0RFXSA9IGZhbHNlOyBcbiAgICAgIC8vICAgbmVlZE1iQ2xlYXJbQ1IuTk9ERV0gPSBmYWxzZTtcbiAgICAgIC8vIFxuICAgICAgLy8gfSBlbHNlIFxuICAgICAgaWYoIG5lZWREcmF3W0NSLk5PREVdIHx8IGRyYXdBbGxMYXllcnMgfHwgZHJhd09ubHlOb2RlTGF5ZXIgfHwgbmVlZE1iQ2xlYXJbQ1IuTk9ERV0gKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ05PREUnLCBuZWVkRHJhd1tDUi5OT0RFXSwgbmVlZE1iQ2xlYXJbQ1IuTk9ERV0pO1xuXG4gICAgICAgIHZhciB1c2VCdWZmZXIgPSBtb3Rpb25CbHVyICYmICFuZWVkTWJDbGVhcltDUi5OT0RFXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAoIHVzZUJ1ZmZlciA/IHIuZGF0YS5idWZmZXJDb250ZXh0c1sgQ1IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERSBdIDogZGF0YS5jb250ZXh0c1tDUi5OT0RFXSApO1xuICAgICAgICB2YXIgY2xlYXIgPSBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gaWYoIG5lZWREcmF3W0NSLkRSQUddICYmIG5lZWREcmF3W0NSLk5PREVdICl7XG4gICAgICAgIC8vICAgY2xlYXIgPSB0cnVlO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgY2xlYXIgKTtcbiAgICAgICAgZHJhd0VsZW1lbnRzKGVsZXMubm9uZHJhZywgY29udGV4dCk7XG4gICAgICAgIFxuICAgICAgICBpZiggIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIgKXtcbiAgICAgICAgICBuZWVkRHJhd1tDUi5OT0RFXSA9IGZhbHNlOyBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoICFkcmF3T25seU5vZGVMYXllciAmJiAobmVlZERyYXdbQ1IuRFJBR10gfHwgZHJhd0FsbExheWVycyB8fCBuZWVkTWJDbGVhcltDUi5EUkFHXSkgKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdEUkFHJyk7XG5cbiAgICAgICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyW0NSLkRSQUddICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICggdXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzWyBDUi5NT1RJT05CTFVSX0JVRkZFUl9EUkFHIF0gOiBkYXRhLmNvbnRleHRzW0NSLkRSQUddICk7XG4gICAgICAgIFxuICAgICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQgKTtcbiAgICAgICAgZHJhd0VsZW1lbnRzKGVsZXMuZHJhZywgY29udGV4dCk7XG4gICAgICAgIFxuICAgICAgICBpZiggIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIgKXtcbiAgICAgICAgICBuZWVkRHJhd1tDUi5EUkFHXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCByLnNob3dGcHMgfHwgKCFkcmF3T25seU5vZGVMYXllciAmJiAobmVlZERyYXdbQ1IuU0VMRUNUX0JPWF0gJiYgIWRyYXdBbGxMYXllcnMpKSApIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlZHJhd2luZyBzZWxlY3Rpb24gYm94Jyk7XG4gICAgICAgIFxuICAgICAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgZGF0YS5jb250ZXh0c1tDUi5TRUxFQ1RfQk9YXTtcblxuICAgICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0ICk7XG5cbiAgICAgICAgaWYoIGRhdGEuc2VsZWN0WzRdID09IDEgJiYgKCByLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nICkgKXtcbiAgICAgICAgICB2YXIgem9vbSA9IGRhdGEuY3kuem9vbSgpO1xuICAgICAgICAgIHZhciBib3JkZXJXaWR0aCA9IGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnXS52YWx1ZSAvIHpvb207XG4gICAgICAgICAgXG4gICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYShcIiBcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWNvbG9yJ10udmFsdWVbMF0gKyBcIixcIlxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtY29sb3InXS52YWx1ZVsxXSArIFwiLFwiXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1jb2xvciddLnZhbHVlWzJdICsgXCIsXCJcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LW9wYWNpdHknXS52YWx1ZSArIFwiKVwiO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoXG4gICAgICAgICAgICBkYXRhLnNlbGVjdFswXSxcbiAgICAgICAgICAgIGRhdGEuc2VsZWN0WzFdLFxuICAgICAgICAgICAgZGF0YS5zZWxlY3RbMl0gLSBkYXRhLnNlbGVjdFswXSxcbiAgICAgICAgICAgIGRhdGEuc2VsZWN0WzNdIC0gZGF0YS5zZWxlY3RbMV0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcInJnYmEoXCIgXG4gICAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvciddLnZhbHVlWzBdICsgXCIsXCJcbiAgICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJ10udmFsdWVbMV0gKyBcIixcIlxuICAgICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InXS52YWx1ZVsyXSArIFwiLFwiXG4gICAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LW9wYWNpdHknXS52YWx1ZSArIFwiKVwiO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoXG4gICAgICAgICAgICAgIGRhdGEuc2VsZWN0WzBdLFxuICAgICAgICAgICAgICBkYXRhLnNlbGVjdFsxXSxcbiAgICAgICAgICAgICAgZGF0YS5zZWxlY3RbMl0gLSBkYXRhLnNlbGVjdFswXSxcbiAgICAgICAgICAgICAgZGF0YS5zZWxlY3RbM10gLSBkYXRhLnNlbGVjdFsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyApe1xuICAgICAgICAgIHZhciB6b29tID0gZGF0YS5jeS56b29tKCk7XG4gICAgICAgICAgdmFyIHBvcyA9IGRhdGEuYmdBY3RpdmVQb3Npc3Rpb247XG5cbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYShcIiBcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydhY3RpdmUtYmctY29sb3InXS52YWx1ZVswXSArIFwiLFwiXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnYWN0aXZlLWJnLWNvbG9yJ10udmFsdWVbMV0gKyBcIixcIlxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1jb2xvciddLnZhbHVlWzJdICsgXCIsXCJcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydhY3RpdmUtYmctb3BhY2l0eSddLnZhbHVlICsgXCIpXCI7XG5cbiAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHBvcy54LCBwb3MueSwgY29yZVN0eWxlWydhY3RpdmUtYmctc2l6ZSddLnB4VmFsdWUgLyB6b29tLCAwLCAyICogTWF0aC5QSSk7IFxuICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgdGltZVRvUmVuZGVyID0gci5hdmVyYWdlUmVkcmF3VGltZTtcbiAgICAgICAgaWYoIHIuc2hvd0ZwcyAmJiB0aW1lVG9SZW5kZXIgKXtcbiAgICAgICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKCB0aW1lVG9SZW5kZXIgKTtcbiAgICAgICAgICB2YXIgZnBzID0gTWF0aC5yb3VuZCgxMDAwL3RpbWVUb1JlbmRlcik7XG5cbiAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgICAgIC8vY29udGV4dC5mb250ID0gJzIwcHggaGVsdmV0aWNhJztcbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgY29udGV4dC5maWxsVGV4dCggJzEgZnJhbWUgPSAnICsgdGltZVRvUmVuZGVyICsgJyBtcyA9ICcgKyBmcHMgKyAnIGZwcycsIDAsIDIwKTtcblxuICAgICAgICAgIHZhciBtYXhGcHMgPSA2MDtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoMCwgMzAsIDI1MCwgMjApO1xuICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMzAsIDI1MCAqIE1hdGgubWluKGZwcy9tYXhGcHMsIDEpLCAyMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWRyYXdBbGxMYXllcnMgKXtcbiAgICAgICAgICBuZWVkRHJhd1tDUi5TRUxFQ1RfQk9YXSA9IGZhbHNlOyBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBtb3Rpb25ibHVyOiBibGl0IHJlbmRlcmVkIGJsdXJyeSBmcmFtZXNcbiAgICAgIGlmKCBtb3Rpb25CbHVyICYmIG1iUHhSYXRpbyAhPT0gMSApe1xuICAgICAgICB2YXIgY3h0Tm9kZSA9IGRhdGEuY29udGV4dHNbQ1IuTk9ERV07XG4gICAgICAgIHZhciB0eHROb2RlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyBDUi5NT1RJT05CTFVSX0JVRkZFUl9OT0RFIF07XG5cbiAgICAgICAgdmFyIGN4dERyYWcgPSBkYXRhLmNvbnRleHRzW0NSLkRSQUddO1xuICAgICAgICB2YXIgdHh0RHJhZyA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1sgQ1IuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyBdO1xuXG4gICAgICAgIHZhciBkcmF3TW90aW9uQmx1ciA9IGZ1bmN0aW9uKCBjeHQsIHR4dCwgbmVlZENsZWFyICl7XG4gICAgICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgICAgIGlmKCBuZWVkQ2xlYXIgfHwgIW1vdGlvbkJsdXJGYWRlRWZmZWN0ICl7XG4gICAgICAgICAgICBjeHQuY2xlYXJSZWN0KCAwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYmNsZWFyKCBjeHQsIDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0ICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHZhciBweHIgPSAvKnIuZnVsbFF1YWxpdHlNYiA/IDEgOiovIG1iUHhSYXRpbztcblxuICAgICAgICAgIGN4dC5kcmF3SW1hZ2UoIFxuICAgICAgICAgICAgdHh0LCAvLyBpbWdcbiAgICAgICAgICAgIDAsIDAsIC8vIHN4LCBzeVxuICAgICAgICAgICAgci5jYW52YXNXaWR0aCAqIHB4ciwgci5jYW52YXNIZWlnaHQgKiBweHIsIC8vIHN3LCBzaFxuICAgICAgICAgICAgMCwgMCwgLy8geCwgeVxuICAgICAgICAgICAgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQgLy8gdywgaFxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIG5lZWREcmF3W0NSLk5PREVdIHx8IG5lZWRNYkNsZWFyW0NSLk5PREVdICl7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ21iIE5PREUnLCBuZWVkTWJDbGVhcltDUi5OT0RFXSk7XG5cbiAgICAgICAgICBkcmF3TW90aW9uQmx1ciggY3h0Tm9kZSwgdHh0Tm9kZSwgbmVlZE1iQ2xlYXJbQ1IuTk9ERV0gKTtcbiAgICAgICAgICBuZWVkRHJhd1tDUi5OT0RFXSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG5lZWREcmF3W0NSLkRSQUddIHx8IG5lZWRNYkNsZWFyW0NSLkRSQUddICl7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ21iIERSQUcnKTtcblxuICAgICAgICAgIGRyYXdNb3Rpb25CbHVyKCBjeHREcmFnLCB0eHREcmFnLCBuZWVkTWJDbGVhcltDUi5EUkFHXSApO1xuICAgICAgICAgIG5lZWREcmF3W0NSLkRSQUddID0gZmFsc2U7XG4gICAgICAgICAgLy9uZWVkTWJDbGVhcltDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICB2YXIgZW5kVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgIGlmKCByLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCByLnJlZHJhd0NvdW50ID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5yZWRyYXdDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3Q291bnQrKztcblxuICAgICAgaWYoIHIucmVkcmF3VG90YWxUaW1lID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5yZWRyYXdUb3RhbFRpbWUgPSAwO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhd1RvdGFsVGltZSArPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgci5sYXN0UmVkcmF3VGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIHVzZSBhIHdlaWdodGVkIGF2ZXJhZ2Ugd2l0aCBhIGJpYXMgZnJvbSB0aGUgcHJldmlvdXMgYXZlcmFnZSBzbyB3ZSBkb24ndCBzcGlrZSBzbyBlYXNpbHlcbiAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lLzIgKyAoZW5kVGltZSAtIHN0YXJ0VGltZSkvMjtcbiAgICAgIC8vY29uc29sZS5sb2coJ2FjdHVhbDogJWksIGF2ZXJhZ2U6ICVpJywgZW5kVGltZSAtIHN0YXJ0VGltZSwgdGhpcy5hdmVyYWdlUmVkcmF3VGltZSk7XG5cbiAgICAgIHIuY3VycmVudGx5RHJhd2luZyA9IGZhbHNlO1xuXG4gICAgICByLnByZXZWaWV3cG9ydCA9IHZwO1xuXG4gICAgICAvLyBjb25zb2xlLnByb2ZpbGVFbmQoJ2RyYXcnICsgc3RhcnRUaW1lKVxuXG4gICAgICBpZiggci5jbGVhcmluZ01vdGlvbkJsdXIgKXtcbiAgICAgICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgICAgci5tb3Rpb25CbHVyQ2xlYXJlZCA9IHRydWU7XG4gICAgICAgIHIubW90aW9uQmx1ciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCBtb3Rpb25CbHVyICl7IFxuICAgICAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtYiBDTEVBUicpO1xuXG4gICAgICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltDUi5OT0RFXSA9IGZhbHNlO1xuICAgICAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbQ1IuRFJBR10gPSBmYWxzZTtcbiAgICAgICAgICByLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgICAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9ICF0ZXh0dXJlRHJhdztcbiAgICAgICAgICByLm1iRnJhbWVzID0gMDtcblxuICAgICAgICAgIG5lZWREcmF3W0NSLk5PREVdID0gdHJ1ZTsgXG4gICAgICAgICAgbmVlZERyYXdbQ1IuRFJBR10gPSB0cnVlOyBcblxuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0sIENhbnZhc1JlbmRlcmVyLm1vdGlvbkJsdXJEZWxheSk7XG4gICAgICB9XG5cbiAgICAgIHIuZHJhd2luZ0ltYWdlID0gZmFsc2U7XG5cbiAgICB9IC8vIGRyYXcgdG8gY29udGV4dFxuXG4gICAgaWYoICFmb3JjZWRDb250ZXh0ICl7XG4gICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3VG9Db250ZXh0KTsgLy8gbWFrZXMgZGlyZWN0IHJlbmRlcnMgdG8gc2NyZWVuIGEgYml0IG1vcmUgcmVzcG9uc2l2ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3VG9Db250ZXh0KCk7XG4gICAgfVxuXG4gICAgaWYoICFmb3JjZWRDb250ZXh0ICYmICFyLmluaXRyZW5kZXIgKXtcbiAgICAgIHIuaW5pdHJlbmRlciA9IHRydWU7XG4gICAgICBjeS50cmlnZ2VyKCdpbml0cmVuZGVyJyk7XG4gICAgfVxuXG4gICAgaWYoICFmb3JjZWRDb250ZXh0ICl7XG4gICAgICBjeS50cmlnZ2VyT25SZW5kZXIoKTtcbiAgICB9XG4gICAgXG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgLy8gQE8gUG9seWdvbiBkcmF3aW5nXG4gIENScC5kcmF3UG9seWdvblBhdGggPSBmdW5jdGlvbihcbiAgICBjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpIHtcblxuICAgIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuXG4gICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAgIGNvbnRleHQubW92ZVRvKCB4ICsgaGFsZlcgKiBwb2ludHNbMF0sIHkgKyBoYWxmSCAqIHBvaW50c1sxXSApO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBjb250ZXh0LmxpbmVUbyggeCArIGhhbGZXICogcG9pbnRzW2kgKiAyXSwgeSArIGhhbGZIICogcG9pbnRzW2kgKiAyICsgMV0gKTtcbiAgICB9XG4gICAgXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcbiAgXG4gIENScC5kcmF3UG9seWdvbiA9IGZ1bmN0aW9uKFxuICAgIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuXG4gICAgLy8gRHJhdyBwYXRoXG4gICAgdGhpcy5kcmF3UG9seWdvblBhdGgoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKTtcbiAgICBcbiAgICAvLyBGaWxsIHBhdGhcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbiAgXG4gIC8vIFJvdW5kIHJlY3RhbmdsZSBkcmF3aW5nXG4gIENScC5kcmF3Um91bmRSZWN0YW5nbGVQYXRoID0gZnVuY3Rpb24oXG4gICAgY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgXG4gICAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIGNvcm5lclJhZGl1cyA9ICQkLm1hdGguZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgXG4gICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cbiAgICBcbiAgICAvLyBTdGFydCBhdCB0b3AgbWlkZGxlXG4gICAgY29udGV4dC5tb3ZlVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICAgIC8vIEFyYyBmcm9tIG1pZGRsZSB0b3AgdG8gcmlnaHQgc2lkZVxuICAgIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHggKyBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gICAgLy8gQXJjIGZyb20gcmlnaHQgc2lkZSB0byBib3R0b21cbiAgICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4LCB5ICsgaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgICAvLyBBcmMgZnJvbSBib3R0b20gdG8gbGVmdCBzaWRlXG4gICAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCAtIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgICAvLyBBcmMgZnJvbSBsZWZ0IHNpZGUgdG8gdG9wQm9yZGVyXG4gICAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCwgeSAtIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gICAgLy8gSm9pbiBsaW5lXG4gICAgY29udGV4dC5saW5lVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICAgIFxuICAgIFxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG4gIFxuICBDUnAuZHJhd1JvdW5kUmVjdGFuZ2xlID0gZnVuY3Rpb24oXG4gICAgY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgXG4gICAgdGhpcy5kcmF3Um91bmRSZWN0YW5nbGVQYXRoKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XG4gICAgXG4gICAgY29udGV4dC5maWxsKCk7XG4gIH07XG5cblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcblxuICBDUnAuY3JlYXRlQnVmZmVyID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBidWZmZXIud2lkdGggPSB3O1xuICAgIGJ1ZmZlci5oZWlnaHQgPSBoO1xuICAgIFxuICAgIHJldHVybiBbYnVmZmVyLCBidWZmZXIuZ2V0Q29udGV4dCgnMmQnKV07XG4gIH07XG5cbiAgQ1JwLmJ1ZmZlckNhbnZhc0ltYWdlID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgY3kgPSBkYXRhLmN5O1xuICAgIHZhciBiYiA9IGN5LmVsZW1lbnRzKCkuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgd2lkdGggPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIudykgOiB0aGlzLmRhdGEuY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIuaCkgOiB0aGlzLmRhdGEuY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICB2YXIgc2NhbGUgPSAxO1xuXG4gICAgaWYoIG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgd2lkdGggKj0gb3B0aW9ucy5zY2FsZTtcbiAgICAgIGhlaWdodCAqPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgICBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5tYXhXaWR0aCkgfHwgJCQuaXMubnVtYmVyKG9wdGlvbnMubWF4SGVpZ2h0KSApe1xuICAgICAgdmFyIG1heFNjYWxlVyA9IEluZmluaXR5O1xuICAgICAgdmFyIG1heFNjYWxlSCA9IEluZmluaXR5O1xuXG4gICAgICBpZiggJCQuaXMubnVtYmVyKG9wdGlvbnMubWF4V2lkdGgpICl7XG4gICAgICAgIG1heFNjYWxlVyA9IHNjYWxlICogb3B0aW9ucy5tYXhXaWR0aCAvIHdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiggJCQuaXMubnVtYmVyKG9wdGlvbnMubWF4SGVpZ2h0KSApe1xuICAgICAgICBtYXhTY2FsZUggPSBzY2FsZSAqIG9wdGlvbnMubWF4SGVpZ2h0IC8gaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBzY2FsZSA9IE1hdGgubWluKCBtYXhTY2FsZVcsIG1heFNjYWxlSCApO1xuXG4gICAgICB3aWR0aCAqPSBzY2FsZTtcbiAgICAgIGhlaWdodCAqPSBzY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgYnVmZkNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgYnVmZkNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGJ1ZmZDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgYnVmZkNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBidWZmQ2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICB2YXIgYnVmZkN4dCA9IGJ1ZmZDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIFJhc3Rlcml6ZSB0aGUgbGF5ZXJzLCBidXQgb25seSBpZiBjb250YWluZXIgaGFzIG5vbnplcm8gc2l6ZVxuICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuXG4gICAgICBidWZmQ3h0LmNsZWFyUmVjdCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG4gICAgICBpZiggb3B0aW9ucy5iZyApe1xuICAgICAgICBidWZmQ3h0LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmc7XG4gICAgICAgIGJ1ZmZDeHQucmVjdCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuICAgICAgICBidWZmQ3h0LmZpbGwoKTtcbiAgICAgIH1cblxuICAgICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuXG4gICAgICBpZiggb3B0aW9ucy5mdWxsICl7IC8vIGRyYXcgdGhlIGZ1bGwgYm91bmRzIG9mIHRoZSBncmFwaFxuICAgICAgICB0aGlzLnJlZHJhdyh7XG4gICAgICAgICAgZm9yY2VkQ29udGV4dDogYnVmZkN4dCxcbiAgICAgICAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgICAgICAgIGZvcmNlZFpvb206IHNjYWxlLFxuICAgICAgICAgIGZvcmNlZFBhbjogeyB4OiAtYmIueDEqc2NhbGUsIHk6IC1iYi55MSpzY2FsZSB9LFxuICAgICAgICAgIGZvcmNlZFB4UmF0aW86IDFcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgeyAvLyBkcmF3IHRoZSBjdXJyZW50IHZpZXdcbiAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG4gICAgICAgIHZhciBwYW4gPSB7XG4gICAgICAgICAgeDogY3lQYW4ueCAqIHNjYWxlLFxuICAgICAgICAgIHk6IGN5UGFuLnkgKiBzY2FsZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKSAqIHNjYWxlO1xuXG4gICAgICAgIHRoaXMucmVkcmF3KHtcbiAgICAgICAgICBmb3JjZWRDb250ZXh0OiBidWZmQ3h0LFxuICAgICAgICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgICAgICAgZm9yY2VkWm9vbTogem9vbSxcbiAgICAgICAgICBmb3JjZWRQYW46IHBhbixcbiAgICAgICAgICBmb3JjZWRQeFJhdGlvOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWZmQ2FudmFzO1xuICB9OyBcblxuICBDUnAucG5nID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJDYW52YXNJbWFnZSggb3B0aW9ucyApLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gIH07XG4gIFxuICBDUnAuanBnID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJDYW52YXNJbWFnZSggb3B0aW9ucyApLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycpO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgQ1IgPSBDYW52YXNSZW5kZXJlcjtcbiAgdmFyIENScCA9IENSLnByb3RvdHlwZTtcblxuICBDUnAucmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSl7XG4gICAgdGhpcy5iaW5kaW5ncy5wdXNoKHtcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgIHVzZUNhcHR1cmU6IHVzZUNhcHR1cmVcbiAgICB9KTtcblxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcbiAgfTtcblxuICBDUnAubm9kZUlzRHJhZ2dhYmxlID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlLl9wcml2YXRlLnN0eWxlWydvcGFjaXR5J10udmFsdWUgIT09IDBcbiAgICAgICYmIG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3Zpc2liaWxpdHknXS52YWx1ZSA9PSAndmlzaWJsZSdcbiAgICAgICYmIG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2Rpc3BsYXknXS52YWx1ZSA9PSAnZWxlbWVudCdcbiAgICAgICYmICFub2RlLmxvY2tlZCgpXG4gICAgICAmJiBub2RlLmdyYWJiYWJsZSgpICkge1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgQ1JwLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICB2YXIgZ2V0RHJhZ0xpc3RJZHMgPSBmdW5jdGlvbihvcHRzKXtcbiAgICAgIHZhciBsaXN0SGFzSWQ7XG5cbiAgICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiByLmRhdGEuY3kuaGFzQ29tcG91bmROb2RlcygpICl7IC8vIG9ubHkgbmVlZGVkIGZvciBjb21wb3VuZCBncmFwaHNcbiAgICAgICAgaWYoICFvcHRzLmFkZFRvTGlzdC5oYXNJZCApeyAvLyBidWlsZCBpZHMgbG9va3VwIGlmIGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgICAgICAgIG9wdHMuYWRkVG9MaXN0Lmhhc0lkID0ge307XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wdHMuYWRkVG9MaXN0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZWxlID0gb3B0cy5hZGRUb0xpc3RbaV07XG5cbiAgICAgICAgICAgIG9wdHMuYWRkVG9MaXN0Lmhhc0lkWyBlbGUuaWQoKSBdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0SGFzSWQgPSBvcHRzLmFkZFRvTGlzdC5oYXNJZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpc3RIYXNJZCB8fCB7fTtcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBjaGlsZCBub2RlcyBhbmQgaW5uZXIgZWRnZXNcbiAgICAvLyBvZiBhIGNvbXBvdW5kIG5vZGUgdG8gYmUgZHJhZ2dlZCBhcyB3ZWxsIGFzIHRoZSBncmFiYmVkIGFuZCBzZWxlY3RlZCBub2Rlc1xuICAgIHZhciBhZGREZXNjZW5kYW50c1RvRHJhZyA9IGZ1bmN0aW9uKG5vZGUsIG9wdHMpe1xuICAgICAgaWYoICFub2RlLl9wcml2YXRlLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCApeyByZXR1cm47IH0gLy8gbm90aGluZyB0byBkb1xuXG4gICAgICB2YXIgbGlzdEhhc0lkID0gZ2V0RHJhZ0xpc3RJZHMoIG9wdHMgKTtcblxuICAgICAgdmFyIGlubmVyTm9kZXMgPSBub2RlLmRlc2NlbmRhbnRzKCk7XG5cbiAgICAgIC8vIFRPRE8gZG8gbm90IGRyYWcgaGlkZGVuIGNoaWxkcmVuICYgY2hpbGRyZW4gb2YgaGlkZGVuIGNoaWxkcmVuP1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBpbm5lck5vZGVzLnNpemUoKTsgaSsrICl7XG4gICAgICAgIHZhciBpTm9kZSA9IGlubmVyTm9kZXNbaV07XG4gICAgICAgIHZhciBfcCA9IGlOb2RlLl9wcml2YXRlO1xuXG4gICAgICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyICl7XG4gICAgICAgICAgX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdHMuYWRkVG9MaXN0ICYmICFsaXN0SGFzSWRbIGlOb2RlLmlkKCkgXSApe1xuICAgICAgICAgIG9wdHMuYWRkVG9MaXN0LnB1c2goIGlOb2RlICk7XG4gICAgICAgICAgbGlzdEhhc0lkWyBpTm9kZS5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgICAgX3AuZ3JhYmJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWRnZXMgPSBfcC5lZGdlcztcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IG9wdHMuaW5EcmFnTGF5ZXIgJiYgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgZWRnZXNbal0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGFkZHMgdGhlIGdpdmVuIG5vZGVzLCBhbmQgaXRzIGVkZ2VzIHRvIHRoZSBkcmFnIGxheWVyXG4gICAgdmFyIGFkZE5vZGVUb0RyYWcgPSBmdW5jdGlvbihub2RlLCBvcHRzKXtcblxuICAgICAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBsaXN0SGFzSWQgPSBnZXREcmFnTGlzdElkcyggb3B0cyApO1xuXG4gICAgICBpZiggb3B0cy5pbkRyYWdMYXllciApe1xuICAgICAgICBfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiAhbGlzdEhhc0lkWyBub2RlLmlkKCkgXSApe1xuICAgICAgICBvcHRzLmFkZFRvTGlzdC5wdXNoKCBub2RlICk7XG4gICAgICAgIGxpc3RIYXNJZFsgbm9kZS5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgIF9wLmdyYWJiZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSBfcC5lZGdlcztcbiAgICAgIGZvciggdmFyIGkgPSAwOyBvcHRzLmluRHJhZ0xheWVyICYmIGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBlZGdlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGFkZERlc2NlbmRhbnRzVG9EcmFnKCBub2RlLCBvcHRzICk7IC8vIGFsd2F5cyBhZGQgdG8gZHJhZ1xuXG4gICAgICAvLyBhbHNvIGFkZCBub2RlcyBhbmQgZWRnZXMgcmVsYXRlZCB0byB0aGUgdG9wbW9zdCBhbmNlc3RvclxuICAgICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIoIG5vZGUsIHtcbiAgICAgICAgaW5EcmFnTGF5ZXI6IG9wdHMuaW5EcmFnTGF5ZXJcbiAgICAgIH0gKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBmcmVlRHJhZ2dlZEVsZW1lbnRzID0gZnVuY3Rpb24oIGRyYWdnZWRFbGVtZW50cyApe1xuICAgICAgaWYoICFkcmFnZ2VkRWxlbWVudHMgKXsgcmV0dXJuOyB9XG4gICAgICBcbiAgICAgIGZvciAodmFyIGk9MDsgaSA8IGRyYWdnZWRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBkRWlfcCA9IGRyYWdnZWRFbGVtZW50c1tpXS5fcHJpdmF0ZTtcblxuICAgICAgICBpZihkRWlfcC5ncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgICAgIGRFaV9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgICAgZEVpX3AuZ3JhYmJlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgdmFyIHNFZGdlcyA9IGRFaV9wLmVkZ2VzO1xuICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgc0VkZ2VzLmxlbmd0aDsgaisrICl7IHNFZGdlc1tqXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlOyB9XG5cbiAgICAgICAgICAvLyBmb3IgY29tcG91bmQgbm9kZXMsIGFsc28gcmVtb3ZlIHJlbGF0ZWQgbm9kZXMgYW5kIGVkZ2VzIGZyb20gdGhlIGRyYWcgbGF5ZXJcbiAgICAgICAgICB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihkcmFnZ2VkRWxlbWVudHNbaV0sIHsgaW5EcmFnTGF5ZXI6IGZhbHNlIH0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiggZEVpX3AuZ3JvdXAgPT09ICdlZGdlcycgKXtcbiAgICAgICAgICBkRWlfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBhbmNlc3RvciBub2RlcyBhbmQgZWRnZXMgc2hvdWxkIGdvXG4gICAgLy8gdG8gdGhlIGRyYWcgbGF5ZXIgKG9yIHNob3VsZCBiZSByZW1vdmVkIGZyb20gZHJhZyBsYXllcikuXG4gICAgdmFyIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyID0gZnVuY3Rpb24obm9kZSwgb3B0cykge1xuXG4gICAgICBpZiggb3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwgKXsgcmV0dXJuOyB9IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgICAgLy8gZmluZCB0b3AtbGV2ZWwgcGFyZW50XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZTtcblxuICAgICAgaWYoICFub2RlLl9wcml2YXRlLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdoaWxlKCBwYXJlbnQucGFyZW50KCkubm9uZW1wdHkoKSApe1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KClbMF07XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIHBhcmVudCBub2RlOiBubyBub2RlcyB0byBhZGQgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgICAgIGlmKCBwYXJlbnQgPT0gbm9kZSApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlcyA9IHBhcmVudC5kZXNjZW5kYW50cygpXG4gICAgICAgIC5tZXJnZSggcGFyZW50IClcbiAgICAgICAgLnVubWVyZ2UoIG5vZGUgKVxuICAgICAgICAudW5tZXJnZSggbm9kZS5kZXNjZW5kYW50cygpIClcbiAgICAgIDtcblxuICAgICAgdmFyIGVkZ2VzID0gbm9kZXMuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgdmFyIGxpc3RIYXNJZCA9IGdldERyYWdMaXN0SWRzKCBvcHRzICk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMuc2l6ZSgpOyBpKysgKXtcbiAgICAgICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIG5vZGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gb3B0cy5pbkRyYWdMYXllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiAhbGlzdEhhc0lkWyBub2Rlc1tpXS5pZCgpIF0gKXtcbiAgICAgICAgICBvcHRzLmFkZFRvTGlzdC5wdXNoKCBub2Rlc1tpXSApO1xuICAgICAgICAgIGxpc3RIYXNJZFsgbm9kZXNbaV0uaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICAgIG5vZGVzW2ldLl9wcml2YXRlLmdyYWJiZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBvcHRzLmluRHJhZ0xheWVyICE9PSB1bmRlZmluZWQgJiYgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICkge1xuICAgICAgICBlZGdlc1tqXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IG9wdHMuaW5EcmFnTGF5ZXI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmKCB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgKXtcbiAgICAgIHIucmVtb3ZlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiggbXV0bnMgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBtdXRucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBtdXRuID0gbXV0bnNbaV07XG4gICAgICAgICAgdmFyIHJOb2RlcyA9IG11dG4ucmVtb3ZlZE5vZGVzO1xuXG4gICAgICAgICAgaWYoIHJOb2RlcyApeyBmb3IoIHZhciBqID0gMDsgaiA8IHJOb2Rlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgdmFyIHJOb2RlID0gck5vZGVzW2pdO1xuXG4gICAgICAgICAgICBpZiggck5vZGUgPT09IHIuZGF0YS5jb250YWluZXIgKXtcbiAgICAgICAgICAgICAgci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgci5yZW1vdmVPYnNlcnZlci5vYnNlcnZlKCByLmRhdGEuY29udGFpbmVyLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ0RPTU5vZGVSZW1vdmVkJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG5cblxuICAgIC8vIGF1dG8gcmVzaXplXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAncmVzaXplJywgJCQudXRpbC5kZWJvdW5jZSggZnVuY3Rpb24oZSkge1xuICAgICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcblxuICAgICAgci5tYXRjaENhbnZhc1NpemUoci5kYXRhLmNvbnRhaW5lcik7XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9LCAxMDAgKSApO1xuXG4gICAgdmFyIGludmFsQ3RuckJCT25TY3JvbGwgPSBmdW5jdGlvbihkb21FbGUpe1xuICAgICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnc2Nyb2xsJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgICB9ICk7XG4gICAgfTtcblxuICAgIHZhciBiYkN0bnIgPSByLmRhdGEuY3kuY29udGFpbmVyKCk7XG5cbiAgICBmb3IoIDs7ICl7XG5cbiAgICAgIGludmFsQ3RuckJCT25TY3JvbGwoIGJiQ3RuciApO1xuXG4gICAgICBpZiggYmJDdG5yLnBhcmVudE5vZGUgKXtcbiAgICAgICAgYmJDdG5yID0gYmJDdG5yLnBhcmVudE5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHN0b3AgcmlnaHQgY2xpY2sgbWVudSBmcm9tIGFwcGVhcmluZyBvbiBjeVxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGUpe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgdmFyIGluQm94U2VsZWN0aW9uID0gZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiByLmRhdGEuc2VsZWN0WzRdICE9PSAwO1xuICAgIH07XG5cbiAgICAvLyBQcmltYXJ5IGtleVxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByLmhvdmVyRGF0YS5jYXB0dXJlID0gdHJ1ZTtcbiAgICAgIHIuaG92ZXJEYXRhLndoaWNoID0gZS53aGljaDtcblxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5O1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICB2YXIgc2VsZWN0ID0gci5kYXRhLnNlbGVjdDtcbiAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuXG4gICAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IHBvcztcbiAgICAgIFxuICAgICAgdmFyIG5lZWRzUmVkcmF3ID0gci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuXG4gICAgICB2YXIgY2hlY2tGb3JUYXBob2xkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IGZhbHNlO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCggci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQgKTtcblxuICAgICAgICByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblxuICAgICAgICAgIGlmKCByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkICl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbGUgPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgICAgIGVsZS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgICB9O1xuXG4gICAgICAvLyBSaWdodCBjbGljayBidXR0b25cbiAgICAgIGlmKCBlLndoaWNoID09IDMgKXtcblxuICAgICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY3h0RXZ0ID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiggbmVhciApe1xuICAgICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgICBuZWFyLnRyaWdnZXIoIGN4dEV2dCApO1xuXG4gICAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcblxuICAgICAgLy8gUHJpbWFyeSBidXR0b25cbiAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSAxKSB7XG5cbiAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbGVtZW50IGRyYWdnaW5nXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5kZXIgdGhlIGN1cnNvciBhbmQgaXQgaXMgZHJhZ2dhYmxlLCBwcmVwYXJlIHRvIGdyYWIgaXRcbiAgICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG5cbiAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZShuZWFyKSApe1xuXG4gICAgICAgICAgICAgIHZhciBncmFiRXZlbnQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdncmFiJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKCBuZWFyLmlzTm9kZSgpICYmICFuZWFyLnNlbGVjdGVkKCkgKXtcblxuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBuZWFyLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzIH0gKTtcblxuICAgICAgICAgICAgICAgIG5lYXIudHJpZ2dlcihncmFiRXZlbnQpO1xuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG5lYXIuaXNOb2RlKCkgJiYgbmVhci5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IFsgIF07XG5cbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGN5LiQoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuaXNOb2RlKCkgJiYgdGhpcy5zZWxlY3RlZCgpOyB9KTtcblxuICAgICAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKyApe1xuXG4gICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCB0aGlzIHNlbGVjdGVkIG5vZGUgdG8gZHJhZyBpZiBpdCBpcyBkcmFnZ2FibGUsIGVnLiBoYXMgbm9uemVybyBvcGFjaXR5XG4gICAgICAgICAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUoIHNlbGVjdGVkTm9kZXNbaV0gKSApe1xuICAgICAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBzZWxlY3RlZE5vZGVzW2ldLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzIH0gKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZWFyLnRyaWdnZXIoIGdyYWJFdmVudCApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5EUkFHXSA9IHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmVhclxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZWRvd24nLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwc3RhcnQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuXG4gICAgICAgICAgfSBlbHNlIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICAgIGN5XG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBzdGFydCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWxlY3Rpb24gYm94XG4gICAgICAgIGlmICggbmVhciA9PSBudWxsIHx8IG5lYXIuaXNFZGdlKCkgKSB7XG4gICAgICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgICAgICB2YXIgdGltZVVudGlsQWN0aXZlID0gTWF0aC5tYXgoIDAsIENSLnBhbk9yQm94U2VsZWN0RGVsYXkgLSAoK25ldyBEYXRlKCkgLSByLmhvdmVyRGF0YS5kb3duVGltZSkgKTtcblxuICAgICAgICAgIGNsZWFyVGltZW91dCggci5iZ0FjdGl2ZVRpbWVvdXQgKTtcblxuICAgICAgICAgIGlmKCBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgfHwgKCBuZWFyICYmIG5lYXIuaXNFZGdlKCkgKSApe1xuICAgICAgICAgICAgci5iZ0FjdGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgICAgICAgbmVhci51bmFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAvL2NoZWNrRm9yVGFwaG9sZCgpO1xuXG4gICAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgICAgfSwgdGltZVVudGlsQWN0aXZlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy9yLmhvdmVyRGF0YS5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vY2hlY2tGb3JUYXBob2xkKCk7XG5cbiAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNoZWNrRm9yVGFwaG9sZCgpO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYWxpemUgc2VsZWN0aW9uIGJveCBjb29yZGluYXRlc1xuICAgICAgc2VsZWN0WzBdID0gc2VsZWN0WzJdID0gcG9zWzBdO1xuICAgICAgc2VsZWN0WzFdID0gc2VsZWN0WzNdID0gcG9zWzFdO1xuXG4gICAgfSwgZmFsc2UpO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnbW91c2Vtb3ZlJywgJCQudXRpbC50aHJvdHRsZSggZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG5cbiAgICAgIC8vIHNhdmUgY3ljbGVzIGlmIG1vdXNlIGV2ZW50cyBhcmVuJ3QgdG8gYmUgY2FwdHVyZWRcbiAgICAgIGlmICggIWNhcHR1cmUgKXtcbiAgICAgICAgdmFyIGNvbnRhaW5lclBhZ2VDb29yZHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcblxuICAgICAgICBpZiAoZS5jbGllbnRYID4gY29udGFpbmVyUGFnZUNvb3Jkc1swXSAmJiBlLmNsaWVudFggPCBjb250YWluZXJQYWdlQ29vcmRzWzBdICsgci5jYW52YXNXaWR0aFxuICAgICAgICAgICYmIGUuY2xpZW50WSA+IGNvbnRhaW5lclBhZ2VDb29yZHNbMV0gJiYgZS5jbGllbnRZIDwgY29udGFpbmVyUGFnZUNvb3Jkc1sxXSArIHIuY2FudmFzSGVpZ2h0XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGluc2lkZSBjb250YWluZXIgYm91bmRzIHNvIE9LXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN5Q29udGFpbmVyID0gci5kYXRhLmNvbnRhaW5lcjtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgdFBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgY29udGFpbmVySXNUYXJnZXQgPSBmYWxzZTtcblxuICAgICAgICB3aGlsZSggdFBhcmVudCApe1xuICAgICAgICAgIGlmKCB0UGFyZW50ID09PSBjeUNvbnRhaW5lciApe1xuICAgICAgICAgICAgY29udGFpbmVySXNUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFBhcmVudCA9IHRQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhY29udGFpbmVySXNUYXJnZXQgKXsgcmV0dXJuOyB9IC8vIGlmIHRhcmdldCBpcyBvdXRpc2RlIGN5IGNvbnRhaW5lciwgdGhlbiB0aGlzIGV2ZW50IGlzIG5vdCBmb3IgdXNcbiAgICAgIH1cblxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5O1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgIHZhciBzZWxlY3QgPSByLmRhdGEuc2VsZWN0O1xuICAgICAgdmFyIG5lZWRzUmVkcmF3ID0gci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuXG4gICAgICB2YXIgbmVhciA9IG51bGw7XG4gICAgICBpZiggIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyApe1xuICAgICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0ID0gci5ob3ZlckRhdGEubGFzdDtcbiAgICAgIHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcblxuICAgICAgdmFyIGRpc3AgPSBbcG9zWzBdIC0gc2VsZWN0WzJdLCBwb3NbMV0gLSBzZWxlY3RbM11dO1xuXG4gICAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcblxuICAgICAgdmFyIGR4ID0gc2VsZWN0WzJdIC0gc2VsZWN0WzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBzZWxlY3RbM10gLSBzZWxlY3RbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tO1xuXG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcblxuICAgICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgICAgaWYoIGRyYWdEZWx0YS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFswXSApO1xuICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKCBkaXNwWzFdICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICAgIH1cbiAgICAgIH07XG5cblxuICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuXG4gICAgICAvLyBNb3VzZW1vdmUgZXZlbnRcbiAgICAgIHtcbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgIG5lYXJcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZW1vdmUnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWcnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIDtcblxuICAgICAgICB9IGVsc2UgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgIGN5XG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyB0cmlnZ2VyIGNvbnRleHQgZHJhZyBpZiBybW91c2UgZG93blxuICAgICAgaWYoIHIuaG92ZXJEYXRhLndoaWNoID09PSAzICl7XG4gICAgICAgIHZhciBjeHRFdnQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoIGRvd24gKXtcbiAgICAgICAgICBkb3duLnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIuaG92ZXJEYXRhLmN4dE92ZXIgKXtcblxuICAgICAgICAgIGlmKCByLmhvdmVyRGF0YS5jeHRPdmVyICl7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3V0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY3h0ZHJhZ291dCAnICsgci5ob3ZlckRhdGEuY3h0T3Zlci5pZCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyID0gbmVhcjtcblxuICAgICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2N4dGRyYWdvdmVyICcgKyBuZWFyLmlkKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlIGFyZSBkcmFnIHBhbm5pbmcgdGhlIGVudGlyZSBncmFwaFxuICAgICAgfSBlbHNlIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgaWYoIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgKXtcbiAgICAgICAgICB2YXIgZGVsdGFQO1xuXG4gICAgICAgICAgaWYoIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuICl7XG4gICAgICAgICAgICB2YXIgbWRQb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcblxuICAgICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgICB4OiAoIHBvc1swXSAtIG1kUG9zWzBdICkgKiB6b29tLFxuICAgICAgICAgICAgICB5OiAoIHBvc1sxXSAtIG1kUG9zWzFdICkgKiB6b29tXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IGZhbHNlO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3kucGFuQnkoIGRlbHRhUCApO1xuXG4gICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZWVkcyByZXByb2plY3QgZHVlIHRvIHBhbiBjaGFuZ2luZyB2aWV3cG9ydFxuICAgICAgICBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuXG4gICAgICAvLyBDaGVja3MgcHJpbWFyeSBidXR0b24gZG93biAmIG91dCBvZiB0aW1lICYgbW91c2Ugbm90IG1vdmVkIG11Y2hcbiAgICAgIH0gZWxzZSBpZihcbiAgICAgICAgICBzZWxlY3RbNF0gPT0gMSAmJiAoZG93biA9PSBudWxsIHx8IGRvd24uaXNFZGdlKCkpXG4gICAgICAgICAgJiYgKCAhY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpIHx8ICgrbmV3IERhdGUoKSAtIHIuaG92ZXJEYXRhLmRvd25UaW1lID49IENSLnBhbk9yQm94U2VsZWN0RGVsYXkpIClcbiAgICAgICAgICAvLyYmIChNYXRoLmFicyhzZWxlY3RbM10gLSBzZWxlY3RbMV0pICsgTWF0aC5hYnMoc2VsZWN0WzJdIC0gc2VsZWN0WzBdKSA8IDQpXG4gICAgICAgICAgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZ1xuICAgICAgICAgICYmIHJkaXN0MiA+PSByLmRlc2t0b3BUYXBUaHJlc2hvbGQyXG4gICAgICAgICAgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKVxuICAgICAgKXtcbiAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSB0cnVlO1xuICAgICAgICBzZWxlY3RbNF0gPSAwO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWFjdGl2YXRlIGJnIG9uIGJveCBzZWxlY3Rpb25cbiAgICAgICAgaWYgKGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiAhci5ob3ZlckRhdGEuZHJhZ2dpbmcgJiYgTWF0aC5wb3coc2VsZWN0WzJdIC0gc2VsZWN0WzBdLCAyKSArIE1hdGgucG93KHNlbGVjdFszXSAtIHNlbGVjdFsxXSwgMikgPiA3ICYmIHNlbGVjdFs0XSl7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KCByLmJnQWN0aXZlVGltZW91dCApO1xuICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZG93biAmJiBkb3duLmlzRWRnZSgpICYmIGRvd24uYWN0aXZlKCkgKXsgZG93bi51bmFjdGl2YXRlKCk7IH1cblxuICAgICAgICBpZiAobmVhciAhPSBsYXN0KSB7XG5cbiAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgbGFzdC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnbW91c2VvdXQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgIGxhc3QudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWdvdXQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ21vdXNlb3ZlcicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZ292ZXInLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEubGFzdCA9IG5lYXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZG93biAmJiBkb3duLmlzTm9kZSgpICYmIHIubm9kZUlzRHJhZ2dhYmxlKGRvd24pICl7XG5cbiAgICAgICAgICBpZiggcmRpc3QyID49IHIuZGVza3RvcFRhcFRocmVzaG9sZDIgKXsgLy8gdGhlbiBkcmFnXG5cbiAgICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuXG4gICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICkge1xuICAgICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7IC8vIGluZGljYXRlIHRoYXQgd2UgYWN0dWFsbHkgZGlkIGRyYWcgdGhlIG5vZGVcblxuICAgICAgICAgICAgdmFyIHRvVHJpZ2dlciA9IFtdO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVtZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICB2YXIgZEVsZSA9IGRyYWdnZWRFbGVtZW50c1tpXTtcblxuICAgICAgICAgICAgICAvLyBub3csIGFkZCB0aGUgZWxlbWVudHMgdG8gdGhlIGRyYWcgbGF5ZXIgaWYgbm90IGRvbmUgYWxyZWFkeVxuICAgICAgICAgICAgICBpZiggIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyApe1xuICAgICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIGRFbGUsIHsgaW5EcmFnTGF5ZXI6IHRydWUgfSApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTG9ja2VkIG5vZGVzIG5vdCBkcmFnZ2FibGUsIGFzIHdlbGwgYXMgbm9uLXZpc2libGUgbm9kZXNcbiAgICAgICAgICAgICAgaWYoIGRFbGUuaXNOb2RlKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUoZEVsZSkgJiYgZEVsZS5ncmFiYmVkKCkgKXtcbiAgICAgICAgICAgICAgICB2YXIgZFBvcyA9IGRFbGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgICAgICAgICB0b1RyaWdnZXIucHVzaCggZEVsZSApO1xuXG4gICAgICAgICAgICAgICAgaWYoICQkLmlzLm51bWJlcihkaXNwWzBdKSAmJiAkJC5pcy5udW1iZXIoZGlzcFsxXSkgKXtcbiAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICAgICAgZFBvcy55ICs9IGRpc3BbMV07XG5cbiAgICAgICAgICAgICAgICAgIGlmKCBqdXN0U3RhcnRlZERyYWcgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKGRyYWdEZWx0YVswXSkgJiYgJCQuaXMubnVtYmVyKGRyYWdEZWx0YVsxXSkgKXtcbiAgICAgICAgICAgICAgICAgICAgICBkUG9zLnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgdGNvbCA9IChuZXcgJCQuQ29sbGVjdGlvbihjeSwgdG9UcmlnZ2VyKSk7XG5cbiAgICAgICAgICAgIHRjb2wudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICAgIHRjb2wudHJpZ2dlcigncG9zaXRpb24gZHJhZycpO1xuXG4gICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5EUkFHXSA9IHRydWU7XG4gICAgICAgICAgICByLnJlZHJhdygpO1xuXG4gICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIHNhdmUgZHJhZyBkZWx0YSBmb3Igd2hlbiB3ZSBhY3R1YWxseSBzdGFydCBkcmFnZ2luZyBzbyB0aGUgcmVsYXRpdmUgZ3JhYiBwb3MgaXMgY29uc3RhbnRcbiAgICAgICAgICAgIHVwZGF0ZURyYWdEZWx0YSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnQgdGhlIGRyYWdnaW5nIGZyb20gdHJpZ2dlcmluZyB0ZXh0IHNlbGVjdGlvbiBvbiB0aGUgcGFnZVxuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdFsyXSA9IHBvc1swXTsgc2VsZWN0WzNdID0gcG9zWzFdO1xuXG4gICAgICBpZiggcHJldmVudERlZmF1bHQgKXtcbiAgICAgICAgaWYoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgaWYoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIDEwMDAvMzAsIHsgdHJhaWxpbmc6IHRydWUgfSksIGZhbHNlKTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnLS1cXG5tb3VzZXVwJywgZSlcblxuICAgICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuICAgICAgaWYgKCFjYXB0dXJlKSB7IHJldHVybjsgfVxuICAgICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgICB2YXIgY3kgPSByLmRhdGEuY3k7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpOyB2YXIgc2VsZWN0ID0gci5kYXRhLnNlbGVjdDtcbiAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzOyB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgICB2YXIgc2hpZnREb3duID0gZS5zaGlmdEtleTtcbiAgICAgIHZhciBuZWVkc1JlZHJhdyA9IHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcblxuICAgICAgaWYoIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiApe1xuICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDsgLy8gbm90IGFjdGl2ZSBiZyBub3dcbiAgICAgIGNsZWFyVGltZW91dCggci5iZ0FjdGl2ZVRpbWVvdXQgKTtcblxuICAgICAgaWYoIGRvd24gKXtcbiAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCByLmhvdmVyRGF0YS53aGljaCA9PT0gMyApe1xuICAgICAgICB2YXIgY3h0RXZ0ID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoIGRvd24gKXtcbiAgICAgICAgICBkb3duLnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5jeHREcmFnZ2VkICl7XG4gICAgICAgICAgdmFyIGN4dFRhcCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYoIGRvd24gKXtcbiAgICAgICAgICAgIGRvd24udHJpZ2dlciggY3h0VGFwICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dFRhcCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgci5ob3ZlckRhdGEud2hpY2ggPSBudWxsO1xuXG4gICAgICAvLyBpZiBub3QgcmlnaHQgbW91c2VcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gRGVzZWxlY3QgYWxsIGVsZW1lbnRzIGlmIG5vdGhpbmcgaXMgY3VycmVudGx5IHVuZGVyIHRoZSBtb3VzZSBjdXJzb3IgYW5kIHdlIGFyZW4ndCBkcmFnZ2luZyBzb21ldGhpbmdcbiAgICAgICAgaWYgKCAoZG93biA9PSBudWxsKSAvLyBub3QgbW91c2Vkb3duIG9uIG5vZGVcbiAgICAgICAgICAmJiAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBtb3ZlIHRoZSBub2RlIGFyb3VuZFxuICAgICAgICAgIC8vJiYgIShNYXRoLnBvdyhzZWxlY3RbMl0gLSBzZWxlY3RbMF0sIDIpICsgTWF0aC5wb3coc2VsZWN0WzNdIC0gc2VsZWN0WzFdLCAyKSA+IDcgJiYgc2VsZWN0WzRdKSAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICAgKSB7XG5cbiAgICAgICAgICBjeS4kKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCgpO1xuICAgICAgICAgIH0pLnVuc2VsZWN0KCk7XG5cbiAgICAgICAgICBpZiAoZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gZHJhZ2dlZEVsZW1lbnRzID0gW107XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIE1vdXNldXAgZXZlbnRcbiAgICAgICAge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0cmlnZ2VyIG1vdXNldXAgZXQgYWwnKTtcblxuICAgICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5lYXJcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2V1cCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBlbmQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNldXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY3lcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2V1cCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBlbmQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNldXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGljayBldmVudFxuICAgICAgICB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3RyaWdnZXIgY2xpY2sgZXQgYWwnKTtcblxuICAgICAgICAgIGlmKFxuICAgICAgICAgICAgLy9NYXRoLnBvdyhzZWxlY3RbMl0gLSBzZWxlY3RbMF0sIDIpICsgTWF0aC5wb3coc2VsZWN0WzNdIC0gc2VsZWN0WzFdLCAyKSA9PT0gMFxuICAgICAgICAgICAgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSBhIG5vZGUgYXJvdW5kXG4gICAgICAgICAgICAmJiAhci5ob3ZlckRhdGEuZHJhZ2dlZCAvLyBkaWRuJ3QgcGFuXG4gICAgICAgICAgKXtcbiAgICAgICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbmVhclxuICAgICAgICAgICAgICAgIC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICAgIH0pIClcbiAgICAgICAgICAgICAgICAudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICd0YXAnLFxuICAgICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgICAgfSkgKVxuICAgICAgICAgICAgICAgIC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZjbGljaycsXG4gICAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgICB9KSApXG4gICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGN5XG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnY2xpY2snLFxuICAgICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgICAgfSkgKVxuICAgICAgICAgICAgICAgIC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3RhcCcsXG4gICAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgICB9KSApXG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndmNsaWNrJyxcbiAgICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICAgIH0pIClcbiAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmdsZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKG5lYXIgPT0gZG93biAmJiAhci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCAmJiBuZWFyLl9wcml2YXRlLnNlbGVjdGFibGUpIHtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3NpbmdsZSBzZWxlY3Rpb24nKVxuXG4gICAgICAgICAgICBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmcgKXtcbiAgICAgICAgICAgICAgLy8gaWYgcGFubmluZywgZG9uJ3QgY2hhbmdlIHNlbGVjdGlvbiBzdGF0ZVxuICAgICAgICAgICAgfSBlbHNlIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScgfHwgc2hpZnREb3duICl7XG4gICAgICAgICAgICAgIGlmKCBuZWFyLnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgICAgICBuZWFyLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVhci5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYoICFzaGlmdERvd24gKXtcbiAgICAgICAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bm1lcmdlKCBuZWFyICkudW5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICBuZWFyLnNlbGVjdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByLmhvdmVyRGF0YS5zZWxlY3RpbmcgJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmICBNYXRoLnBvdyhzZWxlY3RbMl0gLSBzZWxlY3RbMF0sIDIpICsgTWF0aC5wb3coc2VsZWN0WzNdIC0gc2VsZWN0WzFdLCAyKSA+IDcgJiYgc2VsZWN0WzRdICkge1xuICAgICAgICAgIHZhciBuZXdseVNlbGVjdGVkID0gW107XG4gICAgICAgICAgdmFyIGJveCA9IHIuZ2V0QWxsSW5Cb3goIHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSApO1xuXG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgICAgaWYoIGJveC5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYm94Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICBpZiggYm94W2ldLl9wcml2YXRlLnNlbGVjdGFibGUgKXtcbiAgICAgICAgICAgICAgbmV3bHlTZWxlY3RlZC5wdXNoKCBib3hbaV0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV3bHlTZWxDb2wgPSBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIG5ld2x5U2VsZWN0ZWQgKTtcblxuICAgICAgICAgIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScgKXtcbiAgICAgICAgICAgIG5ld2x5U2VsQ29sLnNlbGVjdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiggIXNoaWZ0RG93biApe1xuICAgICAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bm1lcmdlKCBuZXdseVNlbENvbCApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld2x5U2VsQ29sLnNlbGVjdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFsd2F5cyBuZWVkIHJlZHJhdyBpbiBjYXNlIGVsZXMgdW5zZWxlY3RhYmxlXG4gICAgICAgICAgci5yZWRyYXcoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FuY2VsIGRyYWcgcGFuXG4gICAgICAgIGlmKCByLmhvdmVyRGF0YS5kcmFnZ2luZyApe1xuICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgXG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxlY3RbNF0pIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZnJlZSBhdCBlbmQnLCBkcmFnZ2VkRWxlbWVudHMpXG5cbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5EUkFHXSA9IHRydWU7XG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuXG4gICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyggZHJhZ2dlZEVsZW1lbnRzICk7XG5cbiAgICAgICAgICBpZiggZG93biApeyBkb3duLnRyaWdnZXIoJ2ZyZWUnKTsgfVxuXG4gIC8vICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gW107XG5cbiAgICAgICAgfVxuXG4gICAgICB9IC8vIGVsc2Ugbm90IHJpZ2h0IG1vdXNlXG5cbiAgICAgIHNlbGVjdFs0XSA9IDA7IHIuaG92ZXJEYXRhLmRvd24gPSBudWxsO1xuXG4gICAgICAvL3IuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbi8vICAgICAgY29uc29sZS5sb2coJ211JywgcG9zWzBdLCBwb3NbMV0pO1xuLy8gICAgICBjb25zb2xlLmxvZygnc3MnLCBzZWxlY3QpO1xuXG4gICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSBbXTtcblxuICAgIH0sIGZhbHNlKTtcblxuICAgIHZhciB3aGVlbEhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiggci5zY3JvbGxpbmdQYWdlICl7IHJldHVybjsgfSAvLyB3aGlsZSBzY3JvbGxpbmcsIGlnbm9yZSB3aGVlbC10by16b29tXG5cbiAgICAgIHZhciBjeSA9IHIuZGF0YS5jeTtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgdmFyIHJwb3MgPSBbcG9zWzBdICogY3kuem9vbSgpICsgY3kucGFuKCkueCxcbiAgICAgICAgICAgICAgICAgICAgcG9zWzFdICogY3kuem9vbSgpICsgY3kucGFuKCkueV07XG5cbiAgICAgIGlmKCByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCB8fCBpbkJveFNlbGVjdGlvbigpICl7IC8vIGlmIHBhbiBkcmFnZ2luZyBvciBjeHQgZHJhZ2dpbmcsIHdoZWVsIG1vdmVtZW50cyBtYWtlIG5vIHpvb21cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKCBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkgKXtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQoIHIuZGF0YS53aGVlbFRpbWVvdXQgKTtcbiAgICAgICAgci5kYXRhLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICByLmRhdGEud2hlZWxab29taW5nID0gZmFsc2U7XG5cbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0sIDE1MCk7XG5cbiAgICAgICAgdmFyIGRpZmYgPSBlLmRlbHRhWSAvIC0yNTAgfHwgZS53aGVlbERlbHRhWSAvIDEwMDAgfHwgZS53aGVlbERlbHRhIC8gMTAwMDtcbiAgICAgICAgZGlmZiA9IGRpZmYgKiByLndoZWVsU2Vuc2l0aXZpdHk7XG5cbiAgICAgICAgdmFyIG5lZWRzV2hlZWxGaXggPSBlLmRlbHRhTW9kZSA9PT0gMTtcbiAgICAgICAgaWYoIG5lZWRzV2hlZWxGaXggKXsgLy8gZml4ZXMgc2xvdyB3aGVlbCBldmVudHMgb24gZmYvbGludXggYW5kIGZmL3dpbmRvd3NcbiAgICAgICAgICBkaWZmICo9IDMzO1xuICAgICAgICB9XG5cbiAgICAgICAgY3kuem9vbSh7XG4gICAgICAgICAgbGV2ZWw6IGN5Lnpvb20oKSAqIE1hdGgucG93KDEwLCBkaWZmKSxcbiAgICAgICAgICByZW5kZXJlZFBvc2l0aW9uOiB7IHg6IHJwb3NbMF0sIHk6IHJwb3NbMV0gfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICAvLyBGdW5jdGlvbnMgdG8gaGVscCB3aXRoIHdoZXRoZXIgbW91c2Ugd2hlZWwgc2hvdWxkIHRyaWdnZXIgem9vbWluZ1xuICAgIC8vIC0tXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ3doZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcblxuICAgIC8vIGRpc2FibGUgbm9uc3RhbmRhcmQgd2hlZWwgZXZlbnRzXG4gICAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAgIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdET01Nb3VzZVNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gICAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCB3aGVlbEhhbmRsZXIsIHRydWUpOyAvLyBvbGRlciBmaXJlZm94XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdzY3JvbGwnLCBmdW5jdGlvbihlKXtcbiAgICAgIHIuc2Nyb2xsaW5nUGFnZSA9IHRydWU7XG5cbiAgICAgIGNsZWFyVGltZW91dCggci5zY3JvbGxpbmdQYWdlVGltZW91dCApO1xuICAgICAgci5zY3JvbGxpbmdQYWdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgci5zY3JvbGxpbmdQYWdlID0gZmFsc2U7XG4gICAgICB9LCAyNTApO1xuICAgIH0sIHRydWUpO1xuXG4gICAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCBoYW5kbGluZyBtb3VzZW91dC9tb3VzZW92ZXIgb24gdGhlIEN5dG9zY2FwZSBjb250YWluZXJcbiAgICAgICAgICAvLyBIYW5kbGUgbW91c2VvdXQgb24gQ3l0b3NjYXBlIGNvbnRhaW5lclxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdtb3VzZW91dCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuXG4gICAgICByLmRhdGEuY3kudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICB0eXBlOiAnbW91c2VvdXQnLFxuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgIH0pKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnbW91c2VvdmVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cbiAgICAgIHIuZGF0YS5jeS50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgIHR5cGU6ICdtb3VzZW92ZXInLFxuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgIH0pKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB2YXIgZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MTsgLy8gc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG4gICAgdmFyIGRpc3RhbmNlMSwgZGlzdGFuY2UxU3E7IC8vIGluaXRpYWwgZGlzdGFuY2UgYmV0d2VlbiBmaW5nZXIgMSBhbmQgZmluZ2VyIDIgZm9yIHBpbmNoLXRvLXpvb21cbiAgICB2YXIgY2VudGVyMSwgbW9kZWxDZW50ZXIxOyAvLyBjZW50ZXIgcG9pbnQgb24gc3RhcnQgcGluY2ggdG8gem9vbVxuICAgIHZhciBvZmZzZXRMZWZ0LCBvZmZzZXRUb3A7XG4gICAgdmFyIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQ7XG4gICAgdmFyIHR3b0ZpbmdlcnNTdGFydEluc2lkZTtcblxuICAgIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKXtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoICh4Mi14MSkqKHgyLXgxKSArICh5Mi15MSkqKHkyLXkxKSApO1xuICAgIH07XG5cbiAgICB2YXIgZGlzdGFuY2VTcSA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKXtcbiAgICAgIHJldHVybiAoeDIteDEpKih4Mi14MSkgKyAoeTIteTEpKih5Mi15MSk7XG4gICAgfTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZSkge1xuXG4gICAgICBjbGVhclRpbWVvdXQoIHRoaXMudGhyZWVGaW5nZXJTZWxlY3RUaW1lb3V0ICk7XG5cbiAgICAgIGlmKCBlLnRhcmdldCAhPT0gci5kYXRhLmxpbmsgKXtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gdHJ1ZTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5O1xuICAgICAgdmFyIG5vZGVzID0gci5nZXRDYWNoZWROb2RlcygpO1xuICAgICAgdmFyIGVkZ2VzID0gci5nZXRDYWNoZWRFZGdlcygpO1xuICAgICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICAgIHZhciBuZWVkc1JlZHJhdyA9IHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcblxuICAgICAgaWYgKGUudG91Y2hlc1swXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG5cbiAgICAgIC8vIHJlY29yZCBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cbiAgICAgIGlmKCBlLnRvdWNoZXNbMV0gKXtcblxuICAgICAgICAvLyBhbnl0aGluZyBpbiB0aGUgc2V0IG9mIGRyYWdnZWQgZWxlcyBzaG91bGQgYmUgcmVsZWFzZWRcbiAgICAgICAgdmFyIHJlbGVhc2UgPSBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgZWxlc1tpXS5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgICAgICBpZiggZWxlc1tpXS5hY3RpdmUoKSApeyBlbGVzW2ldLnVuYWN0aXZhdGUoKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmVsZWFzZShub2Rlcyk7XG4gICAgICAgIHJlbGVhc2UoZWRnZXMpO1xuXG4gICAgICAgIHZhciBvZmZzZXRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgICAgIG9mZnNldExlZnQgPSBvZmZzZXRzWzBdO1xuICAgICAgICBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICAgICAgICBjb250YWluZXJXaWR0aCA9IG9mZnNldHNbMl07XG4gICAgICAgIGNvbnRhaW5lckhlaWdodCA9IG9mZnNldHNbM107XG5cbiAgICAgICAgZjF4MSA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgICAgZjF5MSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuXG4gICAgICAgIGYyeDEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICAgIGYyeTEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICAgICAgICB0d29GaW5nZXJzU3RhcnRJbnNpZGUgPVxuICAgICAgICAgICAgIDAgPD0gZjF4MSAmJiBmMXgxIDw9IGNvbnRhaW5lcldpZHRoXG4gICAgICAgICAgJiYgMCA8PSBmMngxICYmIGYyeDEgPD0gY29udGFpbmVyV2lkdGhcbiAgICAgICAgICAmJiAwIDw9IGYxeTEgJiYgZjF5MSA8PSBjb250YWluZXJIZWlnaHRcbiAgICAgICAgICAmJiAwIDw9IGYyeTEgJiYgZjJ5MSA8PSBjb250YWluZXJIZWlnaHRcbiAgICAgICAgO1xuXG4gICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UoIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEgKTtcbiAgICAgICAgZGlzdGFuY2UxU3EgPSBkaXN0YW5jZVNxKCBmMXgxLCBmMXkxLCBmMngxLCBmMnkxICk7XG4gICAgICAgIGNlbnRlcjEgPSBbIChmMXgxICsgZjJ4MSkvMiwgKGYxeTEgKyBmMnkxKS8yIF07XG4gICAgICAgIG1vZGVsQ2VudGVyMSA9IFtcbiAgICAgICAgICAoY2VudGVyMVswXSAtIHBhbi54KSAvIHpvb20sXG4gICAgICAgICAgKGNlbnRlcjFbMV0gLSBwYW4ueSkgLyB6b29tXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gY29uc2lkZXIgY29udGV4dCB0YXBcbiAgICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGQgPSAyMDA7XG4gICAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkU3EgPSBjeHREaXN0VGhyZXNob2xkICogY3h0RGlzdFRocmVzaG9sZDtcbiAgICAgICAgaWYoIGRpc3RhbmNlMVNxIDwgY3h0RGlzdFRocmVzaG9sZFNxICYmICFlLnRvdWNoZXNbMl0gKXtcblxuICAgICAgICAgIHZhciBuZWFyMSA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB2YXIgbmVhcjIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMl0sIG5vd1szXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKGRpc3RhbmNlMSlcblxuICAgICAgICAgIGlmKCBuZWFyMSAmJiBuZWFyMS5pc05vZGUoKSApe1xuICAgICAgICAgICAgbmVhcjEuYWN0aXZhdGUoKS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIxO1xuXG4gICAgICAgICAgfSBlbHNlIGlmKCBuZWFyMiAmJiBuZWFyMi5pc05vZGUoKSApe1xuICAgICAgICAgICAgbmVhcjIuYWN0aXZhdGUoKS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIyO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlOyB9XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0ID0gdHJ1ZTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnY3h0dGFwc3RhcnQnKVxuXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGNlbnRlcjEpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndG91Y2hzdGFydCBwdHonKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2cob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coZjF4MSwgZjF5MSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGYyeDEsIGYyeTEpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhkaXN0YW5jZTEpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhjZW50ZXIxKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS5sb2coJ2Fub3RoZXIgdGFwc3RhcnQnKVxuXG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcblxuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIHtcblxuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcblxuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjtcblxuICAgICAgICAgIGlmKCBuZWFyLmlzTm9kZSgpICYmIHIubm9kZUlzRHJhZ2dhYmxlKG5lYXIpICl7XG5cbiAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyA9IFtdO1xuXG4gICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5EUkFHXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmKCBuZWFyLnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgICAgLy8gcmVzZXQgZHJhZyBlbGVtZW50cywgc2luY2UgbmVhciB3aWxsIGJlIGFkZGVkIGFnYWluXG5cbiAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNOb2RlKCkgJiYgdGhpcy5zZWxlY3RlZCgpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBmb3IoIHZhciBrID0gMDsgayA8IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBrKysgKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1trXTtcblxuICAgICAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZShzZWxlY3RlZE5vZGUpICl7XG4gICAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBzZWxlY3RlZE5vZGUsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlcyB9ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBuZWFyLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZXMgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdncmFiJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5lYXJcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBzdGFydCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndm1vdXNkb3duJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA7XG4gICAgICAgIH0gaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgIGN5XG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndG91Y2hzdGFydCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZWRvd24nLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIDtcblxuICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gVGFwLCB0YXBob2xkXG4gICAgICAgIC8vIC0tLS0tXG5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPG5vdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVhcmxpZXJbaV0gPSBub3dbaV07XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXSA9IG5vd1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hTdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuICAgICAgICBjbGVhclRpbWVvdXQoIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ICk7XG4gICAgICAgIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgJiYgIXIucGluY2hpbmcgLy8gaWYgcGluY2hpbmcsIHRoZW4gdGFwaG9sZCB1bnNlbGVjdCBzaG91bGRuJ3QgdGFrZSBlZmZlY3RcblxuICAgICAgICAgICAgICAvLyBUaGlzIHRpbWUgZG91YmxlIGNvbnN0cmFpbnQgcHJldmVudHMgbXVsdGlwbGUgcXVpY2sgdGFwc1xuICAgICAgICAgICAgICAvLyBmb2xsb3dlZCBieSBhIHRhcGhvbGQgdHJpZ2dlcmluZyBtdWx0aXBsZSB0YXBob2xkIGV2ZW50c1xuICAgICAgICAgICAgICAvLyYmIERhdGUubm93KCkgLSByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaFN0YXJ0VGltZSA+IDI1MFxuICAgICAgICAgICl7XG4gICAgICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByLmRhdGEuY3kudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICBjb25zb2xlLmxvZygndGFwaG9sZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgci50YXBob2xkRHVyYXRpb24pO1xuICAgICAgfVxuXG4gICAgICAvL3IucmVkcmF3KCk7XG5cbiAgICB9LCBmYWxzZSk7XG5cbi8vIGNvbnNvbGUubG9nID0gZnVuY3Rpb24obSl7ICQoJyNjb25zb2xlJykuYXBwZW5kKCc8ZGl2PicrbSsnPC9kaXY+Jyk7IH07XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaG1vdmUnLCAkJC51dGlsLnRocm90dGxlKGZ1bmN0aW9uKGUpIHtcblxuICAgICAgdmFyIHNlbGVjdCA9IHIuZGF0YS5zZWxlY3Q7XG4gICAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7IC8vaWYgKCFjYXB0dXJlKSB7IHJldHVybjsgfTtcbiAgICAgIGlmKCBjYXB0dXJlICl7IGUucHJldmVudERlZmF1bHQoKTsgfVxuXG4gICAgICB2YXIgY3kgPSByLmRhdGEuY3k7XG4gICAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93OyB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIFxuICAgICAgdmFyIG5lZWRzUmVkcmF3ID0gci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuXG4gICAgICBpZiAoZS50b3VjaGVzWzBdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTsgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07IH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpOyBub3dbMl0gPSBwb3NbMF07IG5vd1szXSA9IHBvc1sxXTsgfVxuICAgICAgaWYgKGUudG91Y2hlc1syXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7IG5vd1s0XSA9IHBvc1swXTsgbm93WzVdID0gcG9zWzFdOyB9XG4gICAgICB2YXIgZGlzcCA9IFtdOyBmb3IgKHZhciBqPTA7ajxub3cubGVuZ3RoO2orKykgeyBkaXNwW2pdID0gbm93W2pdIC0gZWFybGllcltqXTsgfVxuXG4gICAgICB2YXIgc3RhcnRQb3MgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uO1xuXG4gICAgICB2YXIgZHggPSBub3dbMF0gLSBzdGFydFBvc1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gbm93WzFdIC0gc3RhcnRQb3NbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tO1xuXG4gICAgICBpZiggY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQgKXtcbiAgICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgLy8gdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAgIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgICAgdmFyIGZhY3RvclNxID0gZGlzdGFuY2UyU3EgLyBkaXN0YW5jZTFTcTtcblxuICAgICAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE1MDtcbiAgICAgICAgdmFyIGRpc3RUaHJlc2hvbGRTcSA9IGRpc3RUaHJlc2hvbGQgKiBkaXN0VGhyZXNob2xkO1xuICAgICAgICB2YXIgZmFjdG9yVGhyZXNob2xkID0gMS41O1xuICAgICAgICB2YXIgZmFjdG9yVGhyZXNob2xkU3EgPSBmYWN0b3JUaHJlc2hvbGQgKiBmYWN0b3JUaHJlc2hvbGQ7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhmYWN0b3IsIGRpc3RhbmNlMilcblxuICAgICAgICAvLyBjYW5jZWwgY3R4IGdlc3R1cmVzIGlmIHRoZSBkaXN0YW5jZSBiL3QgdGhlIGZpbmdlcnMgaW5jcmVhc2VzXG4gICAgICAgIGlmKCBmYWN0b3JTcSA+PSBmYWN0b3JUaHJlc2hvbGRTcSB8fCBkaXN0YW5jZTJTcSA+PSBkaXN0VGhyZXNob2xkU3EgKXtcbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcbiAgICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQudW5hY3RpdmF0ZSgpOyByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7IH1cbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIGN4dEV2dCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApe1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmKCBjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCApe1xuICAgICAgICB2YXIgY3h0RXZ0ID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0ZHJhZycsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0pO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7IH1cbiAgICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnY3h0ZHJhZycpXG5cbiAgICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYoICFyLnRvdWNoRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIudG91Y2hEYXRhLmN4dE92ZXIgKXtcblxuICAgICAgICAgIGlmKCByLnRvdWNoRGF0YS5jeHRPdmVyICl7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5jeHRPdmVyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3V0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY3h0ZHJhZ291dCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY3h0ZHJhZ292ZXInKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYoIGNhcHR1cmUgJiYgZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSApe1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNsZWFyVGltZW91dCggdGhpcy50aHJlZUZpbmdlclNlbGVjdFRpbWVvdXQgKTtcbiAgICAgICAgdGhpcy5sYXN0VGhyZWVUb3VjaCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuXG4gICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICBpZiggIXNlbGVjdCB8fCBzZWxlY3QubGVuZ3RoID09PSAwIHx8IHNlbGVjdFswXSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgc2VsZWN0WzBdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkvMztcbiAgICAgICAgICBzZWxlY3RbMV0gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKS8zO1xuICAgICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pLzMgKyAxO1xuICAgICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pLzMgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pLzM7XG4gICAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkvMztcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG5cbiAgICAgICAgci5yZWRyYXcoKTtcblxuICAgICAgfSBlbHNlIGlmICggY2FwdHVyZSAmJiBlLnRvdWNoZXNbMV0gJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICkgeyAvLyB0d28gZmluZ2VycyA9PiBwaW5jaCB0byB6b29tXG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgICAgaWYoIGRyYWdnZWRFbGVzICl7XG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuRFJBR10gPSB0cnVlO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygndG91Y2htb3ZlIHB0eicpO1xuXG4gICAgICAgIC8vICh4MiwgeTIpIGZvciBmaW5nZXJzIDEgYW5kIDJcbiAgICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyggZjF4MiwgZjF5MiApXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBmMngyLCBmMnkyIClcblxuICAgICAgICB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgICAgLy8gdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgICAvLyB2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KCBkaXN0YW5jZTJTcSApIC8gTWF0aC5zcXJ0KCBkaXN0YW5jZTFTcSApO1xuICAgICAgICB2YXIgZmFjdG9yID0gZGlzdGFuY2UyIC8gZGlzdGFuY2UxO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGRpc3RhbmNlMilcbiAgICAgICAgLy8gY29uc29sZS5sb2coZmFjdG9yKVxuXG4gICAgICAgIGlmKCBmYWN0b3IgIT0gMSAmJiB0d29GaW5nZXJzU3RhcnRJbnNpZGUpe1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coZmFjdG9yKVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGRpc3RhbmNlMiArICcgLyAnICsgZGlzdGFuY2UxKTtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0nKTtcblxuICAgICAgICAgIC8vIGRlbHRhIGZpbmdlcjFcbiAgICAgICAgICB2YXIgZGYxeCA9IGYxeDIgLSBmMXgxO1xuICAgICAgICAgIHZhciBkZjF5ID0gZjF5MiAtIGYxeTE7XG5cbiAgICAgICAgICAvLyBkZWx0YSBmaW5nZXIgMlxuICAgICAgICAgIHZhciBkZjJ4ID0gZjJ4MiAtIGYyeDE7XG4gICAgICAgICAgdmFyIGRmMnkgPSBmMnkyIC0gZjJ5MTtcblxuICAgICAgICAgIC8vIHRyYW5zbGF0aW9uIGlzIHRoZSBub3JtYWxpc2VkIHZlY3RvciBvZiB0aGUgdHdvIGZpbmdlcnMgbW92ZW1lbnRcbiAgICAgICAgICAvLyBpLmUuIHNvIHBpbmNoaW5nIGNhbmNlbHMgb3V0IGFuZCBtb3ZpbmcgdG9nZXRoZXIgcGFuc1xuICAgICAgICAgIHZhciB0eCA9IChkZjF4ICsgZGYyeCkvMjtcbiAgICAgICAgICB2YXIgdHkgPSAoZGYxeSArIGRmMnkpLzI7XG5cbiAgICAgICAgICAvLyBhZGp1c3QgZmFjdG9yIGJ5IHRoZSBzcGVlZCBtdWx0aXBsaWVyXG4gICAgICAgICAgLy8gdmFyIHNwZWVkID0gMS41O1xuICAgICAgICAgIC8vIGlmKCBmYWN0b3IgPiAxICl7XG4gICAgICAgICAgLy8gICBmYWN0b3IgPSAoZmFjdG9yIC0gMSkgKiBzcGVlZCArIDE7XG4gICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAvLyAgIGZhY3RvciA9IDEgLSAoMSAtIGZhY3RvcikgKiBzcGVlZDtcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAvLyBub3cgY2FsY3VsYXRlIHRoZSB6b29tXG4gICAgICAgICAgdmFyIHpvb20xID0gY3kuem9vbSgpO1xuICAgICAgICAgIHZhciB6b29tMiA9IHpvb20xICogZmFjdG9yO1xuICAgICAgICAgIHZhciBwYW4xID0gY3kucGFuKCk7XG5cbiAgICAgICAgICAvLyB0aGUgbW9kZWwgY2VudGVyIHBvaW50IGNvbnZlcnRlZCB0byB0aGUgY3VycmVudCByZW5kZXJlZCBwb3NcbiAgICAgICAgICB2YXIgY3RyeCA9IG1vZGVsQ2VudGVyMVswXSAqIHpvb20xICsgcGFuMS54O1xuICAgICAgICAgIHZhciBjdHJ5ID0gbW9kZWxDZW50ZXIxWzFdICogem9vbTEgKyBwYW4xLnk7XG5cbiAgICAgICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgICAgIHg6IC16b29tMi96b29tMSAqIChjdHJ4IC0gcGFuMS54IC0gdHgpICsgY3RyeCxcbiAgICAgICAgICAgIHk6IC16b29tMi96b29tMSAqIChjdHJ5IC0gcGFuMS55IC0gdHkpICsgY3RyeVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhwYW4yKTtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh6b29tMik7XG5cbiAgICAgICAgICAvLyByZW1vdmUgZHJhZ2dlZCBlbGVzXG4gICAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7XG4gICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgICAgICAgIGlmKCBkcmFnZ2VkRWxlcyApeyBmb3IoIHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgIHZhciBkRWlfcCA9IGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZEVpX3AuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBkRWlfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICAgICAgfSB9XG5cbiAgICAgICAgICAgIHZhciBzdGFydF9wID0gci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGU7XG4gICAgICAgICAgICBzdGFydF9wLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhcnRfcC5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgICBzdGFydF9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLkRSQUddID0gdHJ1ZTtcblxuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnRcbiAgICAgICAgICAgICAgLnRyaWdnZXIoJ2ZyZWUnKVxuICAgICAgICAgICAgICAudHJpZ2dlcigndW5hY3RpdmF0ZScpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3kudmlld3BvcnQoe1xuICAgICAgICAgICAgem9vbTogem9vbTIsXG4gICAgICAgICAgICBwYW46IHBhbjIsXG4gICAgICAgICAgICBjYW5jZWxPbkZhaWxlZFpvb206IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlMjtcbiAgICAgICAgICBmMXgxID0gZjF4MjtcbiAgICAgICAgICBmMXkxID0gZjF5MjtcbiAgICAgICAgICBmMngxID0gZjJ4MjtcbiAgICAgICAgICBmMnkxID0gZjJ5MjtcblxuICAgICAgICAgIHIucGluY2hpbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgICBpZiAoZS50b3VjaGVzWzBdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTsgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07IH1cbiAgICAgICAgaWYgKGUudG91Y2hlc1sxXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICAgICAgdmFyIGxhc3QgPSByLnRvdWNoRGF0YS5sYXN0O1xuICAgICAgICB2YXIgbmVhciA9IG5lYXIgfHwgci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuXG4gICAgICAgIGlmKCBzdGFydCAhPSBudWxsICYmIHN0YXJ0Ll9wcml2YXRlLmdyb3VwID09ICdub2RlcycgJiYgci5ub2RlSXNEcmFnZ2FibGUoc3RhcnQpICl7XG5cbiAgICAgICAgICBpZiggcmRpc3QyID49IHIudG91Y2hUYXBUaHJlc2hvbGQyICl7IC8vIHRoZW4gZHJhZ2dpbmcgY2FuIGhhcHBlblxuICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBrID0gMDsgayA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaysrICl7XG4gICAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlID0gZHJhZ2dlZEVsZXNba107XG5cbiAgICAgICAgICAgICAgaWYoIHIubm9kZUlzRHJhZ2dhYmxlKGRyYWdnZWRFbGUpICYmIGRyYWdnZWRFbGUuaXNOb2RlKCkgJiYgZHJhZ2dlZEVsZS5ncmFiYmVkKCkgKXtcbiAgICAgICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBkUG9zID0gZHJhZ2dlZEVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcztcblxuICAgICAgICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoZGlzcFswXSkgJiYgJCQuaXMubnVtYmVyKGRpc3BbMV0pICl7XG4gICAgICAgICAgICAgICAgICBkUG9zLnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCBqdXN0U3RhcnRlZERyYWcgKXtcbiAgICAgICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIGRyYWdnZWRFbGUsIHsgaW5EcmFnTGF5ZXI6IHRydWUgfSApO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGE7XG5cbiAgICAgICAgICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoZHJhZ0RlbHRhWzBdKSAmJiAkJC5pcy5udW1iZXIoZHJhZ0RlbHRhWzFdKSApe1xuICAgICAgICAgICAgICAgICAgICBkUG9zLnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0Y29sID0gbmV3ICQkLkNvbGxlY3Rpb24oY3ksIGRyYWdnZWRFbGUpO1xuXG4gICAgICAgICAgICB0Y29sLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgICB0Y29sLnRyaWdnZXIoJ3Bvc2l0aW9uIGRyYWcnKTtcblxuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcblxuICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuRFJBR10gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSA9PSBlYXJsaWVyWzBdXG4gICAgICAgICAgICAgICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gPT0gZWFybGllclsxXVxuICAgICAgICAgICAgKXtcblxuICAgICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJpc2Uga2VlcCB0cmFjayBvZiBkcmFnIGRlbHRhIGZvciBsYXRlclxuICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgICAgICAgaWYoIGRyYWdEZWx0YS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goIGRpc3BbMF0gKTtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goIGRpc3BbMV0gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUb3VjaG1vdmUgZXZlbnRcbiAgICAgICAge1xuXG4gICAgICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0b3VjaG1vdmUnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgIHN0YXJ0LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICBzdGFydC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlbW92ZScsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuXG4gICAgICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWcnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlbW92ZScsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgY3kudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgICBjeS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgICBjeS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVhciAhPSBsYXN0KSB7XG4gICAgICAgICAgICBpZiAobGFzdCkgeyBsYXN0LnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHsgdHlwZTogJ3RhcGRyYWdvdXQnLCBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH0gfSkpOyB9XG4gICAgICAgICAgICBpZiAobmVhcikgeyBuZWFyLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHsgdHlwZTogJ3RhcGRyYWdvdmVyJywgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9IH0pKTsgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIudG91Y2hEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdG8gY2FuY2VsIHRhcGhvbGRcbiAgICAgICAgZm9yICh2YXIgaT0wO2k8bm93Lmxlbmd0aDtpKyspIHtcbiAgICAgICAgICBpZiAobm93W2ldXG4gICAgICAgICAgICAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uW2ldXG4gICAgICAgICAgICAmJiBNYXRoLmFicyhub3dbaV0gLSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uW2ldKSA+IDQpIHtcblxuICAgICAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgICBjYXB0dXJlXG4gICAgICAgICAgICAmJiAoIHN0YXJ0ID09IG51bGwgfHwgc3RhcnQuaXNFZGdlKCkgKVxuICAgICAgICAgICAgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKVxuICAgICAgICApe1xuXG4gICAgICAgICAgaWYoIHIuc3dpcGVQYW5uaW5nICl7XG4gICAgICAgICAgICBjeS5wYW5CeSh7XG4gICAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICB9IGVsc2UgaWYoIHJkaXN0MiA+PSByLnRvdWNoVGFwVGhyZXNob2xkMiApe1xuICAgICAgICAgICAgci5zd2lwZVBhbm5pbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBjeS5wYW5CeSh7XG4gICAgICAgICAgICAgIHg6IGR4ICogem9vbSxcbiAgICAgICAgICAgICAgeTogZHkgKiB6b29tXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcblxuICAgICAgICAgICAgaWYoICFyLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gKXtcbiAgICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgICBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqPTA7IGo8bm93Lmxlbmd0aDsgaisrKSB7IGVhcmxpZXJbal0gPSBub3dbal07IH1cbiAgICAgIC8vci5yZWRyYXcoKTtcblxuICAgIH0sIDEwMDAvMzAsIHsgdHJhaWxpbmc6IHRydWUgfSksIGZhbHNlKTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNoY2FuY2VsJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNoZW5kJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcblxuICAgICAgaWYoIGNhcHR1cmUgKXtcbiAgICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgc2VsZWN0ID0gci5kYXRhLnNlbGVjdDtcblxuICAgICAgci5zd2lwZVBhbm5pbmcgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuXG4gICAgICB2YXIgY3kgPSByLmRhdGEuY3k7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgICBcbiAgICAgIHZhciBuZWVkc1JlZHJhdyA9IHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcblxuICAgICAgaWYgKGUudG91Y2hlc1swXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4VGFwZW5kO1xuICAgICAgaWYoIHIudG91Y2hEYXRhLmN4dCApe1xuICAgICAgICBjdHhUYXBlbmQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgICBzdGFydC50cmlnZ2VyKCBjdHhUYXBlbmQgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjdHhUYXBlbmQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2N4dHRhcGVuZCcpXG5cbiAgICAgICAgaWYoICFyLnRvdWNoRGF0YS5jeHREcmFnZ2VkICl7XG4gICAgICAgICAgdmFyIGN0eFRhcCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgICAgICBzdGFydC50cmlnZ2VyKCBjdHhUYXAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kudHJpZ2dlciggY3R4VGFwICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnY3h0dGFwJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7IH1cbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcblxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIG1vcmUgYm94IHNlbGVjdGlvbiBpZiB3ZSBkb24ndCBoYXZlIHRocmVlIGZpbmdlcnNcbiAgICAgIGlmKCAhZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiByLnRvdWNoRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIGNsZWFyVGltZW91dCggdGhpcy50aHJlZUZpbmdlclNlbGVjdFRpbWVvdXQgKTtcbiAgICAgICAgLy90aGlzLnRocmVlRmluZ2VyU2VsZWN0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgbmV3bHlTZWxlY3RlZCA9IFtdO1xuICAgICAgICAgIHZhciBib3ggPSByLmdldEFsbEluQm94KCBzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10gKTtcblxuICAgICAgICAgIHNlbGVjdFswXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzZWxlY3RbMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgc2VsZWN0WzJdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGVjdFszXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzZWxlY3RbNF0gPSAwO1xuXG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coYm94KTtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaTwgYm94Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYoIGJveFtpXS5fcHJpdmF0ZS5zZWxlY3RhYmxlICl7XG4gICAgICAgICAgICAgIG5ld2x5U2VsZWN0ZWQucHVzaCggYm94W2ldICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld2x5U2VsQ29sID0gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBuZXdseVNlbGVjdGVkICk7XG5cbiAgICAgICAgICBpZiggY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnc2luZ2xlJyApe1xuICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5tZXJnZSggbmV3bHlTZWxDb2wgKS51bnNlbGVjdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld2x5U2VsQ29sLnNlbGVjdCgpO1xuXG4gICAgICAgICAgaWYoIG5ld2x5U2VsQ29sLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vfSwgMTAwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZVN0YXJ0U3R5bGUgPSBmYWxzZTtcblxuICAgICAgaWYoIHN0YXJ0ICE9IG51bGwgKXtcbiAgICAgICAgc3RhcnQuX3ByaXZhdGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHVwZGF0ZVN0YXJ0U3R5bGUgPSB0cnVlO1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkge1xuXG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuXG4gICAgICAvLyBMYXN0IHRvdWNoIHJlbGVhc2VkXG4gICAgICB9IGVsc2UgaWYgKCFlLnRvdWNoZXNbMF0pIHtcblxuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgICBpZiAoc3RhcnQgIT0gbnVsbCApIHtcblxuICAgICAgICAgIHZhciBzdGFydFdhc0dyYWJiZWQgPSBzdGFydC5fcHJpdmF0ZS5ncmFiYmVkO1xuICAgICAgICAgIFxuICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoIGRyYWdnZWRFbGVzICk7XG5cbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5EUkFHXSA9IHRydWU7XG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBzdGFydFdhc0dyYWJiZWQgKXtcbiAgICAgICAgICAgIHN0YXJ0LnRyaWdnZXIoJ2ZyZWUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGFydFxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBlbmQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZXVwJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA7XG5cbiAgICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5lYXJcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2hlbmQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZW5kJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZXVwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY3lcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2hlbmQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZW5kJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZXVwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR4ID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSAtIG5vd1swXTtcbiAgICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICAgIHZhciBkeSA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gLSBub3dbMV07XG4gICAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tO1xuXG4gICAgICAgIC8vIFByZXBhcmUgdG8gc2VsZWN0IHRoZSBjdXJyZW50bHkgdG91Y2hlZCBub2RlLCBvbmx5IGlmIGl0IGhhc24ndCBiZWVuIGRyYWdnZWQgcGFzdCBhIGNlcnRhaW4gZGlzdGFuY2VcbiAgICAgICAgaWYgKHN0YXJ0ICE9IG51bGxcbiAgICAgICAgICAgICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IGRyYWcgbm9kZXMgYXJvdW5kXG4gICAgICAgICAgICAmJiBzdGFydC5fcHJpdmF0ZS5zZWxlY3RhYmxlXG4gICAgICAgICAgICAmJiByZGlzdDIgPCByLnRvdWNoVGFwVGhyZXNob2xkMlxuICAgICAgICAgICAgJiYgIXIucGluY2hpbmcgLy8gcGluY2ggdG8gem9vbSBzaG91bGQgbm90IGFmZmVjdCBzZWxlY3Rpb25cbiAgICAgICAgKSB7XG5cbiAgICAgICAgICBpZiggY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnc2luZ2xlJyApe1xuICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5tZXJnZSggc3RhcnQgKS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgc3RhcnQuc2VsZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCBzdGFydC5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAgIHN0YXJ0LnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydC5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVTdGFydFN0eWxlID0gdHJ1ZTtcblxuXG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGFwIGV2ZW50LCByb3VnaGx5IHNhbWUgYXMgbW91c2UgY2xpY2sgZXZlbnQgZm9yIHRvdWNoXG4gICAgICAgIGlmICggci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0XG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2Y2xpY2snLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3lcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3ZjbGljaycsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH1cblxuLy8gICAgICAgICAgY29uc29sZS5sb2coJ3RhcCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrICl7IGVhcmxpZXJbal0gPSBub3dbal07IH1cblxuICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7IC8vIHJlc2V0IGZvciBuZXh0IG1vdXNlZG93blxuXG4gICAgICBpZiggZS50b3VjaGVzLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYoIHVwZGF0ZVN0YXJ0U3R5bGUgJiYgc3RhcnQgKXtcbiAgICAgICAgc3RhcnQudXBkYXRlU3R5bGUoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiggZS50b3VjaGVzLmxlbmd0aCA8IDIgKXtcbiAgICAgICAgci5waW5jaGluZyA9IGZhbHNlO1xuICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIC8vci5yZWRyYXcoKTtcblxuICAgIH0sIGZhbHNlKTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIHJlbmRlcmVyID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuICB2YXIgdXNlUGF0aHMgPSBDYW52YXNSZW5kZXJlci51c2VQYXRocygpO1xuXG4gIC8vIE5vZGUgc2hhcGUgY29udHJhY3Q6XG4gIC8vXG4gIC8vIGRyYXc6IGRyYXdcbiAgLy8gaW50ZXJzZWN0TGluZTogcmVwb3J0IGludGVyc2VjdGlvbiBmcm9tIHgsIHksIHRvIG5vZGUgY2VudGVyXG4gIC8vIGNoZWNrUG9pbnQ6IGNoZWNrIHgsIHkgaW4gbm9kZVxuXG4gIHZhciBub2RlU2hhcGVzID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlcyA9IHt9O1xuXG4gIHZhciBzaW4wID0gTWF0aC5zaW4oMCk7XG4gIHZhciBjb3MwID0gTWF0aC5jb3MoMCk7XG5cbiAgdmFyIHNpbiA9IHt9O1xuICB2YXIgY29zID0ge307XG5cbiAgdmFyIGVsbGlwc2VTdGVwU2l6ZSA9IDAuMTtcblxuICBmb3IgKHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUgKSB7XG4gICAgc2luW2ldID0gTWF0aC5zaW4oaSk7XG4gICAgY29zW2ldID0gTWF0aC5jb3MoaSk7XG4gIH1cblxuICBub2RlU2hhcGVzWydlbGxpcHNlJ10gPSB7XG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgbm9kZVNoYXBlc1snZWxsaXBzZSddLmRyYXdQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfSxcbiAgICBcbiAgICBkcmF3UGF0aDogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAgICAgICB2YXIgeFBvcywgeVBvcztcbiAgICAgICAgdmFyIHJ3ID0gd2lkdGgvMjtcbiAgICAgICAgdmFyIHJoID0gaGVpZ2h0LzI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSApIHtcbiAgICAgICAgICAgIHhQb3MgPSBjZW50ZXJYIC0gKHJ3ICogc2luW2ldKSAqIHNpbjAgKyAocncgKiBjb3NbaV0pICogY29zMDtcbiAgICAgICAgICAgIHlQb3MgPSBjZW50ZXJZICsgKHJoICogY29zW2ldKSAqIHNpbjAgKyAocmggKiBzaW5baV0pICogY29zMDtcblxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgY29udGV4dC5zY2FsZSh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgICAvLyBBdCBvcmlnaW4sIHJhZGl1cyAxLCAwIHRvIDJwaVxuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCAxLCAwLCBNYXRoLlBJICogMiAqIDAuOTk5LCBmYWxzZSk7IC8vICowLjk5OSBiL2MgY2hyb21lIHJlbmRlcmluZyBidWcgb24gZnVsbCBjaXJjbGVcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICBjb250ZXh0LnNjYWxlKDIvd2lkdGgsIDIvaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLWNlbnRlclgsIC1jZW50ZXJZKTtcblxuICAgICAgfVxuICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbihub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHZhciBpbnRlcnNlY3QgPSAkJC5tYXRoLmludGVyc2VjdExpbmVFbGxpcHNlKFxuICAgICAgICB4LCB5LFxuICAgICAgICBub2RlWCxcbiAgICAgICAgbm9kZVksXG4gICAgICAgIHdpZHRoIC8gMiArIHBhZGRpbmcsXG4gICAgICAgIGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGludGVyc2VjdDtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oXG4gICAgICB4MSwgeTEsIHgyLCB5Miwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZykge1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5ib3hJbnRlcnNlY3RFbGxpcHNlKFxuICAgICAgICB4MSwgeTEsIHgyLCB5MiwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgfSxcbiAgICBcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbihcbiAgICAgIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIFxuLy8gICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgICAgXG4gICAgICB4IC09IGNlbnRlclg7XG4gICAgICB5IC09IGNlbnRlclk7XG4gICAgICBcbiAgICAgIHggLz0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgeSAvPSAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgICAgXG4gICAgICByZXR1cm4gKE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikgPD0gMSk7XG4gICAgfVxuICB9O1xuICBcbiAgZnVuY3Rpb24gZ2VuZXJhdGVQb2x5Z29uKCBuYW1lLCBwb2ludHMgKXtcbiAgICBub2RlU2hhcGVzW25hbWVdID0ge1xuICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICBcbiAgICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb24oY29udGV4dCxcbiAgICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgbm9kZVNoYXBlc1tuYW1lXS5wb2ludHMpO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgZHJhd1BhdGg6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsXG4gICAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgIG5vZGVTaGFwZXNbbmFtZV0ucG9pbnRzKTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgICByZXR1cm4gJCQubWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZShcbiAgICAgICAgICAgIHgsIHksXG4gICAgICAgICAgICBub2RlU2hhcGVzW25hbWVdLnBvaW50cyxcbiAgICAgICAgICAgIG5vZGVYLFxuICAgICAgICAgICAgbm9kZVksXG4gICAgICAgICAgICB3aWR0aCAvIDIsIGhlaWdodCAvIDIsXG4gICAgICAgICAgICBwYWRkaW5nKTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBcbiAgICAgICAgY2VudGVyWSwgcGFkZGluZykge1xuICAgICAgICBcbiAgICAgICAgdmFyIHBvaW50cyA9IG5vZGVTaGFwZXNbbmFtZV0ucG9pbnRzO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuICQkLm1hdGguYm94SW50ZXJzZWN0UG9seWdvbihcbiAgICAgICAgICB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICBwb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIFxuICAgICAgICAgIGNlbnRlclksIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgY2hlY2tQb2ludDogZnVuY3Rpb24oXG4gICAgICAgIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBub2RlU2hhcGVzW25hbWVdLnBvaW50cyxcbiAgICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIFxuICBnZW5lcmF0ZVBvbHlnb24oICd0cmlhbmdsZScsICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDMsIDApICk7XG4gIFxuICBnZW5lcmF0ZVBvbHlnb24oICdzcXVhcmUnLCAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSApO1xuICBub2RlU2hhcGVzWydyZWN0YW5nbGUnXSA9IG5vZGVTaGFwZXNbJ3NxdWFyZSddO1xuICBcbiAgbm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICBwb2ludHM6ICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdSb3VuZFJlY3RhbmdsZShjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAxMCk7XG4gICAgfSxcbiAgICBcbiAgICBkcmF3UGF0aDogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAxMCk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbihub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiAkJC5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZShcbiAgICAgICAgICB4LCB5LFxuICAgICAgICAgIG5vZGVYLFxuICAgICAgICAgIG5vZGVZLFxuICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uKFxuICAgICAgeDEsIHkxLCB4MiwgeTIsXG4gICAgICB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBcbiAgICAgIGNlbnRlclksIHBhZGRpbmcpIHtcblxuICAgICAgcmV0dXJuICQkLm1hdGgucm91bmRSZWN0YW5nbGVJbnRlcnNlY3RCb3goXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLCBcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICAvLyBMb29rcyBsaWtlIHRoZSB3aWR0aCBwYXNzZWQgaW50byB0aGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IHRoZSB0b3RhbCB3aWR0aCAvIDJcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbihcbiAgICAgIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIFxuICAgICAgdmFyIGNvcm5lclJhZGl1cyA9ICQkLm1hdGguZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmICgkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiBjb3JuZXJSYWRpdXMsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayB2Qm94XG4gICAgICBpZiAoJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgbm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXS5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gMiAqIGNvcm5lclJhZGl1cywgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGNoZWNrSW5FbGxpcHNlID0gZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICAgICAgICB4IC09IGNlbnRlclg7XG4gICAgICAgIHkgLT0gY2VudGVyWTtcbiAgICAgICAgXG4gICAgICAgIHggLz0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgICB5IC89IChoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gKE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikgPD0gMSk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRvcCBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSxcbiAgICAgICAgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcpKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLypcbiAgICAgIGlmIChyZW5kZXJlci5ib3hJbnRlcnNlY3RFbGxpcHNlKHgsIHksIHgsIHksIHBhZGRpbmcsIFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLFxuICAgICAgICBjZW50ZXJYIC0gd2lkdGggKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgLSBoZWlnaHQgKyBjb3JuZXJSYWRpdXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgKi9cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdG9wIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSxcbiAgICAgICAgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcpKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSxcbiAgICAgICAgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcpKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LFxuICAgICAgICBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZykpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICBcbiAgZ2VuZXJhdGVQb2x5Z29uKCAnZGlhbW9uZCcsIFtcbiAgICAwLCAxLFxuICAgIDEsIDAsXG4gICAgMCwgLTEsXG4gICAgLTEsIDBcbiAgXSApO1xuICBcbiAgZ2VuZXJhdGVQb2x5Z29uKCAncGVudGFnb24nLCAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg1LCAwKSApO1xuICBcbiAgZ2VuZXJhdGVQb2x5Z29uKCAnaGV4YWdvbicsICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDYsIDApICk7XG4gIFxuICBnZW5lcmF0ZVBvbHlnb24oICdoZXB0YWdvbicsICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDcsIDApICk7XG4gIFxuICBnZW5lcmF0ZVBvbHlnb24oICdvY3RhZ29uJywgJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoOCwgMCkgKTtcbiAgICBcbiAgdmFyIHN0YXI1UG9pbnRzID0gbmV3IEFycmF5KDIwKTtcbiAge1xuICAgIHZhciBvdXRlclBvaW50cyA9ICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCAwKTtcbiAgICB2YXIgaW5uZXJQb2ludHMgPSAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgTWF0aC5QSSAvIDUpO1xuICAgIFxuICAvLyAgY29uc29sZS5sb2cob3V0ZXJQb2ludHMpO1xuICAvLyAgY29uc29sZS5sb2coaW5uZXJQb2ludHMpO1xuICAgIFxuICAgIC8vIE91dGVyIHJhZGl1cyBpcyAxOyBpbm5lciByYWRpdXMgb2Ygc3RhciBpcyBzbWFsbGVyXG4gICAgdmFyIGlubmVyUmFkaXVzID0gMC41ICogKDMgLSBNYXRoLnNxcnQoNSkpO1xuICAgIGlubmVyUmFkaXVzICo9IDEuNTc7XG4gICAgXG4gICAgZm9yICh2YXIgaT0wO2k8aW5uZXJQb2ludHMubGVuZ3RoLzI7aSsrKSB7XG4gICAgICBpbm5lclBvaW50c1tpKjJdICo9IGlubmVyUmFkaXVzO1xuICAgICAgaW5uZXJQb2ludHNbaSoyKzFdICo9IGlubmVyUmFkaXVzO1xuICAgIH1cbiAgICBcbiAgICBmb3IgKHZhciBpPTA7aTwyMC80O2krKykge1xuICAgICAgc3RhcjVQb2ludHNbaSo0XSA9IG91dGVyUG9pbnRzW2kqMl07XG4gICAgICBzdGFyNVBvaW50c1tpKjQrMV0gPSBvdXRlclBvaW50c1tpKjIrMV07XG4gICAgICBcbiAgICAgIHN0YXI1UG9pbnRzW2kqNCsyXSA9IGlubmVyUG9pbnRzW2kqMl07XG4gICAgICBzdGFyNVBvaW50c1tpKjQrM10gPSBpbm5lclBvaW50c1tpKjIrMV07XG4gICAgfVxuICAgIFxuICAvLyAgY29uc29sZS5sb2coc3RhcjVQb2ludHMpO1xuICB9XG5cbiAgc3RhcjVQb2ludHMgPSAkJC5tYXRoLmZpdFBvbHlnb25Ub1NxdWFyZSggc3RhcjVQb2ludHMgKTtcbiAgXG4gIGdlbmVyYXRlUG9seWdvbiggJ3N0YXInLCBzdGFyNVBvaW50cyApO1xuICBcbiAgZ2VuZXJhdGVQb2x5Z29uKCAndmVlJywgW1xuICAgIC0xLCAtMSxcbiAgICAwLCAtMC4zMzMsXG4gICAgMSwgLTEsXG4gICAgMCwgMVxuICBdICk7XG4gIFxuICBnZW5lcmF0ZVBvbHlnb24oICdyaG9tYm9pZCcsIFtcbiAgICAtMSwgLTEsXG4gICAgMC4zMzMsIC0xLFxuICAgIDEsIDEsXG4gICAgLTAuMzMzLCAxXG4gIF0gKTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGFuaW1hdGU6IHRydWUsIC8vIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGF5b3V0IGFzIGl0J3MgcnVubmluZ1xuICAgIG1heFNpbXVsYXRpb25UaW1lOiA0MDAwLCAvLyBtYXggbGVuZ3RoIGluIG1zIHRvIHJ1biB0aGUgbGF5b3V0XG4gICAgZml0OiB0cnVlLCAvLyBvbiBldmVyeSBsYXlvdXQgcmVwb3NpdGlvbiBvZiBub2RlcywgZml0IHRoZSB2aWV3cG9ydFxuICAgIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIGFyb3VuZCB0aGUgc2ltdWxhdGlvblxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIHVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZzogZmFsc2UsIC8vIHNvIHlvdSBjYW4ndCBkcmFnIG5vZGVzIGR1cmluZyBsYXlvdXRcblxuICAgIC8vIGNhbGxiYWNrcyBvbiBsYXlvdXQgZXZlbnRzXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHkgXG4gICAgc3RvcDogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG5cbiAgICAvLyBmb3JjZXMgdXNlZCBieSBhcmJvciAodXNlIGFyYm9yIGRlZmF1bHQgb24gdW5kZWZpbmVkKVxuICAgIHJlcHVsc2lvbjogdW5kZWZpbmVkLFxuICAgIHN0aWZmbmVzczogdW5kZWZpbmVkLFxuICAgIGZyaWN0aW9uOiB1bmRlZmluZWQsXG4gICAgZ3Jhdml0eTogdHJ1ZSxcbiAgICBmcHM6IHVuZGVmaW5lZCxcbiAgICBwcmVjaXNpb246IHVuZGVmaW5lZCxcblxuICAgIC8vIHN0YXRpYyBudW1iZXJzIG9yIGZ1bmN0aW9ucyB0aGF0IGR5bmFtaWNhbGx5IHJldHVybiB3aGF0IHRoZXNlXG4gICAgLy8gdmFsdWVzIHNob3VsZCBiZSBmb3IgZWFjaCBlbGVtZW50XG4gICAgLy8gZS5nLiBub2RlTWFzczogZnVuY3Rpb24obil7IHJldHVybiBuLmRhdGEoJ3dlaWdodCcpIH1cbiAgICBub2RlTWFzczogdW5kZWZpbmVkLCBcbiAgICBlZGdlTGVuZ3RoOiB1bmRlZmluZWQsXG5cbiAgICBzdGVwU2l6ZTogMC4xLCAvLyBzbW9vdGhpbmcgb2YgYXJib3IgYm91bmRpbmcgYm94XG5cbiAgICAvLyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgc3lzdGVtIGlzIHN0YWJsZSB0byBpbmRpY2F0ZVxuICAgIC8vIHRoYXQgdGhlIGxheW91dCBjYW4gYmUgc3RvcHBlZFxuICAgIHN0YWJsZUVuZXJneTogZnVuY3Rpb24oIGVuZXJneSApe1xuICAgICAgdmFyIGUgPSBlbmVyZ3k7IFxuICAgICAgcmV0dXJuIChlLm1heCA8PSAwLjUpIHx8IChlLm1lYW4gPD0gMC4zKTtcbiAgICB9LFxuXG4gICAgLy8gaW5maW5pdGUgbGF5b3V0IG9wdGlvbnNcbiAgICBpbmZpbml0ZTogZmFsc2UgLy8gb3ZlcnJpZGVzIGFsbCBvdGhlciBvcHRpb25zIGZvciBhIGZvcmNlcy1hbGwtdGhlLXRpbWUgbW9kZVxuICB9O1xuICBcbiAgZnVuY3Rpb24gQXJib3JMYXlvdXQob3B0aW9ucyl7XG4gICAgdGhpcy5fcHJpdmF0ZSA9IHt9O1xuXG4gICAgdGhpcy5fcHJpdmF0ZS5vcHRpb25zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICAgIFxuICBBcmJvckxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3ByaXZhdGUub3B0aW9ucztcblxuICAgICQkLnV0aWwucmVxdWlyZSgnYXJib3InLCBmdW5jdGlvbihhcmJvcil7XG5cbiAgICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gICAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZXMuZWRnZXMoKTtcbiAgICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgICAgfSApO1xuICAgICAgdmFyIHNpbVVwZGF0aW5nUG9zID0gZmFsc2U7XG5cbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIG9sZCBhbmltYXRpb24gb3B0aW9uXG4gICAgICBpZiggb3B0aW9ucy5saXZlVXBkYXRlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRlID0gb3B0aW9ucy5saXZlVXBkYXRlO1xuICAgICAgfVxuXG4gICAgICAvLyBhcmJvciBkb2Vzbid0IHdvcmsgd2l0aCBqdXN0IDEgbm9kZSBcbiAgICAgIGlmKCBlbGVzLm5vZGVzKCkuc2l6ZSgpIDw9IDEgKXtcbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgY3kucmVzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZXMubm9kZXMoKS5wb3NpdGlvbih7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZCggKGJiLngxICsgYmIueDIpLzIgKSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKCAoYmIueTEgKyBiYi55MikvMiApXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzeXMgPSBsYXlvdXQuX3ByaXZhdGUuc3lzdGVtID0gYXJib3IuUGFydGljbGVTeXN0ZW0oKTtcblxuICAgICAgc3lzLnBhcmFtZXRlcnMoe1xuICAgICAgICByZXB1bHNpb246IG9wdGlvbnMucmVwdWxzaW9uLFxuICAgICAgICBzdGlmZm5lc3M6IG9wdGlvbnMuc3RpZmZuZXNzLCBcbiAgICAgICAgZnJpY3Rpb246IG9wdGlvbnMuZnJpY3Rpb24sIFxuICAgICAgICBncmF2aXR5OiBvcHRpb25zLmdyYXZpdHksIFxuICAgICAgICBmcHM6IG9wdGlvbnMuZnBzLCBcbiAgICAgICAgZHQ6IG9wdGlvbnMuZHQsIFxuICAgICAgICBwcmVjaXNpb246IG9wdGlvbnMucHJlY2lzaW9uXG4gICAgICB9KTtcblxuICAgICAgaWYoIG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLmZpdCApe1xuICAgICAgICBjeS5maXQoIGJiLCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGRvbmVUaW1lID0gMjUwO1xuICAgICAgdmFyIGRvbmVUaW1lb3V0O1xuICAgICAgXG4gICAgICB2YXIgcmVhZHkgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgdmFyIGxhc3REcmF3ID0gK25ldyBEYXRlKCk7XG4gICAgICB2YXIgc3lzUmVuZGVyZXIgPSB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKHN5c3RlbSl7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZHJhdzogZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgZW5lcmd5ID0gc3lzLmVuZXJneSgpO1xuXG4gICAgICAgICAgLy8gaWYgd2UncmUgc3RhYmxlIChhY2NvcmRpbmcgdG8gdGhlIGNsaWVudCksIHdlJ3JlIGRvbmVcbiAgICAgICAgICBpZiggIW9wdGlvbnMuaW5maW5pdGUgJiYgb3B0aW9ucy5zdGFibGVFbmVyZ3kgIT0gbnVsbCAmJiBlbmVyZ3kgIT0gbnVsbCAmJiBlbmVyZ3kubiA+IDAgJiYgb3B0aW9ucy5zdGFibGVFbmVyZ3koZW5lcmd5KSApe1xuICAgICAgICAgICAgbGF5b3V0LnN0b3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIW9wdGlvbnMuaW5maW5pdGUgJiYgZG9uZVRpbWUgIT0gSW5maW5pdHkgKXtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChkb25lVGltZW91dCk7XG4gICAgICAgICAgICBkb25lVGltZW91dCA9IHNldFRpbWVvdXQoZG9uZUhhbmRsZXIsIGRvbmVUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIG1vdmVkTm9kZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgc3lzLmVhY2hOb2RlKGZ1bmN0aW9uKG4sIHBvaW50KXsgXG4gICAgICAgICAgICB2YXIgZGF0YSA9IG4uZGF0YTtcbiAgICAgICAgICAgIHZhciBub2RlID0gZGF0YS5lbGVtZW50O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggbm9kZSA9PSBudWxsICl7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoICFub2RlLmxvY2tlZCgpICYmICFub2RlLmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICBub2RlLnNpbGVudFBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICB4OiBiYi54MSArIHBvaW50LngsXG4gICAgICAgICAgICAgICAgeTogYmIueTEgKyBwb2ludC55XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIG1vdmVkTm9kZXMubWVyZ2UoIG5vZGUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcblxuICAgICAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgJiYgbW92ZWROb2Rlcy5sZW5ndGggPiAwICl7XG4gICAgICAgICAgICBzaW1VcGRhdGluZ1BvcyA9IHRydWU7XG5cbiAgICAgICAgICAgIG1vdmVkTm9kZXMucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG5cbiAgICAgICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0RHJhdyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgc2ltVXBkYXRpbmdQb3MgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBcbiAgICAgICAgICBpZiggIXJlYWR5ICl7XG4gICAgICAgICAgICByZWFkeSA9IHRydWU7XG4gICAgICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9O1xuICAgICAgc3lzLnJlbmRlcmVyID0gc3lzUmVuZGVyZXI7XG4gICAgICBzeXMuc2NyZWVuU2l6ZSggYmIudywgYmIuaCApO1xuICAgICAgc3lzLnNjcmVlblBhZGRpbmcoIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgc3lzLnNjcmVlblN0ZXAoIG9wdGlvbnMuc3RlcFNpemUgKTtcblxuICAgICAgZnVuY3Rpb24gY2FsY3VsYXRlVmFsdWVGb3JFbGVtZW50KGVsZW1lbnQsIHZhbHVlKXtcbiAgICAgICAgaWYoIHZhbHVlID09IG51bGwgKXtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYoIHR5cGVvZiB2YWx1ZSA9PSB0eXBlb2YgZnVuY3Rpb24oKXt9ICl7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KGVsZW1lbnQsIFtlbGVtZW50Ll9wcml2YXRlLmRhdGEsIHtcbiAgICAgICAgICAgIG5vZGVzOiBub2Rlcy5sZW5ndGgsXG4gICAgICAgICAgICBlZGdlczogZWRnZXMubGVuZ3RoLFxuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgICAgIH1dKTsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBncmFiSGFuZGxlcjtcbiAgICAgIG5vZGVzLm9uKCdncmFiIGZyZWUgcG9zaXRpb24nLCBncmFiSGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICBpZiggc2ltVXBkYXRpbmdQb3MgKXsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGFwb3MgPSBzeXMuZnJvbVNjcmVlbiggcG9zICk7XG4gICAgICAgIGlmKCAhYXBvcyApeyByZXR1cm47IH1cblxuICAgICAgICB2YXIgcCA9IGFyYm9yLlBvaW50KGFwb3MueCwgYXBvcy55KTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmc7XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgYmIueDEgKyBwYWRkaW5nIDw9IHBvcy54ICYmIHBvcy54IDw9IGJiLngyIC0gcGFkZGluZyAmJlxuICAgICAgICAgIGJiLnkxICsgcGFkZGluZyA8PSBwb3MueSAmJiBwb3MueSA8PSBiYi55MiAtIHBhZGRpbmdcbiAgICAgICAgKXtcbiAgICAgICAgICB0aGlzLnNjcmF0Y2goKS5hcmJvci5wID0gcDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3dpdGNoKCBlLnR5cGUgKXtcbiAgICAgICAgY2FzZSAnZ3JhYic6XG4gICAgICAgICAgdGhpcy5zY3JhdGNoKCkuYXJib3IuZml4ZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmcmVlJzpcbiAgICAgICAgICB0aGlzLnNjcmF0Y2goKS5hcmJvci5maXhlZCA9IGZhbHNlO1xuICAgICAgICAgIC8vdGhpcy5zY3JhdGNoKCkuYXJib3IudGVtcE1hc3MgPSAxMDAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGxvY2tIYW5kbGVyO1xuICAgICAgbm9kZXMub24oJ2xvY2sgdW5sb2NrJywgbG9ja0hhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgbm9kZS5zY3JhdGNoKCkuYXJib3IuZml4ZWQgPSBub2RlLmxvY2tlZCgpO1xuICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgIHZhciByZW1vdmVIYW5kbGVyO1xuICAgICAgZWxlcy5vbigncmVtb3ZlJywgcmVtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uKGUpeyByZXR1cm47IC8vIFRPRE8gZW5hYmxlIHdoZW4gbGF5b3V0IGFkZC9yZW1vdmUgYXBpIGFkZGVkXG4gICAgICAgIC8vIHZhciBlbGUgPSB0aGlzO1xuICAgICAgICAvLyB2YXIgYXJib3JFbGUgPSBlbGUuc2NyYXRjaCgpLmFyYm9yO1xuXG4gICAgICAgIC8vIGlmKCAhYXJib3JFbGUgKXsgcmV0dXJuOyB9XG5cbiAgICAgICAgLy8gaWYoIGVsZS5pc05vZGUoKSApe1xuICAgICAgICAvLyAgIHN5cy5wcnVuZU5vZGUoIGFyYm9yRWxlICk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgc3lzLnBydW5lRWRnZSggYXJib3JFbGUgKTtcbiAgICAgICAgLy8gfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBhZGRIYW5kbGVyO1xuICAgICAgY3kub24oJ2FkZCcsICcqJywgYWRkSGFuZGxlciA9IGZ1bmN0aW9uKCl7IHJldHVybjsgLy8gVE9ETyBlbmFibGUgd2hlbiBsYXlvdXQgYWRkL3JlbW92ZSBhcGkgYWRkZWRcbiAgICAgICAgLy8gdmFyIGVsZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gaWYoIGVsZS5pc05vZGUoKSApe1xuICAgICAgICAvLyAgIGFkZE5vZGUoIGVsZSApO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgIGFkZEVkZ2UoIGVsZSApO1xuICAgICAgICAvLyB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIHJlc2l6ZUhhbmRsZXI7XG4gICAgICBjeS5vbigncmVzaXplJywgcmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCBvcHRpb25zLmJvdW5kaW5nQm94ID09IG51bGwgJiYgbGF5b3V0Ll9wcml2YXRlLnN5c3RlbSAhPSBudWxsICl7XG4gICAgICAgICAgdmFyIHcgPSBjeS53aWR0aCgpO1xuICAgICAgICAgIHZhciBoID0gY3kuaGVpZ2h0KCk7XG5cbiAgICAgICAgICBzeXMuc2NyZWVuU2l6ZSggdywgaCApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gYWRkTm9kZSggbm9kZSApe1xuICAgICAgICBpZiggbm9kZS5pc0Z1bGxBdXRvUGFyZW50KCkgKXsgcmV0dXJuOyB9IC8vIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHNpbVxuXG4gICAgICAgIHZhciBpZCA9IG5vZGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIG1hc3MgPSBjYWxjdWxhdGVWYWx1ZUZvckVsZW1lbnQobm9kZSwgb3B0aW9ucy5ub2RlTWFzcyk7XG4gICAgICAgIHZhciBsb2NrZWQgPSBub2RlLl9wcml2YXRlLmxvY2tlZDtcbiAgICAgICAgdmFyIG5Qb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgcG9zID0gc3lzLmZyb21TY3JlZW4oe1xuICAgICAgICAgIHg6IG5Qb3MueCxcbiAgICAgICAgICB5OiBuUG9zLnlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbm9kZS5zY3JhdGNoKCkuYXJib3IgPSBzeXMuYWRkTm9kZShpZCwge1xuICAgICAgICAgIGVsZW1lbnQ6IG5vZGUsXG4gICAgICAgICAgbWFzczogbWFzcyxcbiAgICAgICAgICBmaXhlZDogbG9ja2VkLFxuICAgICAgICAgIHg6IGxvY2tlZCA/IHBvcy54IDogdW5kZWZpbmVkLFxuICAgICAgICAgIHk6IGxvY2tlZCA/IHBvcy55IDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRFZGdlKCBlZGdlICl7XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpLmlkKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpLmlkKCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBjYWxjdWxhdGVWYWx1ZUZvckVsZW1lbnQoZWRnZSwgb3B0aW9ucy5lZGdlTGVuZ3RoKTtcbiAgICAgICAgXG4gICAgICAgIGVkZ2Uuc2NyYXRjaCgpLmFyYm9yID0gc3lzLmFkZEVkZ2Uoc3JjLCB0Z3QsIHtcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgICB9KTsgXG4gICAgICB9XG5cbiAgICAgIG5vZGVzLmVhY2goZnVuY3Rpb24oaSwgbm9kZSl7XG4gICAgICAgIGFkZE5vZGUoIG5vZGUgKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBlZGdlcy5lYWNoKGZ1bmN0aW9uKGksIGVkZ2Upe1xuICAgICAgICBhZGRFZGdlKCBlZGdlICk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgdmFyIGdyYWJiYWJsZU5vZGVzID0gbm9kZXMuZmlsdGVyKFwiOmdyYWJiYWJsZVwiKTtcbiAgICAgIC8vIGRpc2FibGUgZ3JhYmJpbmcgaWYgc28gc2V0XG4gICAgICBpZiggb3B0aW9ucy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXtcbiAgICAgICAgZ3JhYmJhYmxlTm9kZXMudW5ncmFiaWZ5KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBkb25lSGFuZGxlciA9IGxheW91dC5fcHJpdmF0ZS5kb25lSGFuZGxlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxheW91dC5fcHJpdmF0ZS5kb25lSGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgaWYoICFvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICAgIGN5LnJlc2V0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZXMucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1bmJpbmQgaGFuZGxlcnNcbiAgICAgICAgbm9kZXMub2ZmKCdncmFiIGZyZWUgcG9zaXRpb24nLCBncmFiSGFuZGxlcik7XG4gICAgICAgIG5vZGVzLm9mZignbG9jayB1bmxvY2snLCBsb2NrSGFuZGxlcik7XG4gICAgICAgIGVsZXMub2ZmKCdyZW1vdmUnLCByZW1vdmVIYW5kbGVyKTtcbiAgICAgICAgY3kub2ZmKCdhZGQnLCAnKicsIGFkZEhhbmRsZXIpO1xuICAgICAgICBjeS5vZmYoJ3Jlc2l6ZScsIHJlc2l6ZUhhbmRsZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gZW5hYmxlIGJhY2sgZ3JhYmJpbmcgaWYgc28gc2V0XG4gICAgICAgIGlmKCBvcHRpb25zLnVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZyApe1xuICAgICAgICAgIGdyYWJiYWJsZU5vZGVzLmdyYWJpZnkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBzeXMuc3RhcnQoKTtcbiAgICAgIGlmKCAhb3B0aW9ucy5pbmZpbml0ZSAmJiBvcHRpb25zLm1heFNpbXVsYXRpb25UaW1lICE9IG51bGwgJiYgb3B0aW9ucy5tYXhTaW11bGF0aW9uVGltZSA+IDAgJiYgb3B0aW9ucy5tYXhTaW11bGF0aW9uVGltZSAhPT0gSW5maW5pdHkgKXtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIGxheW91dC5zdG9wKCk7XG4gICAgICAgIH0sIG9wdGlvbnMubWF4U2ltdWxhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIFxuICAgIH0pOyAvLyByZXF1aXJlXG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuXG4gIEFyYm9yTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgICBpZiggdGhpcy5fcHJpdmF0ZS5zeXN0ZW0gIT0gbnVsbCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5zeXN0ZW0uc3RvcCgpO1xuICAgIH1cblxuICAgIGlmKCB0aGlzLl9wcml2YXRlLmRvbmVIYW5kbGVyICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmRvbmVIYW5kbGVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ2FyYm9yJywgQXJib3JMYXlvdXQpO1xuICBcbiAgXG59KShjeXRvc2NhcGUpO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIGRpcmVjdGVkOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgdHJlZSBpcyBkaXJlY3RlZCBkb3dud2FyZHMgKG9yIGVkZ2VzIGNhbiBwb2ludCBpbiBhbnkgZGlyZWN0aW9uIGlmIGZhbHNlKVxuICAgIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIG9uIGZpdFxuICAgIGNpcmNsZTogZmFsc2UsIC8vIHB1dCBkZXB0aHMgaW4gY29uY2VudHJpYyBjaXJjbGVzIGlmIHRydWUsIHB1dCBkZXB0aHMgdG9wIGRvd24gaWYgZmFsc2VcbiAgICBzcGFjaW5nRmFjdG9yOiAxLjc1LCAvLyBwb3NpdGl2ZSBzcGFjaW5nIGZhY3RvciwgbGFyZ2VyID0+IG1vcmUgc3BhY2UgYmV0d2VlbiBub2RlcyAoTi5CLiBuL2EgaWYgY2F1c2VzIG92ZXJsYXApXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gICAgcm9vdHM6IHVuZGVmaW5lZCwgLy8gdGhlIHJvb3RzIG9mIHRoZSB0cmVlc1xuICAgIG1heGltYWxBZGp1c3RtZW50czogMCwgLy8gaG93IG1hbnkgdGltZXMgdG8gdHJ5IHRvIHBvc2l0aW9uIHRoZSBub2RlcyBpbiBhIG1heGltYWwgd2F5IChpLmUuIG5vIGJhY2t0cmFja2luZylcbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB9O1xuICBcbiAgZnVuY3Rpb24gQnJlYWR0aEZpcnN0TGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgQnJlYWR0aEZpcnN0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gICAgXG4gICAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICB2YXIgZ3JhcGggPSBlbGVzO1xuICAgIFxuICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICB9ICk7XG5cbiAgICB2YXIgcm9vdHM7XG4gICAgaWYoICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24ob3B0aW9ucy5yb290cykgKXtcbiAgICAgIHJvb3RzID0gb3B0aW9ucy5yb290cztcbiAgICB9IGVsc2UgaWYoICQkLmlzLmFycmF5KG9wdGlvbnMucm9vdHMpICl7XG4gICAgICB2YXIgcm9vdHNBcnJheSA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wdGlvbnMucm9vdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGlkID0gb3B0aW9ucy5yb290c1tpXTtcbiAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuICAgICAgICByb290c0FycmF5LnB1c2goIGVsZSApO1xuICAgICAgfVxuXG4gICAgICByb290cyA9IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcm9vdHNBcnJheSApO1xuICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKG9wdGlvbnMucm9vdHMpICl7XG4gICAgICByb290cyA9IGN5LiQoIG9wdGlvbnMucm9vdHMgKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiggb3B0aW9ucy5kaXJlY3RlZCApe1xuICAgICAgICByb290cyA9IG5vZGVzLnJvb3RzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgdW5oYW5kbGVkTm9kZXMgPSBub2RlcztcblxuICAgICAgICB3aGlsZSggdW5oYW5kbGVkTm9kZXMubGVuZ3RoID4gMCApe1xuICAgICAgICAgIHZhciBjdXJyQ29tcCA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgICAgICAgIGVsZXMuYmZzKHtcbiAgICAgICAgICAgIHJvb3RzOiB1bmhhbmRsZWROb2Rlc1swXSxcbiAgICAgICAgICAgIHZpc2l0OiBmdW5jdGlvbihpLCBkZXB0aCwgbm9kZSwgZWRnZSwgcE5vZGUpe1xuICAgICAgICAgICAgICBjdXJyQ29tcCA9IGN1cnJDb21wLmFkZCggbm9kZSApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpcmVjdGVkOiBmYWxzZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdW5oYW5kbGVkTm9kZXMgPSB1bmhhbmRsZWROb2Rlcy5ub3QoIGN1cnJDb21wICk7XG4gICAgICAgICAgY29tcG9uZW50cy5wdXNoKCBjdXJyQ29tcCApO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBjb21wID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICB2YXIgbWF4RGVncmVlID0gY29tcC5tYXhEZWdyZWUoIGZhbHNlICk7XG4gICAgICAgICAgdmFyIGNvbXBSb290cyA9IGNvbXAuZmlsdGVyKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWdyZWUoZmFsc2UpID09PSBtYXhEZWdyZWU7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByb290cyA9IHJvb3RzLmFkZCggY29tcFJvb3RzICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgZGVwdGhzID0gW107XG4gICAgdmFyIGZvdW5kQnlCZnMgPSB7fTtcbiAgICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgICB2YXIgcHJldk5vZGUgPSB7fTtcbiAgICB2YXIgcHJldkVkZ2UgPSB7fTtcbiAgICB2YXIgc3VjY2Vzc29ycyA9IHt9O1xuXG4gICAgLy8gZmluZCB0aGUgZGVwdGhzIG9mIHRoZSBub2Rlc1xuICAgIGdyYXBoLmJmcyh7XG4gICAgICByb290czogcm9vdHMsXG4gICAgICBkaXJlY3RlZDogb3B0aW9ucy5kaXJlY3RlZCxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbihpLCBkZXB0aCwgbm9kZSwgZWRnZSwgcE5vZGUpe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgaWYoICFkZXB0aHNbZGVwdGhdICl7XG4gICAgICAgICAgZGVwdGhzW2RlcHRoXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKCBlbGUgKTtcbiAgICAgICAgZm91bmRCeUJmc1sgaWQgXSA9IHRydWU7XG4gICAgICAgIGlkMmRlcHRoWyBpZCBdID0gZGVwdGg7XG4gICAgICAgIHByZXZOb2RlWyBpZCBdID0gcE5vZGU7XG4gICAgICAgIHByZXZFZGdlWyBpZCBdID0gZWRnZTtcblxuICAgICAgICBpZiggcE5vZGUgKXtcbiAgICAgICAgICB2YXIgcHJldklkID0gcE5vZGUuaWQoKTtcbiAgICAgICAgICB2YXIgc3VjYyA9IHN1Y2Nlc3NvcnNbIHByZXZJZCBdID0gc3VjY2Vzc29yc1sgcHJldklkIF0gfHwgW107XG4gICAgICAgICAgXG4gICAgICAgICAgc3VjYy5wdXNoKCBub2RlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZvciBub2RlcyBub3QgZm91bmQgYnkgYmZzXG4gICAgdmFyIG9ycGhhbk5vZGVzID0gW107XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IG5vZGVzW2ldO1xuXG4gICAgICBpZiggZm91bmRCeUJmc1sgZWxlLmlkKCkgXSApe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ycGhhbk5vZGVzLnB1c2goIGVsZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFzc2lnbiBvcnBoYW4gbm9kZXMgYSBkZXB0aCBmcm9tIHRoZWlyIG5laWdoYm9yaG9vZFxuICAgIHZhciBtYXhDaGVja3MgPSBvcnBoYW5Ob2Rlcy5sZW5ndGggKiAzO1xuICAgIHZhciBjaGVja3MgPSAwO1xuICAgIHdoaWxlKCBvcnBoYW5Ob2Rlcy5sZW5ndGggIT09IDAgJiYgY2hlY2tzIDwgbWF4Q2hlY2tzICl7XG4gICAgICB2YXIgbm9kZSA9IG9ycGhhbk5vZGVzLnNoaWZ0KCk7XG4gICAgICB2YXIgbmVpZ2hib3JzID0gbm9kZS5uZWlnaGJvcmhvb2QoKS5ub2RlcygpO1xuICAgICAgdmFyIGFzc2lnbmVkRGVwdGggPSBmYWxzZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIG5laWdoYm9yc1tpXS5pZCgpIF07XG5cbiAgICAgICAgaWYoIGRlcHRoICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBkZXB0aHNbZGVwdGhdLnB1c2goIG5vZGUgKTtcbiAgICAgICAgICBhc3NpZ25lZERlcHRoID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggIWFzc2lnbmVkRGVwdGggKXtcbiAgICAgICAgb3JwaGFuTm9kZXMucHVzaCggbm9kZSApO1xuICAgICAgfVxuXG4gICAgICBjaGVja3MrKztcbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gb3JwaGFuIG5vZGVzIHRoYXQgYXJlIHN0aWxsIGxlZnQgdG8gdGhlIGRlcHRoIG9mIHRoZWlyIHN1YmdyYXBoXG4gICAgd2hpbGUoIG9ycGhhbk5vZGVzLmxlbmd0aCAhPT0gMCApe1xuICAgICAgdmFyIG5vZGUgPSBvcnBoYW5Ob2Rlcy5zaGlmdCgpO1xuICAgICAgLy92YXIgc3ViZ3JhcGggPSBncmFwaC5iZnMoIG5vZGUgKS5wYXRoO1xuICAgICAgdmFyIGFzc2lnbmVkRGVwdGggPSBmYWxzZTtcblxuICAgICAgLy8gZm9yKCB2YXIgaSA9IDA7IGkgPCBzdWJncmFwaC5sZW5ndGg7IGkrKyApe1xuICAgICAgLy8gICB2YXIgZGVwdGggPSBpZDJkZXB0aFsgc3ViZ3JhcGhbaV0uaWQoKSBdO1xuXG4gICAgICAvLyAgIGlmKCBkZXB0aCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAvLyAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKCBub2RlICk7XG4gICAgICAvLyAgICAgYXNzaWduZWREZXB0aCA9IHRydWU7XG4gICAgICAvLyAgICAgYnJlYWs7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cblxuICAgICAgaWYoICFhc3NpZ25lZERlcHRoICl7IC8vIHdvcnN0IGNhc2UgaWYgdGhlIGdyYXBoIHJlYWxseSBpc24ndCB0cmVlIGZyaWVuZGx5LCB0aGVuIGp1c3QgZHVtcCBpdCBpbiAwXG4gICAgICAgIGlmKCBkZXB0aHMubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgZGVwdGhzLnB1c2goW10pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBkZXB0aHNbMF0ucHVzaCggbm9kZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFzc2lnbiB0aGUgbm9kZXMgYSBkZXB0aCBhbmQgaW5kZXhcbiAgICB2YXIgYXNzaWduRGVwdGhzVG9FbGVzID0gZnVuY3Rpb24oKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGVwdGhzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGVzID0gZGVwdGhzW2ldO1xuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2pdO1xuXG4gICAgICAgICAgZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0ID0ge1xuICAgICAgICAgICAgZGVwdGg6IGksXG4gICAgICAgICAgICBpbmRleDogalxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGFzc2lnbkRlcHRoc1RvRWxlcygpO1xuXG5cbiAgICB2YXIgaW50ZXJzZWN0c0RlcHRoID0gZnVuY3Rpb24oIG5vZGUgKXsgLy8gcmV0dXJucyB0cnVlIGlmIGhhcyBlZGdlcyBwb2ludGluZyBpbiBmcm9tIGEgaGlnaGVyIGRlcHRoXG4gICAgICB2YXIgZWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ3RhcmdldCcpID09PSBub2RlLmlkKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciB0aGlzSW5mbyA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICB2YXIgaGlnaGVzdERlcHRoT2ZPdGhlciA9IDA7XG4gICAgICB2YXIgaGlnaGVzdE90aGVyO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgICAgdmFyIG90aGVySW5mbyA9IG90aGVyTm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcblxuICAgICAgICBpZiggdGhpc0luZm8uZGVwdGggPD0gb3RoZXJJbmZvLmRlcHRoICYmIGhpZ2hlc3REZXB0aE9mT3RoZXIgPCBvdGhlckluZm8uZGVwdGggKXtcbiAgICAgICAgICBoaWdoZXN0RGVwdGhPZk90aGVyID0gb3RoZXJJbmZvLmRlcHRoO1xuICAgICAgICAgIGhpZ2hlc3RPdGhlciA9IG90aGVyTm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGlnaGVzdE90aGVyO1xuICAgIH07XG5cbiAgICAgLy8gbWFrZSBtYXhpbWFsIGlmIHNvIHNldCBieSBhZGp1c3RpbmcgZGVwdGhzXG4gICAgZm9yKCB2YXIgYWRqID0gMDsgYWRqIDwgb3B0aW9ucy5tYXhpbWFsQWRqdXN0bWVudHM7IGFkaisrICl7XG5cbiAgICAgIHZhciBuRGVwdGhzID0gZGVwdGhzLmxlbmd0aDtcbiAgICAgIHZhciBlbGVzVG9Nb3ZlID0gW107XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5EZXB0aHM7IGkrKyApe1xuICAgICAgICB2YXIgZGVwdGggPSBkZXB0aHNbaV07XG5cbiAgICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoLmxlbmd0aDtcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBuRGVwdGg7IGorKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBkZXB0aFtqXTtcbiAgICAgICAgICB2YXIgaW5mbyA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgICAgICB2YXIgaW50RWxlID0gaW50ZXJzZWN0c0RlcHRoKGVsZSk7XG5cbiAgICAgICAgICBpZiggaW50RWxlICl7XG4gICAgICAgICAgICBpbmZvLmludEVsZSA9IGludEVsZTtcbiAgICAgICAgICAgIGVsZXNUb01vdmUucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1RvTW92ZS5sZW5ndGg7IGkrKyApeyBcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNUb01vdmVbaV07XG4gICAgICAgIHZhciBpbmZvID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgICB2YXIgaW50RWxlID0gaW5mby5pbnRFbGU7XG4gICAgICAgIHZhciBpbnRJbmZvID0gaW50RWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuXG4gICAgICAgIGRlcHRoc1sgaW5mby5kZXB0aCBdLnNwbGljZSggaW5mby5pbmRleCwgMSApOyAvLyByZW1vdmUgZnJvbSBvbGQgZGVwdGggJiBpbmRleFxuXG4gICAgICAgIC8vIGFkZCB0byBlbmQgb2YgbmV3IGRlcHRoXG4gICAgICAgIHZhciBuZXdEZXB0aCA9IGludEluZm8uZGVwdGggKyAxO1xuICAgICAgICB3aGlsZSggbmV3RGVwdGggPiBkZXB0aHMubGVuZ3RoIC0gMSApe1xuICAgICAgICAgIGRlcHRocy5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aHNbIG5ld0RlcHRoIF0ucHVzaCggZWxlICk7XG5cbiAgICAgICAgaW5mby5kZXB0aCA9IG5ld0RlcHRoO1xuICAgICAgICBpbmZvLmluZGV4ID0gZGVwdGhzW25ld0RlcHRoXS5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICBhc3NpZ25EZXB0aHNUb0VsZXMoKTtcbiAgICB9XG5cbiAgICAvLyBmaW5kIG1pbiBkaXN0YW5jZSB3ZSBuZWVkIHRvIGxlYXZlIGJldHdlZW4gbm9kZXNcbiAgICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuICAgIGlmKCBvcHRpb25zLmF2b2lkT3ZlcmxhcCApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgdyA9IG5vZGVzW2ldLm91dGVyV2lkdGgoKTtcbiAgICAgICAgdmFyIGggPSBub2Rlc1tpXS5vdXRlckhlaWdodCgpO1xuICAgICAgICBcbiAgICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gICAgICB9XG4gICAgICBtaW5EaXN0YW5jZSAqPSBvcHRpb25zLnNwYWNpbmdGYWN0b3I7IC8vIGp1c3QgdG8gaGF2ZSBzb21lIG5pY2Ugc3BhY2luZ1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgd2VpZ2h0ZWQgcGVyY2VudCBmb3IgYW4gZWxlbWVudCBiYXNlZCBvbiBpdHMgY29ubmVjdGl2aXR5IHRvIG90aGVyIGxldmVsc1xuICAgIHZhciBjYWNoZWRXZWlnaHRlZFBlcmNlbnQgPSB7fTtcbiAgICB2YXIgZ2V0V2VpZ2h0ZWRQZXJjZW50ID0gZnVuY3Rpb24oIGVsZSApe1xuICAgICAgaWYoIGNhY2hlZFdlaWdodGVkUGVyY2VudFsgZWxlLmlkKCkgXSApe1xuICAgICAgICByZXR1cm4gY2FjaGVkV2VpZ2h0ZWRQZXJjZW50WyBlbGUuaWQoKSBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlRGVwdGggPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3QuZGVwdGg7XG4gICAgICB2YXIgbmVpZ2hib3JzID0gZWxlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgICB2YXIgcGVyY2VudCA9IDA7XG4gICAgICB2YXIgc2FtcGxlcyA9IDA7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcbiAgICAgICAgdmFyIGJmID0gbmVpZ2hib3IuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICAgIHZhciBpbmRleCA9IGJmLmluZGV4O1xuICAgICAgICB2YXIgZGVwdGggPSBiZi5kZXB0aDtcbiAgICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoc1tkZXB0aF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmKCBlbGVEZXB0aCA+IGRlcHRoIHx8IGVsZURlcHRoID09PSAwICl7IC8vIG9ubHkgZ2V0IGluZmx1ZW5jZWQgYnkgZWxlbWVudHMgYWJvdmVcbiAgICAgICAgICBwZXJjZW50ICs9IGluZGV4IC8gbkRlcHRoO1xuICAgICAgICAgIHNhbXBsZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzYW1wbGVzID0gTWF0aC5tYXgoMSwgc2FtcGxlcyk7XG4gICAgICBwZXJjZW50ID0gcGVyY2VudCAvIHNhbXBsZXM7XG5cbiAgICAgIGlmKCBzYW1wbGVzID09PSAwICl7IC8vIHNvIGxvbmUgbm9kZXMgaGF2ZSBhIFwiZG9uJ3QgY2FyZVwiIHN0YXRlIGluIHNvcnRpbmdcbiAgICAgICAgcGVyY2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50WyBlbGUuaWQoKSBdID0gcGVyY2VudDtcbiAgICAgIHJldHVybiBwZXJjZW50O1xuICAgIH07XG5cblxuICAgIC8vIHJlYXJyYW5nZSB0aGUgaW5kaWNlcyBpbiBlYWNoIGRlcHRoIGxldmVsIGJhc2VkIG9uIGNvbm5lY3Rpdml0eVxuXG4gICAgdmFyIHNvcnRGbiA9IGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgdmFyIGFwY3QgPSBnZXRXZWlnaHRlZFBlcmNlbnQoIGEgKTtcbiAgICAgIHZhciBicGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KCBiICk7XG5cbiAgICAgIHJldHVybiBhcGN0IC0gYnBjdDtcbiAgICB9O1xuXG4gICAgZm9yKCB2YXIgdGltZXMgPSAwOyB0aW1lcyA8IDM7IHRpbWVzKysgKXsgLy8gZG8gaXQgYSBmZXcgdGltZXMgYi9jIHRoZSBkZXB0aHMgYXJlIGR5bmFtaWMgYW5kIHdlIHdhbnQgYSBtb3JlIHN0YWJsZSByZXN1bHRcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgZGVwdGhzW2ldID0gZGVwdGhzW2ldLnNvcnQoIHNvcnRGbiApO1xuICAgICAgfVxuICAgICAgYXNzaWduRGVwdGhzVG9FbGVzKCk7IC8vIGFuZCB1cGRhdGVcblxuICAgIH1cblxuICAgIHZhciBiaWdnZXN0RGVwdGhTaXplID0gMDtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRlcHRocy5sZW5ndGg7IGkrKyApe1xuICAgICAgYmlnZ2VzdERlcHRoU2l6ZSA9IE1hdGgubWF4KCBkZXB0aHNbaV0ubGVuZ3RoLCBiaWdnZXN0RGVwdGhTaXplICk7XG4gICAgfVxuXG4gICAgdmFyIGNlbnRlciA9IHtcbiAgICAgIHg6IGJiLngxICsgYmIudy8yLFxuICAgICAgeTogYmIueDEgKyBiYi5oLzJcbiAgICB9O1xuICAgXG4gICAgdmFyIGdldFBvc2l0aW9uID0gZnVuY3Rpb24oIGVsZSwgaXNCb3R0b21EZXB0aCApe1xuICAgICAgdmFyIGluZm8gPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICB2YXIgZGVwdGggPSBpbmZvLmRlcHRoO1xuICAgICAgdmFyIGluZGV4ID0gaW5mby5pbmRleDtcbiAgICAgIHZhciBkZXB0aFNpemUgPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcblxuICAgICAgdmFyIGRpc3RhbmNlWCA9IE1hdGgubWF4KCBiYi53IC8gKGRlcHRoU2l6ZSArIDEpLCBtaW5EaXN0YW5jZSApO1xuICAgICAgdmFyIGRpc3RhbmNlWSA9IE1hdGgubWF4KCBiYi5oIC8gKGRlcHRocy5sZW5ndGggKyAxKSwgbWluRGlzdGFuY2UgKTtcbiAgICAgIHZhciByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWluKCBiYi53IC8gMiAvIGRlcHRocy5sZW5ndGgsIGJiLmggLyAyIC8gZGVwdGhzLmxlbmd0aCApO1xuICAgICAgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1heCggcmFkaXVzU3RlcFNpemUsIG1pbkRpc3RhbmNlICk7XG5cbiAgICAgIGlmKCAhb3B0aW9ucy5jaXJjbGUgKXtcbiAgICAgICAgXG4gICAgICAgIHZhciBlcG9zID0ge1xuICAgICAgICAgIHg6IGNlbnRlci54ICsgKGluZGV4ICsgMSAtIChkZXB0aFNpemUgKyAxKS8yKSAqIGRpc3RhbmNlWCxcbiAgICAgICAgICB5OiAoZGVwdGggKyAxKSAqIGRpc3RhbmNlWVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBpc0JvdHRvbURlcHRoICl7XG4gICAgICAgICAgcmV0dXJuIGVwb3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgc3VjY3MgPSBzdWNjZXNzb3JzWyBlbGUuaWQoKSBdO1xuICAgICAgICAvLyBpZiggc3VjY3MgKXtcbiAgICAgICAgLy8gICBlcG9zLnggPSAwO1xuICAgICAgICAvLyBcbiAgICAgICAgLy8gICBmb3IoIHZhciBpID0gMCA7IGkgPCBzdWNjcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAvLyAgICAgdmFyIHNwb3MgPSBwb3NbIHN1Y2NzW2ldLmlkKCkgXTtcbiAgICAgICAgLy8gICAgIFxuICAgICAgICAvLyAgICAgZXBvcy54ICs9IHNwb3MueDtcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIFxuICAgICAgICAvLyAgIGVwb3MueCAvPSBzdWNjcy5sZW5ndGg7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgLy9kZWJ1Z2dlcjtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHJldHVybiBlcG9zO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiggb3B0aW9ucy5jaXJjbGUgKXtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gcmFkaXVzU3RlcFNpemUgKiBkZXB0aCArIHJhZGl1c1N0ZXBTaXplIC0gKGRlcHRocy5sZW5ndGggPiAwICYmIGRlcHRoc1swXS5sZW5ndGggPD0gMyA/IHJhZGl1c1N0ZXBTaXplLzIgOiAwKTtcbiAgICAgICAgICB2YXIgdGhldGEgPSAyICogTWF0aC5QSSAvIGRlcHRoc1tkZXB0aF0ubGVuZ3RoICogaW5kZXg7XG5cbiAgICAgICAgICBpZiggZGVwdGggPT09IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA9PT0gMSApe1xuICAgICAgICAgICAgcmFkaXVzID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY2VudGVyLnggKyByYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgICB5OiBjZW50ZXIueSArIHJhZGl1cyAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpLzIpICogZGlzdGFuY2VYLFxuICAgICAgICAgICAgeTogKGRlcHRoICsgMSkgKiBkaXN0YW5jZVlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICB9O1xuXG4gICAgLy8gZ2V0IHBvc2l0aW9ucyBpbiByZXZlcnNlIGRlcHRoIG9yZGVyXG4gICAgdmFyIHBvcyA9IHt9O1xuICAgIGZvciggdmFyIGkgPSBkZXB0aHMubGVuZ3RoIC0gMTsgaSA+PTA7IGktLSApe1xuICAgICAgdmFyIGRlcHRoID0gZGVwdGhzW2ldO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGRlcHRoLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBub2RlID0gZGVwdGhbal07XG5cbiAgICAgICAgcG9zWyBub2RlLmlkKCkgXSA9IGdldFBvc2l0aW9uKCBub2RlLCBpID09PSBkZXB0aHMubGVuZ3RoIC0gMSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHBvc1sgdGhpcy5pZCgpIF07XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ2JyZWFkdGhmaXJzdCcsIEJyZWFkdGhGaXJzdExheW91dCk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIHBhZGRpbmc6IDMwLCAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGFuZCByYWRpdXMgaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIHJhZGl1czogdW5kZWZpbmVkLCAvLyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICBzdGFydEFuZ2xlOiAzLzIgKiBNYXRoLlBJLCAvLyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG5vZGVcbiAgICBjb3VudGVyY2xvY2t3aXNlOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjb3VudGVyY2xvY2t3aXNlICh0cnVlKSBvciBjbG9ja3dpc2UgKGZhbHNlKVxuICAgIHNvcnQ6IHVuZGVmaW5lZCwgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB9O1xuICBcbiAgZnVuY3Rpb24gQ2lyY2xlTGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgQ2lyY2xlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gICAgXG4gICAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgICAgXG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gICAgaWYoIG9wdGlvbnMuc29ydCApe1xuICAgICAgbm9kZXMgPSBub2Rlcy5zb3J0KCBvcHRpb25zLnNvcnQgKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgIH0gKTtcblxuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICB4OiBiYi54MSArIGJiLncvMixcbiAgICAgIHk6IGJiLnkxICsgYmIuaC8yXG4gICAgfTtcbiAgICBcbiAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGU7XG4gICAgdmFyIGRUaGV0YSA9IDIgKiBNYXRoLlBJIC8gbm9kZXMubGVuZ3RoO1xuICAgIHZhciByO1xuXG4gICAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgdyA9IG5vZGVzW2ldLm91dGVyV2lkdGgoKTtcbiAgICAgIHZhciBoID0gbm9kZXNbaV0ub3V0ZXJIZWlnaHQoKTtcbiAgICAgIFxuICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gICAgfVxuXG4gICAgaWYoICQkLmlzLm51bWJlcihvcHRpb25zLnJhZGl1cykgKXtcbiAgICAgIHIgPSBvcHRpb25zLnJhZGl1cztcbiAgICB9IGVsc2UgaWYoIG5vZGVzLmxlbmd0aCA8PSAxICl7XG4gICAgICByID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IE1hdGgubWluKCBiYi5oLCBiYi53ICkvMiAtIG1pbkRpc3RhbmNlO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gICAgaWYoIG5vZGVzLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgICAgbWluRGlzdGFuY2UgKj0gMS43NTsgLy8ganVzdCB0byBoYXZlIHNvbWUgbmljZSBzcGFjaW5nXG5cbiAgICAgIHZhciBkVGhldGEgPSAyICogTWF0aC5QSSAvIG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgICB2YXIgck1pbiA9IE1hdGguc3FydCggbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSAvICggZGNvcypkY29zICsgZHNpbipkc2luICkgKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuICAgICAgciA9IE1hdGgubWF4KCByTWluLCByICk7XG4gICAgfVxuXG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uKCBpLCBlbGUgKXtcbiAgICAgIHZhciByeCA9IHIgKiBNYXRoLmNvcyggdGhldGEgKTtcbiAgICAgIHZhciByeSA9IHIgKiBNYXRoLnNpbiggdGhldGEgKTtcbiAgICAgIHZhciBwb3MgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgcngsXG4gICAgICAgIHk6IGNlbnRlci55ICsgcnlcbiAgICAgIH07XG5cbiAgICAgIHRoZXRhID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlID8gdGhldGEgLSBkVGhldGEgOiB0aGV0YSArIGRUaGV0YTtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcbiAgICBcbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ2NpcmNsZScsIENpcmNsZUxheW91dCk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGFuaW1hdGU6IHRydWUsIC8vIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGF5b3V0IGFzIGl0J3MgcnVubmluZ1xuICAgIHJlZnJlc2g6IDEsIC8vIG51bWJlciBvZiB0aWNrcyBwZXIgZnJhbWU7IGhpZ2hlciBpcyBmYXN0ZXIgYnV0IG1vcmUgamVya3lcbiAgICBtYXhTaW11bGF0aW9uVGltZTogNDAwMCwgLy8gbWF4IGxlbmd0aCBpbiBtcyB0byBydW4gdGhlIGxheW91dFxuICAgIHVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZzogZmFsc2UsIC8vIHNvIHlvdSBjYW4ndCBkcmFnIG5vZGVzIGR1cmluZyBsYXlvdXRcbiAgICBmaXQ6IHRydWUsIC8vIG9uIGV2ZXJ5IGxheW91dCByZXBvc2l0aW9uIG9mIG5vZGVzLCBmaXQgdGhlIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgYXJvdW5kIHRoZSBzaW11bGF0aW9uXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG5cbiAgICAvLyBsYXlvdXQgZXZlbnQgY2FsbGJhY2tzXG4gICAgcmVhZHk6IGZ1bmN0aW9uKCl7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiBmdW5jdGlvbigpe30sIC8vIG9uIGxheW91dHN0b3BcblxuICAgIC8vIHBvc2l0aW9uaW5nIG9wdGlvbnNcbiAgICByYW5kb21pemU6IGZhbHNlLCAvLyB1c2UgcmFuZG9tIG5vZGUgcG9zaXRpb25zIGF0IGJlZ2lubmluZyBvZiBsYXlvdXRcbiAgICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIGlmIHRydWUsIHByZXZlbnRzIG92ZXJsYXAgb2Ygbm9kZSBib3VuZGluZyBib3hlc1xuICAgIGhhbmRsZURpc2Nvbm5lY3RlZDogdHJ1ZSwgLy8gaWYgdHJ1ZSwgYXZvaWRzIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzIGZyb20gb3ZlcmxhcHBpbmdcbiAgICBub2RlU3BhY2luZzogZnVuY3Rpb24oIG5vZGUgKXsgcmV0dXJuIDEwOyB9LCAvLyBleHRyYSBzcGFjaW5nIGFyb3VuZCBub2Rlc1xuICAgIGZsb3c6IHVuZGVmaW5lZCwgLy8gdXNlIERBRy90cmVlIGZsb3cgbGF5b3V0IGlmIHNwZWNpZmllZCwgZS5nLiB7IGF4aXM6ICd5JywgbWluU2VwYXJhdGlvbjogMzAgfVxuICAgIGFsaWdubWVudDogdW5kZWZpbmVkLCAvLyByZWxhdGl2ZSBhbGlnbm1lbnQgY29uc3RyYWludHMgb24gbm9kZXMsIGUuZy4gZnVuY3Rpb24oIG5vZGUgKXsgcmV0dXJuIHsgeDogMCwgeTogMSB9IH1cblxuICAgIC8vIGRpZmZlcmVudCBtZXRob2RzIG9mIHNwZWNpZnlpbmcgZWRnZSBsZW5ndGhcbiAgICAvLyBlYWNoIGNhbiBiZSBhIGNvbnN0YW50IG51bWVyaWNhbCB2YWx1ZSBvciBhIGZ1bmN0aW9uIGxpa2UgYGZ1bmN0aW9uKCBlZGdlICl7IHJldHVybiAyOyB9YFxuICAgIGVkZ2VMZW5ndGg6IHVuZGVmaW5lZCwgLy8gc2V0cyBlZGdlIGxlbmd0aCBkaXJlY3RseSBpbiBzaW11bGF0aW9uXG4gICAgZWRnZVN5bURpZmZMZW5ndGg6IHVuZGVmaW5lZCwgLy8gc3ltbWV0cmljIGRpZmYgZWRnZSBsZW5ndGggaW4gc2ltdWxhdGlvblxuICAgIGVkZ2VKYWNjYXJkTGVuZ3RoOiB1bmRlZmluZWQsIC8vIGphY2NhcmQgZWRnZSBsZW5ndGggaW4gc2ltdWxhdGlvblxuXG4gICAgLy8gaXRlcmF0aW9ucyBvZiBjb2xhIGFsZ29yaXRobTsgdXNlcyBkZWZhdWx0IHZhbHVlcyBvbiB1bmRlZmluZWRcbiAgICB1bmNvbnN0ckl0ZXI6IHVuZGVmaW5lZCwgLy8gdW5jb25zdHJhaW5lZCBpbml0aWFsIGxheW91dCBpdGVyYXRpb25zXG4gICAgdXNlckNvbnN0SXRlcjogdW5kZWZpbmVkLCAvLyBpbml0aWFsIGxheW91dCBpdGVyYXRpb25zIHdpdGggdXNlci1zcGVjaWZpZWQgY29uc3RyYWludHNcbiAgICBhbGxDb25zdEl0ZXI6IHVuZGVmaW5lZCwgLy8gaW5pdGlhbCBsYXlvdXQgaXRlcmF0aW9ucyB3aXRoIGFsbCBjb25zdHJhaW50cyBpbmNsdWRpbmcgbm9uLW92ZXJsYXBcblxuICAgIC8vIGluZmluaXRlIGxheW91dCBvcHRpb25zXG4gICAgaW5maW5pdGU6IGZhbHNlIC8vIG92ZXJyaWRlcyBhbGwgb3RoZXIgb3B0aW9ucyBmb3IgYSBmb3JjZXMtYWxsLXRoZS10aW1lIG1vZGVcbiAgfTtcblxuICAvLyBjb25zdHJ1Y3RvclxuICAvLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAgZnVuY3Rpb24gQ29sYUxheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7IFxuICB9XG5cbiAgLy8gcnVucyB0aGUgbGF5b3V0XG4gIENvbGFMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGxheW91dCA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgXG4gICAgbGF5b3V0Lm1hbnVhbGx5U3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgJCQudXRpbC5yZXF1aXJlKCdjb2xhJywgZnVuY3Rpb24oY29sYSl7XG5cbiAgICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7IC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICAgICAgdmFyIGVkZ2VzID0gZWxlcy5lZGdlcygpO1xuICAgICAgdmFyIHJlYWR5ID0gZmFsc2U7XG4gICAgICBcbiAgICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgICAgfSApO1xuXG4gICAgICB2YXIgZ2V0T3B0VmFsID0gZnVuY3Rpb24oIHZhbCwgZWxlICl7XG4gICAgICAgIGlmKCAkJC5pcy5mbih2YWwpICl7XG4gICAgICAgICAgdmFyIGZuID0gdmFsO1xuICAgICAgICAgIHJldHVybiBmbi5hcHBseSggZWxlLCBbIGVsZSBdICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHVwZGF0ZU5vZGVQb3NpdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgeCA9IHsgbWluOiBJbmZpbml0eSwgbWF4OiAtSW5maW5pdHkgfTtcbiAgICAgICAgdmFyIHkgPSB7IG1pbjogSW5maW5pdHksIG1heDogLUluZmluaXR5IH07XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIHNjcmF0Y2ggPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcblxuICAgICAgICAgIHgubWluID0gTWF0aC5taW4oIHgubWluLCBzY3JhdGNoLnggfHwgMCApO1xuICAgICAgICAgIHgubWF4ID0gTWF0aC5tYXgoIHgubWF4LCBzY3JhdGNoLnggfHwgMCApO1xuXG4gICAgICAgICAgeS5taW4gPSBNYXRoLm1pbiggeS5taW4sIHNjcmF0Y2gueSB8fCAwICk7XG4gICAgICAgICAgeS5tYXggPSBNYXRoLm1heCggeS5tYXgsIHNjcmF0Y2gueSB8fCAwICk7XG4gICAgICAgIH1cblxuICAgICAgICBub2Rlcy5wb3NpdGlvbnMoZnVuY3Rpb24oaSwgbm9kZSl7XG4gICAgICAgICAgdmFyIHNjcmF0Y2ggPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcbiAgICAgICAgICB2YXIgcmV0UG9zO1xuXG4gICAgICAgICAgaWYoICFub2RlLmdyYWJiZWQoKSAmJiAhbm9kZS5pc1BhcmVudCgpICl7XG4gICAgICAgICAgICByZXRQb3MgPSB7XG4gICAgICAgICAgICAgIHg6IGJiLngxICsgc2NyYXRjaC54IC0geC5taW4sXG4gICAgICAgICAgICAgIHk6IGJiLnkxICsgc2NyYXRjaC55IC0geS5taW5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmKCAhJCQuaXMubnVtYmVyKHJldFBvcy54KSB8fCAhJCQuaXMubnVtYmVyKHJldFBvcy55KSApe1xuICAgICAgICAgICAgICByZXRQb3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJldFBvcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbm9kZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTsgLy8gYmVjYXVzZSB0aGUgd2F5IHRoaXMgbGF5b3V0IHNldHMgcG9zaXRpb25zIGlzIGJ1Z2d5IGZvciBzb21lIHJlYXNvbjsgcmVmICM4NzhcblxuICAgICAgICBpZiggIXJlYWR5ICl7XG4gICAgICAgICAgb25SZWFkeSgpO1xuICAgICAgICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBvbkRvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggb3B0aW9ucy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXtcbiAgICAgICAgICBncmFiYmFibGVOb2Rlcy5ncmFiaWZ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2Rlcy5vZmYoJ2dyYWIgZnJlZSBwb3NpdGlvbicsIGdyYWJIYW5kbGVyKTtcbiAgICAgICAgbm9kZXMub2ZmKCdsb2NrIHVubG9jaycsIGxvY2tIYW5kbGVyKTtcblxuICAgICAgICAvLyB0cmlnZ2VyIGxheW91dHN0b3Agd2hlbiB0aGUgbGF5b3V0IHN0b3BzIChlLmcuIGZpbmlzaGVzKVxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9uUmVhZHkgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgdGlja3NQZXJGcmFtZSA9IG9wdGlvbnMucmVmcmVzaDtcbiAgICAgIHZhciB0aWNrU2tpcCA9IDE7IC8vIGZyYW1lcyB1bnRpbCBhIHRpY2s7IHVzZWQgdG8gc2xvdyBkb3duIHNpbSBmb3IgZGVidWdnaW5nXG5cbiAgICAgIGlmKCBvcHRpb25zLnJlZnJlc2ggPCAwICl7XG4gICAgICAgIHRpY2tTa2lwID0gTWF0aC5hYnMoIG9wdGlvbnMucmVmcmVzaCApO1xuICAgICAgICB0aWNrc1BlckZyYW1lID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpY2tzUGVyRnJhbWUgPSBNYXRoLm1heCggMSwgdGlja3NQZXJGcmFtZSApOyAvLyBhdCBsZWFzdCAxXG4gICAgICB9XG5cbiAgICAgIHZhciBhZGFwdG9yID0gbGF5b3V0LmFkYXB0b3IgPSBjb2xhLmFkYXB0b3Ioe1xuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiggZSApeyAvLyBvbiBzaW0gZXZlbnQgICAgICBcbiAgICAgICAgICB2YXIgVElDSyA9IGNvbGEuRXZlbnRUeXBlID8gY29sYS5FdmVudFR5cGUudGljayA6IG51bGw7XG4gICAgICAgICAgdmFyIEVORCA9IGNvbGEuRXZlbnRUeXBlID8gY29sYS5FdmVudFR5cGUuZW5kIDogbnVsbDtcbiAgICAgICAgICBcbiAgICAgICAgICBzd2l0Y2goIGUudHlwZSApe1xuICAgICAgICAgICAgY2FzZSAndGljayc6XG4gICAgICAgICAgICBjYXNlIFRJQ0s6XG4gICAgICAgICAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgICAgICAgICB1cGRhdGVOb2RlUG9zaXRpb25zKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICBjYXNlIEVORDpcbiAgICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucygpO1xuICAgICAgICAgICAgICBpZiggIW9wdGlvbnMuaW5maW5pdGUgKXsgb25Eb25lKCk7IH0gICAgICAgICAgIFxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAga2ljazogZnVuY3Rpb24oKXsgLy8ga2ljayBvZmYgdGhlIHNpbXVsYXRpb25cbiAgICAgICAgICB2YXIgc2tpcCA9IDA7XG5cbiAgICAgICAgICB2YXIgaW5mdGljayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiggbGF5b3V0Lm1hbnVhbGx5U3RvcHBlZCApe1xuICAgICAgICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcmV0ID0gYWRhcHRvci50aWNrKCk7XG5cbiAgICAgICAgICAgIGlmKCByZXQgJiYgb3B0aW9ucy5pbmZpbml0ZSApeyAvLyByZXN1bWUgbGF5b3V0IGlmIGRvbmVcbiAgICAgICAgICAgICAgYWRhcHRvci5yZXN1bWUoKTsgLy8gcmVzdW1lID0+IG5ldyBraWNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiByZXQ7IC8vIGFsbG93IHJlZ3VsYXIgZmluaXNoIGIvYyBvZiBuZXcga2lja1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgbXVsdGl0aWNrID0gZnVuY3Rpb24oKXsgLy8gbXVsdGlwbGUgdGlja3MgaW4gYSByb3dcbiAgICAgICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgICAgIC8vIHNraXAgdGlja3MgdG8gc2xvdyBkb3duIGxheW91dCBmb3IgZGVidWdnaW5nXG4gICAgICAgICAgICAvLyB2YXIgdGhpc1NraXAgPSBza2lwO1xuICAgICAgICAgICAgLy8gc2tpcCA9IChza2lwICsgMSkgJSB0aWNrU2tpcDtcbiAgICAgICAgICAgIC8vIGlmKCB0aGlzU2tpcCAhPT0gMCApe1xuICAgICAgICAgICAgLy8gICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGlja3NQZXJGcmFtZSAmJiAhcmV0OyBpKysgKXtcbiAgICAgICAgICAgICAgcmV0ID0gcmV0IHx8IGluZnRpY2soKTsgLy8gcGljayB1cCB0cnVlIHJldCB2YWxzID0+IHNpbSBkb25lXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCBtdWx0aXRpY2soKSApeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnJhbWUgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICQkLnV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmcmFtZSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSggIWluZnRpY2soKSApe31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb246IGZ1bmN0aW9uKCB0eXBlLCBsaXN0ZW5lciApe30sIC8vIGR1bW15OyBub3QgbmVlZGVkXG5cbiAgICAgICAgZHJhZzogZnVuY3Rpb24oKXt9IC8vIG5vdCBuZWVkZWQgZm9yIG91ciBjYXNlXG4gICAgICB9KTtcbiAgICAgIGxheW91dC5hZGFwdG9yID0gYWRhcHRvcjtcblxuICAgICAgLy8gaWYgc2V0IG5vIGdyYWJiaW5nIGR1cmluZyBsYXlvdXRcbiAgICAgIHZhciBncmFiYmFibGVOb2RlcyA9IG5vZGVzLmZpbHRlcignOmdyYWJiYWJsZScpO1xuICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgIGdyYWJiYWJsZU5vZGVzLnVuZ3JhYmlmeSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgbm9kZSBkcmFnZ2luZ1xuICAgICAgdmFyIGdyYWJIYW5kbGVyO1xuICAgICAgbm9kZXMub24oJ2dyYWIgZnJlZSBwb3NpdGlvbicsIGdyYWJIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciBub2RlID0gdGhpcztcbiAgICAgICAgdmFyIHNjckNvbGEgPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgaWYoIG5vZGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgc2NyQ29sYS54ID0gcG9zLnggLSBiYi54MTtcbiAgICAgICAgICBzY3JDb2xhLnkgPSBwb3MueSAtIGJiLnkxO1xuXG4gICAgICAgICAgYWRhcHRvci5kcmFnc3RhcnQoIHNjckNvbGEgKTtcbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIoc2NyQ29sYS54KSAmJiAkJC5pcy5udW1iZXIoc2NyQ29sYS55KSApe1xuICAgICAgICAgIHBvcy54ID0gc2NyQ29sYS54ICsgYmIueDE7XG4gICAgICAgICAgcG9zLnkgPSBzY3JDb2xhLnkgKyBiYi55MTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCggZS50eXBlICl7XG4gICAgICAgICAgY2FzZSAnZ3JhYic6XG4gICAgICAgICAgICBhZGFwdG9yLmRyYWdzdGFydCggc2NyQ29sYSApO1xuICAgICAgICAgICAgYWRhcHRvci5yZXN1bWUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ZyZWUnOlxuICAgICAgICAgICAgYWRhcHRvci5kcmFnZW5kKCBzY3JDb2xhICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbG9ja0hhbmRsZXI7XG4gICAgICBub2Rlcy5vbignbG9jayB1bmxvY2snLCBsb2NrSGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgIHZhciBzY3JDb2xhID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGE7XG4gICAgICBcbiAgICAgICAgaWYoIG5vZGUubG9ja2VkKCkgKXtcbiAgICAgICAgICBhZGFwdG9yLmRyYWdzdGFydCggc2NyQ29sYSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkYXB0b3IuZHJhZ2VuZCggc2NyQ29sYSApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIG5vbnBhcmVudE5vZGVzID0gbm9kZXMuc3RkRmlsdGVyKGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIHJldHVybiAhbm9kZS5pc1BhcmVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGFkZCBub2RlcyB0byBjb2xhXG4gICAgICBhZGFwdG9yLm5vZGVzKCBub25wYXJlbnROb2Rlcy5tYXAoZnVuY3Rpb24oIG5vZGUsIGkgKXtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBnZXRPcHRWYWwoIG9wdGlvbnMubm9kZVNwYWNpbmcsIG5vZGUgKTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgICAgICB2YXIgc3RydWN0ID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEgPSB7XG4gICAgICAgICAgeDogb3B0aW9ucy5yYW5kb21pemUgPyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIudyApIDogcG9zLngsXG4gICAgICAgICAgeTogb3B0aW9ucy5yYW5kb21pemUgPyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIuaCApIDogcG9zLnksXG4gICAgICAgICAgd2lkdGg6IG5vZGUub3V0ZXJXaWR0aCgpICsgMipwYWRkaW5nLFxuICAgICAgICAgIGhlaWdodDogbm9kZS5vdXRlckhlaWdodCgpICsgMipwYWRkaW5nLFxuICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgIH0pICk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmFsaWdubWVudCApeyAvLyB0aGVuIHNldCBhbGlnbm1lbnQgY29uc3RyYWludHNcblxuICAgICAgICB2YXIgb2Zmc2V0c1ggPSBbXTtcbiAgICAgICAgdmFyIG9mZnNldHNZID0gW107XG5cbiAgICAgICAgbm9ucGFyZW50Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICAgIHZhciBhbGlnbiA9IGdldE9wdFZhbCggb3B0aW9ucy5hbGlnbm1lbnQsIG5vZGUgKTtcbiAgICAgICAgICB2YXIgc2NyQ29sYSA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhO1xuICAgICAgICAgIHZhciBpbmRleCA9IHNjckNvbGEuaW5kZXg7XG5cbiAgICAgICAgICBpZiggIWFsaWduICl7IHJldHVybjsgfVxuXG4gICAgICAgICAgaWYoIGFsaWduLnggIT0gbnVsbCApe1xuICAgICAgICAgICAgb2Zmc2V0c1gucHVzaCh7XG4gICAgICAgICAgICAgIG5vZGU6IGluZGV4LFxuICAgICAgICAgICAgICBvZmZzZXQ6IGFsaWduLnhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBhbGlnbi55ICE9IG51bGwgKXtcbiAgICAgICAgICAgIG9mZnNldHNZLnB1c2goe1xuICAgICAgICAgICAgICBub2RlOiBpbmRleCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBhbGlnbi55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFkZCBhbGlnbm1lbnQgY29uc3RyYWludHMgb24gbm9kZXNcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gW107XG5cbiAgICAgICAgaWYoIG9mZnNldHNYLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdhbGlnbm1lbnQnLFxuICAgICAgICAgICAgYXhpczogJ3gnLFxuICAgICAgICAgICAgb2Zmc2V0czogb2Zmc2V0c1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvZmZzZXRzWS5sZW5ndGggPiAwICl7XG4gICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYWxpZ25tZW50JyxcbiAgICAgICAgICAgIGF4aXM6ICd5JyxcbiAgICAgICAgICAgIG9mZnNldHM6IG9mZnNldHNZXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGFkYXB0b3IuY29uc3RyYWludHMoIGNvbnN0cmFpbnRzICk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGNvbXBvdW5kIG5vZGVzIHRvIGNvbGFcbiAgICAgIGFkYXB0b3IuZ3JvdXBzKCBub2Rlcy5zdGRGaWx0ZXIoZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgcmV0dXJuIG5vZGUuaXNQYXJlbnQoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiggbm9kZSwgaSApeyAvLyBhZGQgYmFzaWMgZ3JvdXAgaW5jbCBsZWFmIG5vZGVzXG4gICAgICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhID0ge1xuICAgICAgICAgIGluZGV4OiBpLFxuXG4gICAgICAgICAgbGVhdmVzOiBub2RlLmRlc2NlbmRhbnRzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKCBjaGlsZCApe1xuICAgICAgICAgICAgcmV0dXJuICFjaGlsZC5pc1BhcmVudCgpO1xuICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiggY2hpbGQgKXtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFswXS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEuaW5kZXg7XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiggbm9kZSApeyAvLyBhZGQgc3ViZ3JvdXBzXG4gICAgICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhLmdyb3VwcyA9IG5vZGUuZGVzY2VuZGFudHMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oIGNoaWxkICl7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkLmlzUGFyZW50KCk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiggY2hpbGQgKXtcbiAgICAgICAgICByZXR1cm4gY2hpbGQuX3ByaXZhdGUuc2NyYXRjaC5jb2xhLmluZGV4O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGE7XG4gICAgICB9KSApO1xuXG4gICAgICAvLyBnZXQgdGhlIGVkZ2UgbGVuZ3RoIHNldHRpbmcgbWVjaGFuaXNtXG4gICAgICB2YXIgbGVuZ3RoO1xuICAgICAgdmFyIGxlbmd0aEZuTmFtZTtcbiAgICAgIGlmKCBvcHRpb25zLmVkZ2VMZW5ndGggIT0gbnVsbCApe1xuICAgICAgICBsZW5ndGggPSBvcHRpb25zLmVkZ2VMZW5ndGg7XG4gICAgICAgIGxlbmd0aEZuTmFtZSA9ICdsaW5rRGlzdGFuY2UnO1xuICAgICAgfSBlbHNlIGlmKCBvcHRpb25zLmVkZ2VTeW1EaWZmTGVuZ3RoICE9IG51bGwgKXtcbiAgICAgICAgbGVuZ3RoID0gb3B0aW9ucy5lZGdlU3ltRGlmZkxlbmd0aDtcbiAgICAgICAgbGVuZ3RoRm5OYW1lID0gJ3N5bW1ldHJpY0RpZmZMaW5rTGVuZ3Rocyc7XG4gICAgICB9IGVsc2UgaWYoIG9wdGlvbnMuZWRnZUphY2NhcmRMZW5ndGggIT0gbnVsbCApe1xuICAgICAgICBsZW5ndGggPSBvcHRpb25zLmVkZ2VKYWNjYXJkTGVuZ3RoO1xuICAgICAgICBsZW5ndGhGbk5hbWUgPSAnamFjY2FyZExpbmtMZW5ndGhzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9IDEwMDtcbiAgICAgICAgbGVuZ3RoRm5OYW1lID0gJ2xpbmtEaXN0YW5jZSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGhHZXR0ZXIgPSBmdW5jdGlvbiggbGluayApe1xuICAgICAgICByZXR1cm4gbGluay5jYWxjTGVuZ3RoO1xuICAgICAgfTtcblxuICAgICAgLy8gYWRkIHRoZSBlZGdlcyB0byBjb2xhXG4gICAgICBhZGFwdG9yLmxpbmtzKCBlZGdlcy5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgICAgcmV0dXJuICFlZGdlLnNvdXJjZSgpLmlzUGFyZW50KCkgJiYgIWVkZ2UudGFyZ2V0KCkuaXNQYXJlbnQoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiggZWRnZSwgaSApe1xuICAgICAgICB2YXIgYyA9IGVkZ2UuX3ByaXZhdGUuc2NyYXRjaC5jb2xhID0ge1xuICAgICAgICAgIHNvdXJjZTogZWRnZS5zb3VyY2UoKVswXS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEuaW5kZXgsXG4gICAgICAgICAgdGFyZ2V0OiBlZGdlLnRhcmdldCgpWzBdLl9wcml2YXRlLnNjcmF0Y2guY29sYS5pbmRleFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBsZW5ndGggIT0gbnVsbCApe1xuICAgICAgICAgIGMuY2FsY0xlbmd0aCA9IGdldE9wdFZhbCggbGVuZ3RoLCBlZGdlICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pICk7XG5cbiAgICAgIGFkYXB0b3Iuc2l6ZShbIGJiLncsIGJiLmggXSk7XG5cbiAgICAgIGlmKCBsZW5ndGggIT0gbnVsbCApe1xuICAgICAgICBhZGFwdG9yWyBsZW5ndGhGbk5hbWUgXSggbGVuZ3RoR2V0dGVyICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB0aGUgZmxvdyBvZiBjb2xhXG4gICAgICBpZiggb3B0aW9ucy5mbG93ICl7XG4gICAgICAgIHZhciBmbG93O1xuICAgICAgICB2YXIgZGVmQXhpcyA9ICd5JztcbiAgICAgICAgdmFyIGRlZk1pblNlcCA9IDUwO1xuXG4gICAgICAgIGlmKCAkJC5pcy5zdHJpbmcob3B0aW9ucy5mbG93KSApe1xuICAgICAgICAgIGZsb3cgPSB7XG4gICAgICAgICAgICBheGlzOiBvcHRpb25zLmZsb3csXG4gICAgICAgICAgICBtaW5TZXBhcmF0aW9uOiBkZWZNaW5TZXBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcihvcHRpb25zLmZsb3cpICl7XG4gICAgICAgICAgZmxvdyA9IHtcbiAgICAgICAgICAgIGF4aXM6IGRlZkF4aXMsXG4gICAgICAgICAgICBtaW5TZXBhcmF0aW9uOiBvcHRpb25zLmZsb3dcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG9wdGlvbnMuZmxvdykgKXtcbiAgICAgICAgICBmbG93ID0gb3B0aW9ucy5mbG93O1xuXG4gICAgICAgICAgZmxvdy5heGlzID0gZmxvdy5heGlzIHx8IGRlZkF4aXM7XG4gICAgICAgICAgZmxvdy5taW5TZXBhcmF0aW9uID0gZmxvdy5taW5TZXBhcmF0aW9uICE9IG51bGwgPyBmbG93Lm1pblNlcGFyYXRpb24gOiBkZWZNaW5TZXA7XG4gICAgICAgIH0gZWxzZSB7IC8vIGUuZy4gb3B0aW9ucy5mbG93OiB0cnVlXG4gICAgICAgICAgZmxvdyA9IHtcbiAgICAgICAgICAgIGF4aXM6IGRlZkF4aXMsXG4gICAgICAgICAgICBtaW5TZXBhcmF0aW9uOiBkZWZNaW5TZXBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgYWRhcHRvci5mbG93TGF5b3V0KCBmbG93LmF4aXMgLCBmbG93Lm1pblNlcGFyYXRpb24gKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgICAgYWRhcHRvclxuICAgICAgICAuYXZvaWRPdmVybGFwcyggb3B0aW9ucy5hdm9pZE92ZXJsYXAgKVxuICAgICAgICAuaGFuZGxlRGlzY29ubmVjdGVkKCBvcHRpb25zLmhhbmRsZURpc2Nvbm5lY3RlZCApXG4gICAgICAgIC5zdGFydCggb3B0aW9ucy51bmNvbnN0ckl0ZXIsIG9wdGlvbnMudXNlckNvbnN0SXRlciwgb3B0aW9ucy5hbGxDb25zdEl0ZXIpXG4gICAgICA7XG5cbiAgICAgIGlmKCAhb3B0aW9ucy5pbmZpbml0ZSApe1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgaWYoICFsYXlvdXQubWFudWFsbHlTdG9wcGVkICl7XG4gICAgICAgICAgICBhZGFwdG9yLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMubWF4U2ltdWxhdGlvblRpbWUpO1xuICAgICAgfVxuXG4gICAgfSk7IC8vIHJlcXVpcmVcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICBDb2xhTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgICBpZiggdGhpcy5hZGFwdG9yICl7XG4gICAgICB0aGlzLm1hbnVhbGx5U3RvcHBlZCA9IHRydWU7XG4gICAgICB0aGlzLmFkYXB0b3Iuc3RvcCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIHJlZ2lzdGVyIHRoZSBsYXlvdXRcbiAgJCQoJ2xheW91dCcsICdjb2xhJywgQ29sYUxheW91dCk7XG5cbn0pKGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgcGFkZGluZzogMzAsIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICAgIHN0YXJ0QW5nbGU6IDMvMiAqIE1hdGguUEksIC8vIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgbm9kZVxuICAgIGNvdW50ZXJjbG9ja3dpc2U6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAodHJ1ZSkgb3IgY2xvY2t3aXNlIChmYWxzZSlcbiAgICBtaW5Ob2RlU3BhY2luZzogMTAsIC8vIG1pbiBzcGFjaW5nIGJldHdlZW4gb3V0c2lkZSBvZiBub2RlcyAodXNlZCBmb3IgcmFkaXVzIGFkanVzdG1lbnQpXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gICAgaGVpZ2h0OiB1bmRlZmluZWQsIC8vIGhlaWdodCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciBoZWlnaHQpXG4gICAgd2lkdGg6IHVuZGVmaW5lZCwgLy8gd2lkdGggb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgd2lkdGgpXG4gICAgY29uY2VudHJpYzogZnVuY3Rpb24obm9kZSl7IC8vIHJldHVybnMgbnVtZXJpYyB2YWx1ZSBmb3IgZWFjaCBub2RlLCBwbGFjaW5nIGhpZ2hlciBub2RlcyBpbiBsZXZlbHMgdG93YXJkcyB0aGUgY2VudHJlXG4gICAgICByZXR1cm4gbm9kZS5kZWdyZWUoKTtcbiAgICB9LFxuICAgIGxldmVsV2lkdGg6IGZ1bmN0aW9uKG5vZGVzKXsgLy8gdGhlIHZhcmlhdGlvbiBvZiBjb25jZW50cmljIHZhbHVlcyBpbiBlYWNoIGxldmVsXG4gICAgICByZXR1cm4gbm9kZXMubWF4RGVncmVlKCkgLyA0O1xuICAgIH0sXG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIENvbmNlbnRyaWNMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBDb25jZW50cmljTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gICAgXG4gICAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICAgIFxuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICBcbiAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgfSApO1xuXG4gICAgdmFyIGNlbnRlciA9IHtcbiAgICAgIHg6IGJiLngxICsgYmIudy8yLFxuICAgICAgeTogYmIueTEgKyBiYi5oLzJcbiAgICB9O1xuICAgIFxuICAgIHZhciBub2RlVmFsdWVzID0gW107IC8vIHsgbm9kZSwgdmFsdWUgfVxuICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZTtcbiAgICB2YXIgbWF4Tm9kZVNpemUgPSAwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIFxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHZhbHVlXG4gICAgICB2YWx1ZSA9IG9wdGlvbnMuY29uY2VudHJpYy5hcHBseShub2RlLCBbIG5vZGUgXSk7XG4gICAgICBub2RlVmFsdWVzLnB1c2goe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG5vZGU6IG5vZGVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBmb3Igc3R5bGUgbWFwcGluZ1xuICAgICAgbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbmNlbnRyaWMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBpbiBjYXNlIHdlIHVzZWQgdGhlIGBjb25jZW50cmljYCBpbiBzdHlsZVxuICAgIG5vZGVzLnVwZGF0ZVN0eWxlKCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgbWF4IHNpemUgbm93IGJhc2VkIG9uIHBvdGVudGlhbGx5IHVwZGF0ZWQgbWFwcGVyc1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgIG1heE5vZGVTaXplID0gTWF0aC5tYXgoIG1heE5vZGVTaXplLCBub2RlLm91dGVyV2lkdGgoKSwgbm9kZS5vdXRlckhlaWdodCgpICk7XG4gICAgfVxuXG4gICAgLy8gc29ydCBub2RlIHZhbHVlcyBpbiBkZXNjcmVhc2luZyBvcmRlclxuICAgIG5vZGVWYWx1ZXMuc29ydChmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTtcbiAgICB9KTtcblxuICAgIHZhciBsZXZlbFdpZHRoID0gb3B0aW9ucy5sZXZlbFdpZHRoKCBub2RlcyApO1xuXG4gICAgLy8gcHV0IHRoZSB2YWx1ZXMgaW50byBsZXZlbHNcbiAgICB2YXIgbGV2ZWxzID0gWyBbXSBdO1xuICAgIHZhciBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbMF07XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2RlVmFsdWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgdmFsID0gbm9kZVZhbHVlc1tpXTtcblxuICAgICAgaWYoIGN1cnJlbnRMZXZlbC5sZW5ndGggPiAwICl7XG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoIGN1cnJlbnRMZXZlbFswXS52YWx1ZSAtIHZhbC52YWx1ZSApO1xuXG4gICAgICAgIGlmKCBkaWZmID49IGxldmVsV2lkdGggKXtcbiAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBbXTtcbiAgICAgICAgICBsZXZlbHMucHVzaCggY3VycmVudExldmVsICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudExldmVsLnB1c2goIHZhbCApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBwb3NpdGlvbnMgZnJvbSBsZXZlbHNcblxuICAgIHZhciBwb3MgPSB7fTsgLy8gaWQgPT4gcG9zaXRpb25cbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIG1pbkRpc3QgPSBtYXhOb2RlU2l6ZSArIG9wdGlvbnMubWluTm9kZVNwYWNpbmc7IC8vIG1pbiBkaXN0IGJldHdlZW4gbm9kZXNcblxuICAgIGlmKCAhb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gdGhlbiBzdHJpY3RseSBjb25zdHJhaW4gdG8gYmJcbiAgICAgIHZhciBmaXJzdEx2bEhhc011bHRpID0gbGV2ZWxzLmxlbmd0aCA+IDAgJiYgbGV2ZWxzWzBdLmxlbmd0aCA+IDE7XG4gICAgICB2YXIgbWF4UiA9ICggTWF0aC5taW4oYmIudywgYmIuaCkgLyAyIC0gbWluRGlzdCApO1xuICAgICAgdmFyIHJTdGVwID0gbWF4UiAvICggbGV2ZWxzLmxlbmd0aCArIGZpcnN0THZsSGFzTXVsdGkgPyAxIDogMCApO1xuXG4gICAgICBtaW5EaXN0ID0gTWF0aC5taW4oIG1pbkRpc3QsIHJTdGVwICk7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgIHZhciBkVGhldGEgPSAyICogTWF0aC5QSSAvIGxldmVsLmxlbmd0aDtcblxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcbiAgICAgIGlmKCBsZXZlbC5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7IC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICAgICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgICAgICB2YXIgck1pbiA9IE1hdGguc3FydCggbWluRGlzdCAqIG1pbkRpc3QgLyAoIGRjb3MqZGNvcyArIGRzaW4qZHNpbiApICk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcbiAgICAgICAgciA9IE1hdGgubWF4KCByTWluLCByICk7XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbGV2ZWwubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHZhbCA9IGxldmVsW2pdO1xuICAgICAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyAob3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlID8gLTEgOiAxKSAqIGRUaGV0YSAqIGo7XG5cbiAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICAgIHk6IGNlbnRlci55ICsgciAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgICB9O1xuXG4gICAgICAgIHBvc1sgdmFsLm5vZGUuaWQoKSBdID0gcDtcbiAgICAgIH1cblxuICAgICAgciArPSBtaW5EaXN0O1xuICAgICAgXG4gICAgfSBcblxuICAgIC8vIHBvc2l0aW9uIHRoZSBub2Rlc1xuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbigpe1xuICAgICAgdmFyIGlkID0gdGhpcy5pZCgpO1xuXG4gICAgICByZXR1cm4gcG9zW2lkXTtcbiAgICB9KTtcbiAgXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ2NvbmNlbnRyaWMnLCBDb25jZW50cmljTGF5b3V0KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbi8qXG4gIFRoZSBDb1NFIGxheW91dCB3YXMgd3JpdHRlbiBieSBHZXJhcmRvIEh1Y2suXG5cbiAgTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiovXG5cbjsoZnVuY3Rpb24oJCQpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBERUJVRztcblxuICAvKipcbiAgICogQGJyaWVmIDogIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAgICovXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICAvLyBDYWxsZWQgb24gYGxheW91dHJlYWR5YFxuICAgIHJlYWR5ICAgICAgICAgICAgICAgOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRzdG9wYFxuICAgIHN0b3AgICAgICAgICAgICAgICAgOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLy8gV2hldGhlciB0byBhbmltYXRlIHdoaWxlIHJ1bm5pbmcgdGhlIGxheW91dFxuICAgIGFuaW1hdGUgICAgICAgICAgICAgOiB0cnVlLFxuXG4gICAgLy8gTnVtYmVyIG9mIGl0ZXJhdGlvbnMgYmV0d2VlbiBjb25zZWN1dGl2ZSBzY3JlZW4gcG9zaXRpb25zIHVwZGF0ZSAoMCAtPiBvbmx5IHVwZGF0ZWQgb24gdGhlIGVuZClcbiAgICByZWZyZXNoICAgICAgICAgICAgIDogNCxcbiAgICBcbiAgICAvLyBXaGV0aGVyIHRvIGZpdCB0aGUgbmV0d29yayB2aWV3IGFmdGVyIHdoZW4gZG9uZVxuICAgIGZpdCAgICAgICAgICAgICAgICAgOiB0cnVlLCBcblxuICAgIC8vIFBhZGRpbmcgb24gZml0XG4gICAgcGFkZGluZyAgICAgICAgICAgICA6IDMwLCBcblxuICAgIC8vIENvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGJvdW5kaW5nQm94ICAgICAgICAgOiB1bmRlZmluZWQsXG5cbiAgICAvLyBXaGV0aGVyIHRvIHJhbmRvbWl6ZSBub2RlIHBvc2l0aW9ucyBvbiB0aGUgYmVnaW5uaW5nXG4gICAgcmFuZG9taXplICAgICAgICAgICA6IHRydWUsXG4gICAgXG4gICAgLy8gV2hldGhlciB0byB1c2UgdGhlIEpTIGNvbnNvbGUgdG8gcHJpbnQgZGVidWcgbWVzc2FnZXNcbiAgICBkZWJ1ZyAgICAgICAgICAgICAgIDogZmFsc2UsXG5cbiAgICAvLyBOb2RlIHJlcHVsc2lvbiAobm9uIG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gICAgbm9kZVJlcHVsc2lvbiAgICAgICA6IDQwMDAwMCxcbiAgICBcbiAgICAvLyBOb2RlIHJlcHVsc2lvbiAob3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgICBub2RlT3ZlcmxhcCAgICAgICAgIDogMTAsXG4gICAgXG4gICAgLy8gSWRlYWwgZWRnZSAobm9uIG5lc3RlZCkgbGVuZ3RoXG4gICAgaWRlYWxFZGdlTGVuZ3RoICAgICA6IDEwLFxuICAgIFxuICAgIC8vIERpdmlzb3IgdG8gY29tcHV0ZSBlZGdlIGZvcmNlc1xuICAgIGVkZ2VFbGFzdGljaXR5ICAgICAgOiAxMDAsXG4gICAgXG4gICAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICAgIG5lc3RpbmdGYWN0b3IgICAgICAgOiA1LCBcbiAgICBcbiAgICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgICBncmF2aXR5ICAgICAgICAgICAgIDogMjUwLCBcbiAgICBcbiAgICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgICBudW1JdGVyICAgICAgICAgICAgIDogMTAwLFxuICAgIFxuICAgIC8vIEluaXRpYWwgdGVtcGVyYXR1cmUgKG1heGltdW0gbm9kZSBkaXNwbGFjZW1lbnQpXG4gICAgaW5pdGlhbFRlbXAgICAgICAgICA6IDIwMCxcbiAgICBcbiAgICAvLyBDb29saW5nIGZhY3RvciAoaG93IHRoZSB0ZW1wZXJhdHVyZSBpcyByZWR1Y2VkIGJldHdlZW4gY29uc2VjdXRpdmUgaXRlcmF0aW9uc1xuICAgIGNvb2xpbmdGYWN0b3IgICAgICAgOiAwLjk1LCBcbiAgICBcbiAgICAvLyBMb3dlciB0ZW1wZXJhdHVyZSB0aHJlc2hvbGQgKGJlbG93IHRoaXMgcG9pbnQgdGhlIGxheW91dCB3aWxsIGVuZClcbiAgICBtaW5UZW1wICAgICAgICAgICAgIDogMS4wXG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmICAgICAgIDogY29uc3RydWN0b3JcbiAgICogQGFyZyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIENvc2VMYXlvdXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7IFxuICB9XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogcnVucyB0aGUgbGF5b3V0XG4gICAqL1xuICBDb3NlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgY3kgICAgICA9IG9wdGlvbnMuY3k7XG4gICAgdmFyIGxheW91dCAgPSB0aGlzO1xuXG4gICAgbGF5b3V0LnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAvLyBTZXQgREVCVUcgLSBHbG9iYWwgdmFyaWFibGVcbiAgICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5kZWJ1Zykge1xuICAgICAgREVCVUcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBERUJVRyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEdldCBzdGFydCB0aW1lXG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIGxheW91dCBpbmZvXG4gICAgdmFyIGxheW91dEluZm8gPSBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpO1xuICAgIFxuICAgIC8vIFNob3cgTGF5b3V0SW5mbyBjb250ZW50cyBpZiBkZWJ1Z2dpbmdcbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIHByaW50TGF5b3V0SW5mbyhsYXlvdXRJbmZvKTtcbiAgICB9XG5cbiAgICAvLyBJZiByZXF1aXJlZCwgcmFuZG9taXplIG5vZGUgcG9zaXRpb25zXG4gICAgaWYgKHRydWUgPT09IG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgICByYW5kb21pemVQb3NpdGlvbnMobGF5b3V0SW5mbywgY3kpO1xuICAgIH1cblxuICAgIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgbWFpbkxvb3AgPSBmdW5jdGlvbihpKXtcbiAgICAgIGlmKCBsYXlvdXQuc3RvcHBlZCApe1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIkxheW91dCBtYW51YWxseSBzdG9wcGVkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gRG8gb25lIHN0ZXAgaW4gdGhlIHBoaXNpY2FsIHNpbXVsYXRpb25cbiAgICAgIHN0ZXAobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMsIGkpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgdGVtcGVyYXR1cmVcbiAgICAgIGxheW91dEluZm8udGVtcGVyYXR1cmUgPSBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlICogb3B0aW9ucy5jb29saW5nRmFjdG9yO1xuICAgICAgLy8gbG9nRGVidWcoXCJOZXcgdGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG5cbiAgICAgIGlmIChsYXlvdXRJbmZvLnRlbXBlcmF0dXJlIDwgb3B0aW9ucy5taW5UZW1wKSB7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiVGVtcGVyYXR1cmUgZHJvcCBiZWxvdyBtaW5pbXVtIHRocmVzaG9sZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcblxuICAgICAgLy8gRml0IHRoZSBncmFwaCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmICh0cnVlID09PSBvcHRpb25zLmZpdCkge1xuICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZXQgZW5kIHRpbWVcbiAgICAgIHZhciBlbmRUaW1lID0gbmV3IERhdGUoKTtcblxuICAgICAgY29uc29sZS5pbmZvKCdMYXlvdXQgdG9vayAnICsgKGVuZFRpbWUgLSBzdGFydFRpbWUpICsgJyBtcycpO1xuXG4gICAgICAvLyBMYXlvdXQgaGFzIGZpbmlzaGVkXG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICB9O1xuXG4gICAgaWYoIG9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGZyYW1lID0gZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgZiA9IDA7XG4gICAgICAgIHZhciBsb29wUmV0O1xuICAgICAgICB3aGlsZSggZiA8IG9wdGlvbnMucmVmcmVzaCAmJiBpIDwgb3B0aW9ucy5udW1JdGVyICl7XG4gICAgICAgICAgdmFyIGxvb3BSZXQgPSBtYWluTG9vcChpKTtcbiAgICAgICAgICBpZiggbG9vcFJldCA9PT0gZmFsc2UgKXsgYnJlYWs7IH1cblxuICAgICAgICAgIGYrKztcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbG9vcFJldCAhPT0gZmFsc2UgJiYgaSArIDEgPCBvcHRpb25zLm51bUl0ZXIgKSB7XG4gICAgICAgICAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZyYW1lICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnJhbWUgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLm51bUl0ZXI7IGkrKykge1xuICAgICAgICBpZiggbWFpbkxvb3AoaSkgPT09IGZhbHNlICl7IGJyZWFrOyB9XG4gICAgICB9XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gICBcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAgICovXG4gIENvc2VMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgICAgIDogQ3JlYXRlcyBhbiBvYmplY3Qgd2hpY2ggaXMgY29udGFpbnMgYWxsIHRoZSBkYXRhXG4gICAqICAgICAgICAgICAgICB1c2VkIGluIHRoZSBsYXlvdXQgcHJvY2Vzc1xuICAgKiBAYXJnIGN5ICAgIDogY3l0b3NjYXBlLmpzIG9iamVjdFxuICAgKiBAcmV0dXJuICAgIDogbGF5b3V0SW5mbyBvYmplY3QgaW5pdGlhbGl6ZWRcbiAgICovXG4gIHZhciBjcmVhdGVMYXlvdXRJbmZvID0gZnVuY3Rpb24oY3ksIGxheW91dCwgb3B0aW9ucykge1xuICAgIC8vIFNob3J0Y3V0XG4gICAgdmFyIGVkZ2VzID0gb3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG4gICAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG5cbiAgICB2YXIgbGF5b3V0SW5mbyAgID0ge1xuICAgICAgbGF5b3V0ICAgICAgIDogbGF5b3V0LFxuICAgICAgbGF5b3V0Tm9kZXMgIDogW10sIFxuICAgICAgaWRUb0luZGV4ICAgIDoge30sXG4gICAgICBub2RlU2l6ZSAgICAgOiBub2Rlcy5zaXplKCksXG4gICAgICBncmFwaFNldCAgICAgOiBbXSxcbiAgICAgIGluZGV4VG9HcmFwaCA6IFtdLCBcbiAgICAgIGxheW91dEVkZ2VzICA6IFtdLFxuICAgICAgZWRnZVNpemUgICAgIDogZWRnZXMuc2l6ZSgpLFxuICAgICAgdGVtcGVyYXR1cmUgIDogb3B0aW9ucy5pbml0aWFsVGVtcCxcbiAgICAgIGNsaWVudFdpZHRoICA6IGN5LndpZHRoKCksXG4gICAgICBjbGllbnRIZWlnaHQgOiBjeS53aWR0aCgpLFxuICAgICAgYm91bmRpbmdCb3ggIDogJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgICAgICAgICAgICAgICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgICAgICAgICAgICAgICAgICB9IClcbiAgICB9OyBcbiAgICBcbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG5vZGVzLCBjcmVhdGluZyBsYXlvdXQgbm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIHRlbXBOb2RlICAgICAgICA9IHt9O1xuICAgICAgdGVtcE5vZGUuaWQgICAgICAgICA9IG5vZGVzW2ldLmRhdGEoJ2lkJyk7XG4gICAgICB0ZW1wTm9kZS5wYXJlbnRJZCAgID0gbm9kZXNbaV0uZGF0YSgncGFyZW50Jyk7ICAgICAgXG4gICAgICB0ZW1wTm9kZS5jaGlsZHJlbiAgID0gW107XG4gICAgICB0ZW1wTm9kZS5wb3NpdGlvblggID0gbm9kZXNbaV0ucG9zaXRpb24oJ3gnKTtcbiAgICAgIHRlbXBOb2RlLnBvc2l0aW9uWSAgPSBub2Rlc1tpXS5wb3NpdGlvbigneScpO1xuICAgICAgdGVtcE5vZGUub2Zmc2V0WCAgICA9IDA7ICAgICAgXG4gICAgICB0ZW1wTm9kZS5vZmZzZXRZICAgID0gMDtcbiAgICAgIHRlbXBOb2RlLmhlaWdodCAgICAgPSBub2Rlc1tpXS5oZWlnaHQoKTtcbiAgICAgIHRlbXBOb2RlLndpZHRoICAgICAgPSBub2Rlc1tpXS53aWR0aCgpO1xuICAgICAgdGVtcE5vZGUubWF4WCAgICAgICA9IHRlbXBOb2RlLnBvc2l0aW9uWCArIHRlbXBOb2RlLndpZHRoICAvIDI7XG4gICAgICB0ZW1wTm9kZS5taW5YICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25YIC0gdGVtcE5vZGUud2lkdGggIC8gMjtcbiAgICAgIHRlbXBOb2RlLm1heFkgICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblkgKyB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgICAgdGVtcE5vZGUubWluWSAgICAgICA9IHRlbXBOb2RlLnBvc2l0aW9uWSAtIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgICB0ZW1wTm9kZS5wYWRMZWZ0ICAgID0gbm9kZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctbGVmdCddLnB4VmFsdWU7XG4gICAgICB0ZW1wTm9kZS5wYWRSaWdodCAgID0gbm9kZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctcmlnaHQnXS5weFZhbHVlO1xuICAgICAgdGVtcE5vZGUucGFkVG9wICAgICA9IG5vZGVzW2ldLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLXRvcCddLnB4VmFsdWU7XG4gICAgICB0ZW1wTm9kZS5wYWRCb3R0b20gID0gbm9kZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10ucHhWYWx1ZTtcbiAgICAgIFxuICAgICAgLy8gQWRkIG5ldyBub2RlXG4gICAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzLnB1c2godGVtcE5vZGUpO1xuICAgICAgLy8gQWRkIGVudHJ5IHRvIGlkLWluZGV4IG1hcFxuICAgICAgbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUuaWRdID0gaTtcbiAgICB9XG5cbiAgICAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIHN0YXJ0ID0gMDsgICAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuICAgIHZhciBlbmQgICA9IC0xOyAgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgICB2YXIgdGVtcEdyYXBoID0gW107XG5cbiAgICAvLyBTZWNvbmQgcGFzcyB0byBhZGQgY2hpbGQgaW5mb3JtYXRpb24gYW5kIFxuICAgIC8vIGluaXRpYWxpemUgcXVldWUgZm9yIGhpZXJhcmNoaWNhbCB0cmF2ZXJzYWxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgdmFyIHBfaWQgPSBuLnBhcmVudElkO1xuICAgICAgLy8gQ2hlY2sgaWYgbm9kZSBuIGhhcyBhIHBhcmVudCBub2RlXG4gICAgICBpZiAobnVsbCAhPSBwX2lkKSB7XG4gICAgICAvLyBBZGQgbm9kZSBJZCB0byBwYXJlbnQncyBsaXN0IG9mIGNoaWxkcmVuXG4gICAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BfaWRdXS5jaGlsZHJlbi5wdXNoKG4uaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGEgbm9kZSBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHRoZW4gaXQncyBpbiB0aGUgcm9vdCBncmFwaFxuICAgICAgcXVldWVbKytlbmRdID0gbi5pZDtcbiAgICAgIHRlbXBHcmFwaC5wdXNoKG4uaWQpOyAgICBcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHJvb3QgZ3JhcGggdG8gZ3JhcGhTZXRcbiAgICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2godGVtcEdyYXBoKTtcblxuICAgIC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsIFxuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICAgIHZhciBub2RlX2lkICA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgICAgdmFyIG5vZGVfaXggID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZV9pZF07XG4gICAgICB2YXIgbm9kZSAgICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVfaXhdO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBBZGQgY2hpbGRyZW4gbm9kZXMgYXMgYSBuZXcgZ3JhcGggdG8gZ3JhcGggc2V0XG4gICAgICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2goY2hpbGRyZW4pO1xuICAgICAgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZSBxdWV1ZSB0byBiZSB2aXNpdGVkXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBpbmRleFRvR3JhcGggbWFwXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7ICAgICAgXG4gICAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncmFwaC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dO1xuICAgICAgbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbaW5kZXhdID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlcywgY3JlYXRpbmcgTGF5b3V0IEVkZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICB2YXIgdGVtcEVkZ2UgPSB7fTsgICAgICBcbiAgICAgIHRlbXBFZGdlLmlkICAgICAgID0gZS5kYXRhKCdpZCcpO1xuICAgICAgdGVtcEVkZ2Uuc291cmNlSWQgPSBlLmRhdGEoJ3NvdXJjZScpO1xuICAgICAgdGVtcEVkZ2UudGFyZ2V0SWQgPSBlLmRhdGEoJ3RhcmdldCcpO1xuXG4gICAgICAvLyBDb21wdXRlIGlkZWFsIGxlbmd0aFxuICAgICAgdmFyIGlkZWFsTGVuZ3RoID0gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7XG5cbiAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gaW50ZXIgZ3JhcGggZWRnZVxuICAgICAgdmFyIHNvdXJjZUl4ICAgID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2Uuc291cmNlSWRdO1xuICAgICAgdmFyIHRhcmdldEl4ICAgID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2UudGFyZ2V0SWRdO1xuICAgICAgdmFyIHNvdXJjZUdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbc291cmNlSXhdO1xuICAgICAgdmFyIHRhcmdldEdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbdGFyZ2V0SXhdO1xuXG4gICAgICBpZiAoc291cmNlR3JhcGggIT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgIC8vIEZpbmQgbG93ZXN0IGNvbW1vbiBncmFwaCBhbmNlc3RvclxuICAgICAgdmFyIGxjYSA9IGZpbmRMQ0EodGVtcEVkZ2Uuc291cmNlSWQsIHRlbXBFZGdlLnRhcmdldElkLCBsYXlvdXRJbmZvKTtcblxuICAgICAgLy8gQ29tcHV0ZSBzdW0gb2Ygbm9kZSBkZXB0aHMsIHJlbGF0aXZlIHRvIGxjYSBncmFwaFxuICAgICAgdmFyIGxjYUdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtsY2FdO1xuICAgICAgdmFyIGRlcHRoICAgID0gMDtcblxuICAgICAgLy8gU291cmNlIGRlcHRoXG4gICAgICB2YXIgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcbiAgICAgIHdoaWxlICgtMSA9PT0gJC5pbkFycmF5KHRlbXBOb2RlLmlkLCBsY2FHcmFwaCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhcmdldCBkZXB0aFxuICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcbiAgICAgIHdoaWxlICgtMSA9PT0gJC5pbkFycmF5KHRlbXBOb2RlLmlkLCBsY2FHcmFwaCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKCdMQ0Egb2Ygbm9kZXMgJyArIHRlbXBFZGdlLnNvdXJjZUlkICsgJyBhbmQgJyArIHRlbXBFZGdlLnRhcmdldElkICsgIFxuICAgICAgICAvLyAgXCIuIEluZGV4OiBcIiArIGxjYSArIFwiIENvbnRlbnRzOiBcIiArIGxjYUdyYXBoLnRvU3RyaW5nKCkgKyBcbiAgICAgICAgLy8gIFwiLiBEZXB0aDogXCIgKyBkZXB0aCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBpZGVhbExlbmd0aFxuICAgICAgaWRlYWxMZW5ndGggKj0gZGVwdGggKiBvcHRpb25zLm5lc3RpbmdGYWN0b3I7XG4gICAgICB9XG5cbiAgICAgIHRlbXBFZGdlLmlkZWFsTGVuZ3RoID0gaWRlYWxMZW5ndGg7XG5cbiAgICAgIGxheW91dEluZm8ubGF5b3V0RWRnZXMucHVzaCh0ZW1wRWRnZSk7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSwgcmV0dXJuIGxheW91dEluZm8gb2JqZWN0XG4gICAgcmV0dXJuIGxheW91dEluZm87XG4gIH07XG5cbiAgXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbG93ZXN0IGNvbW1vbiBcbiAgICogICAgICAgICAgZ3JhcGggYW5jZXN0b3IgYmV0d2VlbiAyIG5vZGVzIGluIHRoZSBzdWJ0cmVlIFxuICAgKiAgICAgICAgICAoZnJvbSB0aGUgZ3JhcGggaGllcmFyY2h5IGluZHVjZWQgdHJlZSkgd2hvc2VcbiAgICogICAgICAgICAgcm9vdCBpcyBncmFwaEl4XG4gICAqXG4gICAqIEBhcmcgbm9kZTE6IG5vZGUxJ3MgSURcbiAgICogQGFyZyBub2RlMjogbm9kZTIncyBJRFxuICAgKiBAYXJnIGxheW91dEluZm86IGxheW91dEluZm8gb2JqZWN0XG4gICAqXG4gICAqL1xuICB2YXIgZmluZExDQSA9IGZ1bmN0aW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbykge1xuICAgIC8vIEZpbmQgdGhlaXIgY29tbW9uIGFuY2VzdGVyLCBzdGFydGluZyBmcm9tIHRoZSByb290IGdyYXBoXG4gICAgdmFyIHJlcyA9IGZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgMCwgbGF5b3V0SW5mbyk7XG4gICAgaWYgKDIgPiByZXMuY291bnQpIHtcbiAgICAgIC8vIElmIGF1eCBmdW5jdGlvbiBjb3VsZG4ndCBmaW5kIHRoZSBjb21tb24gYW5jZXN0ZXIsIFxuICAgICAgLy8gdGhlbiBpdCBpcyB0aGUgcm9vdCBncmFwaFxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXMuZ3JhcGg7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiAgICAgICAgICA6IEF1eGlsaWFyeSBmdW5jdGlvbiB1c2VkIGZvciBMQ0EgY29tcHV0YXRpb25cbiAgICogXG4gICAqIEBhcmcgbm9kZTEgICAgICA6IG5vZGUxJ3MgSURcbiAgICogQGFyZyBub2RlMiAgICAgIDogbm9kZTIncyBJRFxuICAgKiBAYXJnIGdyYXBoSXggICAgOiBzdWJncmFwaCBpbmRleFxuICAgKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIG9iamVjdFxuICAgKlxuICAgKiBAcmV0dXJuICAgICAgICAgOiBvYmplY3Qgb2YgdGhlIGZvcm0ge2NvdW50OiBYLCBncmFwaDogWX0sIHdoZXJlOlxuICAgKiAgICAgICAgICAgICAgICAgICBYIGlzIHRoZSBudW1iZXIgb2YgYW5jZXN0ZXJzIChtYXg6IDIpIGZvdW5kIGluIFxuICAgKiAgICAgICAgICAgICAgICAgICBncmFwaEl4IChhbmQgaXQncyBzdWJncmFwaHMpLFxuICAgKiAgICAgICAgICAgICAgICAgICBZIGlzIHRoZSBncmFwaCBpbmRleCBvZiB0aGUgbG93ZXN0IGdyYXBoIGNvbnRhaW5pbmcgXG4gICAqICAgICAgICAgICAgICAgICAgIGFsbCBYIG5vZGVzXG4gICAqL1xuICB2YXIgZmluZExDQV9hdXggPSBmdW5jdGlvbihub2RlMSwgbm9kZTIsIGdyYXBoSXgsIGxheW91dEluZm8pIHtcbiAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2dyYXBoSXhdO1xuICAgIC8vIElmIGJvdGggbm9kZXMgYmVsb25ncyB0byBncmFwaEl4XG4gICAgaWYgKC0xIDwgJC5pbkFycmF5KG5vZGUxLCBncmFwaCkgJiYgLTEgPCAkLmluQXJyYXkobm9kZTIsIGdyYXBoKSkge1xuICAgICAgcmV0dXJuIHtjb3VudDoyLCBncmFwaDpncmFwaEl4fTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHJlY3Vyc2l2ZSBjYWxscyBmb3IgYWxsIHN1YmdyYXBoc1xuICAgIHZhciBjID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZUlkICAgPSBncmFwaFtpXTtcbiAgICAgIHZhciBub2RlSXggICA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgICB2YXIgY2hpbGRyZW4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVJeF0uY2hpbGRyZW47XG5cbiAgICAgIC8vIElmIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgc2tpcCBpdFxuICAgICAgaWYgKDAgPT09IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZEdyYXBoSXggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlblswXV1dO1xuICAgICAgdmFyIHJlc3VsdCA9IGZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgY2hpbGRHcmFwaEl4LCBsYXlvdXRJbmZvKTtcbiAgICAgIGlmICgwID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgIC8vIE5laXRoZXIgbm9kZTEgbm9yIG5vZGUyIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICgxID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgIC8vIE9uZSBvZiAobm9kZTEsIG5vZGUyKSBpcyBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGMrKztcbiAgICAgIGlmICgyID09PSBjKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgZm91bmQgYm90aCBub2Rlcywgbm8gbmVlZCB0byBrZWVwIHNlYXJjaGluZ1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIG5vZGVzIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9ICAgICAgXG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7Y291bnQ6YywgZ3JhcGg6Z3JhcGhJeH07XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmOiBwcmludHNMYXlvdXRJbmZvIGludG8ganMgY29uc29sZVxuICAgKiAgICAgICAgIE9ubHkgdXNlZCBmb3IgZGViYnVnaW5nIFxuICAgKi9cbiAgdmFyIHByaW50TGF5b3V0SW5mbyA9IGZ1bmN0aW9uKGxheW91dEluZm8pIHtcbiAgICBpZiAoIURFQlVHKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUuZGVidWcoXCJsYXlvdXROb2RlczpcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgIHZhciBzID0gXG4gICAgICBcIlxcbmluZGV4OiBcIiAgICAgKyBpICsgXG4gICAgICBcIlxcbklkOiBcIiAgICAgICAgKyBuLmlkICsgXG4gICAgICBcIlxcbkNoaWxkcmVuOiBcIiAgKyBuLmNoaWxkcmVuLnRvU3RyaW5nKCkgKyAgXG4gICAgICBcIlxcbnBhcmVudElkOiBcIiAgKyBuLnBhcmVudElkICArIFxuICAgICAgXCJcXG5wb3NpdGlvblg6IFwiICsgbi5wb3NpdGlvblggKyBcbiAgICAgIFwiXFxucG9zaXRpb25ZOiBcIiArIG4ucG9zaXRpb25ZICtcbiAgICAgIFwiXFxuT2Zmc2V0WDogXCIgKyBuLm9mZnNldFggKyBcbiAgICAgIFwiXFxuT2Zmc2V0WTogXCIgKyBuLm9mZnNldFkgKyBcbiAgICAgIFwiXFxucGFkTGVmdDogXCIgKyBuLnBhZExlZnQgKyBcbiAgICAgIFwiXFxucGFkUmlnaHQ6IFwiICsgbi5wYWRSaWdodCArIFxuICAgICAgXCJcXG5wYWRUb3A6IFwiICsgbi5wYWRUb3AgKyBcbiAgICAgIFwiXFxucGFkQm90dG9tOiBcIiArIG4ucGFkQm90dG9tO1xuXG4gICAgICBjb25zb2xlLmRlYnVnKHMpOyAgICBcbiAgICB9ICBcbiAgICBcbiAgICBjb25zb2xlLmRlYnVnKCdpZFRvSW5kZXgnKTtcbiAgICBmb3IgKHZhciBpIGluIGxheW91dEluZm8uaWRUb0luZGV4KSB7XG4gICAgICBjb25zb2xlLmRlYnVnKFwiSWQ6IFwiICsgaSArIFwiXFxuSW5kZXg6IFwiICsgbGF5b3V0SW5mby5pZFRvSW5kZXhbaV0pO1xuICAgIH1cblxuICAgIGNvbnNvbGUuZGVidWcoJ0dyYXBoIFNldCcpO1xuICAgIHZhciBzZXQgPSBsYXlvdXRJbmZvLmdyYXBoU2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSArKykge1xuICAgICAgY29uc29sZS5kZWJ1ZyhcIlNldCA6IFwiICsgaSArIFwiOiBcIiArIHNldFtpXS50b1N0cmluZygpKTtcbiAgICB9IFxuXG4gICAgdmFyIHMgPSAnSW5kZXhUb0dyYXBoJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uaW5kZXhUb0dyYXBoLmxlbmd0aDsgaSArKykge1xuICAgICAgcyArPSBcIlxcbkluZGV4IDogXCIgKyBpICsgXCIgR3JhcGg6IFwiKyBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtpXTtcbiAgICB9XG4gICAgY29uc29sZS5kZWJ1ZyhzKTtcblxuICAgIHMgPSAnTGF5b3V0IEVkZ2VzJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubGF5b3V0RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlID0gbGF5b3V0SW5mby5sYXlvdXRFZGdlc1tpXTtcbiAgICAgIHMgKz0gXCJcXG5FZGdlIEluZGV4OiBcIiArIGkgKyBcIiBJRDogXCIgKyBlLmlkICsgXG4gICAgICBcIiBTb3VjZUlEOiBcIiArIGUuc291cmNlSWQgKyBcIiBUYXJnZXRJZDogXCIgKyBlLnRhcmdldElkICsgXG4gICAgICBcIiBJZGVhbCBMZW5ndGg6IFwiICsgZS5pZGVhbExlbmd0aDtcbiAgICB9XG4gICAgY29uc29sZS5kZWJ1ZyhzKTtcblxuICAgIHMgPSAgXCJub2RlU2l6ZTogXCIgKyBsYXlvdXRJbmZvLm5vZGVTaXplO1xuICAgIHMgKz0gXCJcXG5lZGdlU2l6ZTogXCIgKyBsYXlvdXRJbmZvLmVkZ2VTaXplO1xuICAgIHMgKz0gXCJcXG50ZW1wZXJhdHVyZTogXCIgKyBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlO1xuICAgIGNvbnNvbGUuZGVidWcocyk7XG5cbiAgICByZXR1cm47XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogUmFuZG9taXplcyB0aGUgcG9zaXRpb24gb2YgYWxsIG5vZGVzXG4gICAqL1xuICB2YXIgcmFuZG9taXplUG9zaXRpb25zID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3kpIHtcbiAgICB2YXIgd2lkdGggICAgID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aDtcbiAgICB2YXIgaGVpZ2h0ICAgID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgLy8gTm8gbmVlZCB0byByYW5kb21pemUgY29tcG91bmQgbm9kZXNcbiAgICAgIGlmICh0cnVlIHx8IDAgPT09IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIG4ucG9zaXRpb25YID0gTWF0aC5yYW5kb20oKSAqIHdpZHRoO1xuICAgICAgICBuLnBvc2l0aW9uWSA9IE1hdGgucmFuZG9tKCkgKiBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFxuICAvKipcbiAgICogQGJyaWVmICAgICAgICAgIDogVXBkYXRlcyB0aGUgcG9zaXRpb25zIG9mIG5vZGVzIGluIHRoZSBuZXR3b3JrXG4gICAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0XG4gICAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICovXG4gIHZhciByZWZyZXNoUG9zaXRpb25zID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHsgIFxuICAgIC8vIHZhciBzID0gJ1JlZnJlc2hpbmcgcG9zaXRpb25zJztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIHZhciBsYXlvdXQgPSBsYXlvdXRJbmZvLmxheW91dDtcbiAgICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgICB2YXIgYmIgPSBsYXlvdXRJbmZvLmJvdW5kaW5nQm94O1xuICAgIHZhciBjb3NlQkIgPSB7IHgxOiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTE6IEluZmluaXR5LCB5MjogLUluZmluaXR5IH07XG4gICAgXG4gICAgaWYoIG9wdGlvbnMuYm91bmRpbmdCb3ggKXtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlLmRhdGEoJ2lkJyldXTtcblxuICAgICAgICBjb3NlQkIueDEgPSBNYXRoLm1pbiggY29zZUJCLngxLCBsbm9kZS5wb3NpdGlvblggKTtcbiAgICAgICAgY29zZUJCLngyID0gTWF0aC5tYXgoIGNvc2VCQi54MiwgbG5vZGUucG9zaXRpb25YICk7XG5cbiAgICAgICAgY29zZUJCLnkxID0gTWF0aC5taW4oIGNvc2VCQi55MSwgbG5vZGUucG9zaXRpb25ZICk7XG4gICAgICAgIGNvc2VCQi55MiA9IE1hdGgubWF4KCBjb3NlQkIueTIsIGxub2RlLnBvc2l0aW9uWSApO1xuICAgICAgfSk7XG5cbiAgICAgIGNvc2VCQi53ID0gY29zZUJCLngyIC0gY29zZUJCLngxO1xuICAgICAgY29zZUJCLmggPSBjb3NlQkIueTIgLSBjb3NlQkIueTE7XG4gICAgfVxuXG4gICAgbm9kZXMucG9zaXRpb25zKGZ1bmN0aW9uKGksIGVsZSkge1xuICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtlbGUuZGF0YSgnaWQnKV1dO1xuICAgICAgLy8gcyA9IFwiTm9kZTogXCIgKyBsbm9kZS5pZCArIFwiLiBSZWZyZXNoZWQgcG9zaXRpb246IChcIiArIFxuICAgICAgLy8gbG5vZGUucG9zaXRpb25YICsgXCIsIFwiICsgbG5vZGUucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmJvdW5kaW5nQm94ICl7IC8vIHRoZW4gYWRkIGV4dHJhIGJvdW5kaW5nIGJveCBjb25zdHJhaW50XG4gICAgICAgIHZhciBwY3RYID0gKGxub2RlLnBvc2l0aW9uWCAtIGNvc2VCQi54MSkgLyBjb3NlQkIudztcbiAgICAgICAgdmFyIHBjdFkgPSAobG5vZGUucG9zaXRpb25ZIC0gY29zZUJCLnkxKSAvIGNvc2VCQi5oO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogYmIueDEgKyBwY3RYICogYmIudyxcbiAgICAgICAgICB5OiBiYi55MSArIHBjdFkgKiBiYi5oXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGxub2RlLnBvc2l0aW9uWCxcbiAgICAgICAgICB5OiBsbm9kZS5wb3NpdGlvbllcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRyaWdnZXIgbGF5b3V0UmVhZHkgb25seSBvbiBmaXJzdCBjYWxsXG4gICAgaWYgKHRydWUgIT09IGxheW91dEluZm8ucmVhZHkpIHtcbiAgICAgIC8vIHMgPSAnVHJpZ2dlcmluZyBsYXlvdXRyZWFkeSc7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIGxheW91dEluZm8ucmVhZHkgPSB0cnVlO1xuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiB0aGlzIH0pO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgICAgOiBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRoZSBwaHlzaWNhbCBzaW11bGF0aW9uXG4gICAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICAgKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICAgKi9cbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucywgc3RlcCkgeyAgXG4gICAgLy8gdmFyIHMgPSBcIlxcblxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcIjtcbiAgICAvLyBzICs9IFwiXFxuU1RFUDogXCIgKyBzdGVwO1xuICAgIC8vIHMgKz0gXCJcXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXFxuXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAvLyBDYWxjdWxhdGUgbm9kZSByZXB1bHNpb25zXG4gICAgY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gICAgLy8gQ2FsY3VsYXRlIGVkZ2UgZm9yY2VzXG4gICAgY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gICAgLy8gQ2FsY3VsYXRlIGdyYXZpdHkgZm9yY2VzXG4gICAgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gICAgLy8gUHJvcGFnYXRlIGZvcmNlcyBmcm9tIHBhcmVudCB0byBjaGlsZFxuICAgIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gICAgLy8gVXBkYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiBjYWxjdWxhdGVkIGZvcmNlc1xuICAgIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDb21wdXRlcyB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzXG4gICAqL1xuICB2YXIgY2FsY3VsYXRlTm9kZUZvcmNlcyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gICAgLy8gR28gdGhyb3VnaCBlYWNoIG9mIHRoZSBncmFwaHMgaW4gZ3JhcGhTZXRcbiAgICAvLyBOb2RlcyBvbmx5IHJlcGVsIGVhY2ggb3RoZXIgaWYgdGhleSBiZWxvbmcgdG8gdGhlIHNhbWUgZ3JhcGhcbiAgICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVOb2RlRm9yY2VzJztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpICsrKSB7XG4gICAgICB2YXIgZ3JhcGggICAgPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoO1xuXG4gICAgICAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAvLyBOb3cgZ2V0IGFsbCB0aGUgcGFpcnMgb2Ygbm9kZXMgXG4gICAgICAvLyBPbmx5IGdldCBlYWNoIHBhaXIgb25jZSwgKEEsIEIpID0gKEIsIEEpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgIHZhciBub2RlMSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcbiAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IG51bU5vZGVzOyBrKyspIHtcbiAgICAgICAgdmFyIG5vZGUyID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtrXV1dO1xuICAgICAgICBub2RlUmVwdWxzaW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICAgICAgfSBcbiAgICAgIH1cbiAgICB9IFxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IENvbXB1dGUgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGEgcGFpciBvZiBub2Rlc1xuICAgKi9cbiAgdmFyIG5vZGVSZXB1bHNpb24gPSBmdW5jdGlvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gICAgLy8gdmFyIHMgPSBcIk5vZGUgcmVwdWxzaW9uLiBOb2RlMTogXCIgKyBub2RlMS5pZCArIFwiIE5vZGUyOiBcIiArIG5vZGUyLmlkO1xuXG4gICAgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcbiAgICB2YXIgZGlyZWN0aW9uWCA9IG5vZGUyLnBvc2l0aW9uWCAtIG5vZGUxLnBvc2l0aW9uWDtcbiAgICB2YXIgZGlyZWN0aW9uWSA9IG5vZGUyLnBvc2l0aW9uWSAtIG5vZGUxLnBvc2l0aW9uWTtcbiAgICAvLyBzICs9IFwiXFxuZGlyZWN0aW9uWDogXCIgKyBkaXJlY3Rpb25YICsgXCIsIGRpcmVjdGlvblk6IFwiICsgZGlyZWN0aW9uWTtcblxuICAgIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGFwcGx5IGEgcmFuZG9tIGZvcmNlXG4gICAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIGhhdmUgdGhlIHNhbWUgcG9zaXRpb24uXCI7XG4gICAgICByZXR1cm47IC8vIFRPRE9cbiAgICB9XG5cbiAgICB2YXIgb3ZlcmxhcCA9IG5vZGVzT3ZlcmxhcChub2RlMSwgbm9kZTIsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgIFxuICAgIGlmIChvdmVybGFwID4gMCkge1xuICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIERPIG92ZXJsYXAuXCI7XG4gICAgICAvLyBzICs9IFwiXFxuT3ZlcmxhcDogXCIgKyBvdmVybGFwO1xuICAgICAgLy8gSWYgbm9kZXMgb3ZlcmxhcCwgcmVwdWxzaW9uIGZvcmNlIGlzIHByb3BvcnRpb25hbCBcbiAgICAgIC8vIHRvIHRoZSBvdmVybGFwXG4gICAgICB2YXIgZm9yY2UgICAgPSBvcHRpb25zLm5vZGVPdmVybGFwICogb3ZlcmxhcDtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcbiAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXJlY3Rpb25YICogZGlyZWN0aW9uWCArIGRpcmVjdGlvblkgKiBkaXJlY3Rpb25ZKTtcbiAgICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcbiAgICAgIHZhciBmb3JjZVggICA9IGZvcmNlICogZGlyZWN0aW9uWCAvIGRpc3RhbmNlO1xuICAgICAgdmFyIGZvcmNlWSAgID0gZm9yY2UgKiBkaXJlY3Rpb25ZIC8gZGlzdGFuY2U7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIGRvIE5PVCBvdmVybGFwLlwiO1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBvdmVybGFwLCBmb3JjZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIFxuICAgICAgLy8gdG8gc3F1YXJlZCBkaXN0YW5jZVxuXG4gICAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTEsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUyLCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG5cbiAgICAgIC8vIFVzZSBjbGlwcGluZyBwb2ludHMgdG8gY29tcHV0ZSBkaXN0YW5jZVxuICAgICAgdmFyIGRpc3RhbmNlWCAgID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgIHZhciBkaXN0YW5jZVkgICA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgICB2YXIgZGlzdGFuY2VTcXIgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgICB2YXIgZGlzdGFuY2UgICAgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXIpO1xuICAgICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuICAgICAgdmFyIGZvcmNlICA9IG9wdGlvbnMubm9kZVJlcHVsc2lvbiAvIGRpc3RhbmNlU3FyO1xuICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogZGlzdGFuY2VYIC8gZGlzdGFuY2U7XG4gICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBkaXN0YW5jZVkgLyBkaXN0YW5jZTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBmb3JjZVxuICAgIG5vZGUxLm9mZnNldFggLT0gZm9yY2VYO1xuICAgIG5vZGUxLm9mZnNldFkgLT0gZm9yY2VZO1xuICAgIG5vZGUyLm9mZnNldFggKz0gZm9yY2VYO1xuICAgIG5vZGUyLm9mZnNldFkgKz0gZm9yY2VZO1xuXG4gICAgLy8gcyArPSBcIlxcbkZvcmNlWDogXCIgKyBmb3JjZVggKyBcIiBGb3JjZVk6IFwiICsgZm9yY2VZO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgcmV0dXJuO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IEZpbmRzIHRoZSBwb2ludCBpbiB3aGljaCBhbiBlZGdlIChkaXJlY3Rpb24gZFgsIGRZKSBpbnRlcnNlY3RzIFxuICAgKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlIFxuICAgKi9cbiAgdmFyIGZpbmRDbGlwcGluZ1BvaW50ID0gZnVuY3Rpb24obm9kZSwgZFgsIGRZKSB7XG5cbiAgICAvLyBTaG9yY3V0c1xuICAgIHZhciBYID0gbm9kZS5wb3NpdGlvblg7XG4gICAgdmFyIFkgPSBub2RlLnBvc2l0aW9uWTtcbiAgICB2YXIgSCA9IG5vZGUuaGVpZ2h0O1xuICAgIHZhciBXID0gbm9kZS53aWR0aDtcbiAgICB2YXIgZGlyU2xvcGUgICAgID0gZFkgLyBkWDtcbiAgICB2YXIgbm9kZVNsb3BlICAgID0gSCAvIFc7XG5cbiAgICAvLyB2YXIgcyA9ICdDb21wdXRpbmcgY2xpcHBpbmcgcG9pbnQgb2Ygbm9kZSAnICsgbm9kZS5pZCArIFxuICAgIC8vICAgXCIgLiBIZWlnaHQ6ICBcIiArIEggKyBcIiwgV2lkdGg6IFwiICsgVyArIFxuICAgIC8vICAgXCJcXG5EaXJlY3Rpb24gXCIgKyBkWCArIFwiLCBcIiArIGRZOyBcbiAgICAvLyBcbiAgICAvLyBDb21wdXRlIGludGVyc2VjdGlvblxuICAgIHZhciByZXMgPSB7fTtcbiAgICBkbyB7XG4gICAgICAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKHVwKVxuICAgICAgaWYgKDAgPT09IGRYICYmIDAgPCBkWSkge1xuICAgICAgICByZXMueCA9IFg7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5VcCBkaXJlY3Rpb25cIjtcbiAgICAgICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKGRvd24pXG4gICAgICBpZiAoMCA9PT0gZFggJiYgMCA+IGRZKSB7XG4gICAgICAgIHJlcy54ID0gWDtcbiAgICAgICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5Eb3duIGRpcmVjdGlvblwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gICAgICBcblxuICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgcmlnaHQgYm9yZGVyXG4gICAgICBpZiAoMCA8IGRYICYmIFxuICAgICAgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgXG4gICAgICBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICAgICAgcmVzLnggPSBYICsgVyAvIDI7XG4gICAgICAgIHJlcy55ID0gWSArIChXICogZFkgLyAyIC8gZFgpO1xuICAgICAgICAvLyBzICs9IFwiXFxuUmlnaHRib3JkZXJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGxlZnQgYm9yZGVyXG4gICAgICBpZiAoMCA+IGRYICYmIFxuICAgICAgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgXG4gICAgICBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICAgICAgcmVzLnggPSBYIC0gVyAvIDI7XG4gICAgICAgIHJlcy55ID0gWSAtIChXICogZFkgLyAyIC8gZFgpO1xuICAgICAgICAvLyBzICs9IFwiXFxuTGVmdGJvcmRlclwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgdG9wIGJvcmRlclxuICAgICAgaWYgKDAgPCBkWSAmJiBcbiAgICAgICggZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHxcbiAgICAgICAgZGlyU2xvcGUgPj0gbm9kZVNsb3BlICkpIHtcbiAgICAgICAgcmVzLnggPSBYICsgKEggKiBkWCAvIDIgLyBkWSk7XG4gICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICAvLyBzICs9IFwiXFxuVG9wIGJvcmRlclwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgYm90dG9tIGJvcmRlclxuICAgICAgaWYgKDAgPiBkWSAmJiBcbiAgICAgICggZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHxcbiAgICAgICAgZGlyU2xvcGUgPj0gbm9kZVNsb3BlICkpIHtcbiAgICAgICAgcmVzLnggPSBYIC0gKEggKiBkWCAvIDIgLyBkWSk7XG4gICAgICAgIHJlcy55ID0gWSAtIEggLyAyO1xuICAgICAgICAvLyBzICs9IFwiXFxuQm90dG9tIGJvcmRlclwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH0gd2hpbGUgKGZhbHNlKTtcblxuICAgIC8vIHMgKz0gXCJcXG5DbGlwcGluZyBwb2ludCBmb3VuZCBhdCBcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnk7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgIDogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBub2RlcyBvdmVybGFwIG9yIG5vdFxuICAgKiBAcmV0dXJuIDogQW1vdW50IG9mIG92ZXJsYXBwaW5nICgwID0+IG5vIG92ZXJsYXApXG4gICAqL1xuICB2YXIgbm9kZXNPdmVybGFwID0gZnVuY3Rpb24obm9kZTEsIG5vZGUyLCBkWCwgZFkpIHtcblxuICAgIGlmIChkWCA+IDApIHtcbiAgICAgIHZhciBvdmVybGFwWCA9IG5vZGUxLm1heFggLSBub2RlMi5taW5YO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3ZlcmxhcFggPSBub2RlMi5tYXhYIC0gbm9kZTEubWluWDtcbiAgICB9XG5cbiAgICBpZiAoZFkgPiAwKSB7XG4gICAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMS5tYXhZIC0gbm9kZTIubWluWTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG92ZXJsYXBZID0gbm9kZTIubWF4WSAtIG5vZGUxLm1pblk7XG4gICAgfVxuXG4gICAgaWYgKG92ZXJsYXBYID49IDAgJiYgb3ZlcmxhcFkgPj0gMCkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydChvdmVybGFwWCAqIG92ZXJsYXBYICsgb3ZlcmxhcFkgKiBvdmVybGFwWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcbiAgICBcbiAgXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDYWxjdWxhdGVzIGFsbCBlZGdlIGZvcmNlc1xuICAgKi9cbiAgdmFyIGNhbGN1bGF0ZUVkZ2VGb3JjZXMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgICAgLy8gR2V0IGVkZ2UsIHNvdXJjZSAmIHRhcmdldCBub2Rlc1xuICAgICAgdmFyIGVkZ2UgICAgID0gbGF5b3V0SW5mby5sYXlvdXRFZGdlc1tpXTtcbiAgICAgIHZhciBzb3VyY2VJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2Uuc291cmNlSWRdO1xuICAgICAgdmFyIHNvdXJjZSAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG4gICAgICB2YXIgdGFyZ2V0SXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtlZGdlLnRhcmdldElkXTtcbiAgICAgIHZhciB0YXJnZXQgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbdGFyZ2V0SXhdO1xuXG4gICAgICAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuICAgICAgdmFyIGRpcmVjdGlvblggPSB0YXJnZXQucG9zaXRpb25YIC0gc291cmNlLnBvc2l0aW9uWDtcbiAgICAgIHZhciBkaXJlY3Rpb25ZID0gdGFyZ2V0LnBvc2l0aW9uWSAtIHNvdXJjZS5wb3NpdGlvblk7XG4gICAgICBcbiAgICAgIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGRvIG5vdGhpbmcuXG4gICAgICAvLyBBIHJhbmRvbSBmb3JjZSBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYXMgbm9kZSByZXB1bHNpb25cbiAgICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KHNvdXJjZSwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG4gICAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQodGFyZ2V0LCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG5cblxuICAgICAgdmFyIGx4ID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgIHZhciBseSA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgICB2YXIgbCAgPSBNYXRoLnNxcnQobHggKiBseCArIGx5ICogbHkpO1xuXG4gICAgICB2YXIgZm9yY2UgID0gTWF0aC5wb3coZWRnZS5pZGVhbExlbmd0aCAtIGwsIDIpIC8gb3B0aW9ucy5lZGdlRWxhc3RpY2l0eTsgXG5cbiAgICAgIGlmICgwICE9PSBsKSB7XG4gICAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGx4IC8gbDtcbiAgICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogbHkgLyBsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZvcmNlWCA9IDA7XG4gICAgICAgIHZhciBmb3JjZVkgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhpcyBmb3JjZSB0byB0YXJnZXQgYW5kIHNvdXJjZSBub2Rlc1xuICAgICAgc291cmNlLm9mZnNldFggKz0gZm9yY2VYO1xuICAgICAgc291cmNlLm9mZnNldFkgKz0gZm9yY2VZO1xuICAgICAgdGFyZ2V0Lm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgdGFyZ2V0Lm9mZnNldFkgLT0gZm9yY2VZO1xuXG4gICAgICAvLyB2YXIgcyA9ICdFZGdlIGZvcmNlIGJldHdlZW4gbm9kZXMgJyArIHNvdXJjZS5pZCArICcgYW5kICcgKyB0YXJnZXQuaWQ7XG4gICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgbCArIFwiIEZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIilcIjtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDb21wdXRlcyBncmF2aXR5IGZvcmNlcyBmb3IgYWxsIG5vZGVzXG4gICAqL1xuICB2YXIgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gICAgLy8gdmFyIHMgPSAnY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyc7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGdyYXBoICAgID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDtcblxuICAgICAgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgICBcbiAgICAgIC8vIENvbXB1dGUgZ3JhcGggY2VudGVyXG4gICAgICBpZiAoMCA9PT0gaSkge1xuICAgICAgICB2YXIgY2VudGVyWCAgID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgICB2YXIgY2VudGVyWSAgID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aCAgLyAyOyAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCBQYXJlbnQgbm9kZSBmb3IgdGhpcyBncmFwaCwgYW5kIHVzZSBpdHMgcG9zaXRpb24gYXMgY2VudGVyXG4gICAgICAgIHZhciB0ZW1wICAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFswXV1dO1xuICAgICAgICB2YXIgcGFyZW50ICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcC5wYXJlbnRJZF1dO1xuICAgICAgICB2YXIgY2VudGVyWCA9IHBhcmVudC5wb3NpdGlvblg7XG4gICAgICAgIHZhciBjZW50ZXJZID0gcGFyZW50LnBvc2l0aW9uWTtcbiAgICAgIH1cbiAgICAgIC8vIHMgPSBcIkNlbnRlciBmb3VuZCBhdDogXCIgKyBjZW50ZXJYICsgXCIsIFwiICsgY2VudGVyWTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZSB0byBhbGwgbm9kZXMgaW4gZ3JhcGhcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcbiAgICAgICAgLy8gcyA9IFwiTm9kZTogXCIgKyBub2RlLmlkO1xuICAgICAgICB2YXIgZHggPSBjZW50ZXJYIC0gbm9kZS5wb3NpdGlvblg7XG4gICAgICAgIHZhciBkeSA9IGNlbnRlclkgLSBub2RlLnBvc2l0aW9uWTtcbiAgICAgICAgdmFyIGQgID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgaWYgKGQgPiAxLjApIHsgLy8gVE9ETzogVXNlIGdsb2JhbCB2YXJpYWJsZSBmb3IgZGlzdGFuY2UgdGhyZXNob2xkXG4gICAgICAgICAgdmFyIGZ4ID0gb3B0aW9ucy5ncmF2aXR5ICogZHggLyBkO1xuICAgICAgICAgIHZhciBmeSA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR5IC8gZDtcbiAgICAgICAgICBub2RlLm9mZnNldFggKz0gZng7XG4gICAgICAgICAgbm9kZS5vZmZzZXRZICs9IGZ5O1xuICAgICAgICAgIC8vIHMgKz0gXCI6IEFwcGxpZWQgZm9yY2U6IFwiICsgZnggKyBcIiwgXCIgKyBmeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzICs9IFwiOiBza3lwcGVkIHNpbmNlIGl0J3MgdG9vIGNsb3NlIHRvIGNlbnRlclwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgICAgOiBUaGlzIGZ1bmN0aW9uIHByb3BhZ2F0ZXMgdGhlIGV4aXN0aW5nIG9mZnNldHMgZnJvbSBcbiAgICogICAgICAgICAgICAgICAgICAgcGFyZW50IG5vZGVzIHRvIGl0cyBkZXNjZW5kZW50cy5cbiAgICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBPYmplY3RcbiAgICogQGFyZyBjeSAgICAgICAgIDogY3l0b3NjYXBlIE9iamVjdFxuICAgKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICAgKi9cbiAgdmFyIHByb3BhZ2F0ZUZvcmNlcyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7ICBcbiAgICAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIHN0YXJ0ID0gMDsgICAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuICAgIHZhciBlbmQgICA9IC0xOyAgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgICAvLyBsb2dEZWJ1ZygncHJvcGFnYXRlRm9yY2VzJyk7XG5cbiAgICAvLyBTdGFydCBieSB2aXNpdGluZyB0aGUgbm9kZXMgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICBxdWV1ZS5wdXNoLmFwcGx5KHF1ZXVlLCBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdKTtcbiAgICBlbmQgKz0gbGF5b3V0SW5mby5ncmFwaFNldFswXS5sZW5ndGg7XG5cbiAgICAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLCBcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgICB2YXIgbm9kZUlkICAgID0gcXVldWVbc3RhcnQrK107XG4gICAgICB2YXIgbm9kZUluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZUlkXTtcbiAgICAgIHZhciBub2RlICAgICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVJbmRleF07XG4gICAgICB2YXIgY2hpbGRyZW4gID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5vZGUgaWYgaXQncyBjb21wb3VuZFxuICAgICAgaWYgKDAgPCBjaGlsZHJlbi5sZW5ndGgpIHsgICAgXG4gICAgICB2YXIgb2ZmWCA9IG5vZGUub2Zmc2V0WDtcbiAgICAgIHZhciBvZmZZID0gbm9kZS5vZmZzZXRZO1xuXG4gICAgICAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgb2Zmc2V0IGZyb20gcGFyZW50IG5vZGUgOiBcIiArIG5vZGUuaWQgKyBcbiAgICAgIC8vICAgXCIuIE9mZnNldFg6IFwiICsgb2ZmWCArIFwiLiBPZmZzZXRZOiBcIiArIG9mZlk7XG4gICAgICAvLyBzICs9IFwiXFxuIENoaWxkcmVuOiBcIiArIGNoaWxkcmVuLnRvU3RyaW5nKCk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlbltpXV1dO1xuICAgICAgICAvLyBQcm9wYWdhdGUgb2Zmc2V0XG4gICAgICAgIGNoaWxkTm9kZS5vZmZzZXRYICs9IG9mZlg7XG4gICAgICAgIGNoaWxkTm9kZS5vZmZzZXRZICs9IG9mZlk7XG4gICAgICAgIC8vIEFkZCBjaGlsZHJlbiB0byBxdWV1ZSB0byBiZSB2aXNpdGVkXG4gICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZXNldCBwYXJlbnQgb2Zmc2V0c1xuICAgICAgbm9kZS5vZmZzZXRYID0gMDtcbiAgICAgIG5vZGUub2Zmc2V0WSA9IDA7XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogVXBkYXRlcyB0aGUgbGF5b3V0IG1vZGVsIHBvc2l0aW9ucywgYmFzZWQgb24gXG4gICAqICAgICAgICAgIHRoZSBhY2N1bXVsYXRlZCBmb3JjZXNcbiAgICovXG4gIHZhciB1cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAgIC8vIHZhciBzID0gJ1VwZGF0aW5nIHBvc2l0aW9ucyc7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAvLyBSZXNldCBib3VuZGFyaWVzIGZvciBjb21wb3VuZCBub2Rlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiUmVzZXR0aW5nIGJvdW5kYXJpZXMgb2YgY29tcG91bmQgbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgICAgbi5tYXhYID0gdW5kZWZpbmVkO1xuICAgICAgICBuLm1pblggPSB1bmRlZmluZWQ7XG4gICAgICAgIG4ubWF4WSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbi5taW5ZID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2V0IGNvbXBvdW5kIG5vZGUgcG9zaXRpb25cbiAgICAgICAgLy8gbG9nRGVidWcoXCJTa2lwcGluZyBwb3NpdGlvbiB1cGRhdGUgb2Ygbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBzID0gXCJOb2RlOiBcIiArIG4uaWQgKyBcIiBQcmV2aW91cyBwb3NpdGlvbjogKFwiICsgXG4gICAgICAvLyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiOyBcblxuICAgICAgLy8gTGltaXQgZGlzcGxhY2VtZW50IGluIG9yZGVyIHRvIGltcHJvdmUgc3RhYmlsaXR5XG4gICAgICB2YXIgdGVtcEZvcmNlID0gbGltaXRGb3JjZShuLm9mZnNldFgsIG4ub2Zmc2V0WSwgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG4gICAgICBuLnBvc2l0aW9uWCArPSB0ZW1wRm9yY2UueDsgXG4gICAgICBuLnBvc2l0aW9uWSArPSB0ZW1wRm9yY2UueTtcbiAgICAgIG4ub2Zmc2V0WCA9IDA7XG4gICAgICBuLm9mZnNldFkgPSAwO1xuICAgICAgbi5taW5YICAgID0gbi5wb3NpdGlvblggLSBuLndpZHRoOyBcbiAgICAgIG4ubWF4WCAgICA9IG4ucG9zaXRpb25YICsgbi53aWR0aDsgXG4gICAgICBuLm1pblkgICAgPSBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0OyBcbiAgICAgIG4ubWF4WSAgICA9IG4ucG9zaXRpb25ZICsgbi5oZWlnaHQ7IFxuICAgICAgLy8gcyArPSBcIiBOZXcgUG9zaXRpb246IChcIiArIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgLy8gVXBkYXRlIGFuY2VzdHJ5IGJvdWRhcmllc1xuICAgICAgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKG4sIGxheW91dEluZm8pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzaXplLCBwb3NpdGlvbiBvZiBjb21wdW5kIG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgbi5wb3NpdGlvblggPSAobi5tYXhYICsgbi5taW5YKSAvIDI7XG4gICAgICAgIG4ucG9zaXRpb25ZID0gKG4ubWF4WSArIG4ubWluWSkgLyAyO1xuICAgICAgICBuLndpZHRoICAgICA9IG4ubWF4WCAtIG4ubWluWDtcbiAgICAgICAgbi5oZWlnaHQgICAgPSBuLm1heFkgLSBuLm1pblk7XG4gICAgICAgIC8vIHMgPSBcIlVwZGF0aW5nIHBvc2l0aW9uLCBzaXplIG9mIGNvbXBvdW5kIG5vZGUgXCIgKyBuLmlkO1xuICAgICAgICAvLyBzICs9IFwiXFxuUG9zaXRpb25YOiBcIiArIG4ucG9zaXRpb25YICsgXCIsIFBvc2l0aW9uWTogXCIgKyBuLnBvc2l0aW9uWTtcbiAgICAgICAgLy8gcyArPSBcIlxcbldpZHRoOiBcIiArIG4ud2lkdGggKyBcIiwgSGVpZ2h0OiBcIiArIG4uaGVpZ2h0O1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIH1cbiAgICB9ICBcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBMaW1pdHMgYSBmb3JjZSAoZm9yY2VYLCBmb3JjZVkpIHRvIGJlIG5vdCBcbiAgICogICAgICAgICAgZ3JlYXRlciAoaW4gbW9kdWxvKSB0aGFuIG1heC4gXG4gICA4ICAgICAgICAgIFByZXNlcnZlcyBmb3JjZSBkaXJlY3Rpb24uIFxuICAgKi9cbiAgdmFyIGxpbWl0Rm9yY2UgPSBmdW5jdGlvbihmb3JjZVgsIGZvcmNlWSwgbWF4KSB7XG4gICAgLy8gdmFyIHMgPSBcIkxpbWl0aW5nIGZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIikuIE1heDogXCIgKyBtYXg7XG4gICAgdmFyIGZvcmNlID0gTWF0aC5zcXJ0KGZvcmNlWCAqIGZvcmNlWCArIGZvcmNlWSAqIGZvcmNlWSk7XG5cbiAgICBpZiAoZm9yY2UgPiBtYXgpIHtcbiAgICAgIHZhciByZXMgPSB7XG4gICAgICB4IDogbWF4ICogZm9yY2VYIC8gZm9yY2UsXG4gICAgICB5IDogbWF4ICogZm9yY2VZIC8gZm9yY2VcbiAgICAgIH07ICAgICAgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IHtcbiAgICAgIHggOiBmb3JjZVgsXG4gICAgICB5IDogZm9yY2VZXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHMgKz0gXCIuXFxuUmVzdWx0OiAoXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55ICsgXCIpXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IEZ1bmN0aW9uIHVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgY29tcG91bmQgbm9kZSBcbiAgICogICAgICAgICAgc2l6ZXMsIHNpbmNlIHRoZXkgc2hvdWxkIGJvdW5kIGFsbCB0aGVpciBzdWJub2Rlcy5cbiAgICovXG4gIHZhciB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMgPSBmdW5jdGlvbihub2RlLCBsYXlvdXRJbmZvKSB7XG4gICAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG5ldyBwb3NpdGlvbi9zaXplIG9mIG5vZGUgXCIgKyBub2RlLmlkO1xuICAgIHZhciBwYXJlbnRJZCA9IG5vZGUucGFyZW50SWQ7XG4gICAgaWYgKG51bGwgPT0gcGFyZW50SWQpIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSBhcmUgZG9uZVxuICAgICAgLy8gcyArPSBcIi4gTm8gcGFyZW50IG5vZGUuXCI7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgUGFyZW50IE5vZGVcbiAgICB2YXIgcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbcGFyZW50SWRdXTtcbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuXG4gICAgLy8gTWF4WFxuICAgIGlmIChudWxsID09IHAubWF4WCB8fCBub2RlLm1heFggKyBwLnBhZFJpZ2h0ID4gcC5tYXhYKSB7XG4gICAgICBwLm1heFggPSBub2RlLm1heFggKyBwLnBhZFJpZ2h0O1xuICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAvLyBzICs9IFwiXFxuTmV3IG1heFggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WDtcbiAgICB9XG5cbiAgICAvLyBNaW5YXG4gICAgaWYgKG51bGwgPT0gcC5taW5YIHx8IG5vZGUubWluWCAtIHAucGFkTGVmdCA8IHAubWluWCkge1xuICAgICAgcC5taW5YID0gbm9kZS5taW5YIC0gcC5wYWRMZWZ0O1xuICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAvLyBzICs9IFwiXFxuTmV3IG1pblggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWDtcbiAgICB9XG5cbiAgICAvLyBNYXhZXG4gICAgaWYgKG51bGwgPT0gcC5tYXhZIHx8IG5vZGUubWF4WSArIHAucGFkQm90dG9tID4gcC5tYXhZKSB7XG4gICAgICBwLm1heFkgPSBub2RlLm1heFkgKyBwLnBhZEJvdHRvbTtcbiAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgLy8gcyArPSBcIlxcbk5ldyBtYXhZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFk7XG4gICAgfVxuXG4gICAgLy8gTWluWVxuICAgIGlmIChudWxsID09IHAubWluWSB8fCBub2RlLm1pblkgLSBwLnBhZFRvcCA8IHAubWluWSkge1xuICAgICAgcC5taW5ZID0gbm9kZS5taW5ZIC0gcC5wYWRUb3A7XG4gICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWluWSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5ZO1xuICAgIH1cblxuICAgIC8vIElmIHVwZGF0ZWQgYm91bmRhcmllcywgcHJvcGFnYXRlIGNoYW5nZXMgdXB3YXJkXG4gICAgaWYgKGZsYWcpIHtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhwLCBsYXlvdXRJbmZvKTtcbiAgICB9IFxuXG4gICAgLy8gcyArPSBcIi4gTm8gY2hhbmdlcyBpbiBib3VuZGFyaWVzL3Bvc2l0aW9uIG9mIHBhcmVudCBub2RlIFwiICsgcC5pZDsgIFxuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIHJldHVybjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBMb2dzIGEgZGVidWcgbWVzc2FnZSBpbiBKUyBjb25zb2xlLCBpZiBERUJVRyBpcyBPTlxuICAgKi9cbiAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24odGV4dCkge1xuICAvLyAgIGlmIChERUJVRykge1xuICAvLyAgICAgY29uc29sZS5kZWJ1Zyh0ZXh0KTtcbiAgLy8gICB9XG4gIC8vIH07XG5cblxuICAvLyByZWdpc3RlciB0aGUgbGF5b3V0XG4gICQkKCdsYXlvdXQnLCAnY29zZScsIENvc2VMYXlvdXQpO1xuXG59KShjeXRvc2NhcGUpO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIC8vIGRhZ3JlIGFsZ28gb3B0aW9ucywgdXNlcyBkZWZhdWx0IHZhbHVlIG9uIHVuZGVmaW5lZFxuICAgIG5vZGVTZXA6IHVuZGVmaW5lZCwgLy8gdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBhZGphY2VudCBub2RlcyBpbiB0aGUgc2FtZSByYW5rXG4gICAgZWRnZVNlcDogdW5kZWZpbmVkLCAvLyB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuIGFkamFjZW50IGVkZ2VzIGluIHRoZSBzYW1lIHJhbmtcbiAgICByYW5rU2VwOiB1bmRlZmluZWQsIC8vIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gYWRqYWNlbnQgbm9kZXMgaW4gdGhlIHNhbWUgcmFua1xuICAgIHJhbmtEaXI6IHVuZGVmaW5lZCwgLy8gJ1RCJyBmb3IgdG9wIHRvIGJvdHRvbSBmbG93LCAnTFInIGZvciBsZWZ0IHRvIHJpZ2h0XG4gICAgbWluTGVuOiBmdW5jdGlvbiggZWRnZSApeyByZXR1cm4gMTsgfSwgLy8gbnVtYmVyIG9mIHJhbmtzIHRvIGtlZXAgYmV0d2VlbiB0aGUgc291cmNlIGFuZCB0YXJnZXQgb2YgdGhlIGVkZ2VcbiAgICBlZGdlV2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApeyByZXR1cm4gMTsgfSwgLy8gaGlnaGVyIHdlaWdodCBlZGdlcyBhcmUgZ2VuZXJhbGx5IG1hZGUgc2hvcnRlciBhbmQgc3RyYWlnaHRlciB0aGFuIGxvd2VyIHdlaWdodCBlZGdlc1xuICAgIFxuICAgIC8vIGdlbmVyYWwgbGF5b3V0IG9wdGlvbnNcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsIC8vIGZpdCBwYWRkaW5nXG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIHJlYWR5OiBmdW5jdGlvbigpe30sIC8vIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogZnVuY3Rpb24oKXt9IC8vIG9uIGxheW91dHN0b3BcbiAgfTtcblxuICAvLyBjb25zdHJ1Y3RvclxuICAvLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAgZnVuY3Rpb24gRGFncmVMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpOyBcbiAgfVxuXG4gIC8vIHJ1bnMgdGhlIGxheW91dFxuICBEYWdyZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgbGF5b3V0ID0gdGhpcztcblxuICAgICQkLnV0aWwucmVxdWlyZSgnZGFncmUnLCBmdW5jdGlvbihkYWdyZSl7XG5cbiAgICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7IC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuXG4gICAgICB2YXIgZ2V0VmFsID0gZnVuY3Rpb24oIGVsZSwgdmFsICl7XG4gICAgICAgIHJldHVybiAkJC5pcy5mbih2YWwpID8gdmFsLmFwcGx5KCBlbGUsIFsgZWxlIF0gKSA6IHZhbDtcbiAgICAgIH07XG5cbiAgICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgICAgfSApO1xuXG4gICAgICB2YXIgZyA9IG5ldyBkYWdyZS5ncmFwaGxpYi5HcmFwaCh7XG4gICAgICAgIG11bHRpZ3JhcGg6IHRydWUsXG4gICAgICAgIGNvbXBvdW5kOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgdmFyIGdPYmogPSB7fTtcbiAgICAgIHZhciBzZXRHT2JqID0gZnVuY3Rpb24oIG5hbWUsIHZhbCApe1xuICAgICAgICBpZiggdmFsICE9IG51bGwgKXtcbiAgICAgICAgICBnT2JqWyBuYW1lIF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIHNldEdPYmooICdub2Rlc2VwJywgb3B0aW9ucy5ub2RlU2VwICk7XG4gICAgICBzZXRHT2JqKCAnZWRnZXNlcCcsIG9wdGlvbnMuZWRnZVNlcCApO1xuICAgICAgc2V0R09iaiggJ3JhbmtzZXAnLCBvcHRpb25zLnJhbmtTZXAgKTtcbiAgICAgIHNldEdPYmooICdyYW5rZGlyJywgb3B0aW9ucy5yYW5rRGlyICk7XG5cbiAgICAgIGcuc2V0R3JhcGgoIGdPYmogKTtcblxuICAgICAgZy5zZXREZWZhdWx0RWRnZUxhYmVsKGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH0pO1xuICAgICAgZy5zZXREZWZhdWx0Tm9kZUxhYmVsKGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH0pO1xuXG4gICAgICAvLyBhZGQgbm9kZXMgdG8gZGFncmVcbiAgICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgICBnLnNldE5vZGUoIG5vZGUuaWQoKSwge1xuICAgICAgICAgIHdpZHRoOiBub2RlLndpZHRoKCksXG4gICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCgpLFxuICAgICAgICAgIG5hbWU6IG5vZGUuaWQoKVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coIGcubm9kZShub2RlLmlkKCkpICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBjb21wb3VuZCBwYXJlbnRzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgICAgaWYoIG5vZGUuaXNDaGlsZCgpICl7XG4gICAgICAgICAgZy5zZXRQYXJlbnQoIG5vZGUuaWQoKSwgbm9kZS5wYXJlbnQoKS5pZCgpICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGVkZ2VzIHRvIGRhZ3JlXG4gICAgICB2YXIgZWRnZXMgPSBlbGVzLmVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICAgIHJldHVybiAhZWRnZS5zb3VyY2UoKS5pc1BhcmVudCgpICYmICFlZGdlLnRhcmdldCgpLmlzUGFyZW50KCk7IC8vIGRhZ3JlIGNhbid0IGhhbmRsZSBlZGdlcyBvbiBjb21wb3VuZCBub2Rlc1xuICAgICAgfSk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG5cbiAgICAgICAgZy5zZXRFZGdlKCBlZGdlLnNvdXJjZSgpLmlkKCksIGVkZ2UudGFyZ2V0KCkuaWQoKSwge1xuICAgICAgICAgIG1pbmxlbjogZ2V0VmFsKCBlZGdlLCBvcHRpb25zLm1pbkxlbiApLFxuICAgICAgICAgIHdlaWdodDogZ2V0VmFsKCBlZGdlLCBvcHRpb25zLmVkZ2VXZWlnaHQgKSxcbiAgICAgICAgICBuYW1lOiBlZGdlLmlkKClcbiAgICAgICAgfSwgZWRnZS5pZCgpICk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coIGcuZWRnZShlZGdlLnNvdXJjZSgpLmlkKCksIGVkZ2UudGFyZ2V0KCkuaWQoKSwgZWRnZS5pZCgpKSApO1xuICAgICAgfVxuXG4gICAgICBkYWdyZS5sYXlvdXQoIGcgKTtcblxuICAgICAgdmFyIGdOb2RlSWRzID0gZy5ub2RlcygpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBnTm9kZUlkcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgaWQgPSBnTm9kZUlkc1tpXTtcbiAgICAgICAgdmFyIG4gPSBnLm5vZGUoIGlkICk7XG5cbiAgICAgICAgY3kuZ2V0RWxlbWVudEJ5SWQoaWQpLnNjcmF0Y2goKS5kYWdyZSA9IG47XG4gICAgICB9XG5cbiAgICAgIHZhciBkYWdyZUJCO1xuXG4gICAgICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCApe1xuICAgICAgICBkYWdyZUJCID0geyB4MTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkxOiBJbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9O1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgICAgdmFyIGRNb2RlbCA9IG5vZGUuc2NyYXRjaCgpLmRhZ3JlO1xuXG4gICAgICAgICAgZGFncmVCQi54MSA9IE1hdGgubWluKCBkYWdyZUJCLngxLCBkTW9kZWwueCApO1xuICAgICAgICAgIGRhZ3JlQkIueDIgPSBNYXRoLm1heCggZGFncmVCQi54MiwgZE1vZGVsLnggKTtcblxuICAgICAgICAgIGRhZ3JlQkIueTEgPSBNYXRoLm1pbiggZGFncmVCQi55MSwgZE1vZGVsLnkgKTtcbiAgICAgICAgICBkYWdyZUJCLnkyID0gTWF0aC5tYXgoIGRhZ3JlQkIueTIsIGRNb2RlbC55ICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRhZ3JlQkIudyA9IGRhZ3JlQkIueDIgLSBkYWdyZUJCLngxO1xuICAgICAgICBkYWdyZUJCLmggPSBkYWdyZUJCLnkyIC0gZGFncmVCQi55MTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhZ3JlQkIgPSBiYjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnN0cmFpblBvcyA9IGZ1bmN0aW9uKCBwICl7XG4gICAgICAgIGlmKCBvcHRpb25zLmJvdW5kaW5nQm94ICl7XG4gICAgICAgICAgdmFyIHhQY3QgPSAocC54IC0gZGFncmVCQi54MSkgLyBkYWdyZUJCLnc7XG4gICAgICAgICAgdmFyIHlQY3QgPSAocC55IC0gZGFncmVCQi55MSkgLyBkYWdyZUJCLmg7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogYmIueDEgKyB4UGN0ICogYmIudyxcbiAgICAgICAgICAgIHk6IGJiLnkxICsgeVBjdCAqIGJiLmhcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMobGF5b3V0LCBvcHRpb25zLCBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgZE1vZGVsID0gdGhpcy5zY3JhdGNoKCkuZGFncmU7XG5cbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpblBvcyh7XG4gICAgICAgICAgeDogZE1vZGVsLngsXG4gICAgICAgICAgeTogZE1vZGVsLnlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIH0pOyAvLyByZXF1aXJlXG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICAvLyByZWdpc3RlciB0aGUgbGF5b3V0XG4gICQkKCdsYXlvdXQnLCAnZGFncmUnLCBEYWdyZUxheW91dCk7XG5cbn0pKGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgdXNlZCBvbiBmaXRcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgICByb3dzOiB1bmRlZmluZWQsIC8vIGZvcmNlIG51bSBvZiByb3dzIGluIHRoZSBncmlkXG4gICAgY29sdW1uczogdW5kZWZpbmVkLCAvLyBmb3JjZSBudW0gb2YgY29scyBpbiB0aGUgZ3JpZFxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbiggbm9kZSApe30sIC8vIHJldHVybnMgeyByb3csIGNvbCB9IGZvciBlbGVtZW50XG4gICAgc29ydDogdW5kZWZpbmVkLCAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICAgIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIH07XG4gIFxuICBmdW5jdGlvbiBHcmlkTGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgR3JpZExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICAgIFxuICAgIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG5cbiAgICBpZiggb3B0aW9ucy5zb3J0ICl7XG4gICAgICBub2RlcyA9IG5vZGVzLnNvcnQoIG9wdGlvbnMuc29ydCApO1xuICAgIH1cbiAgICBcbiAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgfSApO1xuXG4gICAgaWYoIGJiLmggPT09IDAgfHwgYmIudyA9PT0gMCl7XG4gICAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHsgeDogYmIueDEsIHk6IGJiLnkxIH07XG4gICAgICB9KTtcbiAgICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICBcbiAgICAgIC8vIHdpZHRoL2hlaWdodCAqIHNwbGl0c14yID0gY2VsbHMgd2hlcmUgc3BsaXRzIGlzIG51bWJlciBvZiB0aW1lcyB0byBzcGxpdCB3aWR0aFxuICAgICAgdmFyIGNlbGxzID0gbm9kZXMuc2l6ZSgpO1xuICAgICAgdmFyIHNwbGl0cyA9IE1hdGguc3FydCggY2VsbHMgKiBiYi5oL2JiLncgKTtcbiAgICAgIHZhciByb3dzID0gTWF0aC5yb3VuZCggc3BsaXRzICk7XG4gICAgICB2YXIgY29scyA9IE1hdGgucm91bmQoIGJiLncvYmIuaCAqIHNwbGl0cyApO1xuXG4gICAgICB2YXIgc21hbGwgPSBmdW5jdGlvbih2YWwpe1xuICAgICAgICBpZiggdmFsID09IG51bGwgKXtcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4ocm93cywgY29scyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgICAgIGlmKCBtaW4gPT0gcm93cyApe1xuICAgICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIHZhciBsYXJnZSA9IGZ1bmN0aW9uKHZhbCl7XG4gICAgICAgIGlmKCB2YWwgPT0gbnVsbCApe1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heChyb3dzLCBjb2xzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICAgICAgaWYoIG1heCA9PSByb3dzICl7XG4gICAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gaWYgcm93cyBvciBjb2x1bW5zIHdlcmUgc2V0IGluIG9wdGlvbnMsIHVzZSB0aG9zZSB2YWx1ZXNcbiAgICAgIGlmKCBvcHRpb25zLnJvd3MgIT0gbnVsbCAmJiBvcHRpb25zLmNvbHVtbnMgIT0gbnVsbCApe1xuICAgICAgICByb3dzID0gb3B0aW9ucy5yb3dzO1xuICAgICAgICBjb2xzID0gb3B0aW9ucy5jb2x1bW5zO1xuICAgICAgfSBlbHNlIGlmKCBvcHRpb25zLnJvd3MgIT0gbnVsbCAmJiBvcHRpb25zLmNvbHVtbnMgPT0gbnVsbCApe1xuICAgICAgICByb3dzID0gb3B0aW9ucy5yb3dzO1xuICAgICAgICBjb2xzID0gTWF0aC5jZWlsKCBjZWxscyAvIHJvd3MgKTtcbiAgICAgIH0gZWxzZSBpZiggb3B0aW9ucy5yb3dzID09IG51bGwgJiYgb3B0aW9ucy5jb2x1bW5zICE9IG51bGwgKXtcbiAgICAgICAgY29scyA9IG9wdGlvbnMuY29sdW1ucztcbiAgICAgICAgcm93cyA9IE1hdGguY2VpbCggY2VsbHMgLyBjb2xzICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIGF1dG9tYXRpYyB2YWx1ZXMgYW5kIGFkanVzdCBhY2NvcmRpbmdseVxuICAgICAgXG4gICAgICAvLyBpZiByb3VuZGluZyB3YXMgdXAsIHNlZSBpZiB3ZSBjYW4gcmVkdWNlIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgZWxzZSBpZiggY29scyAqIHJvd3MgPiBjZWxscyApe1xuICAgICAgICB2YXIgc20gPSBzbWFsbCgpO1xuICAgICAgICB2YXIgbGcgPSBsYXJnZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gcmVkdWNpbmcgdGhlIHNtYWxsIHNpZGUgdGFrZXMgYXdheSB0aGUgbW9zdCBjZWxscywgc28gdHJ5IGl0IGZpcnN0XG4gICAgICAgIGlmKCAoc20gLSAxKSAqIGxnID49IGNlbGxzICl7XG4gICAgICAgICAgc21hbGwoc20gLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmKCAobGcgLSAxKSAqIHNtID49IGNlbGxzICl7XG4gICAgICAgICAgbGFyZ2UobGcgLSAxKTtcbiAgICAgICAgfSBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFxuICAgICAgICAvLyBpZiByb3VuZGluZyB3YXMgdG9vIGxvdywgYWRkIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgICB3aGlsZSggY29scyAqIHJvd3MgPCBjZWxscyApe1xuICAgICAgICAgIHZhciBzbSA9IHNtYWxsKCk7XG4gICAgICAgICAgdmFyIGxnID0gbGFyZ2UoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyB0cnkgdG8gYWRkIHRvIGxhcmdlciBzaWRlIGZpcnN0IChhZGRzIGxlc3MgaW4gbXVsdGlwbGljYXRpb24pXG4gICAgICAgICAgaWYoIChsZyArIDEpICogc20gPj0gY2VsbHMgKXtcbiAgICAgICAgICAgIGxhcmdlKGxnICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNtYWxsKHNtICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBjZWxsV2lkdGggPSBiYi53IC8gY29scztcbiAgICAgIHZhciBjZWxsSGVpZ2h0ID0gYmIuaCAvIHJvd3M7XG5cbiAgICAgIGlmKCBvcHRpb25zLmF2b2lkT3ZlcmxhcCApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICB2YXIgdyA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgIHZhciBoID0gbm9kZS5vdXRlckhlaWdodCgpO1xuXG4gICAgICAgICAgY2VsbFdpZHRoID0gTWF0aC5tYXgoIGNlbGxXaWR0aCwgdyApO1xuICAgICAgICAgIGNlbGxIZWlnaHQgPSBNYXRoLm1heCggY2VsbEhlaWdodCwgaCApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBjZWxsVXNlZCA9IHt9OyAvLyBlLmcuICdjLTAtMicgPT4gdHJ1ZVxuICAgICAgXG4gICAgICB2YXIgdXNlZCA9IGZ1bmN0aW9uKHJvdywgY29sKXtcbiAgICAgICAgcmV0dXJuIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgdmFyIHVzZSA9IGZ1bmN0aW9uKHJvdywgY29sKXtcbiAgICAgICAgY2VsbFVzZWRbJ2MtJyArIHJvdyArICctJyArIGNvbF0gPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgLy8gdG8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGNlbGwgcG9zaXRpb25cbiAgICAgIHZhciByb3cgPSAwO1xuICAgICAgdmFyIGNvbCA9IDA7XG4gICAgICB2YXIgbW92ZVRvTmV4dENlbGwgPSBmdW5jdGlvbigpe1xuICAgICAgICBjb2wrKztcbiAgICAgICAgaWYoIGNvbCA+PSBjb2xzICl7XG4gICAgICAgICAgY29sID0gMDtcbiAgICAgICAgICByb3crKztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gZ2V0IGEgY2FjaGUgb2YgYWxsIHRoZSBtYW51YWwgcG9zaXRpb25zXG4gICAgICB2YXIgaWQybWFuUG9zID0ge307XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciByY1BvcyA9IG9wdGlvbnMucG9zaXRpb24oIG5vZGUgKTtcblxuICAgICAgICBpZiggcmNQb3MgJiYgKHJjUG9zLnJvdyAhPT0gdW5kZWZpbmVkIHx8IHJjUG9zLmNvbCAhPT0gdW5kZWZpbmVkKSApeyAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgcm93IG9yIGNvbCBkZWYnZFxuICAgICAgICAgIHZhciBwb3MgPSB7XG4gICAgICAgICAgICByb3c6IHJjUG9zLnJvdyxcbiAgICAgICAgICAgIGNvbDogcmNQb3MuY29sXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmKCBwb3MuY29sID09PSB1bmRlZmluZWQgKXsgLy8gZmluZCB1bnVzZWQgY29sXG4gICAgICAgICAgICBwb3MuY29sID0gMDtcblxuICAgICAgICAgICAgd2hpbGUoIHVzZWQocG9zLnJvdywgcG9zLmNvbCkgKXtcbiAgICAgICAgICAgICAgcG9zLmNvbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiggcG9zLnJvdyA9PT0gdW5kZWZpbmVkICl7IC8vIGZpbmQgdW51c2VkIHJvd1xuICAgICAgICAgICAgcG9zLnJvdyA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlKCB1c2VkKHBvcy5yb3csIHBvcy5jb2wpICl7XG4gICAgICAgICAgICAgIHBvcy5yb3crKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZDJtYW5Qb3NbIG5vZGUuaWQoKSBdID0gcG9zO1xuICAgICAgICAgIHVzZSggcG9zLnJvdywgcG9zLmNvbCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbihpLCBlbGVtZW50KXtcbiAgICAgICAgdmFyIHgsIHk7XG5cbiAgICAgICAgaWYoIGVsZW1lbnQubG9ja2VkKCkgfHwgZWxlbWVudC5pc0Z1bGxBdXRvUGFyZW50KCkgKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWUgaWYgd2UgaGF2ZSBhIG1hbnVhbCBwb3NpdGlvbiBzZXRcbiAgICAgICAgdmFyIHJjUG9zID0gaWQybWFuUG9zWyBlbGVtZW50LmlkKCkgXTtcbiAgICAgICAgaWYoIHJjUG9zICl7XG4gICAgICAgICAgeCA9IHJjUG9zLmNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aC8yICsgYmIueDE7XG4gICAgICAgICAgeSA9IHJjUG9zLnJvdyAqIGNlbGxIZWlnaHQgKyBjZWxsSGVpZ2h0LzIgKyBiYi55MTtcbiAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBzZXQgYXV0b21hdGljYWxseVxuICAgICAgICBcbiAgICAgICAgICB3aGlsZSggdXNlZChyb3csIGNvbCkgKXtcbiAgICAgICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeCA9IGNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aC8yICsgYmIueDE7XG4gICAgICAgICAgeSA9IHJvdyAqIGNlbGxIZWlnaHQgKyBjZWxsSGVpZ2h0LzIgKyBiYi55MTtcbiAgICAgICAgICB1c2UoIHJvdywgY29sICk7XG4gICAgICAgICAgXG4gICAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgICAgICBcbiAgICAgIH07XG5cbiAgICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyggdGhpcywgb3B0aW9ucywgZ2V0UG9zICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ2dyaWQnLCBHcmlkTGF5b3V0KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgcmVhZHk6IGZ1bmN0aW9uKCl7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiBmdW5jdGlvbigpe30gLy8gb24gbGF5b3V0c3RvcFxuICB9O1xuXG4gIC8vIGNvbnN0cnVjdG9yXG4gIC8vIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICBmdW5jdGlvbiBOdWxsTGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBvcHRpb25zKTsgXG4gIH1cblxuICAvLyBydW5zIHRoZSBsYXlvdXRcbiAgTnVsbExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlczsgLy8gZWxlbWVudHMgdG8gY29uc2lkZXIgaW4gdGhlIGxheW91dFxuICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuXG4gICAgLy8gY3kgaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZWQgZm9yIHVzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgbGF5b3V0LnRyaWdnZXIoJ2xheW91dHN0YXJ0Jyk7XG5cbiAgICAvLyBwdXRzIGFsbCBub2RlcyBhdCAoMCwgMClcbiAgICBlbGVzLm5vZGVzKCkucG9zaXRpb25zKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gdHJpZ2dlciBsYXlvdXRyZWFkeSB3aGVuIGVhY2ggbm9kZSBoYXMgaGFkIGl0cyBwb3NpdGlvbiBzZXQgYXQgbGVhc3Qgb25jZVxuICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgbGF5b3V0LnRyaWdnZXIoJ2xheW91dHJlYWR5Jyk7XG5cbiAgICAvLyB0cmlnZ2VyIGxheW91dHN0b3Agd2hlbiB0aGUgbGF5b3V0IHN0b3BzIChlLmcuIGZpbmlzaGVzKVxuICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgIGxheW91dC50cmlnZ2VyKCdsYXlvdXRzdG9wJyk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICAvLyBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAgTnVsbExheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gcmVnaXN0ZXIgdGhlIGxheW91dFxuICAkJCgnbGF5b3V0JywgJ251bGwnLCBOdWxsTGF5b3V0KTtcblxufSkoY3l0b3NjYXBlKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgcG9zaXRpb25zOiB1bmRlZmluZWQsIC8vIG1hcCBvZiAobm9kZSBpZCkgPT4gKHBvc2l0aW9uIG9iaik7IG9yIGZ1bmN0aW9uKG5vZGUpeyByZXR1cm4gc29tUG9zOyB9XG4gICAgem9vbTogdW5kZWZpbmVkLCAvLyB0aGUgem9vbSBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gICAgcGFuOiB1bmRlZmluZWQsIC8vIHRoZSBwYW4gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyBvbiBmaXRcbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB9O1xuICBcbiAgZnVuY3Rpb24gUHJlc2V0TGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgUHJlc2V0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuXG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICAgIHZhciBwb3NJc0ZuID0gJCQuaXMuZm4oIG9wdGlvbnMucG9zaXRpb25zICk7XG5cbiAgICBmdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlKXtcbiAgICAgIGlmKCBvcHRpb25zLnBvc2l0aW9ucyA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiggcG9zSXNGbiApe1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wb3NpdGlvbnMuYXBwbHkoIG5vZGUsIFsgbm9kZSBdICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBwb3MgPSBvcHRpb25zLnBvc2l0aW9uc1tub2RlLl9wcml2YXRlLmRhdGEuaWRdO1xuXG4gICAgICBpZiggcG9zID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIFxuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbihpLCBub2RlKXtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKG5vZGUpO1xuICAgICAgXG4gICAgICBpZiggbm9kZS5sb2NrZWQoKSB8fCBwb3NpdGlvbiA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0pO1xuICAgICAgICBcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgXG4gICQkKCdsYXlvdXQnLCAncHJlc2V0JywgUHJlc2V0TGF5b3V0KTtcbiAgXG59KShjeXRvc2NhcGUpO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgICBwYWRkaW5nOiAzMCwgLy8gZml0IHBhZGRpbmdcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB9O1xuICBcbiAgZnVuY3Rpb24gUmFuZG9tTGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgUmFuZG9tTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgIFxuICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICB9ICk7XG5cbiAgICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24oIGksIG5vZGUgKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJiLngxICsgTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIGJiLncgKSxcbiAgICAgICAgeTogYmIueTEgKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIuaCApXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAvLyByZWdpc3RlciB0aGUgbGF5b3V0XG4gICQkKFxuICAgICdsYXlvdXQnLCAvLyB3ZSdyZSByZWdpc3RlcmluZyBhIGxheW91dFxuICAgICdyYW5kb20nLCAvLyB0aGUgbGF5b3V0IG5hbWVcbiAgICBSYW5kb21MYXlvdXQgLy8gdGhlIGxheW91dCBwcm90b3R5cGVcbiAgKTtcbiAgXG59KShjeXRvc2NhcGUpO1xuXG47KCBmdW5jdGlvbiggJCQgKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qXG4gICAqIFRoaXMgbGF5b3V0IGNvbWJpbmVzIHNldmVyYWwgYWxnb3JpdGhtczpcbiAgICpcbiAgICogLSBJdCBnZW5lcmF0ZXMgYW4gaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgbm9kZXMgYnkgdXNpbmcgdGhlXG4gICAqICAgRnJ1Y2h0ZXJtYW4tUmVpbmdvbGQgYWxnb3JpdGhtIChkb2k6MTAuMTAwMi9zcGUuNDM4MDIxMTEwMilcbiAgICpcbiAgICogLSBGaW5hbGx5IGl0IGVsaW1pbmF0ZXMgb3ZlcmxhcHMgYnkgdXNpbmcgdGhlIG1ldGhvZCBkZXNjcmliZWQgYnlcbiAgICogICBHYW5zbmVyIGFuZCBOb3J0aCAoZG9pOjEwLjEwMDcvMy01NDAtMzc2MjMtMl8yOClcbiAgICovXG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGFuaW1hdGU6IHRydWUsIC8vIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGF5b3V0IGFzIGl0J3MgcnVubmluZ1xuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIENhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkLCAvLyBDYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gICAgZml0OiB0cnVlLCAvLyBSZXNldCB2aWV3cG9ydCB0byBmaXQgZGVmYXVsdCBzaW11bGF0aW9uQm91bmRzXG4gICAgbWluRGlzdDogMjAsIC8vIE1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiBub2Rlc1xuICAgIHBhZGRpbmc6IDIwLCAvLyBQYWRkaW5nXG4gICAgZXhwYW5kaW5nRmFjdG9yOiAtMS4wLCAvLyBJZiB0aGUgbmV0d29yayBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBtaW5EaXN0XG4gICAgLy8gY3JpdGVyaXVtIHRoZW4gaXQgZXhwYW5kcyB0aGUgbmV0d29yayBvZiB0aGlzIGFtb3VudFxuICAgIC8vIElmIGl0IGlzIHNldCB0byAtMS4wIHRoZSBhbW91bnQgb2YgZXhwYW5zaW9uIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBtaW5EaXN0LCB0aGUgYXNwZWN0IHJhdGlvIGFuZCB0aGVcbiAgICAvLyBudW1iZXIgb2Ygbm9kZXNcbiAgICBtYXhGcnVjaHRlcm1hblJlaW5nb2xkSXRlcmF0aW9uczogNTAsIC8vIE1heGltdW0gbnVtYmVyIG9mIGluaXRpYWwgZm9yY2UtZGlyZWN0ZWQgaXRlcmF0aW9uc1xuICAgIG1heEV4cGFuZEl0ZXJhdGlvbnM6IDQsIC8vIE1heGltdW0gbnVtYmVyIG9mIGV4cGFuZGluZyBpdGVyYXRpb25zXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCAvLyBDb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTcHJlYWRMYXlvdXQoIG9wdGlvbnMgKSB7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQoIHt9LCBkZWZhdWx0cywgb3B0aW9ucyApO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VsbENlbnRyb2lkKCBjZWxsICkge1xuICAgIHZhciBoZXMgPSBjZWxsLmhhbGZlZGdlcztcbiAgICB2YXIgYXJlYSA9IDAsXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwO1xuICAgIHZhciBwMSwgcDIsIGY7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGhlcy5sZW5ndGg7ICsraSApIHtcbiAgICAgIHAxID0gaGVzWyBpIF0uZ2V0RW5kcG9pbnQoKTtcbiAgICAgIHAyID0gaGVzWyBpIF0uZ2V0U3RhcnRwb2ludCgpO1xuXG4gICAgICBhcmVhICs9IHAxLnggKiBwMi55O1xuICAgICAgYXJlYSAtPSBwMS55ICogcDIueDtcblxuICAgICAgZiA9IHAxLnggKiBwMi55IC0gcDIueCAqIHAxLnk7XG4gICAgICB4ICs9ICggcDEueCArIHAyLnggKSAqIGY7XG4gICAgICB5ICs9ICggcDEueSArIHAyLnkgKSAqIGY7XG4gICAgfVxuXG4gICAgYXJlYSAvPSAyO1xuICAgIGYgPSBhcmVhICogNjtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCAvIGYsXG4gICAgICB5OiB5IC8gZlxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzaXRlc0Rpc3RhbmNlKCBscywgcnMgKSB7XG4gICAgdmFyIGR4ID0gbHMueCAtIHJzLng7XG4gICAgdmFyIGR5ID0gbHMueSAtIHJzLnk7XG4gICAgcmV0dXJuIE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcbiAgfVxuXG4gIFNwcmVhZExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgICAvLyB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAkJC51dGlsLnJlcXVpcmVzKFsnZm9vZ3JhcGgnLCAnVm9yb25vaSddLCBmdW5jdGlvbihmb29ncmFwaCwgVm9yb25vaSl7XG5cbiAgICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gICAgICAvLyB2YXIgYWxsTm9kZXMgPSBjeS5ub2RlcygpO1xuICAgICAgdmFyIG5vZGVzID0gY3kubm9kZXMoKTtcbiAgICAgIC8vdmFyIGFsbEVkZ2VzID0gY3kuZWRnZXMoKTtcbiAgICAgIHZhciBlZGdlcyA9IGN5LmVkZ2VzKCk7XG4gICAgICB2YXIgY1dpZHRoID0gY3kud2lkdGgoKTtcbiAgICAgIHZhciBjSGVpZ2h0ID0gY3kuaGVpZ2h0KCk7XG4gICAgICB2YXIgc2ltdWxhdGlvbkJvdW5kcyA9IG9wdGlvbnMuYm91bmRpbmdCb3ggPyAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCApIDogbnVsbDtcbiAgICAgIHZhciBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nO1xuICAgICAgdmFyIHNpbUJCRmFjdG9yID0gTWF0aC5tYXgoIDEsIE1hdGgubG9nKG5vZGVzLmxlbmd0aCkgKiAwLjggKTtcbiAgICAgIFxuICAgICAgaWYoIG5vZGVzLmxlbmd0aCA8IDEwMCApe1xuICAgICAgICBzaW1CQkZhY3RvciAvPSAyO1xuICAgICAgfVxuXG4gICAgICBsYXlvdXQudHJpZ2dlcigge1xuICAgICAgICB0eXBlOiAnbGF5b3V0c3RhcnQnLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSApO1xuXG4gICAgICB2YXIgc2ltQkIgPSB7XG4gICAgICAgIHgxOiAwLFxuICAgICAgICB5MTogMCxcbiAgICAgICAgeDI6IGNXaWR0aCAqIHNpbUJCRmFjdG9yLFxuICAgICAgICB5MjogY0hlaWdodCAqIHNpbUJCRmFjdG9yXG4gICAgICB9O1xuXG4gICAgICBpZiggc2ltdWxhdGlvbkJvdW5kcyApIHtcbiAgICAgICAgc2ltQkIueDEgPSBzaW11bGF0aW9uQm91bmRzLngxO1xuICAgICAgICBzaW1CQi55MSA9IHNpbXVsYXRpb25Cb3VuZHMueTE7XG4gICAgICAgIHNpbUJCLngyID0gc2ltdWxhdGlvbkJvdW5kcy54MjtcbiAgICAgICAgc2ltQkIueTIgPSBzaW11bGF0aW9uQm91bmRzLnkyO1xuICAgICAgfVxuXG4gICAgICBzaW1CQi54MSArPSBwYWRkaW5nO1xuICAgICAgc2ltQkIueTEgKz0gcGFkZGluZztcbiAgICAgIHNpbUJCLngyIC09IHBhZGRpbmc7XG4gICAgICBzaW1CQi55MiAtPSBwYWRkaW5nO1xuXG4gICAgICB2YXIgd2lkdGggPSBzaW1CQi54MiAtIHNpbUJCLngxO1xuICAgICAgdmFyIGhlaWdodCA9IHNpbUJCLnkyIC0gc2ltQkIueTE7XG5cbiAgICAgIC8vIEdldCBzdGFydCB0aW1lXG4gICAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gbGF5b3V0IGRvZXNuJ3Qgd29yayB3aXRoIGp1c3QgMSBub2RlXG4gICAgICBpZiggbm9kZXMuc2l6ZSgpIDw9IDEgKSB7XG4gICAgICAgIG5vZGVzLnBvc2l0aW9ucygge1xuICAgICAgICAgIHg6IE1hdGgucm91bmQoICggc2ltQkIueDEgKyBzaW1CQi54MiApIC8gMiApLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQoICggc2ltQkIueTEgKyBzaW1CQi55MiApIC8gMiApXG4gICAgICAgIH0gKTtcblxuICAgICAgICBpZiggb3B0aW9ucy5maXQgKSB7XG4gICAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBlbmQgdGltZVxuICAgICAgICB2YXIgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyggXCJMYXlvdXQgb24gXCIgKyBub2Rlcy5zaXplKCkgKyBcIiBub2RlcyB0b29rIFwiICsgKCBlbmRUaW1lIC0gc3RhcnRUaW1lICkgKyBcIiBtc1wiICk7XG5cbiAgICAgICAgbGF5b3V0Lm9uZSggXCJsYXlvdXRyZWFkeVwiLCBvcHRpb25zLnJlYWR5ICk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKCBcImxheW91dHJlYWR5XCIgKTtcblxuICAgICAgICBsYXlvdXQub25lKCBcImxheW91dHN0b3BcIiwgb3B0aW9ucy5zdG9wICk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKCBcImxheW91dHN0b3BcIiApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QgSSBuZWVkIHRvIGNyZWF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmUgdG8gcGFzcyB0byB0aGUgd29ya2VyXG4gICAgICB2YXIgcERhdGEgPSB7XG4gICAgICAgICd3aWR0aCc6IHdpZHRoLFxuICAgICAgICAnaGVpZ2h0JzogaGVpZ2h0LFxuICAgICAgICAnbWluRGlzdCc6IG9wdGlvbnMubWluRGlzdCxcbiAgICAgICAgJ2V4cEZhY3QnOiBvcHRpb25zLmV4cGFuZGluZ0ZhY3RvcixcbiAgICAgICAgJ2V4cEl0JzogMCxcbiAgICAgICAgJ21heEV4cEl0Jzogb3B0aW9ucy5tYXhFeHBhbmRJdGVyYXRpb25zLFxuICAgICAgICAndmVydGljZXMnOiBbXSxcbiAgICAgICAgJ2VkZ2VzJzogW10sXG4gICAgICAgICdzdGFydFRpbWUnOiBzdGFydFRpbWUsXG4gICAgICAgICdtYXhGcnVjaHRlcm1hblJlaW5nb2xkSXRlcmF0aW9ucyc6IG9wdGlvbnMubWF4RnJ1Y2h0ZXJtYW5SZWluZ29sZEl0ZXJhdGlvbnNcbiAgICAgIH07XG5cbiAgICAgIG5vZGVzLmVhY2goXG4gICAgICAgIGZ1bmN0aW9uKCBpLCBub2RlICkge1xuICAgICAgICAgIHZhciBub2RlSWQgPSB0aGlzLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgICAgcERhdGFbICd2ZXJ0aWNlcycgXS5wdXNoKCB7XG4gICAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH0gKTtcblxuICAgICAgZWRnZXMuZWFjaChcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHNyY05vZGVJZCA9IHRoaXMuc291cmNlKCkuaWQoKTtcbiAgICAgICAgICB2YXIgdGd0Tm9kZUlkID0gdGhpcy50YXJnZXQoKS5pZCgpO1xuICAgICAgICAgIHBEYXRhWyAnZWRnZXMnIF0ucHVzaCgge1xuICAgICAgICAgICAgc3JjOiBzcmNOb2RlSWQsXG4gICAgICAgICAgICB0Z3Q6IHRndE5vZGVJZFxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfSApO1xuXG4gICAgICAvL0RlY2xlcmF0aW9uXG4gICAgICB2YXIgdDEgPSAkJC5UaHJlYWQoKTtcbiAgICAgIC8vIEFuZCB0byBhZGQgdGhlIHJlcXVpcmVkIHNjcmlwdHNcbiAgICAgIC8vRVhURVJOQUwgMVxuICAgICAgdDEucmVxdWlyZSggZm9vZ3JhcGgsICdmb29ncmFwaCcgKTtcbiAgICAgIC8vRVhURVJOQUwgMlxuICAgICAgdDEucmVxdWlyZSggVm9yb25vaSApO1xuXG4gICAgICAvL0xvY2FsIGZ1bmN0aW9uXG4gICAgICB0MS5yZXF1aXJlKCBzaXRlc0Rpc3RhbmNlICk7XG4gICAgICB0MS5yZXF1aXJlKCBjZWxsQ2VudHJvaWQgKTtcblxuICAgICAgZnVuY3Rpb24gc2V0UG9zaXRpb25zKCBwRGF0YSApeyAvL2NvbnNvbGUubG9nKCdzZXQgcG9zbnMnKVxuICAgICAgICAvLyBGaXJzdCB3ZSByZXRyaWV2ZSB0aGUgaW1wb3J0YW50IGRhdGFcbiAgICAgICAgLy8gdmFyIGV4cGFuZEl0ZXJhdGlvbiA9IHBEYXRhWyAnZXhwSXQnIF07XG4gICAgICAgIHZhciBkYXRhVmVydGljZXMgPSBwRGF0YVsgJ3ZlcnRpY2VzJyBdO1xuICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkYXRhVmVydGljZXMubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgdmFyIGR2ID0gZGF0YVZlcnRpY2VzWyBpIF07XG4gICAgICAgICAgdmVydGljZXNbIGR2LmlkIF0gPSB7XG4gICAgICAgICAgICB4OiBkdi54LFxuICAgICAgICAgICAgeTogZHYueVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogRklOQUxMWTpcbiAgICAgICAgICpcbiAgICAgICAgICogV2UgcG9zaXRpb24gdGhlIG5vZGVzIGJhc2VkIG9uIHRoZSBjYWxjdWxhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZXMucG9zaXRpb25zKFxuICAgICAgICAgIGZ1bmN0aW9uKCBpLCBub2RlICkge1xuICAgICAgICAgICAgdmFyIGlkID0gbm9kZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICAgICAgLy8gdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbIGlkIF07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IE1hdGgucm91bmQoIHNpbUJCLngxICsgdmVydGV4LnggKSxcbiAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZCggc2ltQkIueTEgKyB2ZXJ0ZXgueSApXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gKTtcblxuICAgICAgICBpZiggb3B0aW9ucy5maXQgKSB7XG4gICAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN5Lm5vZGVzKCkucnRyaWdnZXIoIFwicG9zaXRpb25cIiApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlkTGF5b3V0UmVhZHkgPSBmYWxzZTtcbiAgICAgIHQxLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciBwRGF0YSA9IGUubWVzc2FnZTsgLy9jb25zb2xlLmxvZygnbWVzc2FnZScsIGUpXG5cbiAgICAgICAgaWYoICFvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRQb3NpdGlvbnMoIHBEYXRhICk7XG5cbiAgICAgICAgaWYoICFkaWRMYXlvdXRSZWFkeSApe1xuICAgICAgICAgIGxheW91dC50cmlnZ2VyKCBcImxheW91dHJlYWR5XCIgKTtcblxuICAgICAgICAgIGRpZExheW91dFJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGxheW91dC5vbmUoIFwibGF5b3V0cmVhZHlcIiwgb3B0aW9ucy5yZWFkeSApO1xuXG4gICAgICB0MS5wYXNzKCBwRGF0YSApLnJ1biggZnVuY3Rpb24oIHBEYXRhICkge1xuICAgICAgICBcbiAgICAgICAgZm9vZ3JhcGggPSBldmFsKCdmb29ncmFwaCcpO1xuICAgICAgICBWb3Jvbm9pID0gZXZhbCgnVm9yb25vaScpO1xuICAgICAgICBcbiAgICAgICAgLy8gSSBuZWVkIHRvIHJldHJpZXZlIHRoZSBpbXBvcnRhbnQgZGF0YVxuICAgICAgICB2YXIgbFdpZHRoID0gcERhdGFbICd3aWR0aCcgXTtcbiAgICAgICAgdmFyIGxIZWlnaHQgPSBwRGF0YVsgJ2hlaWdodCcgXTtcbiAgICAgICAgdmFyIGxNaW5EaXN0ID0gcERhdGFbICdtaW5EaXN0JyBdO1xuICAgICAgICB2YXIgbEV4cEZhY3QgPSBwRGF0YVsgJ2V4cEZhY3QnIF07XG4gICAgICAgIHZhciBsTWF4RXhwSXQgPSBwRGF0YVsgJ21heEV4cEl0JyBdO1xuICAgICAgICB2YXIgbE1heEZydWNodGVybWFuUmVpbmdvbGRJdGVyYXRpb25zID0gcERhdGFbICdtYXhGcnVjaHRlcm1hblJlaW5nb2xkSXRlcmF0aW9ucycgXTtcblxuICAgICAgICAvLyBQcmVwYXJlIHRoZSBkYXRhIHRvIG91dHB1dFxuICAgICAgICB2YXIgc2F2ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcERhdGFbICd3aWR0aCcgXSA9IGxXaWR0aDtcbiAgICAgICAgICBwRGF0YVsgJ2hlaWdodCcgXSA9IGxIZWlnaHQ7XG4gICAgICAgICAgcERhdGFbICdleHBJdCcgXSA9IGV4cGFuZEl0ZXJhdGlvbjtcbiAgICAgICAgICBwRGF0YVsgJ2V4cEZhY3QnIF0gPSBsRXhwRmFjdDtcblxuICAgICAgICAgIHBEYXRhWyAndmVydGljZXMnIF0gPSBbXTtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZ2Lmxlbmd0aDsgKytpICkge1xuICAgICAgICAgICAgcERhdGFbICd2ZXJ0aWNlcycgXS5wdXNoKCB7XG4gICAgICAgICAgICAgIGlkOiBmdlsgaSBdLmxhYmVsLFxuICAgICAgICAgICAgICB4OiBmdlsgaSBdLngsXG4gICAgICAgICAgICAgIHk6IGZ2WyBpIF0ueVxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWVzc2FnZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgYnJvYWRjYXN0KCBwRGF0YSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEZJUlNUIFNURVA6IEFwcGxpY2F0aW9uIG9mIHRoZSBGcnVjaHRlcm1hbi1SZWluZ29sZCBhbGdvcml0aG1cbiAgICAgICAgICpcbiAgICAgICAgICogV2UgdXNlIHRoZSB2ZXJzaW9uIGltcGxlbWVudGVkIGJ5IHRoZSBmb29ncmFwaCBsaWJyYXJ5XG4gICAgICAgICAqXG4gICAgICAgICAqIFJlZi46IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZm9vZ3JhcGgvXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIGEgZ3JhcGggY29tcGF0aWJsZSB3aXRoIHRoZSBsaWJyYXJ5XG4gICAgICAgIHZhciBmcmcgPSBuZXcgZm9vZ3JhcGguR3JhcGgoIFwiRlJncmFwaFwiLCBmYWxzZSApO1xuXG4gICAgICAgIHZhciBmcmdOb2RlcyA9IHt9O1xuXG4gICAgICAgIC8vIFRoZW4gd2UgaGF2ZSB0byBhZGQgdGhlIHZlcnRpY2VzXG4gICAgICAgIHZhciBkYXRhVmVydGljZXMgPSBwRGF0YVsgJ3ZlcnRpY2VzJyBdO1xuICAgICAgICBmb3IoIHZhciBuaSA9IDA7IG5pIDwgZGF0YVZlcnRpY2VzLmxlbmd0aDsgKytuaSApIHtcbiAgICAgICAgICB2YXIgaWQgPSBkYXRhVmVydGljZXNbIG5pIF1bICdpZCcgXTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBmb29ncmFwaC5WZXJ0ZXgoIGlkLCBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogbEhlaWdodCApLCBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogbEhlaWdodCApICk7XG4gICAgICAgICAgZnJnTm9kZXNbIGlkIF0gPSB2O1xuICAgICAgICAgIGZyZy5pbnNlcnRWZXJ0ZXgoIHYgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhRWRnZXMgPSBwRGF0YVsgJ2VkZ2VzJyBdO1xuICAgICAgICBmb3IoIHZhciBlaSA9IDA7IGVpIDwgZGF0YUVkZ2VzLmxlbmd0aDsgKytlaSApIHtcbiAgICAgICAgICB2YXIgc3JjTm9kZUlkID0gZGF0YUVkZ2VzWyBlaSBdWyAnc3JjJyBdO1xuICAgICAgICAgIHZhciB0Z3ROb2RlSWQgPSBkYXRhRWRnZXNbIGVpIF1bICd0Z3QnIF07XG4gICAgICAgICAgZnJnLmluc2VydEVkZ2UoIFwiXCIsIDEsIGZyZ05vZGVzWyBzcmNOb2RlSWQgXSwgZnJnTm9kZXNbIHRndE5vZGVJZCBdICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnYgPSBmcmcudmVydGljZXM7XG5cbiAgICAgICAgLy8gVGhlbiB3ZSBhcHBseSB0aGUgbGF5b3V0XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gbE1heEZydWNodGVybWFuUmVpbmdvbGRJdGVyYXRpb25zO1xuICAgICAgICB2YXIgZnJMYXlvdXRNYW5hZ2VyID0gbmV3IGZvb2dyYXBoLkZvcmNlRGlyZWN0ZWRWZXJ0ZXhMYXlvdXQoIGxXaWR0aCwgbEhlaWdodCwgaXRlcmF0aW9ucywgZmFsc2UsIGxNaW5EaXN0ICk7XG5cbiAgICAgICAgZnJMYXlvdXRNYW5hZ2VyLmNhbGxiYWNrID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICBzYXZlUG9zaXRpb25zKCk7XG4gICAgICAgICAgbWVzc2FnZVBvc2l0aW9ucygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZyTGF5b3V0TWFuYWdlci5sYXlvdXQoIGZyZyApO1xuXG4gICAgICAgIHNhdmVQb3NpdGlvbnMoKTtcbiAgICAgICAgbWVzc2FnZVBvc2l0aW9ucygpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFNFQ09ORCBTVEVQOiBUaWRpbmcgdXAgb2YgdGhlIGdyYXBoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXZSB1c2UgdGhlIG1ldGhvZCBkZXNjcmliZWQgYnkgR2Fuc25lciBhbmQgTm9ydGgsIGJhc2VkIG9uIFZvcm9ub2lcbiAgICAgICAgICogZGlhZ3JhbXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJlZjogZG9pOjEwLjEwMDcvMy01NDAtMzc2MjMtMl8yOFxuICAgICAgICAgKi9cblxuICAgICAgICAvLyBXZSBjYWxjdWxhdGUgdGhlIFZvcm9ub2kgZGlhZ3JhbSBkb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSBub2Rlc1xuICAgICAgICB2YXIgdm9yb25vaSA9IG5ldyBWb3Jvbm9pKCk7XG4gICAgICAgIHZhciBiYm94ID0ge1xuICAgICAgICAgIHhsOiAwLFxuICAgICAgICAgIHhyOiBsV2lkdGgsXG4gICAgICAgICAgeXQ6IDAsXG4gICAgICAgICAgeWI6IGxIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZTaXRlcyA9IFtdO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZ2Lmxlbmd0aDsgKytpICkge1xuICAgICAgICAgIHZTaXRlc1sgZnZbIGkgXS5sYWJlbCBdID0gZnZbIGkgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTWluRGlzdCggZWUgKSB7XG4gICAgICAgICAgdmFyIGluZnJhY3Rpb25zID0gMDtcbiAgICAgICAgICAvLyBUaGVuIHdlIGNoZWNrIGlmIHRoZSBtaW5pbXVtIGRpc3RhbmNlIGlzIHNhdGlzZmllZFxuICAgICAgICAgIGZvciggdmFyIGVlaSA9IDA7IGVlaSA8IGVlLmxlbmd0aDsgKytlZWkgKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGVlWyBlZWkgXTtcbiAgICAgICAgICAgIGlmKCAoIGUubFNpdGUgIT0gbnVsbCApICYmICggZS5yU2l0ZSAhPSBudWxsICkgJiYgc2l0ZXNEaXN0YW5jZSggZS5sU2l0ZSwgZS5yU2l0ZSApIDwgbE1pbkRpc3QgKSB7XG4gICAgICAgICAgICAgICsraW5mcmFjdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbmZyYWN0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWFncmFtID0gdm9yb25vaS5jb21wdXRlKCBmdiwgYmJveCApO1xuXG4gICAgICAgIC8vIFRoZW4gd2UgcmVwb3NpdGlvbiB0aGUgbm9kZXMgYXQgdGhlIGNlbnRyb2lkIG9mIHRoZWlyIFZvcm9ub2kgY2VsbHNcbiAgICAgICAgdmFyIGNlbGxzID0gZGlhZ3JhbS5jZWxscztcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7ICsraSApIHtcbiAgICAgICAgICB2YXIgY2VsbCA9IGNlbGxzWyBpIF07XG4gICAgICAgICAgdmFyIHNpdGUgPSBjZWxsLnNpdGU7XG4gICAgICAgICAgdmFyIGNlbnRyb2lkID0gY2VsbENlbnRyb2lkKCBjZWxsICk7XG4gICAgICAgICAgdmFyIGN1cnJ2ID0gdlNpdGVzWyBzaXRlLmxhYmVsIF07XG4gICAgICAgICAgY3VycnYueCA9IGNlbnRyb2lkLng7XG4gICAgICAgICAgY3VycnYueSA9IGNlbnRyb2lkLnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggbEV4cEZhY3QgPCAwLjAgKSB7XG4gICAgICAgICAgLy8gQ2FsY3VsYXRlcyB0aGUgZXhwYW5kaW5nIGZhY3RvclxuICAgICAgICAgIGxFeHBGYWN0ID0gTWF0aC5tYXgoIDAuMDUsIE1hdGgubWluKCAwLjEwLCBsTWluRGlzdCAvIE1hdGguc3FydCggKCBsV2lkdGggKiBsSGVpZ2h0ICkgLyBmdi5sZW5ndGggKSAqIDAuNSApICk7XG4gICAgICAgICAgLy9jb25zb2xlLmluZm8oXCJFeHBhbmRpbmcgZmFjdG9yIGlzIFwiICsgKG9wdGlvbnMuZXhwYW5kaW5nRmFjdG9yICogMTAwLjApICsgXCIlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZXZJbmZyYWN0aW9ucyA9IGNoZWNrTWluRGlzdCggZGlhZ3JhbS5lZGdlcyApO1xuICAgICAgICAvL2NvbnNvbGUuaW5mbyhcIkluaXRpYWwgaW5mcmFjdGlvbnMgXCIgKyBwcmV2SW5mcmFjdGlvbnMpO1xuXG4gICAgICAgIHZhciBiU3RvcCA9ICggcHJldkluZnJhY3Rpb25zIDw9IDAgKTtcblxuICAgICAgICB2YXIgdm9yb25vaUl0ZXJhdGlvbiA9IDA7XG4gICAgICAgIHZhciBleHBhbmRJdGVyYXRpb24gPSAwO1xuXG4gICAgICAgIC8vIHZhciBpbml0V2lkdGggPSBsV2lkdGg7XG5cbiAgICAgICAgd2hpbGUoICFiU3RvcCApIHtcbiAgICAgICAgICArK3Zvcm9ub2lJdGVyYXRpb247XG4gICAgICAgICAgZm9yKCB2YXIgaXQgPSAwOyBpdCA8PSA0OyArK2l0ICkge1xuICAgICAgICAgICAgdm9yb25vaS5yZWN5Y2xlKCBkaWFncmFtICk7XG4gICAgICAgICAgICBkaWFncmFtID0gdm9yb25vaS5jb21wdXRlKCBmdiwgYmJveCApO1xuXG4gICAgICAgICAgICAvLyBUaGVuIHdlIHJlcG9zaXRpb24gdGhlIG5vZGVzIGF0IHRoZSBjZW50cm9pZCBvZiB0aGVpciBWb3Jvbm9pIGNlbGxzXG4gICAgICAgICAgICBjZWxscyA9IGRpYWdyYW0uY2VsbHM7XG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgKytpICkge1xuICAgICAgICAgICAgICB2YXIgY2VsbCA9IGNlbGxzWyBpIF07XG4gICAgICAgICAgICAgIHZhciBzaXRlID0gY2VsbC5zaXRlO1xuICAgICAgICAgICAgICB2YXIgY2VudHJvaWQgPSBjZWxsQ2VudHJvaWQoIGNlbGwgKTtcbiAgICAgICAgICAgICAgdmFyIGN1cnJ2ID0gdlNpdGVzWyBzaXRlLmxhYmVsIF07XG4gICAgICAgICAgICAgIGN1cnJ2LnggPSBjZW50cm9pZC54O1xuICAgICAgICAgICAgICBjdXJydi55ID0gY2VudHJvaWQueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3VyckluZnJhY3Rpb25zID0gY2hlY2tNaW5EaXN0KCBkaWFncmFtLmVkZ2VzICk7XG4gICAgICAgICAgLy9jb25zb2xlLmluZm8oXCJDdXJyZW50IGluZnJhY3Rpb25zIFwiICsgY3VyckluZnJhY3Rpb25zKTtcblxuICAgICAgICAgIGlmKCBjdXJySW5mcmFjdGlvbnMgPD0gMCApIHtcbiAgICAgICAgICAgIGJTdG9wID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoIGN1cnJJbmZyYWN0aW9ucyA+PSBwcmV2SW5mcmFjdGlvbnMgfHwgdm9yb25vaUl0ZXJhdGlvbiA+PSA0ICkge1xuICAgICAgICAgICAgICBpZiggZXhwYW5kSXRlcmF0aW9uID49IGxNYXhFeHBJdCApIHtcbiAgICAgICAgICAgICAgICBiU3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbFdpZHRoICs9IGxXaWR0aCAqIGxFeHBGYWN0O1xuICAgICAgICAgICAgICAgIGxIZWlnaHQgKz0gbEhlaWdodCAqIGxFeHBGYWN0O1xuICAgICAgICAgICAgICAgIGJib3ggPSB7XG4gICAgICAgICAgICAgICAgICB4bDogMCxcbiAgICAgICAgICAgICAgICAgIHhyOiBsV2lkdGgsXG4gICAgICAgICAgICAgICAgICB5dDogMCxcbiAgICAgICAgICAgICAgICAgIHliOiBsSGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICArK2V4cGFuZEl0ZXJhdGlvbjtcbiAgICAgICAgICAgICAgICB2b3Jvbm9pSXRlcmF0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUuaW5mbyhcIkV4cGFuZGVkIHRvIChcIit3aWR0aCtcIixcIitoZWlnaHQrXCIpXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZJbmZyYWN0aW9ucyA9IGN1cnJJbmZyYWN0aW9ucztcblxuICAgICAgICAgIHNhdmVQb3NpdGlvbnMoKTtcbiAgICAgICAgICBtZXNzYWdlUG9zaXRpb25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzYXZlUG9zaXRpb25zKCk7XG4gICAgICAgIHJldHVybiBwRGF0YTtcblxuICAgICAgfSApLnRoZW4oIGZ1bmN0aW9uKCBwRGF0YSApIHtcbiAgICAgICAgLy8gdmFyIGV4cGFuZEl0ZXJhdGlvbiA9IHBEYXRhWyAnZXhwSXQnIF07XG4gICAgICAgIHZhciBkYXRhVmVydGljZXMgPSBwRGF0YVsgJ3ZlcnRpY2VzJyBdO1xuXG4gICAgICAgIHNldFBvc2l0aW9ucyggcERhdGEgKTtcblxuICAgICAgICAvLyBHZXQgZW5kIHRpbWVcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHBEYXRhWyAnc3RhcnRUaW1lJyBdO1xuICAgICAgICB2YXIgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyggXCJMYXlvdXQgb24gXCIgKyBkYXRhVmVydGljZXMubGVuZ3RoICsgXCIgbm9kZXMgdG9vayBcIiArICggZW5kVGltZSAtIHN0YXJ0VGltZSApICsgXCIgbXNcIiApO1xuXG4gICAgICAgIGxheW91dC5vbmUoIFwibGF5b3V0c3RvcFwiLCBvcHRpb25zLnN0b3AgKTtcblxuICAgICAgICBpZiggIW9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgICAgIGxheW91dC50cmlnZ2VyKCBcImxheW91dHJlYWR5XCIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheW91dC50cmlnZ2VyKCBcImxheW91dHN0b3BcIiApO1xuXG4gICAgICAgIHQxLnN0b3AoKTtcbiAgICAgIH0gKTtcblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIHJ1blxuXG4gIFNwcmVhZExheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge307XG5cbiAgJCQoICdsYXlvdXQnLCAnc3ByZWFkJywgU3ByZWFkTGF5b3V0ICk7XG5cblxufSApKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBhbmltYXRlOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHNob3cgdGhlIGxheW91dCBhcyBpdCdzIHJ1bm5pbmdcbiAgICBtYXhTaW11bGF0aW9uVGltZTogNDAwMCwgLy8gbWF4IGxlbmd0aCBpbiBtcyB0byBydW4gdGhlIGxheW91dFxuICAgIHVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZzogZmFsc2UsIC8vIHNvIHlvdSBjYW4ndCBkcmFnIG5vZGVzIGR1cmluZyBsYXlvdXRcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyBvbiBmaXRcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICByYW5kb206IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHVzZSByYW5kb20gaW5pdGlhbCBwb3NpdGlvbnNcbiAgICBpbmZpbml0ZTogZmFsc2UsIC8vIG92ZXJyaWRlcyBhbGwgb3RoZXIgb3B0aW9ucyBmb3IgYSBmb3JjZXMtYWxsLXRoZS10aW1lIG1vZGVcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuXG4gICAgLy8gc3ByaW5neSBmb3JjZXNcbiAgICBzdGlmZm5lc3M6IDQwMCxcbiAgICByZXB1bHNpb246IDQwMCxcbiAgICBkYW1waW5nOiAwLjVcbiAgfTtcblxuICBmdW5jdGlvbiBTcHJpbmd5TGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgU3ByaW5neUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAkJC51dGlsLnJlcXVpcmUoJ1NwcmluZ3knLCBmdW5jdGlvbihTcHJpbmd5KXtcblxuICAgICAgdmFyIHNpbVVwZGF0aW5nUG9zID0gZmFsc2U7XG5cbiAgICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgXG4gICAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZXMuZWRnZXMoKTtcbiAgIFxuICAgICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgICB9ICk7XG4gICAgICBcbiAgICAgIC8vIG1ha2UgYSBuZXcgZ3JhcGhcbiAgICAgIHZhciBncmFwaCA9IG5ldyBTcHJpbmd5LkdyYXBoKCk7XG5cbiAgICAgIC8vIG1ha2Ugc29tZSBub2Rlc1xuICAgICAgbm9kZXMuZWFjaChmdW5jdGlvbihpLCBub2RlKXtcbiAgICAgICAgbm9kZS5zY3JhdGNoKCdzcHJpbmd5Jywge1xuICAgICAgICAgIG1vZGVsOiBncmFwaC5uZXdOb2RlKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IG5vZGVcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjb25uZWN0IHRoZW0gd2l0aCBlZGdlc1xuICAgICAgZWRnZXMuZWFjaChmdW5jdGlvbihpLCBlZGdlKXtcbiAgICAgICAgdmFyIGZkU3JjID0gZWRnZS5zb3VyY2UoKS5zY3JhdGNoKCdzcHJpbmd5JykubW9kZWw7XG4gICAgICAgIHZhciBmZFRndCA9IGVkZ2UudGFyZ2V0KCkuc2NyYXRjaCgnc3ByaW5neScpLm1vZGVsO1xuICAgICAgICBcbiAgICAgICAgZWRnZS5zY3JhdGNoKCdzcHJpbmd5Jywge1xuICAgICAgICAgIG1vZGVsOiBncmFwaC5uZXdFZGdlKGZkU3JjLCBmZFRndCwge1xuICAgICAgICAgICAgZWxlbWVudDogZWRnZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHZhciBzaW0gPSB3aW5kb3cuc2ltID0gbmV3IFNwcmluZ3kuTGF5b3V0LkZvcmNlRGlyZWN0ZWQoZ3JhcGgsIG9wdGlvbnMuc3RpZmZuZXNzLCBvcHRpb25zLnJlcHVsc2lvbiwgb3B0aW9ucy5kYW1waW5nKTtcblxuICAgICAgaWYoIG9wdGlvbnMuaW5maW5pdGUgKXtcbiAgICAgICAgc2ltLm1pbkVuZXJneVRocmVzaG9sZCA9IC1JbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRCQiA9IHNpbS5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgLy8gdmFyIHRhcmdldEJCID0ge2JvdHRvbWxlZnQ6IG5ldyBTcHJpbmd5LlZlY3RvcigtMiwgLTIpLCB0b3ByaWdodDogbmV3IFNwcmluZ3kuVmVjdG9yKDIsIDIpfTtcbiAgICAgIFxuICAgICAgLy8gY29udmVydCB0by9mcm9tIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgdmFyIHRvU2NyZWVuID0gZnVuY3Rpb24ocCkge1xuICAgICAgICBjdXJyZW50QkIgPSBzaW0uZ2V0Qm91bmRpbmdCb3goKTtcblxuICAgICAgICB2YXIgc2l6ZSA9IGN1cnJlbnRCQi50b3ByaWdodC5zdWJ0cmFjdChjdXJyZW50QkIuYm90dG9tbGVmdCk7XG4gICAgICAgIHZhciBzeCA9IHAuc3VidHJhY3QoY3VycmVudEJCLmJvdHRvbWxlZnQpLmRpdmlkZShzaXplLngpLnggKiBiYi53ICsgYmIueDE7XG4gICAgICAgIHZhciBzeSA9IHAuc3VidHJhY3QoY3VycmVudEJCLmJvdHRvbWxlZnQpLmRpdmlkZShzaXplLnkpLnkgKiBiYi5oICsgYmIueDE7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpbmd5LlZlY3RvcihzeCwgc3kpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGZyb21TY3JlZW4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGN1cnJlbnRCQiA9IHNpbS5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIHZhciBzaXplID0gY3VycmVudEJCLnRvcHJpZ2h0LnN1YnRyYWN0KGN1cnJlbnRCQi5ib3R0b21sZWZ0KTtcbiAgICAgICAgdmFyIHB4ID0gKChzLnggLSBiYi54MSkgLyBiYi53KSAqIHNpemUueCArIGN1cnJlbnRCQi5ib3R0b21sZWZ0Lng7XG4gICAgICAgIHZhciBweSA9ICgocy55IC0gYmIueTEpIC8gYmIuaCkgKiBzaXplLnkgKyBjdXJyZW50QkIuYm90dG9tbGVmdC55O1xuXG4gICAgICAgIHJldHVybiBuZXcgU3ByaW5neS5WZWN0b3IocHgsIHB5KTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHZhciBtb3ZlZE5vZGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgXG4gICAgICB2YXIgbnVtTm9kZXMgPSBjeS5ub2RlcygpLnNpemUoKTtcbiAgICAgIHZhciBkcmF3bk5vZGVzID0gMTtcbiAgICAgIHZhciBmZFJlbmRlcmVyID0gbmV3IFNwcmluZ3kuUmVuZGVyZXIoc2ltLFxuICAgICAgICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICBpZiggc2VsZi5zdG9wcGVkICl7IHJldHVybjsgfSAvLyBiZWNhdXNlIHNwcmluZ3kgaXMgYSBidWdneSBsYXlvdXRcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggbW92ZWROb2Rlcy5sZW5ndGggPiAwICYmIG9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgICAgICAgc2ltVXBkYXRpbmdQb3MgPSB0cnVlO1xuXG4gICAgICAgICAgICBtb3ZlZE5vZGVzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuXG4gICAgICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW92ZWROb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgICAgICAgICAgc2ltVXBkYXRpbmdQb3MgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd0VkZ2UoZWRnZSwgcDEsIHAyKSB7XG4gICAgICAgICAgLy8gZHJhdyBhbiBlZGdlXG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd05vZGUobm9kZSwgcCkge1xuICAgICAgICAgIGlmKCBzZWxmLnN0b3BwZWQgKXsgcmV0dXJuOyB9IC8vIGJlY2F1c2Ugc3ByaW5neSBpcyBhIGJ1Z2d5IGxheW91dFxuXG4gICAgICAgICAgdmFyIHYgPSB0b1NjcmVlbihwKTtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IG5vZGUuZGF0YS5lbGVtZW50O1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCAhZWxlbWVudC5sb2NrZWQoKSAmJiAhZWxlbWVudC5ncmFiYmVkKCkgKXtcbiAgICAgICAgICAgICAgZWxlbWVudC5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiB2LngsXG4gICAgICAgICAgICAgICAgeTogdi55XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIG1vdmVkTm9kZXMubWVyZ2UoZWxlbWVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vc2V0TGF5b3V0UG9zaXRpb25Gb3JFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiggZHJhd25Ob2RlcyA9PSBudW1Ob2RlcyApe1xuICAgICAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICAgICAgfSBcbiAgICAgICAgICBcbiAgICAgICAgICBkcmF3bk5vZGVzKys7XG4gICAgICAgIFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBzZXQgaW5pdGlhbCBub2RlIHBvaW50c1xuICAgICAgbm9kZXMuZWFjaChmdW5jdGlvbihpLCBlbGUpe1xuICAgICAgICBpZiggIW9wdGlvbnMucmFuZG9tICl7XG4gICAgICAgICAgc2V0TGF5b3V0UG9zaXRpb25Gb3JFbGVtZW50KGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyB1cGRhdGUgbm9kZSBwb3NpdGlvbnMgd2hlbiBkcmFnZ2luZ1xuICAgICAgdmFyIGRyYWdIYW5kbGVyO1xuICAgICAgbm9kZXMub24oJ3Bvc2l0aW9uJywgZHJhZ0hhbmRsZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggc2ltVXBkYXRpbmdQb3MgKXsgcmV0dXJuOyB9XG5cbiAgICAgICAgc2V0TGF5b3V0UG9zaXRpb25Gb3JFbGVtZW50KHRoaXMpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHNldExheW91dFBvc2l0aW9uRm9yRWxlbWVudChlbGVtZW50KXtcbiAgICAgICAgdmFyIGZkSWQgPSBlbGVtZW50LnNjcmF0Y2goJ3NwcmluZ3knKS5tb2RlbC5pZDtcbiAgICAgICAgdmFyIGZkUCA9IGZkUmVuZGVyZXIubGF5b3V0Lm5vZGVQb2ludHNbZmRJZF0ucDtcbiAgICAgICAgdmFyIHBvcyA9IGVsZW1lbnQucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uSW5GZCA9IChwb3MueCAhPSBudWxsICYmIHBvcy55ICE9IG51bGwpID8gZnJvbVNjcmVlbihlbGVtZW50LnBvc2l0aW9uKCkpIDoge1xuICAgICAgICAgIHg6IE1hdGgucmFuZG9tKCkgKiA0IC0gMixcbiAgICAgICAgICB5OiBNYXRoLnJhbmRvbSgpICogNCAtIDJcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGZkUC54ID0gcG9zaXRpb25JbkZkLng7XG4gICAgICAgIGZkUC55ID0gcG9zaXRpb25JbkZkLnk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBncmFiYmFibGVOb2RlcyA9IG5vZGVzLmZpbHRlcihcIjpncmFiYmFibGVcIik7XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHN0YXJ0KCl7XG4gICAgICAgIHNlbGYuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGRpc2FibGUgZ3JhYmJpbmcgaWYgc28gc2V0XG4gICAgICAgIGlmKCBvcHRpb25zLnVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZyApe1xuICAgICAgICAgIGdyYWJiYWJsZU5vZGVzLnVuZ3JhYmlmeSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmZFJlbmRlcmVyLnN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNlbGYuc3RvcFN5c3RlbSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYuc3RvcHBlZCA9IHRydWU7XG5cbiAgICAgICAgZ3JhcGguZmlsdGVyTm9kZXMoZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJlbW92ZSBhbGwgbm9kZXNcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiggb3B0aW9ucy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXtcbiAgICAgICAgICBncmFiYmFibGVOb2Rlcy5ncmFiaWZ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBub2Rlcy5vZmYoJ2RyYWcgcG9zaXRpb24nLCBkcmFnSGFuZGxlcik7XG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgICAgICBzZWxmLnN0b3BTeXN0ZW0gPSBudWxsO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgc3RhcnQoKTtcbiAgICAgIGlmKCAhb3B0aW9ucy5pbmZpbml0ZSApe1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgc2VsZi5zdG9wKCk7XG4gICAgICAgIH0sIG9wdGlvbnMubWF4U2ltdWxhdGlvblRpbWUpO1xuICAgICAgfVxuXG4gICAgfSk7IC8vIHJlcXVpcmVcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIFNwcmluZ3lMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgIGlmKCB0aGlzLnN0b3BTeXN0ZW0gIT0gbnVsbCApe1xuICAgICAgdGhpcy5zdG9wU3lzdGVtKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ3NwcmluZ3knLCBTcHJpbmd5TGF5b3V0KTtcblxuICBcbn0pKGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gICAgXG4gIGZ1bmN0aW9uIE51bGxSZW5kZXJlcihvcHRpb25zKXtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIFxuICBOdWxsUmVuZGVyZXIucHJvdG90eXBlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCl7XG4gIH07XG5cbiAgTnVsbFJlbmRlcmVyLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIC8vIHRoZSBudWxsIHJlbmRlcmVyIGRvZXMgbm90aGluZ1xuICB9O1xuICBcbiAgJCQoJ3JlbmRlcmVyJywgJ251bGwnLCBOdWxsUmVuZGVyZXIpO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcbiIsIi8qISBpbWpzIC0gdjMuMTMuMCAtIDIwMTUtMDUtMDggKi9cblxuLy8gVGhpcyBsaWJyYXJ5IGlzIG9wZW4gc291cmNlIHNvZnR3YXJlIGFjY29yZGluZyB0byB0aGUgZGVmaW5pdGlvbiBvZiB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5jZSwgVmVyc2lvbiAzLCAoTEdQTHYzKSBhIGNvcHkgb2Ygd2hpY2ggaXNcbi8vIGluY2x1ZGVkIHdpdGggdGhpcyBzb2Z0d2FyZS4gQWxsIHVzZSBvZiB0aGlzIHNvZnR3YXJlIGlzIGNvdmVyZWQgYWNjb3JkaW5nIHRvXG4vLyB0aGUgdGVybXMgb2YgdGhlIExHUEx2My5cbi8vIFxuLy8gVGhlIGNvcHlyaWdodCBpcyBoZWxkIGJ5IEludGVyTWluZSAod3d3LmludGVybWluZS5vcmcpIGFuZCBBbGV4IEthbGRlcmltaXMgKGFsZXhAaW50ZXJtaW5lLm9yZykuXG5cbihmdW5jdGlvbiAoaW50ZXJtaW5lKSB7XG4hZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5pbWpzPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICBleHBvcnRzLkFDQ0VQVF9IRUFERVIgPSB7XG4gICAgJ3htbCc6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgICdqc29uJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICd0c3YnOiAndGV4dC90YWItc2VwYXJhdGVkLXZhbHVlcycsXG4gICAgJ3RhYic6ICd0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzJyxcbiAgICAnY3N2JzogJ3RleHQvY29tbWEtc2VwYXJhdGVkLXZhbHVlcycsXG4gICAgJ2Zhc3RhJzogJ3RleHQveC1mYXN0YScsXG4gICAgJ2dmZjMnOiAndGV4dC94LWdmZjMnLFxuICAgICdiZWQnOiAndGV4dC94LWJlZCcsXG4gICAgJ29iamVjdHMnOiAnYXBwbGljYXRpb24vanNvbjt0eXBlPW9iamVjdHMnLFxuICAgICdqc29ub2JqZWN0cyc6ICdhcHBsaWNhdGlvbi9qc29uO3R5cGU9b2JqZWN0cycsXG4gICAgJ2pzb250YWJsZSc6ICdhcHBsaWNhdGlvbi9qc29uO3R5cGU9dGFibGUnLFxuICAgICdqc29ucm93cyc6ICdhcHBsaWNhdGlvbi9qc29uO3R5cGU9cm93cycsXG4gICAgJ2pzb25jb3VudCc6ICdhcHBsaWNhdGlvbi9qc29uO3R5cGU9Y291bnQnLFxuICAgICdqc29ucCc6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgICAnanNvbnBvYmplY3RzJzogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQ7dHlwZT1vYmplY3RzJyxcbiAgICAnanNvbnB0YWJsZSc6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0O3R5cGU9dGFibGUnLFxuICAgICdqc29ucHJvd3MnOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdDt0eXBlPXJvd3MnLFxuICAgICdqc29ucGNvdW50JzogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQ7dHlwZT1jb3VudCdcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcblxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBleHBvc2UsIGltanMsIG1lcmdlO1xuXG4gIF9kZXJlcV8oJy4vc2hpdicpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gaW1qcyA9IF9kZXJlcV8oJy4vc2VydmljZScpO1xuXG4gIG1lcmdlID0gaW1qcy51dGlscy5tZXJnZTtcblxuICBleHBvc2UgPSBmdW5jdGlvbihuYW1lLCB0aGluZykge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIHJldHVybiBkZWZpbmUobmFtZSwgW10sIHRoaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdsb2JhbFtuYW1lXSA9IHRoaW5nO1xuICAgIH1cbiAgfTtcblxuICBleHBvc2UoJ2ltanMnLCBpbWpzKTtcblxuICBpZiAodHlwZW9mIGludGVybWluZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvc2UoJ2ludGVybWluZScsIGltanMpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9zZSgnaW50ZXJtaW5lJywgbWVyZ2UoaW50ZXJtaW5lLCBpbWpzKSk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vc2VydmljZVwiOjEwLFwiLi9zaGl2XCI6MTJ9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIEFDQ0VQVF9IRUFERVIsIEpTT05TdHJlYW0sIFBFU0tZX0NPTU1BLCBVUkwsIFVSTEVOQywgVVNFUl9BR0VOVCwgVkVSU0lPTiwgYmxvY2tpbmcsIGRlZmVyLCBlcnJvciwgZ2V0TXNnLCBodHRwLCBpbnZva2UsIG1lcmdlLCBwYXJzZU9wdGlvbnMsIHJlamVjdEFmdGVyLCBzdHJlYW1pbmcsIHV0aWxzLCBfcmVmO1xuXG4gIFVSTCA9IF9kZXJlcV8oJ3VybCcpO1xuXG4gIEpTT05TdHJlYW0gPSBfZGVyZXFfKCdKU09OU3RyZWFtJyk7XG5cbiAgaHR0cCA9IF9kZXJlcV8oJ2h0dHAnKTtcblxuICBBQ0NFUFRfSEVBREVSID0gX2RlcmVxXygnLi9jb25zdGFudHMnKS5BQ0NFUFRfSEVBREVSO1xuXG4gIFZFUlNJT04gPSBfZGVyZXFfKCcuL3ZlcnNpb24nKS5WRVJTSU9OO1xuXG4gIF9yZWYgPSB1dGlscyA9IF9kZXJlcV8oJy4vdXRpbCcpLCBlcnJvciA9IF9yZWYuZXJyb3IsIGRlZmVyID0gX3JlZi5kZWZlciwgbWVyZ2UgPSBfcmVmLm1lcmdlLCBpbnZva2UgPSBfcmVmLmludm9rZTtcblxuICBVU0VSX0FHRU5UID0gXCJub2RlLWh0dHAvaW1qcy1cIiArIFZFUlNJT047XG5cbiAgUEVTS1lfQ09NTUEgPSAvLFxccyokLztcblxuICBVUkxFTkMgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiO1xuXG4gIGV4cG9ydHMuc3VwcG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBzdHJlYW1pbmcgPSBmdW5jdGlvbihvcHRzLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgdmFyIGVycm9ycywgcmVzdWx0cztcbiAgICAgIGlmIChyZXNwLnBpcGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcigncmVzcG9uc2UgaXMgbm90IGEgc3RyZWFtJykpO1xuICAgICAgfVxuICAgICAgcmVzcC5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgaWYgKChyZXNwLnN0YXR1c0NvZGUgIT0gbnVsbCkgJiYgcmVzcC5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgZXJyb3JzID0gSlNPTlN0cmVhbS5wYXJzZSgnZXJyb3InKTtcbiAgICAgICAgZXJyb3JzLnBhdXNlKCk7XG4gICAgICAgIHJlc3AucGlwZShlcnJvcnMpO1xuICAgICAgICByZXR1cm4gcmVqZWN0KFtyZXNwLnN0YXR1c0NvZGUsIGVycm9yc10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cyA9IEpTT05TdHJlYW0ucGFyc2UoJ3Jlc3VsdHMuKicpO1xuICAgICAgICByZXN1bHRzLnBhdXNlKCk7XG4gICAgICAgIHJlc3AucGlwZShyZXN1bHRzKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBnZXRNc2cgPSBmdW5jdGlvbihfYXJnLCB0ZXh0LCBlLCBjb2RlKSB7XG4gICAgdmFyIHR5cGUsIHVybDtcbiAgICB0eXBlID0gX2FyZy50eXBlLCB1cmwgPSBfYXJnLnVybDtcbiAgICByZXR1cm4gXCJDb3VsZCBub3QgcGFyc2UgcmVzcG9uc2UgdG8gXCIgKyB0eXBlICsgXCIgXCIgKyB1cmwgKyBcIjogXFxcIlwiICsgdGV4dCArIFwiXFxcIiAoXCIgKyBjb2RlICsgXCI6IFwiICsgZSArIFwiKVwiO1xuICB9O1xuXG4gIGJsb2NraW5nID0gZnVuY3Rpb24ob3B0cywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgIHZhciBjb250YWluZXJCdWZmZXI7XG4gICAgICBjb250YWluZXJCdWZmZXIgPSAnJztcbiAgICAgIHJlc3Aub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyQnVmZmVyICs9IGNodW5rO1xuICAgICAgfSk7XG4gICAgICByZXNwLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICByZXR1cm4gcmVzcC5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdCwgZSwgZXJyLCBmLCBtYXRjaCwgcGFyc2VkLCBfcmVmMTtcbiAgICAgICAgY3QgPSByZXNwLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgICAgICBpZiAoJ2FwcGxpY2F0aW9uL2pzb24nID09PSBjdCB8fCAvanNvbi8udGVzdChvcHRzLmRhdGFUeXBlKSB8fCAvanNvbi8udGVzdChvcHRzLmRhdGEuZm9ybWF0KSkge1xuICAgICAgICAgIGlmICgnJyA9PT0gY29udGFpbmVyQnVmZmVyICYmIHJlc3Auc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGNvbnRhaW5lckJ1ZmZlcik7XG4gICAgICAgICAgICAgIGlmIChlcnIgPSBwYXJzZWQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShwYXJzZWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgaWYgKHJlc3Auc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihyZXNwLnN0YXR1c0NvZGUpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihnZXRNc2cob3B0cywgY29udGFpbmVyQnVmZmVyLCBlLCByZXNwLnN0YXR1c0NvZGUpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1hdGNoID0gY29udGFpbmVyQnVmZmVyLm1hdGNoKC9cXFtFUlJPUlxcXSAoXFxkKykoW1xcc1xcU10qKS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihtYXRjaFsyXSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmID0gKDIwMCA8PSAoX3JlZjEgPSByZXNwLnN0YXR1c0NvZGUpICYmIF9yZWYxIDwgNDAwKSA/IHJlc29sdmUgOiByZWplY3Q7XG4gICAgICAgICAgICByZXR1cm4gZihjb250YWluZXJCdWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICBleHBvcnRzLml0ZXJSZXEgPSBmdW5jdGlvbihtZXRob2QsIHBhdGgsIGZvcm1hdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihxLCBwYWdlLCBjYiwgZWIsIG9uRW5kKSB7XG4gICAgICB2YXIgYXR0YWNoLCBwcm9taXNlLCByZWFkRXJyb3JzLCByZXEsIF9yZWYxO1xuICAgICAgaWYgKHBhZ2UgPT0gbnVsbCkge1xuICAgICAgICBwYWdlID0ge307XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmIChlYiA9PSBudWxsKSB7XG4gICAgICAgIGViID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgaWYgKG9uRW5kID09IG51bGwpIHtcbiAgICAgICAgb25FbmQgPSAoZnVuY3Rpb24oKSB7fSk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihwYWdlKSkge1xuICAgICAgICBfcmVmMSA9IFt7fSwgcGFnZSwgY2IsIGViXSwgcGFnZSA9IF9yZWYxWzBdLCBjYiA9IF9yZWYxWzFdLCBlYiA9IF9yZWYxWzJdLCBvbkVuZCA9IF9yZWYxWzNdO1xuICAgICAgfVxuICAgICAgcmVxID0gbWVyZ2Uoe1xuICAgICAgICBmb3JtYXQ6IGZvcm1hdFxuICAgICAgfSwgcGFnZSwge1xuICAgICAgICBxdWVyeTogcS50b1hNTCgpXG4gICAgICB9KTtcbiAgICAgIGF0dGFjaCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCBjYik7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCBlYik7XG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgb25FbmQpO1xuICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLnJlc3VtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIDMpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfTtcbiAgICAgIHJlYWRFcnJvcnMgPSBmdW5jdGlvbihfYXJnKSB7XG4gICAgICAgIHZhciBlcnJvcnMsIHNjO1xuICAgICAgICBzYyA9IF9hcmdbMF0sIGVycm9ycyA9IF9hcmdbMV07XG4gICAgICAgIGVycm9ycy5vbignZGF0YScsIGViKTtcbiAgICAgICAgZXJyb3JzLm9uKCdlcnJvcicsIGViKTtcbiAgICAgICAgZXJyb3JzLm9uKCdlbmQnLCBvbkVuZCk7XG4gICAgICAgIGlmIChlcnJvcnMucmVzdW1lICE9IG51bGwpIHtcbiAgICAgICAgICBlcnJvcnMucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yKHNjKTtcbiAgICAgIH07XG4gICAgICBwcm9taXNlID0gdGhpcy5tYWtlUmVxdWVzdChtZXRob2QsIHBhdGgsIHJlcSwgbnVsbCwgdHJ1ZSk7XG4gICAgICBwcm9taXNlLnRoZW4oYXR0YWNoLCByZWFkRXJyb3JzKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gIH07XG5cbiAgcmVqZWN0QWZ0ZXIgPSBmdW5jdGlvbih0aW1lb3V0LCByZWplY3QsIHByb21pc2UpIHtcbiAgICB2YXIgdG87XG4gICAgdG8gPSBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZWplY3QoXCJSZXF1ZXN0IHRpbWVkIG91dC5cIik7XG4gICAgfSksIHRpbWVvdXQpO1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2FuY2VsVGltZW91dCh0byk7XG4gICAgfSk7XG4gIH07XG5cbiAgcGFyc2VPcHRpb25zID0gZnVuY3Rpb24ob3B0cykge1xuICAgIHZhciBrLCBwYXJzZWQsIHBvc3RkYXRhLCBzZXAsIHYsIF9yZWYxLCBfcmVmMiwgX3JlZjM7XG4gICAgaWYgKCFvcHRzLnVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXJsIHByb3ZpZGVkIGluIFwiICsgKEpTT04uc3RyaW5naWZ5KG9wdHMpKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgcG9zdGRhdGEgPSBvcHRzLmRhdGE7XG4gICAgICBpZiAoKF9yZWYxID0gb3B0cy50eXBlKSA9PT0gJ0dFVCcgfHwgX3JlZjEgPT09ICdERUxFVEUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVxdWVzdC4gXCIgKyBvcHRzLnR5cGUgKyBcIiByZXF1ZXN0cyBtdXN0IG5vdCBoYXZlIGJvZGllc1wiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zdGRhdGEgPSB1dGlscy5xdWVyeXN0cmluZyhvcHRzLmRhdGEpO1xuICAgIH1cbiAgICBwYXJzZWQgPSBVUkwucGFyc2Uob3B0cy51cmwsIHRydWUpO1xuICAgIHBhcnNlZC53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICBwYXJzZWQubWV0aG9kID0gb3B0cy50eXBlIHx8ICdHRVQnO1xuICAgIGlmIChvcHRzLnBvcnQgIT0gbnVsbCkge1xuICAgICAgcGFyc2VkLnBvcnQgPSBvcHRzLnBvcnQ7XG4gICAgfVxuICAgIHBhcnNlZC5oZWFkZXJzID0ge1xuICAgICAgJ1VzZXItQWdlbnQnOiBVU0VSX0FHRU5ULFxuICAgICAgJ0FjY2VwdCc6IEFDQ0VQVF9IRUFERVJbb3B0cy5kYXRhVHlwZV1cbiAgICB9O1xuICAgIGlmICgoKF9yZWYyID0gcGFyc2VkLm1ldGhvZCkgPT09ICdHRVQnIHx8IF9yZWYyID09PSAnREVMRVRFJykgJiYgKHBvc3RkYXRhICE9IG51bGwgPyBwb3N0ZGF0YS5sZW5ndGggOiB2b2lkIDApKSB7XG4gICAgICBzZXAgPSAvXFw/Ly50ZXN0KHBhcnNlZC5wYXRoKSA/ICcmJyA6ICc/JztcbiAgICAgIHBhcnNlZC5wYXRoICs9IHNlcCArIHBvc3RkYXRhO1xuICAgICAgcG9zdGRhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAob3B0cy5jb250ZW50VHlwZSB8fCBVUkxFTkMpICsgJzsgY2hhcnNldD1VVEYtOCc7XG4gICAgICBwYXJzZWQuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IHBvc3RkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKG9wdHMuaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICBfcmVmMyA9IG9wdHMuaGVhZGVycztcbiAgICAgIGZvciAoayBpbiBfcmVmMykge1xuICAgICAgICB2ID0gX3JlZjNba107XG4gICAgICAgIHBhcnNlZC5oZWFkZXJzW2tdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdHMuYXV0aCAhPSBudWxsKSB7XG4gICAgICBwYXJzZWQuYXV0aCA9IG9wdHMuYXV0aDtcbiAgICB9XG4gICAgcmV0dXJuIFtwYXJzZWQsIHBvc3RkYXRhXTtcbiAgfTtcblxuICBleHBvcnRzLmRvUmVxID0gZnVuY3Rpb24ob3B0cywgaXRlcikge1xuICAgIHZhciBlLCBoYW5kbGVyLCBwb3N0ZGF0YSwgcHJvbWlzZSwgcmVqZWN0LCByZXEsIHJlc29sdmUsIHRpbWVvdXQsIHVybCwgX3JlZjEsIF9yZWYyO1xuICAgIF9yZWYxID0gZGVmZXIoKSwgcHJvbWlzZSA9IF9yZWYxLnByb21pc2UsIHJlc29sdmUgPSBfcmVmMS5yZXNvbHZlLCByZWplY3QgPSBfcmVmMS5yZWplY3Q7XG4gICAgcHJvbWlzZS50aGVuKG51bGwsIG9wdHMuZXJyb3IpO1xuICAgIHRyeSB7XG4gICAgICBfcmVmMiA9IHBhcnNlT3B0aW9ucyhvcHRzKSwgdXJsID0gX3JlZjJbMF0sIHBvc3RkYXRhID0gX3JlZjJbMV07XG4gICAgICBoYW5kbGVyID0gKGl0ZXIgPyBzdHJlYW1pbmcgOiBibG9ja2luZykob3B0cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIHJlcSA9IGh0dHAucmVxdWVzdCh1cmwsIGhhbmRsZXIpO1xuICAgICAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIkVycm9yOiBcIiArIHVybC5tZXRob2QgKyBcIiBcIiArIG9wdHMudXJsICsgXCI6IFwiICsgZXJyKSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChwb3N0ZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHJlcS53cml0ZShwb3N0ZGF0YSk7XG4gICAgICB9XG4gICAgICByZXEuZW5kKCk7XG4gICAgICB0aW1lb3V0ID0gb3B0cy50aW1lb3V0O1xuICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHJlamVjdEFmdGVyKHRpbWVvdXQsIHJlamVjdCwgcHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlID0gX2Vycm9yO1xuICAgICAgcmVqZWN0KGUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCIuL2NvbnN0YW50c1wiOjEsXCIuL3V0aWxcIjoxNSxcIi4vdmVyc2lvblwiOjE2LFwiSlNPTlN0cmVhbVwiOjE4LFwiaHR0cFwiOjUwLFwidXJsXCI6NDd9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIENhdGVnb3J5UmVzdWx0cywgSURSZXNvbHV0aW9uSm9iLCBJZFJlc3VsdHMsIE9ORV9NSU5VVEUsIGNvbmNhdE1hcCwgZGVmZXIsIGRpZmZlcmVuY2UsIGZvbGQsIGZ1bmN1dGlscywgZ2V0LCBpZCwgaW50ZXJtaW5lLCB1bmlxQnksIHdpdGhDQixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfSxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIGZ1bmN1dGlscyA9IF9kZXJlcV8oJy4vdXRpbCcpO1xuXG4gIGludGVybWluZSA9IGV4cG9ydHM7XG5cbiAgdW5pcUJ5ID0gZnVuY3V0aWxzLnVuaXFCeSwgZGlmZmVyZW5jZSA9IGZ1bmN1dGlscy5kaWZmZXJlbmNlLCBkZWZlciA9IGZ1bmN1dGlscy5kZWZlciwgd2l0aENCID0gZnVuY3V0aWxzLndpdGhDQiwgaWQgPSBmdW5jdXRpbHMuaWQsIGdldCA9IGZ1bmN1dGlscy5nZXQsIGZvbGQgPSBmdW5jdXRpbHMuZm9sZCwgY29uY2F0TWFwID0gZnVuY3V0aWxzLmNvbmNhdE1hcDtcblxuICBPTkVfTUlOVVRFID0gNjAgKiAxMDAwO1xuXG4gIENhdGVnb3J5UmVzdWx0cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2V0SXNzdWVNYXRjaGVzO1xuXG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgIHZhciBrLCB2O1xuICAgICAgZm9yIChrIGluIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChyZXN1bHRzLCBrKSkgY29udGludWU7XG4gICAgICAgIHYgPSByZXN1bHRzW2tdO1xuICAgICAgICB0aGlzW2tdID0gdjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBDYXRlZ29yeVJlc3VsdHMucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgaWYgKHR5cGUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0c1t0eXBlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBnZXRJc3N1ZU1hdGNoZXMgPSBjb25jYXRNYXAoZ2V0KCdtYXRjaGVzJykpO1xuXG4gICAgQ2F0ZWdvcnlSZXN1bHRzLnByb3RvdHlwZS5nZXRNYXRjaGVzID0gZnVuY3Rpb24oaykge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICBpZiAoayA9PT0gJ01BVENIJykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaGVzW2tdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChfcmVmID0gZ2V0SXNzdWVNYXRjaGVzKHRoaXMubWF0Y2hlc1trXSkpICE9IG51bGwgPyBfcmVmIDogW107XG4gICAgICB9XG4gICAgfTtcblxuICAgIENhdGVnb3J5UmVzdWx0cy5wcm90b3R5cGUuZ2V0TWF0Y2hJZHMgPSBmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1hdGNoZXMoaykubWFwKGdldCgnaWQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxNYXRjaElkcygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDYXRlZ29yeVJlc3VsdHMucHJvdG90eXBlLmdvb2RNYXRjaElkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hJZHMoJ01BVENIJyk7XG4gICAgfTtcblxuICAgIENhdGVnb3J5UmVzdWx0cy5wcm90b3R5cGUuYWxsTWF0Y2hJZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb21iaW5lSWRzO1xuICAgICAgY29tYmluZUlkcyA9IGZvbGQoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyZXMsIGlzc3VlU2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlcy5jb25jYXQoX3RoaXMuZ2V0TWF0Y2hJZHMoaXNzdWVTZXQpKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHJldHVybiBjb21iaW5lSWRzKHRoaXMuZ29vZE1hdGNoSWRzKCksIFsnRFVQTElDQVRFJywgJ1dJTERDQVJEJywgJ1RZUEVfQ09OVkVSVEVEJywgJ09USEVSJ10pO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2F0ZWdvcnlSZXN1bHRzO1xuXG4gIH0pKCk7XG5cbiAgSWRSZXN1bHRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBmbGF0dGVuLCBnZXRSZWFzb25zLCBpc0dvb2QsIHVuaXF1ZTtcblxuICAgIHVuaXF1ZSA9IHVuaXFCeShpZCk7XG5cbiAgICBmbGF0dGVuID0gY29uY2F0TWFwKGlkKTtcblxuICAgIGdldFJlYXNvbnMgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgdmFyIGssIHZhbHM7XG4gICAgICByZXR1cm4gZmxhdHRlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IG1hdGNoLmlkZW50aWZpZXJzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGsgaW4gX3JlZikge1xuICAgICAgICAgIHZhbHMgPSBfcmVmW2tdO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godmFscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKSk7XG4gICAgfTtcblxuICAgIGlzR29vZCA9IGZ1bmN0aW9uKG1hdGNoLCBrKSB7XG4gICAgICByZXR1cm4gKGsgPT0gbnVsbCkgfHwgX19pbmRleE9mLmNhbGwoZ2V0UmVhc29ucyhtYXRjaCksIGspID49IDA7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIElkUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICB2YXIgaywgdjtcbiAgICAgIGZvciAoayBpbiByZXN1bHRzKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwocmVzdWx0cywgaykpIGNvbnRpbnVlO1xuICAgICAgICB2ID0gcmVzdWx0c1trXTtcbiAgICAgICAgdGhpc1trXSA9IHY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgSWRSZXN1bHRzLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdvYmplY3RzJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RTdGF0cygpO1xuICAgICAgICBjYXNlICdpZGVudGlmaWVycyc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWRlbnRpZmllclN0YXRzKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9iamVjdHM6IHRoaXMuZ2V0T2JqZWN0U3RhdHMoKSxcbiAgICAgICAgICAgIGlkZW50aWZpZXJzOiB0aGlzLmdldElkZW50aWZpZXJTdGF0cygpXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgSWRSZXN1bHRzLnByb3RvdHlwZS5nZXRJZGVudGlmaWVyU3RhdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhbGwsIGFsbElkZW50cywgaXNzdWVzLCBtYXRjaElkZW50cywgbWF0Y2hlcywgdG9JZGVudHM7XG4gICAgICB0b0lkZW50cyA9IGZ1bmN0aW9uKG1zKSB7XG4gICAgICAgIHZhciBpZGVudCwgbWF0Y2g7XG4gICAgICAgIHJldHVybiB1bmlxdWUoZmxhdHRlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gbXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIG1hdGNoID0gbXNbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBfcmVzdWx0czE7XG4gICAgICAgICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGlkZW50IGluIG1hdGNoICE9IG51bGwgPyBtYXRjaC5pZGVudGlmaWVycyA6IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKGlkZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkoKSkpO1xuICAgICAgfTtcbiAgICAgIG1hdGNoSWRlbnRzID0gdG9JZGVudHModGhpcy5nZXRNYXRjaGVzKCdNQVRDSCcpKTtcbiAgICAgIGFsbElkZW50cyA9IHRvSWRlbnRzKHRoaXMuZ2V0TWF0Y2hlcygpKTtcbiAgICAgIG1hdGNoZXMgPSBtYXRjaElkZW50cy5sZW5ndGg7XG4gICAgICBhbGwgPSBhbGxJZGVudHMubGVuZ3RoO1xuICAgICAgaXNzdWVzID0gKGRpZmZlcmVuY2UoYWxsSWRlbnRzLCBtYXRjaElkZW50cykpLmxlbmd0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICAgIGFsbDogYWxsLFxuICAgICAgICBpc3N1ZXM6IGlzc3Vlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgSWRSZXN1bHRzLnByb3RvdHlwZS5nZXRPYmplY3RTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFsbCwgaXNzdWVzLCBtYXRjaCwgbWF0Y2hlcztcbiAgICAgIG1hdGNoZXMgPSB0aGlzLmdvb2RNYXRjaElkcygpLmxlbmd0aDtcbiAgICAgIGFsbCA9IHRoaXMuYWxsTWF0Y2hJZHMoKS5sZW5ndGg7XG4gICAgICBpc3N1ZXMgPSAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaWQgaW4gdGhpcykge1xuICAgICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwodGhpcywgaWQpKSBjb250aW51ZTtcbiAgICAgICAgICBtYXRjaCA9IHRoaXNbaWRdO1xuICAgICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChnZXRSZWFzb25zKG1hdGNoKSwgJ01BVENIJykgPCAwKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKSkubGVuZ3RoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgICAgICAgYWxsOiBhbGwsXG4gICAgICAgIGlzc3VlczogaXNzdWVzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBJZFJlc3VsdHMucHJvdG90eXBlLmdldE1hdGNoZXMgPSBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgbWF0Y2gsIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoaWQgaW4gdGhpcykge1xuICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKHRoaXMsIGlkKSkgY29udGludWU7XG4gICAgICAgIG1hdGNoID0gdGhpc1tpZF07XG4gICAgICAgIGlmIChpc0dvb2QobWF0Y2gsIGspKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChtYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgSWRSZXN1bHRzLnByb3RvdHlwZS5nZXRNYXRjaElkcyA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBtYXRjaCwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChpZCBpbiB0aGlzKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwodGhpcywgaWQpKSBjb250aW51ZTtcbiAgICAgICAgbWF0Y2ggPSB0aGlzW2lkXTtcbiAgICAgICAgaWYgKGlzR29vZChtYXRjaCwgaykpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBJZFJlc3VsdHMucHJvdG90eXBlLmdvb2RNYXRjaElkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hJZHMoJ01BVENIJyk7XG4gICAgfTtcblxuICAgIElkUmVzdWx0cy5wcm90b3R5cGUuYWxsTWF0Y2hJZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1hdGNoSWRzKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBJZFJlc3VsdHM7XG5cbiAgfSkoKTtcblxuICBJRFJlc29sdXRpb25Kb2IgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSURSZXNvbHV0aW9uSm9iKHVpZCwgc2VydmljZSkge1xuICAgICAgdGhpcy51aWQgPSB1aWQ7XG4gICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgdGhpcy5kZWwgPSBfX2JpbmQodGhpcy5kZWwsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaFJlc3VsdHMgPSBfX2JpbmQodGhpcy5mZXRjaFJlc3VsdHMsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaEVycm9yTWVzc2FnZSA9IF9fYmluZCh0aGlzLmZldGNoRXJyb3JNZXNzYWdlLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hTdGF0dXMgPSBfX2JpbmQodGhpcy5mZXRjaFN0YXR1cywgdGhpcyk7XG4gICAgfVxuXG4gICAgSURSZXNvbHV0aW9uSm9iLnByb3RvdHlwZS5mZXRjaFN0YXR1cyA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLnNlcnZpY2UuZ2V0KFwiaWRzL1wiICsgdGhpcy51aWQgKyBcIi9zdGF0dXNcIikudGhlbihnZXQoJ3N0YXR1cycpKSk7XG4gICAgfTtcblxuICAgIElEUmVzb2x1dGlvbkpvYi5wcm90b3R5cGUuZmV0Y2hFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLmdldChcImlkcy9cIiArIHRoaXMudWlkICsgXCIvc3RhdHVzXCIpLnRoZW4oZ2V0KCdtZXNzYWdlJykpKTtcbiAgICB9O1xuXG4gICAgSURSZXNvbHV0aW9uSm9iLnByb3RvdHlwZS5mZXRjaFJlc3VsdHMgPSBmdW5jdGlvbihjYikge1xuICAgICAgdmFyIGdldHRpbmdSZXMsIGdldHRpbmdWZXI7XG4gICAgICBnZXR0aW5nUmVzID0gdGhpcy5zZXJ2aWNlLmdldChcImlkcy9cIiArIHRoaXMudWlkICsgXCIvcmVzdWx0XCIpLnRoZW4oZ2V0KCdyZXN1bHRzJykpO1xuICAgICAgZ2V0dGluZ1ZlciA9IHRoaXMuc2VydmljZS5mZXRjaFZlcnNpb24oKTtcbiAgICAgIHJldHVybiBnZXR0aW5nVmVyLnRoZW4oZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gZ2V0dGluZ1Jlcy50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgICAgICBpZiAodiA+PSAxNikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYXRlZ29yeVJlc3VsdHMocmVzdWx0cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWRSZXN1bHRzKHJlc3VsdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgSURSZXNvbHV0aW9uSm9iLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLm1ha2VSZXF1ZXN0KCdERUxFVEUnLCBcImlkcy9cIiArIHRoaXMudWlkKSk7XG4gICAgfTtcblxuICAgIElEUmVzb2x1dGlvbkpvYi5wcm90b3R5cGUuZGVjYXkgPSA1MDtcblxuICAgIElEUmVzb2x1dGlvbkpvYi5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKG9uU3VjY2Vzcywgb25FcnJvciwgb25Qcm9ncmVzcykge1xuICAgICAgdmFyIGJhY2tPZmYsIG5vdGlmeSwgcHJvbWlzZSwgcmVqZWN0LCByZXNvbHZlLCByZXNwLCBfcmVmO1xuICAgICAgX3JlZiA9IGRlZmVyKCksIHByb21pc2UgPSBfcmVmLnByb21pc2UsIHJlc29sdmUgPSBfcmVmLnJlc29sdmUsIHJlamVjdCA9IF9yZWYucmVqZWN0O1xuICAgICAgcHJvbWlzZS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gICAgICBub3RpZnkgPSBvblByb2dyZXNzICE9IG51bGwgPyBvblByb2dyZXNzIDogKGZ1bmN0aW9uKCkge30pO1xuICAgICAgcmVzcCA9IHRoaXMuZmV0Y2hTdGF0dXMoKTtcbiAgICAgIHJlc3AudGhlbihudWxsLCByZWplY3QpO1xuICAgICAgYmFja09mZiA9IHRoaXMuZGVjYXk7XG4gICAgICB0aGlzLmRlY2F5ID0gTWF0aC5taW4oT05FX01JTlVURSwgYmFja09mZiAqIDEuMjUpO1xuICAgICAgcmVzcC50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICAgICAgbm90aWZ5KHN0YXR1cyk7XG4gICAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ1NVQ0NFU1MnOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZmV0Y2hSZXN1bHRzKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgY2FzZSAnRVJST1InOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZmV0Y2hFcnJvck1lc3NhZ2UoKS50aGVuKHJlamVjdCwgcmVqZWN0KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucG9sbChyZXNvbHZlLCByZWplY3QsIG5vdGlmeSk7XG4gICAgICAgICAgICAgIH0pLCBiYWNrT2ZmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIElEUmVzb2x1dGlvbkpvYjtcblxuICB9KSgpO1xuXG4gIElEUmVzb2x1dGlvbkpvYi5wcm90b3R5cGUud2FpdCA9IElEUmVzb2x1dGlvbkpvYi5wcm90b3R5cGUucG9sbDtcblxuICBJRFJlc29sdXRpb25Kb2IuY3JlYXRlID0gZnVuY3Rpb24oc2VydmljZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih1aWQpIHtcbiAgICAgIHJldHVybiBuZXcgSURSZXNvbHV0aW9uSm9iKHVpZCwgc2VydmljZSk7XG4gICAgfTtcbiAgfTtcblxuICBpbnRlcm1pbmUuSURSZXNvbHV0aW9uSm9iID0gSURSZXNvbHV0aW9uSm9iO1xuXG4gIGludGVybWluZS5DYXRlZ29yeVJlc3VsdHMgPSBDYXRlZ29yeVJlc3VsdHM7XG5cbiAgaW50ZXJtaW5lLklkUmVzdWx0cyA9IElkUmVzdWx0cztcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCIuL3V0aWxcIjoxNX1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgSU5WSVRFUywgTGlzdCwgUkVRVUlSRVNfVkVSU0lPTiwgU0hBUkVTLCBUQUdTX1BBVEgsIGRlam9pbiwgZ2V0LCBnZXRGb2xkZXJOYW1lLCBpbnRlcm1pbmUsIGludm9rZSwgaXNGb2xkZXIsIG1lcmdlLCBzZXQsIHV0aWxzLCB3aXRoQ0IsXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICB1dGlscyA9IF9kZXJlcV8oJy4vdXRpbCcpO1xuXG4gIGludGVybWluZSA9IGV4cG9ydHM7XG5cbiAgbWVyZ2UgPSB1dGlscy5tZXJnZSwgd2l0aENCID0gdXRpbHMud2l0aENCLCBnZXQgPSB1dGlscy5nZXQsIGludm9rZSA9IHV0aWxzLmludm9rZSwgUkVRVUlSRVNfVkVSU0lPTiA9IHV0aWxzLlJFUVVJUkVTX1ZFUlNJT04sIHNldCA9IHV0aWxzLnNldCwgZGVqb2luID0gdXRpbHMuZGVqb2luO1xuXG4gIFRBR1NfUEFUSCA9IFwibGlzdC90YWdzXCI7XG5cbiAgU0hBUkVTID0gXCJsaXN0cy9zaGFyZXNcIjtcblxuICBJTlZJVEVTID0gJ2xpc3RzL2ludml0YXRpb25zJztcblxuICBpc0ZvbGRlciA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5zdWJzdHIoMCwgdC5pbmRleE9mKCc6JykpID09PSAnX19mb2xkZXJfXyc7XG4gIH07XG5cbiAgZ2V0Rm9sZGVyTmFtZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5zdWJzdHIodC5pbmRleE9mKCc6JykgKyAxKTtcbiAgfTtcblxuICBMaXN0ID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBnZXRUYWdzO1xuXG4gICAgZnVuY3Rpb24gTGlzdChwcm9wZXJ0aWVzLCBzZXJ2aWNlKSB7XG4gICAgICB2YXIgaywgdjtcbiAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICB0aGlzLl91cGRhdGVUYWdzID0gX19iaW5kKHRoaXMuX3VwZGF0ZVRhZ3MsIHRoaXMpO1xuICAgICAgdGhpcy5oYXNUYWcgPSBfX2JpbmQodGhpcy5oYXNUYWcsIHRoaXMpO1xuICAgICAgZm9yIChrIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChwcm9wZXJ0aWVzLCBrKSkgY29udGludWU7XG4gICAgICAgIHYgPSBwcm9wZXJ0aWVzW2tdO1xuICAgICAgICB0aGlzW2tdID0gdjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGF0ZUNyZWF0ZWQgPSAodGhpcy5kYXRlQ3JlYXRlZCAhPSBudWxsKSA/IG5ldyBEYXRlKHRoaXMuZGF0ZUNyZWF0ZWQpIDogbnVsbDtcbiAgICAgIHRoaXMuZm9sZGVycyA9IHRoaXMudGFncy5maWx0ZXIoaXNGb2xkZXIpLm1hcChnZXRGb2xkZXJOYW1lKTtcbiAgICB9XG5cbiAgICBMaXN0LnByb3RvdHlwZS5oYXNUYWcgPSBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gX19pbmRleE9mLmNhbGwodGhpcy50YWdzLCB0KSA+PSAwO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgIGlmICh2aWV3ID09IG51bGwpIHtcbiAgICAgICAgdmlldyA9IFsnKiddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5xdWVyeSh7XG4gICAgICAgIHNlbGVjdDogdmlldyxcbiAgICAgICAgZnJvbTogdGhpcy50eXBlLFxuICAgICAgICB3aGVyZTogW1t0aGlzLnR5cGUsICdJTicsIHRoaXMubmFtZV1dXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcnZpY2UubWFrZVJlcXVlc3QoJ0RFTEVURScsICdsaXN0cycsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgICB9LCBjYik7XG4gICAgfTtcblxuICAgIGdldFRhZ3MgPSBmdW5jdGlvbihfYXJnKSB7XG4gICAgICB2YXIgdGFncztcbiAgICAgIHRhZ3MgPSBfYXJnLnRhZ3M7XG4gICAgICByZXR1cm4gdGFncztcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuX3VwZGF0ZVRhZ3MgPSBmdW5jdGlvbihlcnIsIHRhZ3MpIHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRhZ3MgPSB0YWdzLnNsaWNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5mb2xkZXJzID0gdGhpcy50YWdzLmZpbHRlcihpc0ZvbGRlcikubWFwKGdldEZvbGRlck5hbWUpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5mZXRjaFRhZ3MgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQih0aGlzLl91cGRhdGVUYWdzLCBjYiwgdGhpcy5zZXJ2aWNlLm1ha2VSZXF1ZXN0KCdHRVQnLCAnbGlzdC90YWdzJywge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICAgIH0pLnRoZW4oZ2V0VGFncykpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5hZGRUYWdzID0gZnVuY3Rpb24odGFncywgY2IpIHtcbiAgICAgIHZhciByZXE7XG4gICAgICByZXEgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgdGFnczogdGFnc1xuICAgICAgfTtcbiAgICAgIHJldHVybiB3aXRoQ0IodGhpcy5fdXBkYXRlVGFncywgY2IsIHRoaXMuc2VydmljZS5tYWtlUmVxdWVzdCgnUE9TVCcsICdsaXN0L3RhZ3MnLCByZXEpLnRoZW4oZ2V0VGFncykpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5yZW1vdmVUYWdzID0gZnVuY3Rpb24odGFncywgY2IpIHtcbiAgICAgIHZhciByZXE7XG4gICAgICByZXEgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgdGFnczogdGFnc1xuICAgICAgfTtcbiAgICAgIHJldHVybiB3aXRoQ0IodGhpcy5fdXBkYXRlVGFncywgY2IsIHRoaXMuc2VydmljZS5tYWtlUmVxdWVzdCgnREVMRVRFJywgJ2xpc3QvdGFncycsIHJlcSkudGhlbihnZXRUYWdzKSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmNvbnRlbnRzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMucXVlcnkoKS50aGVuKGRlam9pbikudGhlbihpbnZva2UoJ3JlY29yZHMnKSkpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihuZXdOYW1lLCBjYikge1xuICAgICAgdmFyIHByb21pc2U7XG4gICAgICBwcm9taXNlID0gdGhpcy5zZXJ2aWNlLnBvc3QoJ2xpc3RzL3JlbmFtZScsIHtcbiAgICAgICAgb2xkbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBuZXduYW1lOiBuZXdOYW1lXG4gICAgICB9KS50aGVuKGdldCgnbGlzdE5hbWUnKSkudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMubmFtZSA9IG47XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSkudGhlbih0aGlzLnNlcnZpY2UuZmV0Y2hMaXN0KTtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHByb21pc2UpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24ob3B0cywgY2IpIHtcbiAgICAgIHZhciBiYXNlTmFtZSwgbmFtZSwgcXVlcnksIHRhZ3MsIF9yZWYsIF9yZWYxLCBfcmVmMjtcbiAgICAgIGlmIChvcHRzID09IG51bGwpIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGNiID09IG51bGwpIHtcbiAgICAgICAgY2IgPSAoZnVuY3Rpb24oKSB7fSk7XG4gICAgICB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB1dGlscy5pc0Z1bmN0aW9uKG9wdHMpKSB7XG4gICAgICAgIF9yZWYgPSBbe30sIG9wdHNdLCBvcHRzID0gX3JlZlswXSwgY2IgPSBfcmVmWzFdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRzID0ge1xuICAgICAgICAgIG5hbWU6IG9wdHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG5hbWUgPSBiYXNlTmFtZSA9IChfcmVmMSA9IG9wdHMubmFtZSkgIT0gbnVsbCA/IF9yZWYxIDogXCJcIiArIHRoaXMubmFtZSArIFwiX2NvcHlcIjtcbiAgICAgIHRhZ3MgPSB0aGlzLnRhZ3MuY29uY2F0KChfcmVmMiA9IG9wdHMudGFncykgIT0gbnVsbCA/IF9yZWYyIDogW10pO1xuICAgICAgcXVlcnkgPSB0aGlzLnF1ZXJ5KFsnaWQnXSk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLnNlcnZpY2UuZmV0Y2hMaXN0cygpLnRoZW4oaW52b2tlKCdtYXAnLCBnZXQoJ25hbWUnKSkpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lcykge1xuICAgICAgICAgIHZhciBjO1xuICAgICAgICAgIGMgPSAxO1xuICAgICAgICAgIHdoaWxlIChfX2luZGV4T2YuY2FsbChuYW1lcywgbmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgbmFtZSA9IFwiXCIgKyBiYXNlTmFtZSArIFwiLVwiICsgKGMrKyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBxdWVyeS50aGVuKGludm9rZSgnc2F2ZUFzTGlzdCcsIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB0YWdzOiB0YWdzLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IF90aGlzLmRlc2NyaXB0aW9uXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuZW5yaWNobWVudCA9IGZ1bmN0aW9uKG9wdHMsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLmVucmljaG1lbnQobWVyZ2Uoe1xuICAgICAgICBsaXN0OiB0aGlzLm5hbWVcbiAgICAgIH0sIG9wdHMpLCBjYik7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnNoYXJlV2l0aFVzZXIgPSBmdW5jdGlvbihyZWNpcGllbnQsIGNiKSB7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLnNlcnZpY2UucG9zdChTSEFSRVMsIHtcbiAgICAgICAgJ2xpc3QnOiB0aGlzLm5hbWUsXG4gICAgICAgICd3aXRoJzogcmVjaXBpZW50XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmludml0ZVVzZXJUb1NoYXJlID0gZnVuY3Rpb24ocmVjaXBpZW50LCBub3RpZnksIGNiKSB7XG4gICAgICBpZiAobm90aWZ5ID09IG51bGwpIHtcbiAgICAgICAgbm90aWZ5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLnBvc3QoSU5WSVRFUywge1xuICAgICAgICBsaXN0OiB0aGlzLm5hbWUsXG4gICAgICAgIHRvOiByZWNpcGllbnQsXG4gICAgICAgIG5vdGlmeTogISFub3RpZnlcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExpc3Q7XG5cbiAgfSkoKTtcblxuICBpbnRlcm1pbmUuTGlzdCA9IExpc3Q7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi91dGlsXCI6MTV9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIEpBVkFfTEFOR19PQkosIE1vZGVsLCBQYXRoSW5mbywgVGFibGUsIGVycm9yLCBmaW5kLCBmbGF0dGVuLCBpbnRlcm1pbmUsIG9tYXAsIF9yZWYsXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICBUYWJsZSA9IF9kZXJlcV8oJy4vdGFibGUnKS5UYWJsZTtcblxuICBQYXRoSW5mbyA9IF9kZXJlcV8oJy4vcGF0aCcpLlBhdGhJbmZvO1xuXG4gIF9yZWYgPSBfZGVyZXFfKCcuL3V0aWwnKSwgZmxhdHRlbiA9IF9yZWYuZmxhdHRlbiwgZmluZCA9IF9yZWYuZmluZCwgZXJyb3IgPSBfcmVmLmVycm9yLCBvbWFwID0gX3JlZi5vbWFwO1xuXG4gIGludGVybWluZSA9IGV4cG9ydHM7XG5cbiAgSkFWQV9MQU5HX09CSiA9IG5ldyBUYWJsZSh7XG4gICAgbmFtZTogJ09iamVjdCcsXG4gICAgdGFnczogW10sXG4gICAgZGlzcGxheU5hbWU6ICdPYmplY3QnLFxuICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIHJlZmVyZW5jZXM6IHt9LFxuICAgIGNvbGxlY3Rpb25zOiB7fVxuICB9KTtcblxuICBNb2RlbCA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNb2RlbChfYXJnKSB7XG4gICAgICB2YXIgY2xhc3NlcywgbGlmdFRvVGFibGU7XG4gICAgICB0aGlzLm5hbWUgPSBfYXJnLm5hbWUsIGNsYXNzZXMgPSBfYXJnLmNsYXNzZXM7XG4gICAgICB0aGlzLmZpbmRDb21tb25UeXBlID0gX19iaW5kKHRoaXMuZmluZENvbW1vblR5cGUsIHRoaXMpO1xuICAgICAgdGhpcy5maW5kU2hhcmVkQW5jZXN0b3IgPSBfX2JpbmQodGhpcy5maW5kU2hhcmVkQW5jZXN0b3IsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRBbmNlc3RvcnNPZiA9IF9fYmluZCh0aGlzLmdldEFuY2VzdG9yc09mLCB0aGlzKTtcbiAgICAgIHRoaXMuZ2V0U3ViY2xhc3Nlc09mID0gX19iaW5kKHRoaXMuZ2V0U3ViY2xhc3Nlc09mLCB0aGlzKTtcbiAgICAgIHRoaXMuZ2V0UGF0aEluZm8gPSBfX2JpbmQodGhpcy5nZXRQYXRoSW5mbywgdGhpcyk7XG4gICAgICBsaWZ0VG9UYWJsZSA9IG9tYXAoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgcmV0dXJuIFtrLCBuZXcgVGFibGUodiwgX3RoaXMpXTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHRoaXMuY2xhc3NlcyA9IGxpZnRUb1RhYmxlKGNsYXNzZXMpO1xuICAgICAgdGhpcy5jbGFzc2VzWydqYXZhLmxhbmcuT2JqZWN0J10gPSBKQVZBX0xBTkdfT0JKO1xuICAgIH1cblxuICAgIE1vZGVsLnByb3RvdHlwZS5nZXRQYXRoSW5mbyA9IGZ1bmN0aW9uKHBhdGgsIHN1YmNscykge1xuICAgICAgcmV0dXJuIFBhdGhJbmZvLnBhcnNlKHRoaXMsIHBhdGgsIHN1YmNscyk7XG4gICAgfTtcblxuICAgIE1vZGVsLnByb3RvdHlwZS5nZXRTdWJjbGFzc2VzT2YgPSBmdW5jdGlvbihjbHMpIHtcbiAgICAgIHZhciBjZCwgY2xhenosIHJldCwgXywgX3JlZjEsIF9yZWYyO1xuICAgICAgY2xhenogPSBjbHMgJiYgY2xzLm5hbWUgPyBjbHMgOiB0aGlzLmNsYXNzZXNbY2xzXTtcbiAgICAgIGlmIChjbGF6eiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiICsgY2xzICsgXCIgaXMgbm90IGEgdGFibGVcIik7XG4gICAgICB9XG4gICAgICByZXQgPSBbY2xhenoubmFtZV07XG4gICAgICBfcmVmMSA9IHRoaXMuY2xhc3NlcztcbiAgICAgIGZvciAoXyBpbiBfcmVmMSkge1xuICAgICAgICBjZCA9IF9yZWYxW19dO1xuICAgICAgICBpZiAoX3JlZjIgPSBjbGF6ei5uYW1lLCBfX2luZGV4T2YuY2FsbChjZC5wYXJlbnRzKCksIF9yZWYyKSA+PSAwKSB7XG4gICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdCh0aGlzLmdldFN1YmNsYXNzZXNPZihjZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0QW5jZXN0b3JzT2YgPSBmdW5jdGlvbihjbHMpIHtcbiAgICAgIHZhciBjbGF6eiwgcGFyZW50cztcbiAgICAgIGNsYXp6ID0gY2xzICYmIGNscy5uYW1lID8gY2xzIDogdGhpcy5jbGFzc2VzW2Nsc107XG4gICAgICBpZiAoY2xhenogPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIGNscyArIFwiIGlzIG5vdCBhIHRhYmxlXCIpO1xuICAgICAgfVxuICAgICAgcGFyZW50cyA9IGNsYXp6LnBhcmVudHMoKTtcbiAgICAgIHJldHVybiBwYXJlbnRzLmZpbHRlcigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2xhc3Nlc1twXTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKS5yZWR1Y2UoKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXMsIHApIHtcbiAgICAgICAgICByZXR1cm4gYXMuY29uY2F0KF90aGlzLmdldEFuY2VzdG9yc09mKHApKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKSwgcGFyZW50cyk7XG4gICAgfTtcblxuICAgIE1vZGVsLnByb3RvdHlwZS5maW5kU2hhcmVkQW5jZXN0b3IgPSBmdW5jdGlvbihjbGFzc0EsIGNsYXNzQikge1xuICAgICAgdmFyIGFfYW5jZXN0cnksIGJfYW5jZXN0cnksIGZpcnN0Q29tbW9uO1xuICAgICAgaWYgKGNsYXNzQiA9PT0gbnVsbCB8fCBjbGFzc0EgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2xhc3NBID09PSBjbGFzc0IpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzQTtcbiAgICAgIH1cbiAgICAgIGFfYW5jZXN0cnkgPSB0aGlzLmdldEFuY2VzdG9yc09mKGNsYXNzQSk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoYV9hbmNlc3RyeSwgY2xhc3NCKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBjbGFzc0I7XG4gICAgICB9XG4gICAgICBiX2FuY2VzdHJ5ID0gdGhpcy5nZXRBbmNlc3RvcnNPZihjbGFzc0IpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKGJfYW5jZXN0cnksIGNsYXNzQSkgPj0gMCkge1xuICAgICAgICByZXR1cm4gY2xhc3NBO1xuICAgICAgfVxuICAgICAgZmlyc3RDb21tb24gPSBmaW5kKGFfYW5jZXN0cnksIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIF9faW5kZXhPZi5jYWxsKGJfYW5jZXN0cnksIGEpID49IDA7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmaXJzdENvbW1vbjtcbiAgICB9O1xuXG4gICAgTW9kZWwucHJvdG90eXBlLmZpbmRDb21tb25UeXBlID0gZnVuY3Rpb24oeHMpIHtcbiAgICAgIGlmICh4cyA9PSBudWxsKSB7XG4gICAgICAgIHhzID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4geHMucmVkdWNlKHRoaXMuZmluZFNoYXJlZEFuY2VzdG9yKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1vZGVsO1xuXG4gIH0pKCk7XG5cbiAgTW9kZWwucHJvdG90eXBlLm1ha2VQYXRoID0gTW9kZWwucHJvdG90eXBlLmdldFBhdGhJbmZvO1xuXG4gIE1vZGVsLnByb3RvdHlwZS5maW5kQ29tbW9uVHlwZU9mTXVsdGlwbGVDbGFzc2VzID0gTW9kZWwucHJvdG90eXBlLmZpbmRDb21tb25UeXBlO1xuXG4gIE1vZGVsLmxvYWQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgTW9kZWwoZGF0YSk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlID0gX2Vycm9yO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgbG9hZGluZyBtb2RlbDogXCIgKyBlKTtcbiAgICB9XG4gIH07XG5cbiAgTW9kZWwuSU5URUdSQUxfVFlQRVMgPSBbXCJpbnRcIiwgXCJJbnRlZ2VyXCIsIFwibG9uZ1wiLCBcIkxvbmdcIl07XG5cbiAgTW9kZWwuRlJBQ1RJT05BTF9UWVBFUyA9IFtcImRvdWJsZVwiLCBcIkRvdWJsZVwiLCBcImZsb2F0XCIsIFwiRmxvYXRcIl07XG5cbiAgTW9kZWwuTlVNRVJJQ19UWVBFUyA9IE1vZGVsLklOVEVHUkFMX1RZUEVTLmNvbmNhdChNb2RlbC5GUkFDVElPTkFMX1RZUEVTKTtcblxuICBNb2RlbC5CT09MRUFOX1RZUEVTID0gW1wiYm9vbGVhblwiLCBcIkJvb2xlYW5cIl07XG5cbiAgaW50ZXJtaW5lLk1vZGVsID0gTW9kZWw7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi9wYXRoXCI6NyxcIi4vdGFibGVcIjoxMyxcIi4vdXRpbFwiOjE1fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBOQU1FUywgUEFSU0VELCBQYXRoSW5mbywgYW55LCBjb25jYXRNYXAsIGNvcHksIGVycm9yLCBnZXQsIGludGVybWluZSwgbWFrZUtleSwgc2V0LCBzdWNjZXNzLCB1dGlscywgd2l0aENCLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgX19zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG4gIGludGVybWluZSA9IGV4cG9ydHM7XG5cbiAgdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWwnKTtcblxuICB3aXRoQ0IgPSB1dGlscy53aXRoQ0IsIGNvbmNhdE1hcCA9IHV0aWxzLmNvbmNhdE1hcCwgZ2V0ID0gdXRpbHMuZ2V0LCBhbnkgPSB1dGlscy5hbnksIHNldCA9IHV0aWxzLnNldCwgY29weSA9IHV0aWxzLmNvcHksIHN1Y2Nlc3MgPSB1dGlscy5zdWNjZXNzLCBlcnJvciA9IHV0aWxzLmVycm9yO1xuXG4gIE5BTUVTID0ge307XG5cbiAgUEFSU0VEID0ge307XG5cbiAgbWFrZUtleSA9IGZ1bmN0aW9uKG1vZGVsLCBwYXRoLCBzdWJjbGFzc2VzKSB7XG4gICAgdmFyIGssIHYsIF9yZWY7XG4gICAgcmV0dXJuIFwiXCIgKyAobW9kZWwgIT0gbnVsbCA/IG1vZGVsLm5hbWUgOiB2b2lkIDApICsgXCJ8XCIgKyAobW9kZWwgIT0gbnVsbCA/IChfcmVmID0gbW9kZWwuc2VydmljZSkgIT0gbnVsbCA/IF9yZWYucm9vdCA6IHZvaWQgMCA6IHZvaWQgMCkgKyBcInxcIiArIHBhdGggKyBcIjpcIiArICgoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChrIGluIHN1YmNsYXNzZXMpIHtcbiAgICAgICAgdiA9IHN1YmNsYXNzZXNba107XG4gICAgICAgIF9yZXN1bHRzLnB1c2goXCJcIiArIGsgKyBcIj1cIiArIHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pKCkpO1xuICB9O1xuXG4gIFBhdGhJbmZvID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFBhdGhJbmZvKF9hcmcpIHtcbiAgICAgIHZhciBfaSwgX3JlZjtcbiAgICAgIHRoaXMucm9vdCA9IF9hcmcucm9vdCwgdGhpcy5tb2RlbCA9IF9hcmcubW9kZWwsIHRoaXMuZGVzY3JpcHRvcnMgPSBfYXJnLmRlc2NyaXB0b3JzLCB0aGlzLnN1YmNsYXNzZXMgPSBfYXJnLnN1YmNsYXNzZXMsIHRoaXMuZGlzcGxheU5hbWUgPSBfYXJnLmRpc3BsYXlOYW1lLCB0aGlzLmlkZW50ID0gX2FyZy5pZGVudDtcbiAgICAgIHRoaXMuYWxsRGVzY3JpcHRvcnMgPSBfX2JpbmQodGhpcy5hbGxEZXNjcmlwdG9ycywgdGhpcyk7XG4gICAgICB0aGlzLmdldENoaWxkTm9kZXMgPSBfX2JpbmQodGhpcy5nZXRDaGlsZE5vZGVzLCB0aGlzKTtcbiAgICAgIHRoaXMuZ2V0RGlzcGxheU5hbWUgPSBfX2JpbmQodGhpcy5nZXREaXNwbGF5TmFtZSwgdGhpcyk7XG4gICAgICB0aGlzLmlzYSA9IF9fYmluZCh0aGlzLmlzYSwgdGhpcyk7XG4gICAgICB0aGlzLmFwcGVuZCA9IF9fYmluZCh0aGlzLmFwcGVuZCwgdGhpcyk7XG4gICAgICB0aGlzLmdldFBhcmVudCA9IF9fYmluZCh0aGlzLmdldFBhcmVudCwgdGhpcyk7XG4gICAgICB0aGlzLmdldEVuZENsYXNzID0gX19iaW5kKHRoaXMuZ2V0RW5kQ2xhc3MsIHRoaXMpO1xuICAgICAgdGhpcy5jb250YWluc0NvbGxlY3Rpb24gPSBfX2JpbmQodGhpcy5jb250YWluc0NvbGxlY3Rpb24sIHRoaXMpO1xuICAgICAgdGhpcy5pc0NvbGxlY3Rpb24gPSBfX2JpbmQodGhpcy5pc0NvbGxlY3Rpb24sIHRoaXMpO1xuICAgICAgdGhpcy5pc1JldmVyc2VSZWZlcmVuY2UgPSBfX2JpbmQodGhpcy5pc1JldmVyc2VSZWZlcmVuY2UsIHRoaXMpO1xuICAgICAgdGhpcy5pc1JlZmVyZW5jZSA9IF9fYmluZCh0aGlzLmlzUmVmZXJlbmNlLCB0aGlzKTtcbiAgICAgIHRoaXMuaXNDbGFzcyA9IF9fYmluZCh0aGlzLmlzQ2xhc3MsIHRoaXMpO1xuICAgICAgdGhpcy5pc0F0dHJpYnV0ZSA9IF9fYmluZCh0aGlzLmlzQXR0cmlidXRlLCB0aGlzKTtcbiAgICAgIHRoaXMuaXNSb290ID0gX19iaW5kKHRoaXMuaXNSb290LCB0aGlzKTtcbiAgICAgIF9yZWYgPSB0aGlzLmRlc2NyaXB0b3JzLCB0aGlzLm1pZCA9IDIgPD0gX3JlZi5sZW5ndGggPyBfX3NsaWNlLmNhbGwoX3JlZiwgMCwgX2kgPSBfcmVmLmxlbmd0aCAtIDEpIDogKF9pID0gMCwgW10pLCB0aGlzLmVuZCA9IF9yZWZbX2krK107XG4gICAgICBpZiAodGhpcy5pZGVudCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaWRlbnQgPSBtYWtlS2V5KHRoaXMubW9kZWwsIHRoaXMsIHRoaXMuc3ViY2xhc3Nlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmlzUm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRvcnMubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUuaXNBdHRyaWJ1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAodGhpcy5lbmQgIT0gbnVsbCkgJiYgIXRoaXMuaXNSZWZlcmVuY2UoKTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmlzQ2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzUm9vdCgpIHx8IHRoaXMuaXNSZWZlcmVuY2UoKTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmlzUmVmZXJlbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIHJldHVybiAoKF9yZWYgPSB0aGlzLmVuZCkgIT0gbnVsbCA/IF9yZWYucmVmZXJlbmNlZFR5cGUgOiB2b2lkIDApICE9IG51bGw7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5pc1JldmVyc2VSZWZlcmVuY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBncCwgcCwgcmVmZXJlbmNlZFR5cGUsIHJldmVyc2VSZWZlcmVuY2UsIF9yZWY7XG4gICAgICBpZiAodGhpcy5pc1JlZmVyZW5jZSgpICYmICh0aGlzLm1pZC5sZW5ndGggPiAwKSkge1xuICAgICAgICBfcmVmID0gdGhpcy5lbmQsIHJldmVyc2VSZWZlcmVuY2UgPSBfcmVmLnJldmVyc2VSZWZlcmVuY2UsIHJlZmVyZW5jZWRUeXBlID0gX3JlZi5yZWZlcmVuY2VkVHlwZTtcbiAgICAgICAgcCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgIGdwID0gcC5nZXRQYXJlbnQoKTtcbiAgICAgICAgcmV0dXJuIChyZWZlcmVuY2VkVHlwZSAhPSBudWxsKSAmJiAoZ3AuaXNhKHJlZmVyZW5jZWRUeXBlKSkgJiYgKHAuZW5kLm5hbWUgPT09IHJldmVyc2VSZWZlcmVuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUuaXNDb2xsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZiwgX3JlZjE7XG4gICAgICByZXR1cm4gKF9yZWYgPSAoX3JlZjEgPSB0aGlzLmVuZCkgIT0gbnVsbCA/IF9yZWYxLmlzQ29sbGVjdGlvbiA6IHZvaWQgMCkgIT0gbnVsbCA/IF9yZWYgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmNvbnRhaW5zQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFueSh0aGlzLmRlc2NyaXB0b3JzLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB4LmlzQ29sbGVjdGlvbjtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUuZ2V0RW5kQ2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY2xhc3Nlc1t0aGlzLnN1YmNsYXNzZXNbdGhpcy50b1N0cmluZygpXSB8fCAoKF9yZWYgPSB0aGlzLmVuZCkgIT0gbnVsbCA/IF9yZWYucmVmZXJlbmNlZFR5cGUgOiB2b2lkIDApXSB8fCB0aGlzLnJvb3Q7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkYXRhO1xuICAgICAgaWYgKHRoaXMuaXNSb290KCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBwYXRocyBkbyBub3QgaGF2ZSBwYXJlbnRzXCIpO1xuICAgICAgfVxuICAgICAgZGF0YSA9IHtcbiAgICAgICAgcm9vdDogdGhpcy5yb290LFxuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgZGVzY3JpcHRvcnM6IHRoaXMubWlkLnNsaWNlKCksXG4gICAgICAgIHN1YmNsYXNzZXM6IHRoaXMuc3ViY2xhc3Nlc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBuZXcgUGF0aEluZm8oZGF0YSk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgICB2YXIgZGF0YSwgZmxkO1xuICAgICAgaWYgKHRoaXMuaXNBdHRyaWJ1dGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIHRoaXMgKyBcIiBpcyBhbiBhdHRyaWJ1dGUuXCIpO1xuICAgICAgfVxuICAgICAgZmxkID0gdHlwZW9mIGF0dHIgPT09ICdzdHJpbmcnID8gdGhpcy5nZXRUeXBlKCkuZmllbGRzW2F0dHJdIDogYXR0cjtcbiAgICAgIGlmIChmbGQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIGF0dHIgKyBcIiBpcyBub3QgYSBmaWVsZCBvZiBcIiArICh0aGlzLmdldFR5cGUoKSkpO1xuICAgICAgfVxuICAgICAgZGF0YSA9IHtcbiAgICAgICAgcm9vdDogdGhpcy5yb290LFxuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgZGVzY3JpcHRvcnM6IHRoaXMuZGVzY3JpcHRvcnMuY29uY2F0KFtmbGRdKSxcbiAgICAgICAgc3ViY2xhc3NlczogdGhpcy5zdWJjbGFzc2VzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5ldyBQYXRoSW5mbyhkYXRhKTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmlzYSA9IGZ1bmN0aW9uKGNsYXp6KSB7XG4gICAgICB2YXIgbmFtZSwgdHlwZTtcbiAgICAgIGlmIChjbGF6eiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQXR0cmlidXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpID09PSBjbGF6ejtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBjbGF6ei5uYW1lID8gY2xhenoubmFtZSA6ICcnICsgY2xheno7XG4gICAgICAgIHR5cGUgPSB0aGlzLmdldFR5cGUoKTtcbiAgICAgICAgcmV0dXJuIChuYW1lID09PSB0eXBlLm5hbWUpIHx8IChfX2luZGV4T2YuY2FsbCh0aGlzLm1vZGVsLmdldEFuY2VzdG9yc09mKHR5cGUpLCBuYW1lKSA+PSAwKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHZhciBjYWNoZWQsIGN1c3RvbSwgcGFyYW1zLCBwYXRoO1xuICAgICAgaWYgKGN1c3RvbSA9IHRoaXMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3MoY3VzdG9tKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5hbWVQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5uYW1lUHJvbWlzZSA9IChjYWNoZWQgPSBOQU1FU1t0aGlzLmlkZW50XSkgPyBzdWNjZXNzKGNhY2hlZCkgOiB0aGlzLmlzUm9vdCgpICYmIHRoaXMucm9vdC5kaXNwbGF5TmFtZSA/IHN1Y2Nlc3ModGhpcy5yb290LmRpc3BsYXlOYW1lKSA6IHRoaXMubW9kZWwuc2VydmljZSA9PSBudWxsID8gZXJyb3IoXCJObyBzZXJ2aWNlXCIpIDogKHBhdGggPSAnbW9kZWwnICsgKGNvbmNhdE1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuICcvJyArIGQubmFtZTtcbiAgICAgICAgfSkpKHRoaXMuYWxsRGVzY3JpcHRvcnMoKSksIHBhcmFtcyA9IChzZXQoe1xuICAgICAgICAgIGZvcm1hdDogJ2pzb24nXG4gICAgICAgIH0pKShjb3B5KHRoaXMuc3ViY2xhc3NlcykpLCB0aGlzLm1vZGVsLnNlcnZpY2UuZ2V0KHBhdGgsIHBhcmFtcykudGhlbihnZXQoJ2Rpc3BsYXknKSkudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obikge1xuICAgICAgICAgICAgdmFyIF9uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIE5BTUVTW19uYW1lID0gX3RoaXMuaWRlbnRdICE9IG51bGwgPyBOQU1FU1tfbmFtZV0gOiBOQU1FU1tfbmFtZV0gPSBuO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLm5hbWVQcm9taXNlKTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmdldENoaWxkTm9kZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmbGQsIG5hbWUsIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIF9yZWYxID0gKChfcmVmID0gdGhpcy5nZXRFbmRDbGFzcygpKSAhPSBudWxsID8gX3JlZi5maWVsZHMgOiB2b2lkIDApIHx8IHt9O1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAobmFtZSBpbiBfcmVmMSkge1xuICAgICAgICBmbGQgPSBfcmVmMVtuYW1lXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmFwcGVuZChmbGQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmFsbERlc2NyaXB0b3JzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3RoaXMucm9vdF0uY29uY2F0KHRoaXMuZGVzY3JpcHRvcnMpO1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFsbERlc2NyaXB0b3JzKCkubWFwKGdldCgnbmFtZScpKS5qb2luKCcuJyk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8ICh0aGlzLmlkZW50ICYmIChvdGhlciAhPSBudWxsID8gb3RoZXIuaWRlbnQgOiB2b2lkIDApID09PSB0aGlzLmlkZW50KTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmLCBfcmVmMTtcbiAgICAgIHJldHVybiAoKF9yZWYgPSB0aGlzLmVuZCkgIT0gbnVsbCA/IChfcmVmMSA9IF9yZWYudHlwZSkgIT0gbnVsbCA/IF9yZWYxLnJlcGxhY2UoL2phdmFcXC5sYW5nXFwuLywgJycpIDogdm9pZCAwIDogdm9pZCAwKSB8fCB0aGlzLmdldEVuZENsYXNzKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXRoSW5mbztcblxuICB9KSgpO1xuXG4gIFBhdGhJbmZvLnByb3RvdHlwZS50b1BhdGhTdHJpbmcgPSBQYXRoSW5mby5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgUGF0aEluZm8ucGFyc2UgPSBmdW5jdGlvbihtb2RlbCwgcGF0aCwgc3ViY2xhc3Nlcykge1xuICAgIHZhciBjYWNoZWQsIGNkLCBkZXNjcmlwdG9ycywgZmxkLCBpZGVudCwga2V5UGF0aCwgcGFydCwgcGFydHMsIHJvb3Q7XG4gICAgaWYgKHN1YmNsYXNzZXMgPT0gbnVsbCkge1xuICAgICAgc3ViY2xhc3NlcyA9IHt9O1xuICAgIH1cbiAgICBpZGVudCA9IG1ha2VLZXkobW9kZWwsIHBhdGgsIHN1YmNsYXNzZXMpO1xuICAgIGlmIChjYWNoZWQgPSBQQVJTRURbaWRlbnRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBwYXJ0cyA9IChwYXRoICsgJycpLnNwbGl0KCcuJyk7XG4gICAgcm9vdCA9IGNkID0gbW9kZWwuY2xhc3Nlc1twYXJ0cy5zaGlmdCgpXTtcbiAgICBrZXlQYXRoID0gcm9vdC5uYW1lO1xuICAgIGRlc2NyaXB0b3JzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHBhcnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHBhcnQgPSBwYXJ0c1tfaV07XG4gICAgICAgIGZsZCA9IChjZCAhPSBudWxsID8gY2QuZmllbGRzW3BhcnRdIDogdm9pZCAwKSB8fCAoKF9yZWYgPSAoY2QgPSBtb2RlbC5jbGFzc2VzW3N1YmNsYXNzZXNba2V5UGF0aF1dKSkgIT0gbnVsbCA/IF9yZWYuZmllbGRzW3BhcnRdIDogdm9pZCAwKTtcbiAgICAgICAgaWYgKCFmbGQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBcIiArIHBhcnQgKyBcIiBpbiBcIiArIGNkICsgXCIgd2hlbiBwYXJzaW5nIFwiICsgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAga2V5UGF0aCArPSBcIi5cIiArIHBhcnQ7XG4gICAgICAgIGNkID0gbW9kZWwuY2xhc3Nlc1tmbGQudHlwZSB8fCBmbGQucmVmZXJlbmNlZFR5cGVdO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGZsZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gUEFSU0VEW2lkZW50XSA9IG5ldyBQYXRoSW5mbyh7XG4gICAgICByb290OiByb290LFxuICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzLFxuICAgICAgc3ViY2xhc3Nlczogc3ViY2xhc3NlcyxcbiAgICAgIGlkZW50OiBpZGVudFxuICAgIH0pO1xuICB9O1xuXG4gIFBhdGhJbmZvLmZsdXNoQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICBQQVJTRUQgPSB7fTtcbiAgICByZXR1cm4gTkFNRVMgPSB7fTtcbiAgfTtcblxuICBpbnRlcm1pbmUuUGF0aEluZm8gPSBQYXRoSW5mbztcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCIuL3V0aWxcIjoxNX1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgUHJvbWlzZTtcblxuICBQcm9taXNlID0gX2RlcmVxXygnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCJlczYtcHJvbWlzZVwiOjIyfV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBCQVNJQ19BVFRSUywgQ09ERVMsIEV2ZW50cywgTElTVF9QSVBFLCBRdWVyeSwgUkVRVUlSRVNfVkVSU0lPTiwgUkVTVUxUU19NRVRIT0RTLCBTSU1QTEVfQVRUUlMsIGJpb1VyaUFyZ3MsIGNvbkF0dHJzLCBjb25TdHIsIGNvblRvSlNPTiwgY29uVmFsU3RyLCBjb25jYXRNYXAsIGNvcHlDb24sIGRlY2FwaXRhdGUsIGRpZG50UmVtb3ZlLCBmLCBmaWx0ZXIsIGZvbGQsIGdldCwgZ2V0X2Nhbm9uaWNhbF9vcCwgaGVhZExlc3MsIGlkLCBpZENvblN0ciwgaW50ZXJtaW5lLCBpbnRlcnByZXRDb25BcnJheSwgaW50ZXJwcmV0Q29uc3RyYWludCwgaW52b2tlLCBtZXJnZSwgbXRoLCBtdWx0aUNvblN0ciwgbm9VbmRlZlZhbHMsIG5vVmFsdWVDb25TdHIsIHBhcnRpdGlvbiwgcmVtb3ZlSXJyZWxldmFudFNvcnRPcmRlcnMsIHNpbXBsZUNvblN0ciwgc3RyaW5nVG9Tb3J0T3JkZXIsIHN0cmluZ2lmeVNvcnRPcmRlciwgdG9RdWVyeVN0cmluZywgdHlwZUNvblN0ciwgdW5pb24sIHV0aWxzLCB3aXRoQ0IsIF9mbiwgX2dldF9kYXRhX2ZldGNoZXIsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYsXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH0sXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcbiAgICBfX3NsaWNlID0gW10uc2xpY2UsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgRXZlbnRzID0gX2RlcmVxXygnYmFja2JvbmUtZXZlbnRzLXN0YW5kYWxvbmUnKTtcblxuICBpbnRlcm1pbmUgPSBleHBvcnRzO1xuXG4gIGludGVybWluZS54bWwgPSBfZGVyZXFfKCcuL3htbCcpO1xuXG4gIHV0aWxzID0gX2RlcmVxXygnLi91dGlsJyk7XG5cbiAgUkVRVUlSRVNfVkVSU0lPTiA9IHV0aWxzLlJFUVVJUkVTX1ZFUlNJT04sIHdpdGhDQiA9IHV0aWxzLndpdGhDQiwgbWVyZ2UgPSB1dGlscy5tZXJnZSwgZmlsdGVyID0gdXRpbHMuZmlsdGVyLCBwYXJ0aXRpb24gPSB1dGlscy5wYXJ0aXRpb24sIGZvbGQgPSB1dGlscy5mb2xkLCBjb25jYXRNYXAgPSB1dGlscy5jb25jYXRNYXAsIGlkID0gdXRpbHMuaWQsIGdldCA9IHV0aWxzLmdldCwgaW52b2tlID0gdXRpbHMuaW52b2tlO1xuXG4gIHRvUXVlcnlTdHJpbmcgPSB1dGlscy5xdWVyeXN0cmluZztcblxuICBnZXRfY2Fub25pY2FsX29wID0gZnVuY3Rpb24ob3JpZykge1xuICAgIHZhciBjYW5vbmljYWw7XG4gICAgY2Fub25pY2FsID0gKG9yaWcgIT0gbnVsbCA/IG9yaWcudG9Mb3dlckNhc2UgOiB2b2lkIDApICE9IG51bGwgPyBRdWVyeS5PUF9ESUNUW29yaWcudG9Mb3dlckNhc2UoKV0gOiBudWxsO1xuICAgIGlmICghY2Fub25pY2FsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGNvbnN0cmFpbnQgb3BlcmF0b3I6IFwiICsgb3JpZyk7XG4gICAgfVxuICAgIHJldHVybiBjYW5vbmljYWw7XG4gIH07XG5cbiAgQkFTSUNfQVRUUlMgPSBbJ3BhdGgnLCAnb3AnLCAnY29kZSddO1xuXG4gIFNJTVBMRV9BVFRSUyA9IEJBU0lDX0FUVFJTLmNvbmNhdChbJ3ZhbHVlJywgJ2V4dHJhVmFsdWUnXSk7XG5cbiAgUkVTVUxUU19NRVRIT0RTID0gWydyb3dCeVJvdycsICdlYWNoUm93JywgJ3JlY29yZEJ5UmVjb3JkJywgJ2VhY2hSZWNvcmQnLCAncmVjb3JkcycsICdyb3dzJywgJ3RhYmxlJywgJ3RhYmxlUm93cycsICd2YWx1ZXMnXTtcblxuICBMSVNUX1BJUEUgPSBmdW5jdGlvbihzZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbXBvc2Uoc2VydmljZS5mZXRjaExpc3QsIGdldCgnbGlzdE5hbWUnKSk7XG4gIH07XG5cbiAgQ09ERVMgPSBbJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWiddO1xuXG4gIGRlY2FwaXRhdGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgeCA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4geC5zdWJzdHIoeC5pbmRleE9mKCcuJykpO1xuICB9O1xuXG4gIGNvblZhbFN0ciA9IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAodiAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gXCI8dmFsdWU+XCIgKyAodXRpbHMuZXNjYXBlKHYpKSArIFwiPC92YWx1ZT5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiPG51bGxWYWx1ZS8+XCI7XG4gICAgfVxuICB9O1xuXG4gIGNvbkF0dHJzID0gZnVuY3Rpb24oYywgbmFtZXMpIHtcbiAgICB2YXIgaywgdjtcbiAgICByZXR1cm4gKChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVzdWx0cztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKGsgaW4gYykge1xuICAgICAgICB2ID0gY1trXTtcbiAgICAgICAgaWYgKChfX2luZGV4T2YuY2FsbChuYW1lcywgaykgPj0gMCkpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKFwiXCIgKyBrICsgXCI9XFxcIlwiICsgKHV0aWxzLmVzY2FwZSh2KSkgKyBcIlxcXCIgXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSkoKSkuam9pbignJyk7XG4gIH07XG5cbiAgbm9WYWx1ZUNvblN0ciA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gXCI8Y29uc3RyYWludCBcIiArIChjb25BdHRycyhjLCBCQVNJQ19BVFRSUykpICsgXCIvPlwiO1xuICB9O1xuXG4gIHR5cGVDb25TdHIgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIFwiPGNvbnN0cmFpbnQgXCIgKyAoY29uQXR0cnMoYywgWydwYXRoJywgJ3R5cGUnXSkpICsgXCIvPlwiO1xuICB9O1xuXG4gIHNpbXBsZUNvblN0ciA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gXCI8Y29uc3RyYWludCBcIiArIChjb25BdHRycyhjLCBTSU1QTEVfQVRUUlMpKSArIFwiLz5cIjtcbiAgfTtcblxuICBtdWx0aUNvblN0ciA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gXCI8Y29uc3RyYWludCBcIiArIChjb25BdHRycyhjLCBCQVNJQ19BVFRSUykpICsgXCI+XCIgKyAoY29uY2F0TWFwKGNvblZhbFN0cikoYy52YWx1ZXMpKSArIFwiPC9jb25zdHJhaW50PlwiO1xuICB9O1xuXG4gIGlkQ29uU3RyID0gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBcIjxjb25zdHJhaW50IFwiICsgKGNvbkF0dHJzKGMsIEJBU0lDX0FUVFJTKSkgKyBcImlkcz1cXFwiXCIgKyAoYy5pZHMuam9pbignLCcpKSArIFwiXFxcIi8+XCI7XG4gIH07XG5cbiAgY29uU3RyID0gZnVuY3Rpb24oYykge1xuICAgIHZhciBfcmVmO1xuICAgIGlmIChjLnZhbHVlcyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbXVsdGlDb25TdHIoYyk7XG4gICAgfSBlbHNlIGlmIChjLmlkcyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gaWRDb25TdHIoYyk7XG4gICAgfSBlbHNlIGlmIChjLm9wID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0eXBlQ29uU3RyKGMpO1xuICAgIH0gZWxzZSBpZiAoX3JlZiA9IGMub3AsIF9faW5kZXhPZi5jYWxsKFF1ZXJ5Lk5VTExfT1BTLCBfcmVmKSA+PSAwKSB7XG4gICAgICByZXR1cm4gbm9WYWx1ZUNvblN0cihjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNpbXBsZUNvblN0cihjKTtcbiAgICB9XG4gIH07XG5cbiAgaGVhZExlc3MgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlteXFwuXStcXC4vLCAnJyk7XG4gIH07XG5cbiAgY29weUNvbiA9IGZ1bmN0aW9uKGNvbikge1xuICAgIHZhciBjb2RlLCBlZGl0YWJsZSwgZXh0cmFWYWx1ZSwgaWRzLCBvcCwgcGF0aCwgc3dpdGNoYWJsZSwgc3dpdGNoZWQsIHR5cGUsIHZhbHVlLCB2YWx1ZXM7XG4gICAgcGF0aCA9IGNvbi5wYXRoLCB0eXBlID0gY29uLnR5cGUsIG9wID0gY29uLm9wLCB2YWx1ZSA9IGNvbi52YWx1ZSwgdmFsdWVzID0gY29uLnZhbHVlcywgZXh0cmFWYWx1ZSA9IGNvbi5leHRyYVZhbHVlLCBpZHMgPSBjb24uaWRzLCBjb2RlID0gY29uLmNvZGUsIGVkaXRhYmxlID0gY29uLmVkaXRhYmxlLCBzd2l0Y2hlZCA9IGNvbi5zd2l0Y2hlZCwgc3dpdGNoYWJsZSA9IGNvbi5zd2l0Y2hhYmxlO1xuICAgIGlkcyA9IGlkcyAhPSBudWxsID8gaWRzLnNsaWNlKCkgOiB2b2lkIDA7XG4gICAgdmFsdWVzID0gdmFsdWVzICE9IG51bGwgPyB2YWx1ZXMuc2xpY2UoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbm9VbmRlZlZhbHMoe1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBvcDogb3AsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgIGV4dHJhVmFsdWU6IGV4dHJhVmFsdWUsXG4gICAgICBpZHM6IGlkcyxcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICBlZGl0YWJsZTogZWRpdGFibGUsXG4gICAgICBzd2l0Y2hlZDogc3dpdGNoZWQsXG4gICAgICBzd2l0Y2hhYmxlOiBzd2l0Y2hhYmxlXG4gICAgfSk7XG4gIH07XG5cbiAgY29uVG9KU09OID0gZnVuY3Rpb24oY29uKSB7XG4gICAgdmFyIGNvcHk7XG4gICAgY29weSA9IGNvcHlDb24oY29uKTtcbiAgICBjb3B5LnBhdGggPSBoZWFkTGVzcyhjb3B5LnBhdGgpO1xuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gIG5vVW5kZWZWYWxzID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBrLCB2O1xuICAgIGZvciAoayBpbiB4KSB7XG4gICAgICB2ID0geFtrXTtcbiAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHhba107XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9O1xuXG4gIGRpZG50UmVtb3ZlID0gZnVuY3Rpb24ob3JpZywgcmVkdWNlZCkge1xuICAgIHJldHVybiBcIkRpZCBub3QgcmVtb3ZlIGEgc2luZ2xlIGNvbnN0cmFpbnQuIG9yaWdpbmFsID0gXCIgKyBvcmlnICsgXCIsIHJlZHVjZWQgPSBcIiArIHJlZHVjZWQ7XG4gIH07XG5cbiAgaW50ZXJwcmV0Q29uc3RyYWludCA9IGZ1bmN0aW9uKHBhdGgsIGNvbikge1xuICAgIHZhciBjb25zdHJhaW50LCBrLCBrZXlzLCB2LCB4LCBfcmVmLCBfcmVmMTtcbiAgICBjb25zdHJhaW50ID0ge1xuICAgICAgcGF0aDogcGF0aFxuICAgIH07XG4gICAgaWYgKGNvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3RyYWludC5vcCA9ICdJUyBOVUxMJztcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoY29uKSkge1xuICAgICAgY29uc3RyYWludC5vcCA9ICdPTkUgT0YnO1xuICAgICAgY29uc3RyYWludC52YWx1ZXMgPSBjb247XG4gICAgfSBlbHNlIGlmICgoX3JlZiA9IHR5cGVvZiBjb24pID09PSAnc3RyaW5nJyB8fCBfcmVmID09PSAnbnVtYmVyJyB8fCBfcmVmID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGlmIChfcmVmMSA9IHR5cGVvZiBjb24udG9VcHBlckNhc2UgPT09IFwiZnVuY3Rpb25cIiA/IGNvbi50b1VwcGVyQ2FzZSgpIDogdm9pZCAwLCBfX2luZGV4T2YuY2FsbChRdWVyeS5OVUxMX09QUywgX3JlZjEpID49IDApIHtcbiAgICAgICAgY29uc3RyYWludC5vcCA9IGNvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0cmFpbnQub3AgPSAnPSc7XG4gICAgICAgIGNvbnN0cmFpbnQudmFsdWUgPSBjb247XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrIGluIGNvbikge1xuICAgICAgICAgIHggPSBjb25ba107XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKGtleXMsICdpc2EnKSA+PSAwKSB7XG4gICAgICAgIGlmICh1dGlscy5pc0FycmF5KGNvbi5pc2EpKSB7XG4gICAgICAgICAgY29uc3RyYWludC5vcCA9IGs7XG4gICAgICAgICAgY29uc3RyYWludC52YWx1ZXMgPSBjb24uaXNhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0cmFpbnQudHlwZSA9IGNvbi5pc2E7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChrZXlzLCAnZXh0cmFWYWx1ZScpID49IDApIHtcbiAgICAgICAgICBjb25zdHJhaW50LmV4dHJhVmFsdWUgPSBjb24uZXh0cmFWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGsgaW4gY29uKSB7XG4gICAgICAgICAgdiA9IGNvbltrXTtcbiAgICAgICAgICBpZiAoIShrICE9PSAnZXh0cmFWYWx1ZScpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3RyYWludC5vcCA9IGs7XG4gICAgICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQudmFsdWVzID0gdjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3RyYWludC52YWx1ZSA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50O1xuICB9O1xuXG4gIGludGVycHJldENvbkFycmF5ID0gZnVuY3Rpb24oY29uQXJncykge1xuICAgIHZhciBhMCwgY29uc3RyYWludCwgdiwgX3JlZjtcbiAgICBjb25BcmdzID0gY29uQXJncy5zbGljZSgpO1xuICAgIGNvbnN0cmFpbnQgPSB7XG4gICAgICBwYXRoOiBjb25BcmdzLnNoaWZ0KClcbiAgICB9O1xuICAgIGlmIChjb25BcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgYTAgPSBjb25BcmdzWzBdO1xuICAgICAgaWYgKF9yZWYgPSB0eXBlb2YgYTAudG9VcHBlckNhc2UgPT09IFwiZnVuY3Rpb25cIiA/IGEwLnRvVXBwZXJDYXNlKCkgOiB2b2lkIDAsIF9faW5kZXhPZi5jYWxsKFF1ZXJ5Lk5VTExfT1BTLCBfcmVmKSA+PSAwKSB7XG4gICAgICAgIGNvbnN0cmFpbnQub3AgPSBhMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0cmFpbnQudHlwZSA9IGEwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29uQXJncy5sZW5ndGggPj0gMikge1xuICAgICAgY29uc3RyYWludC5vcCA9IGNvbkFyZ3NbMF07XG4gICAgICB2ID0gY29uQXJnc1sxXTtcbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHYpKSB7XG4gICAgICAgIGNvbnN0cmFpbnQudmFsdWVzID0gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0cmFpbnQudmFsdWUgPSB2O1xuICAgICAgfVxuICAgICAgaWYgKGNvbkFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNvbnN0cmFpbnQuZXh0cmFWYWx1ZSA9IGNvbkFyZ3NbMl07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50O1xuICB9O1xuXG4gIHN0cmluZ2lmeVNvcnRPcmRlciA9IGZ1bmN0aW9uKHNvcnRPcmRlcikge1xuICAgIHZhciBvZTtcbiAgICByZXR1cm4gKChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBzb3J0T3JkZXIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgb2UgPSBzb3J0T3JkZXJbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKFwiXCIgKyBvZS5wYXRoICsgXCIgXCIgKyBvZS5kaXJlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pKCkpLmpvaW4oJyAnKTtcbiAgfTtcblxuICBzdHJpbmdUb1NvcnRPcmRlciA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBpLCBwYXJ0cywgcGF0aEluZGljZXMsIHgsIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICBpZiAoc3RyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcGFydHMgPSBzdHIuc3BsaXQoL1xccysvKTtcbiAgICBwYXRoSW5kaWNlcyA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfaSwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yICh4ID0gX2kgPSAwLCBfcmVmID0gcGFydHMubGVuZ3RoIC8gMjsgMCA8PSBfcmVmID8gX2kgPCBfcmVmIDogX2kgPiBfcmVmOyB4ID0gMCA8PSBfcmVmID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh4ICogMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSkoKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcGF0aEluZGljZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGkgPSBwYXRoSW5kaWNlc1tfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKFtwYXJ0c1tpXSwgcGFydHNbaSArIDFdXSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICByZW1vdmVJcnJlbGV2YW50U29ydE9yZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvZSwgb2xkT3JkZXI7XG4gICAgb2xkT3JkZXIgPSB0aGlzLnNvcnRPcmRlcjtcbiAgICB0aGlzLnNvcnRPcmRlciA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBvbGRPcmRlci5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBvZSA9IG9sZE9yZGVyW19pXTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWxldmFudChvZS5wYXRoKSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gob2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgICBpZiAob2xkT3JkZXIubGVuZ3RoICE9PSB0aGlzLnNvcnRPcmRlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpzb3J0b3JkZXIgY2hhbmdlOm9yZGVyYnknLCB0aGlzLnNvcnRPcmRlci5zbGljZSgpKTtcbiAgICB9XG4gIH07XG5cbiAgUXVlcnkgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFkZFBJLCBjQXR0cnMsIGtpZHMsIHBhcnNlU3VtbWFyeSwgcUF0dHJzLCBzY0ZvbGQsIHRvQXR0clBhaXJzLCB0b1BhdGhBbmRUeXBlLCB4bWxBdHRyO1xuXG4gICAgUXVlcnkuSk9JTl9TVFlMRVMgPSBbJ0lOTkVSJywgJ09VVEVSJ107XG5cbiAgICBRdWVyeS5CSU9fRk9STUFUUyA9IFsnZ2ZmMycsICdmYXN0YScsICdiZWQnXTtcblxuICAgIFF1ZXJ5Lk5VTExfT1BTID0gWydJUyBOVUxMJywgJ0lTIE5PVCBOVUxMJ107XG5cbiAgICBRdWVyeS5BVFRSSUJVVEVfVkFMVUVfT1BTID0gW1wiPVwiLCBcIiE9XCIsIFwiPlwiLCBcIj49XCIsIFwiPFwiLCBcIjw9XCIsIFwiQ09OVEFJTlNcIiwgXCJMSUtFXCIsIFwiTk9UIExJS0VcIl07XG5cbiAgICBRdWVyeS5NVUxUSVZBTFVFX09QUyA9IFsnT05FIE9GJywgJ05PTkUgT0YnXTtcblxuICAgIFF1ZXJ5LlJBTkdFX09QUyA9IFsnT1ZFUkxBUFMnLCAnRE9FUyBOT1QgT1ZFUkxBUCcsICdPVVRTSURFJywgJ1dJVEhJTicsICdDT05UQUlOUycsICdET0VTIE5PVCBDT05UQUlOJ107XG5cbiAgICBRdWVyeS5URVJOQVJZX09QUyA9IFsnTE9PS1VQJ107XG5cbiAgICBRdWVyeS5MT09QX09QUyA9IFsnPScsICchPSddO1xuXG4gICAgUXVlcnkuTElTVF9PUFMgPSBbJ0lOJywgJ05PVCBJTiddO1xuXG4gICAgUXVlcnkuT1BfRElDVCA9IHtcbiAgICAgICc9JzogJz0nLFxuICAgICAgJz09JzogJz09JyxcbiAgICAgICdlcSc6ICc9JyxcbiAgICAgICdlcXEnOiAnPT0nLFxuICAgICAgJyE9JzogJyE9JyxcbiAgICAgICduZSc6ICchPScsXG4gICAgICAnPic6ICc+JyxcbiAgICAgICdndCc6ICc+JyxcbiAgICAgICc+PSc6ICc+PScsXG4gICAgICAnZ2UnOiAnPj0nLFxuICAgICAgJzwnOiAnPCcsXG4gICAgICAnbHQnOiAnPCcsXG4gICAgICAnPD0nOiAnPD0nLFxuICAgICAgJ2xlJzogJzw9JyxcbiAgICAgICdjb250YWlucyc6ICdDT05UQUlOUycsXG4gICAgICAnQ09OVEFJTlMnOiAnQ09OVEFJTlMnLFxuICAgICAgJ2RvZXMgbm90IGNvbnRhaW4nOiAnRE9FUyBOT1QgQ09OVEFJTicsXG4gICAgICAnRE9FUyBOT1QgQ09OVEFJTic6ICdET0VTIE5PVCBDT05UQUlOJyxcbiAgICAgICdsaWtlJzogJ0xJS0UnLFxuICAgICAgJ0xJS0UnOiAnTElLRScsXG4gICAgICAnbm90IGxpa2UnOiAnTk9UIExJS0UnLFxuICAgICAgJ05PVCBMSUtFJzogJ05PVCBMSUtFJyxcbiAgICAgICdsb29rdXAnOiAnTE9PS1VQJyxcbiAgICAgICdJUyBOVUxMJzogJ0lTIE5VTEwnLFxuICAgICAgJ2lzIG51bGwnOiAnSVMgTlVMTCcsXG4gICAgICAnSVMgTk9UIE5VTEwnOiAnSVMgTk9UIE5VTEwnLFxuICAgICAgJ2lzIG5vdCBudWxsJzogJ0lTIE5PVCBOVUxMJyxcbiAgICAgICdPTkUgT0YnOiAnT05FIE9GJyxcbiAgICAgICdvbmUgb2YnOiAnT05FIE9GJyxcbiAgICAgICdOT05FIE9GJzogJ05PTkUgT0YnLFxuICAgICAgJ25vbmUgb2YnOiAnTk9ORSBPRicsXG4gICAgICAnaW4nOiAnSU4nLFxuICAgICAgJ25vdCBpbic6ICdOT1QgSU4nLFxuICAgICAgJ0lOJzogJ0lOJyxcbiAgICAgICdOT1QgSU4nOiAnTk9UIElOJyxcbiAgICAgICdXSVRISU4nOiAnV0lUSElOJyxcbiAgICAgICd3aXRoaW4nOiAnV0lUSElOJyxcbiAgICAgICdPVkVSTEFQUyc6ICdPVkVSTEFQUycsXG4gICAgICAnb3ZlcmxhcHMnOiAnT1ZFUkxBUFMnLFxuICAgICAgJ0RPRVMgTk9UIE9WRVJMQVAnOiAnRE9FUyBOT1QgT1ZFUkxBUCcsXG4gICAgICAnZG9lcyBub3Qgb3ZlcmxhcCc6ICdET0VTIE5PVCBPVkVSTEFQJyxcbiAgICAgICdPVVRTSURFJzogJ09VVFNJREUnLFxuICAgICAgJ291dHNpZGUnOiAnT1VUU0lERScsXG4gICAgICAnSVNBJzogJ0lTQScsXG4gICAgICAnaXNhJzogJ0lTQSdcbiAgICB9O1xuXG4gICAgcUF0dHJzID0gWyduYW1lJywgJ3ZpZXcnLCAnc29ydE9yZGVyJywgJ2NvbnN0cmFpbnRMb2dpYycsICd0aXRsZScsICdkZXNjcmlwdGlvbicsICdjb21tZW50J107XG5cbiAgICBjQXR0cnMgPSBbJ3BhdGgnLCAndHlwZScsICdvcCcsICdjb2RlJywgJ3ZhbHVlJywgJ2lkcyddO1xuXG4gICAgdG9BdHRyUGFpcnMgPSBmdW5jdGlvbihlbCwgYXR0cnMpIHtcbiAgICAgIHZhciB4LCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBhdHRycy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB4ID0gYXR0cnNbX2ldO1xuICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKHgpKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChbeCwgZWwuZ2V0QXR0cmlidXRlKHgpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAga2lkcyA9IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgICB2YXIga2lkLCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBfcmVmID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSk7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGtpZCA9IF9yZWZbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGtpZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIHhtbEF0dHIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIFF1ZXJ5LmZyb21YTUwgPSBmdW5jdGlvbih4bWwpIHtcbiAgICAgIHZhciBjb24sIGRvbSwgaiwgcGF0aE9mLCBxLCBxdWVyeSwgc3R5bGVPZjtcbiAgICAgIGRvbSA9IGludGVybWluZS54bWwucGFyc2UoeG1sKTtcbiAgICAgIHF1ZXJ5ID0ga2lkcyhkb20sICdxdWVyeScpWzBdIHx8IGtpZHMoZG9tLCAndGVtcGxhdGUnKVswXTtcbiAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gcXVlcnkgaW4geG1sXCIpO1xuICAgICAgfVxuICAgICAgcGF0aE9mID0geG1sQXR0cigncGF0aCcpO1xuICAgICAgc3R5bGVPZiA9IHhtbEF0dHIoJ3N0eWxlJyk7XG4gICAgICBxID0gdXRpbHMucGFpcnNUb09iaih0b0F0dHJQYWlycyhxdWVyeSwgcUF0dHJzKSk7XG4gICAgICBxLnZpZXcgPSBxLnZpZXcuc3BsaXQoL1xccysvKTtcbiAgICAgIHEuc29ydE9yZGVyID0gc3RyaW5nVG9Tb3J0T3JkZXIocS5zb3J0T3JkZXIpO1xuICAgICAgcS5qb2lucyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IGtpZHMocXVlcnksICdqb2luJyk7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGogPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAoc3R5bGVPZihqKSA9PT0gJ09VVEVSJykge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChwYXRoT2YoaikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpO1xuICAgICAgcS5jb25zdHJhaW50cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IGtpZHMocXVlcnksICdjb25zdHJhaW50Jyk7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGNvbiA9IF9yZWZbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goKGZ1bmN0aW9uKGNvbikge1xuICAgICAgICAgICAgdmFyIGMsIHRuLCB2LCB2YWx1ZXMsIHg7XG4gICAgICAgICAgICBjID0gdXRpbHMucGFpcnNUb09iaih0b0F0dHJQYWlycyhjb24sIGNBdHRycykpO1xuICAgICAgICAgICAgaWYgKGMuaWRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgYy5pZHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3JlZjEsIF9yZXN1bHRzMTtcbiAgICAgICAgICAgICAgICBfcmVmMSA9IGMuaWRzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICAgICAgICB4ID0gX3JlZjFbX2pdO1xuICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2gocGFyc2VJbnQoeCwgMTApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcyA9IGtpZHMoY29uLCAndmFsdWUnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGMudmFsdWVzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZXN1bHRzMTtcbiAgICAgICAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSB2YWx1ZXMubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICAgICAgICB2ID0gdmFsdWVzW19qXTtcbiAgICAgICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaywgX2xlbjIsIF9yZWYxLCBfcmVzdWx0czI7XG4gICAgICAgICAgICAgICAgICAgIF9yZWYxID0gdi5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICBfcmVzdWx0czIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfayA9IDAsIF9sZW4yID0gX3JlZjEubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG4gPSBfcmVmMVtfa107XG4gICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMyLnB1c2godG4uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMjtcbiAgICAgICAgICAgICAgICAgIH0pKCkpLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgIH0pKGNvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCk7XG4gICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmNvbnN0cmFpbnRzID0gW107XG5cbiAgICBRdWVyeS5wcm90b3R5cGUudmlld3MgPSBbXTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5qb2lucyA9IHt9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmNvbnN0cmFpbnRMb2dpYyA9ICcnO1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnNvcnRPcmRlciA9ICcnO1xuXG4gICAgUXVlcnkucHJvdG90eXBlLm5hbWUgPSBudWxsO1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnRpdGxlID0gbnVsbDtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5jb21tZW50ID0gbnVsbDtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBRdWVyeShwcm9wZXJ0aWVzLCBzZXJ2aWNlLCBfYXJnKSB7XG4gICAgICB2YXIgbW9kZWwsIHByb3AsIHN1bW1hcnlGaWVsZHMsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3JlZjEwLCBfcmVmMiwgX3JlZjMsIF9yZWY0LCBfcmVmNSwgX3JlZjYsIF9yZWY3LCBfcmVmOCwgX3JlZjk7XG4gICAgICBfcmVmID0gX2FyZyAhPSBudWxsID8gX2FyZyA6IHt9LCBtb2RlbCA9IF9yZWYubW9kZWwsIHN1bW1hcnlGaWVsZHMgPSBfcmVmLnN1bW1hcnlGaWVsZHM7XG4gICAgICB0aGlzLmFkZENvbnN0cmFpbnQgPSBfX2JpbmQodGhpcy5hZGRDb25zdHJhaW50LCB0aGlzKTtcbiAgICAgIHRoaXMuZXhwYW5kU3RhciA9IF9fYmluZCh0aGlzLmV4cGFuZFN0YXIsIHRoaXMpO1xuICAgICAgdGhpcy5hZGp1c3RQYXRoID0gX19iaW5kKHRoaXMuYWRqdXN0UGF0aCwgdGhpcyk7XG4gICAgICB0aGlzLnNlbGVjdCA9IF9fYmluZCh0aGlzLnNlbGVjdCwgdGhpcyk7XG4gICAgICBpZiAocHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcbiAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgIHRoaXMuam9pbnMgPSB7fTtcbiAgICAgIHRoaXMuZGlzcGxheU5hbWVzID0gdXRpbHMuY29weSgoX3JlZjEgPSAoX3JlZjIgPSBwcm9wZXJ0aWVzLmRpc3BsYXlOYW1lcykgIT0gbnVsbCA/IF9yZWYyIDogcHJvcGVydGllcy5hbGlhc2VzKSAhPSBudWxsID8gX3JlZjEgOiB7fSk7XG4gICAgICBfcmVmMyA9IFsnbmFtZScsICd0aXRsZScsICdjb21tZW50JywgJ2Rlc2NyaXB0aW9uJywgJ3R5cGUnXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcCA9IF9yZWYzW19pXTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXNbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXNbcHJvcF0gPSBwcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlICE9IG51bGwgPyBzZXJ2aWNlIDoge307XG4gICAgICB0aGlzLm1vZGVsID0gKF9yZWY0ID0gbW9kZWwgIT0gbnVsbCA/IG1vZGVsIDogcHJvcGVydGllcy5tb2RlbCkgIT0gbnVsbCA/IF9yZWY0IDoge307XG4gICAgICB0aGlzLnN1bW1hcnlGaWVsZHMgPSAoX3JlZjUgPSBzdW1tYXJ5RmllbGRzICE9IG51bGwgPyBzdW1tYXJ5RmllbGRzIDogcHJvcGVydGllcy5zdW1tYXJ5RmllbGRzKSAhPSBudWxsID8gX3JlZjUgOiB7fTtcbiAgICAgIHRoaXMucm9vdCA9IChfcmVmNiA9IHByb3BlcnRpZXMucm9vdCkgIT0gbnVsbCA/IF9yZWY2IDogcHJvcGVydGllcy5mcm9tO1xuICAgICAgdGhpcy5tYXhSb3dzID0gKF9yZWY3ID0gKF9yZWY4ID0gcHJvcGVydGllcy5zaXplKSAhPSBudWxsID8gX3JlZjggOiBwcm9wZXJ0aWVzLmxpbWl0KSAhPSBudWxsID8gX3JlZjcgOiBwcm9wZXJ0aWVzLm1heFJvd3M7XG4gICAgICB0aGlzLnN0YXJ0ID0gKF9yZWY5ID0gKF9yZWYxMCA9IHByb3BlcnRpZXMuc3RhcnQpICE9IG51bGwgPyBfcmVmMTAgOiBwcm9wZXJ0aWVzLm9mZnNldCkgIT0gbnVsbCA/IF9yZWY5IDogMDtcbiAgICAgIHRoaXMuc2VsZWN0KHByb3BlcnRpZXMudmlld3MgfHwgcHJvcGVydGllcy52aWV3IHx8IHByb3BlcnRpZXMuc2VsZWN0IHx8IFtdKTtcbiAgICAgIHRoaXMuYWRkQ29uc3RyYWludHMocHJvcGVydGllcy5jb25zdHJhaW50cyB8fCBwcm9wZXJ0aWVzLndoZXJlIHx8IFtdKTtcbiAgICAgIHRoaXMuYWRkSm9pbnMocHJvcGVydGllcy5qb2lucyB8fCBwcm9wZXJ0aWVzLmpvaW4gfHwgW10pO1xuICAgICAgdGhpcy5vcmRlckJ5KHByb3BlcnRpZXMuc29ydE9yZGVyIHx8IHByb3BlcnRpZXMub3JkZXJCeSB8fCBbXSk7XG4gICAgICBpZiAocHJvcGVydGllcy5jb25zdHJhaW50TG9naWMgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRMb2dpYyA9IHByb3BlcnRpZXMuY29uc3RyYWludExvZ2ljO1xuICAgICAgfVxuICAgICAgdGhpcy5vbignY2hhbmdlOnZpZXdzJywgcmVtb3ZlSXJyZWxldmFudFNvcnRPcmRlcnMsIHRoaXMpO1xuICAgIH1cblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5yZW1vdmVGcm9tU2VsZWN0ID0gZnVuY3Rpb24odW53YW50ZWQpIHtcbiAgICAgIHZhciBtYXBGbiwgc28sIHV3LCB2O1xuICAgICAgaWYgKHVud2FudGVkID09IG51bGwpIHtcbiAgICAgICAgdW53YW50ZWQgPSBbXTtcbiAgICAgIH1cbiAgICAgIHVud2FudGVkID0gdXRpbHMuc3RyaW5nTGlzdCh1bndhbnRlZCk7XG4gICAgICBtYXBGbiA9IHV0aWxzLmNvbXBvc2UodGhpcy5leHBhbmRTdGFyLCB0aGlzLmFkanVzdFBhdGgpO1xuICAgICAgdW53YW50ZWQgPSB1dGlscy5mbGF0dGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB1bndhbnRlZC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHV3ID0gdW53YW50ZWRbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobWFwRm4odXcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpKTtcbiAgICAgIHRoaXMuc29ydE9yZGVyID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMuc29ydE9yZGVyO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBzbyA9IF9yZWZbX2ldO1xuICAgICAgICAgIGlmICghKF9yZWYxID0gc28ucGF0aCwgX19pbmRleE9mLmNhbGwodW53YW50ZWQsIF9yZWYxKSA+PSAwKSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChzbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnZpZXdzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gdGhpcy52aWV3cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgdiA9IF9yZWZbX2ldO1xuICAgICAgICAgIGlmICghKF9faW5kZXhPZi5jYWxsKHVud2FudGVkLCB2KSA+PSAwKSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudHJpZ2dlcigncmVtb3ZlOnZpZXcnLCB1bndhbnRlZCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTp2aWV3cycsIHRoaXMudmlld3MpO1xuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignY2hhbmdlJywgdGhpcy52aWV3cyk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24oY29uLCBzaWxlbnQpIHtcbiAgICAgIHZhciBjLCBpc2Nvbiwgb3JpZywgcmVkdWNlZDtcbiAgICAgIGlmIChzaWxlbnQgPT0gbnVsbCkge1xuICAgICAgICBzaWxlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9yaWcgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgICAgaXNjb24gPSB0eXBlb2YgY29uID09PSAnc3RyaW5nJyA/IChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBjLmNvZGUgPT09IGNvbjtcbiAgICAgIH0pIDogKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIF9yZWYsIF9yZWYxO1xuICAgICAgICByZXR1cm4gKGMucGF0aCA9PT0gY29uLnBhdGgpICYmIChjLm9wID09PSBjb24ub3ApICYmIChjLnZhbHVlID09PSBjb24udmFsdWUpICYmIChjLmV4dHJhVmFsdWUgPT09IGNvbi5leHRyYVZhbHVlKSAmJiAoY29uLnR5cGUgPT09IGMudHlwZSkgJiYgKCgoX3JlZiA9IGMudmFsdWVzKSAhPSBudWxsID8gX3JlZi5qb2luKCclJScpIDogdm9pZCAwKSA9PT0gKChfcmVmMSA9IGNvbi52YWx1ZXMpICE9IG51bGwgPyBfcmVmMS5qb2luKCclJScpIDogdm9pZCAwKSk7XG4gICAgICB9KTtcbiAgICAgIHJlZHVjZWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gb3JpZy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGMgPSBvcmlnW19pXTtcbiAgICAgICAgICBpZiAoIWlzY29uKGMpKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpO1xuICAgICAgaWYgKHJlZHVjZWQubGVuZ3RoICE9PSBvcmlnLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRpZG50UmVtb3ZlKG9yaWcsIHJlZHVjZWQpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29uc3RyYWludHMgPSByZWR1Y2VkO1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6Y29uc3RyYWludHMnKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcigncmVtb3ZlZDpjb25zdHJhaW50JywgdXRpbHMuZmluZChvcmlnLCBpc2NvbikpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuYWRkVG9TZWxlY3QgPSBmdW5jdGlvbih2aWV3cywgb3B0cykge1xuICAgICAgdmFyIGR1cHMsIG1hcEZuLCBwLCB0b0FkZCwgdiwgeCwgX3JlZiwgX3JlZjE7XG4gICAgICBpZiAodmlld3MgPT0gbnVsbCkge1xuICAgICAgICB2aWV3cyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG4gICAgICB2aWV3cyA9IHV0aWxzLnN0cmluZ0xpc3Qodmlld3MpO1xuICAgICAgbWFwRm4gPSB1dGlscy5jb21wb3NlKHRoaXMuZXhwYW5kU3RhciwgdGhpcy5hZGp1c3RQYXRoKTtcbiAgICAgIHRvQWRkID0gdXRpbHMuZmxhdHRlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdmlld3MubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICB2ID0gdmlld3NbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobWFwRm4odikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpO1xuICAgICAgZHVwcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0b0FkZC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHAgPSB0b0FkZFtfaV07XG4gICAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKHRoaXMudmlld3MsIHApID49IDApIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gocCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICBpZiAoZHVwcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIgKyBkdXBzICsgXCIgYWxyZWFkeSBpbiB0aGUgc2VsZWN0IGxpc3RcIik7XG4gICAgICB9XG4gICAgICBkdXBzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHRvQWRkLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcCA9IHRvQWRkW19pXTtcbiAgICAgICAgICBpZiAoKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZXN1bHRzMTtcbiAgICAgICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gdG9BZGQubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICAgIHggPSB0b0FkZFtfal07XG4gICAgICAgICAgICAgIGlmICh4ID09PSBwKSB7XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2goeCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICAgICAgfSkoKSkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKTtcbiAgICAgIGlmIChkdXBzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIGR1cHMgKyBcIiBzcGVjaWZpZWQgbXVsdGlwbGUgdGltZXMgYXMgYXJndW1lbnRzIHRvIGFkZFRvU2VsZWN0XCIpO1xuICAgICAgfVxuICAgICAgKF9yZWYgPSB0aGlzLnZpZXdzKS5wdXNoLmFwcGx5KF9yZWYsIHRvQWRkKTtcbiAgICAgIGlmIChvcHRzLnNpbGVudCkge1xuICAgICAgICBvcHRzLmV2ZW50cyA9ICgoX3JlZjEgPSBvcHRzLmV2ZW50cykgIT0gbnVsbCA/IF9yZWYxIDogW10pLmNvbmNhdChbJ2NoYW5nZScsICdhZGQ6dmlldycsICdjaGFuZ2U6dmlld3MnXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2FkZDp2aWV3IGNoYW5nZTp2aWV3cycsIHRvQWRkKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24odmlld3MsIG9wdHMpIHtcbiAgICAgIHZhciBlLCBvbGRWaWV3cztcbiAgICAgIG9sZFZpZXdzID0gdGhpcy52aWV3cy5zbGljZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy52aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLmFkZFRvU2VsZWN0KHZpZXdzLCBvcHRzKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICB0aGlzLnZpZXdzID0gb2xkVmlld3M7XG4gICAgICAgIHV0aWxzLmVycm9yKGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5hZGp1c3RQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcGF0aCA9IHBhdGggJiYgcGF0aC5uYW1lID8gcGF0aC5uYW1lIDogXCJcIiArIHBhdGg7XG4gICAgICBpZiAodGhpcy5yb290ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCFwYXRoLm1hdGNoKFwiXlwiICsgdGhpcy5yb290KSkge1xuICAgICAgICAgIHBhdGggPSB0aGlzLnJvb3QgKyBcIi5cIiArIHBhdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHBhdGguc3BsaXQoJy4nKVswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0UG9zc2libGVQYXRocyA9IGZ1bmN0aW9uKGRlcHRoLCBhbGxvd1JldmVyc2VSZWZlcmVuY2VzLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBnZXRQYXRocywga2V5LCByZXQsIHRlc3QsIF9iYXNlO1xuICAgICAgaWYgKGRlcHRoID09IG51bGwpIHtcbiAgICAgICAgZGVwdGggPSAzO1xuICAgICAgfVxuICAgICAgaWYgKGFsbG93UmV2ZXJzZVJlZmVyZW5jZXMgPT0gbnVsbCkge1xuICAgICAgICBhbGxvd1JldmVyc2VSZWZlcmVuY2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVkaWNhdGUgPT0gbnVsbCkge1xuICAgICAgICBwcmVkaWNhdGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGVzdCA9IHR5cGVvZiBwcmVkaWNhdGUgPT09ICdzdHJpbmcnID8gZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gcFtwcmVkaWNhdGVdKCk7XG4gICAgICB9IDogcHJlZGljYXRlO1xuICAgICAgZ2V0UGF0aHMgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJvb3QsIGQpIHtcbiAgICAgICAgICB2YXIgY2QsIGZpZWxkLCBuYW1lLCBvdGhlcnMsIHBhdGgsIHN1YlBhdGhzO1xuICAgICAgICAgIHBhdGggPSBfdGhpcy5nZXRQYXRoSW5mbyhyb290KTtcbiAgICAgICAgICBpZiAoKCFhbGxvd1JldmVyc2VSZWZlcmVuY2VzKSAmJiBwYXRoLmlzUmV2ZXJzZVJlZmVyZW5jZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXRoLmlzQXR0cmlidXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbcGF0aF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNkID0gcGF0aC5nZXRUeXBlKCk7XG4gICAgICAgICAgICBzdWJQYXRocyA9IGNvbmNhdE1hcChmdW5jdGlvbihyZWYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFBhdGhzKFwiXCIgKyByb290ICsgXCIuXCIgKyByZWYubmFtZSwgZCAtIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdGhlcnMgPSBjZCAmJiAoZCA+IDApID8gc3ViUGF0aHMoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgICAgICAgIF9yZWYgPSBjZC5maWVsZHM7XG4gICAgICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAobmFtZSBpbiBfcmVmKSB7XG4gICAgICAgICAgICAgICAgZmllbGQgPSBfcmVmW25hbWVdO1xuICAgICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCkpIDogW107XG4gICAgICAgICAgICByZXR1cm4gW3BhdGhdLmNvbmNhdChvdGhlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAga2V5ID0gXCJcIiArIGRlcHRoICsgXCItXCIgKyBhbGxvd1JldmVyc2VSZWZlcmVuY2VzO1xuICAgICAgaWYgKHRoaXMuX3Bvc3NpYmxlUGF0aHMgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wb3NzaWJsZVBhdGhzID0ge307XG4gICAgICB9XG4gICAgICByZXQgPSAoKF9iYXNlID0gdGhpcy5fcG9zc2libGVQYXRocylba2V5XSAhPSBudWxsID8gX2Jhc2Vba2V5XSA6IF9iYXNlW2tleV0gPSBnZXRQYXRocyh0aGlzLnJvb3QsIGRlcHRoKSkuc2xpY2UoKTtcbiAgICAgIGlmICh0ZXN0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJldC5maWx0ZXIodGVzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0UGF0aEluZm8gPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICB2YXIgYWRqdXN0ZWQsIHBpLCBfcmVmO1xuICAgICAgYWRqdXN0ZWQgPSB0aGlzLmFkanVzdFBhdGgocGF0aCk7XG4gICAgICBwaSA9IChfcmVmID0gdGhpcy5tb2RlbCkgIT0gbnVsbCA/IHR5cGVvZiBfcmVmLmdldFBhdGhJbmZvID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmLmdldFBhdGhJbmZvKGFkanVzdGVkLCB0aGlzLmdldFN1YmNsYXNzZXMoKSkgOiB2b2lkIDAgOiB2b2lkIDA7XG4gICAgICBpZiAocGkgJiYgYWRqdXN0ZWQgaW4gdGhpcy5kaXNwbGF5TmFtZXMpIHtcbiAgICAgICAgcGkuZGlzcGxheU5hbWUgPSB0aGlzLmRpc3BsYXlOYW1lc1thZGp1c3RlZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5tYWtlUGF0aCA9IFF1ZXJ5LnByb3RvdHlwZS5nZXRQYXRoSW5mbztcblxuICAgIHRvUGF0aEFuZFR5cGUgPSBmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gW2MucGF0aCwgYy50eXBlXTtcbiAgICB9O1xuXG4gICAgc2NGb2xkID0gdXRpbHMuY29tcG9zZSh1dGlscy5wYWlyc1RvT2JqLCB1dGlscy5tYXAodG9QYXRoQW5kVHlwZSksIGZpbHRlcihnZXQoJ3R5cGUnKSkpO1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldFN1YmNsYXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzY0ZvbGQodGhpcy5jb25zdHJhaW50cyk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UGF0aEluZm8ocGF0aCkuZ2V0VHlwZSgpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0Vmlld05vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCwgdG9QYXJlbnROb2RlO1xuICAgICAgdG9QYXJlbnROb2RlID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmdldFBhdGhJbmZvKHYpLmdldFBhcmVudCgpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICByZXR1cm4gdXRpbHMudW5pcUJ5KFN0cmluZywgKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gdGhpcy52aWV3cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcCA9IF9yZWZbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godG9QYXJlbnROb2RlKHApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmlzSW5WaWV3ID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdmFyIHBpLCBwc3RyLCBfcmVmO1xuICAgICAgcGkgPSB0aGlzLmdldFBhdGhJbmZvKHBhdGgpO1xuICAgICAgaWYgKCFwaSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAocGkuaXNBdHRyaWJ1dGUoKSkge1xuICAgICAgICByZXR1cm4gX3JlZiA9IHBpLnRvU3RyaW5nKCksIF9faW5kZXhPZi5jYWxsKHRoaXMudmlld3MsIF9yZWYpID49IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwc3RyID0gcGkudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmFueSh0aGlzLmdldFZpZXdOb2RlcygpLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG4udG9TdHJpbmcoKSA9PT0gcHN0cjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5pc0NvbnN0cmFpbmVkID0gZnVuY3Rpb24ocGF0aCwgaW5jbHVkZUF0dHJzKSB7XG4gICAgICB2YXIgcGksIHRlc3Q7XG4gICAgICBpZiAoaW5jbHVkZUF0dHJzID09IG51bGwpIHtcbiAgICAgICAgaW5jbHVkZUF0dHJzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBwaSA9IHRoaXMuZ2V0UGF0aEluZm8ocGF0aCk7XG4gICAgICBpZiAoIXBpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXRoKTtcbiAgICAgIH1cbiAgICAgIHRlc3QgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiAoYy5vcCAhPSBudWxsKSAmJiBjLnBhdGggPT09IHBpLnRvU3RyaW5nKCk7XG4gICAgICB9O1xuICAgICAgaWYgKCghcGkuaXNBdHRyaWJ1dGUoKSkgJiYgaW5jbHVkZUF0dHJzKSB7XG4gICAgICAgIHRlc3QgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgcmV0dXJuIChjLm9wICE9IG51bGwpICYmIChjLnBhdGggPT09IHBpLnRvU3RyaW5nKCkgfHwgcGkuZXF1YWxzKF90aGlzLmdldFBhdGhJbmZvKGMucGF0aCkuZ2V0UGFyZW50KCkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1dGlscy5hbnkodGhpcy5jb25zdHJhaW50cywgdGVzdCk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5jYW5IYXZlTXVsdGlwbGVWYWx1ZXMgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQYXRoSW5mbyhwYXRoKS5jb250YWluc0NvbGxlY3Rpb24oKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldFF1ZXJ5Tm9kZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjLCBjb25zdHJhaW5lZE5vZGVzLCBwaSwgdmlld05vZGVzO1xuICAgICAgdmlld05vZGVzID0gdGhpcy5nZXRWaWV3Tm9kZXMoKTtcbiAgICAgIGNvbnN0cmFpbmVkTm9kZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBjID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKCEoYy50eXBlID09IG51bGwpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGkgPSB0aGlzLmdldFBhdGhJbmZvKGMucGF0aCk7XG4gICAgICAgICAgaWYgKHBpLmlzQXR0cmlidXRlKCkpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gocGkuZ2V0UGFyZW50KCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB1dGlscy51bmlxQnkoU3RyaW5nLCB2aWV3Tm9kZXMuY29uY2F0KGNvbnN0cmFpbmVkTm9kZXMpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmlzSW5RdWVyeSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBjLCBwaSwgcHN0ciwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBwaSA9IHRoaXMuZ2V0UGF0aEluZm8ocCk7XG4gICAgICBpZiAocGkpIHtcbiAgICAgICAgcHN0ciA9IHBpLnRvUGF0aFN0cmluZygpO1xuICAgICAgICBfcmVmID0gdGhpcy52aWV3cy5jb25jYXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaiwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZiA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaiA8IF9sZW47IF9qKyspIHtcbiAgICAgICAgICAgIGMgPSBfcmVmW19qXTtcbiAgICAgICAgICAgIGlmIChjLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGMucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKSk7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHAgPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAoMCA9PT0gcC5pbmRleE9mKHBzdHIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5pc1JlbGV2YW50ID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdmFyIG5vZGVzLCBwaSwgc291Z2h0O1xuICAgICAgcGkgPSB0aGlzLmdldFBhdGhJbmZvKHBhdGgpO1xuICAgICAgaWYgKHBpLmlzQXR0cmlidXRlKCkpIHtcbiAgICAgICAgcGkgPSBwaS5nZXRQYXJlbnQoKTtcbiAgICAgIH1cbiAgICAgIHNvdWdodCA9IHBpLnRvU3RyaW5nKCk7XG4gICAgICBub2RlcyA9IHRoaXMuZ2V0Vmlld05vZGVzKCk7XG4gICAgICByZXR1cm4gdXRpbHMuYW55KG5vZGVzLCBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBuLnRvUGF0aFN0cmluZygpID09PSBzb3VnaHQ7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmV4cGFuZFN0YXIgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICB2YXIgYXR0clZpZXdzLCBjZCwgZXhwYW5kLCBmbiwgbiwgbmFtZSwgcGF0aFN0ZW0sIHN0YXJWaWV3cztcbiAgICAgIGlmICgvXFwqJC8udGVzdChwYXRoKSkge1xuICAgICAgICBwYXRoU3RlbSA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGFzdEluZGV4T2YoJy4nKSk7XG4gICAgICAgIGV4cGFuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aFN0ZW0gKyB4O1xuICAgICAgICB9O1xuICAgICAgICBjZCA9IHRoaXMuZ2V0VHlwZShwYXRoU3RlbSk7XG4gICAgICAgIGlmICgvXFwuXFwqJC8udGVzdChwYXRoKSkge1xuICAgICAgICAgIGlmIChjZCAmJiB0aGlzLnN1bW1hcnlGaWVsZHNbY2QubmFtZV0pIHtcbiAgICAgICAgICAgIGZuID0gdXRpbHMuY29tcG9zZShleHBhbmQsIGRlY2FwaXRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgICAgICAgX3JlZiA9IHRoaXMuc3VtbWFyeUZpZWxkc1tjZC5uYW1lXTtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbiA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNWaWV3KG4pKSB7XG4gICAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGZuKG4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcLlxcKlxcKiQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICBzdGFyVmlld3MgPSB0aGlzLmV4cGFuZFN0YXIocGF0aFN0ZW0gKyAnLionKTtcbiAgICAgICAgICBhdHRyVmlld3MgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIGNkLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChleHBhbmQoXCIuXCIgKyBuYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgICByZXR1cm4gdXRpbHMudW5pcUJ5KGlkLCBzdGFyVmlld3MuY29uY2F0KGF0dHJWaWV3cykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmlzT3V0ZXJKb2luID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHRoaXMuam9pbnNbdGhpcy5hZGp1c3RQYXRoKHApXSA9PT0gJ09VVEVSJztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmhhc1ZpZXcgPSBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdzICYmIChfcmVmID0gdGhpcy5hZGp1c3RQYXRoKHYpLCBfX2luZGV4T2YuY2FsbCh0aGlzLnZpZXdzLCBfcmVmKSA+PSAwKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oY29udCkge1xuICAgICAgaWYgKHRoaXMuc2VydmljZS5jb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLmNvdW50KHRoaXMsIGNvbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBxdWVyeSBoYXMgbm8gc2VydmljZSB3aXRoIGNvdW50IGZ1bmN0aW9uYWxpdHkgYXR0YWNoZWQuXCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuYXBwZW5kVG9MaXN0ID0gZnVuY3Rpb24odGFyZ2V0LCBjYikge1xuICAgICAgdmFyIG5hbWUsIHByb2Nlc3NvciwgcmVxLCB0b1J1biwgdXBkYXRlVGFyZ2V0O1xuICAgICAgaWYgKHRhcmdldCAhPSBudWxsID8gdGFyZ2V0Lm5hbWUgOiB2b2lkIDApIHtcbiAgICAgICAgbmFtZSA9IHRhcmdldC5uYW1lO1xuICAgICAgICB1cGRhdGVUYXJnZXQgPSBmdW5jdGlvbihlcnIsIGxpc3QpIHtcbiAgICAgICAgICBpZiAoZXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuc2l6ZSA9IGxpc3Quc2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gU3RyaW5nKHRhcmdldCk7XG4gICAgICAgIHVwZGF0ZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0b1J1biA9IHRoaXMubWFrZUxpc3RRdWVyeSgpO1xuICAgICAgcmVxID0ge1xuICAgICAgICBsaXN0TmFtZTogbmFtZSxcbiAgICAgICAgcXVlcnk6IHRvUnVuLnRvWE1MKClcbiAgICAgIH07XG4gICAgICBwcm9jZXNzb3IgPSBMSVNUX1BJUEUodGhpcy5zZXJ2aWNlKTtcbiAgICAgIHJldHVybiB3aXRoQ0IodXBkYXRlVGFyZ2V0LCBjYiwgdGhpcy5zZXJ2aWNlLnBvc3QoJ3F1ZXJ5L2FwcGVuZC90b2xpc3QnLCByZXEpLnRoZW4ocHJvY2Vzc29yKSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3RQcmVzZXJ2aW5nSW1wbGllZENvbnN0cmFpbnRzID0gZnVuY3Rpb24ocGF0aHMpIHtcbiAgICAgIHZhciBuLCB0b1J1biwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBpZiAocGF0aHMgPT0gbnVsbCkge1xuICAgICAgICBwYXRocyA9IFtdO1xuICAgICAgfVxuICAgICAgdG9SdW4gPSB0aGlzLmNsb25lKCk7XG4gICAgICB0b1J1bi5zZWxlY3QocGF0aHMpO1xuICAgICAgX3JlZiA9IHRoaXMuZ2V0Vmlld05vZGVzKCk7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgbiA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoIXRoaXMuaXNPdXRlckpvaW5lZChuKSkge1xuICAgICAgICAgIGlmICghKHRvUnVuLmlzSW5WaWV3KG4gfHwgdG9SdW4uaXNDb25zdHJhaW5lZChuKSkpICYmIChuLmdldEVuZENsYXNzKCkuZmllbGRzLmlkICE9IG51bGwpKSB7XG4gICAgICAgICAgICB0b1J1bi5hZGRDb25zdHJhaW50KFtuLmFwcGVuZCgnaWQnKSwgJ0lTIE5PVCBOVUxMJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRvUnVuO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUubWFrZUxpc3RRdWVyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGhzLCBfcmVmO1xuICAgICAgcGF0aHMgPSB0aGlzLnZpZXdzLnNsaWNlKCk7XG4gICAgICBpZiAocGF0aHMubGVuZ3RoICE9PSAxIHx8ICEoKF9yZWYgPSBwYXRoc1swXSkgIT0gbnVsbCA/IF9yZWYubWF0Y2goL1xcLmlkJC8pIDogdm9pZCAwKSkge1xuICAgICAgICBwYXRocyA9IFsnaWQnXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdFByZXNlcnZpbmdJbXBsaWVkQ29uc3RyYWludHMocGF0aHMpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuc2F2ZUFzTGlzdCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNiKSB7XG4gICAgICB2YXIgcmVxLCB0b1J1bjtcbiAgICAgIHRvUnVuID0gdGhpcy5tYWtlTGlzdFF1ZXJ5KCk7XG4gICAgICByZXEgPSB1dGlscy5jb3B5KG9wdGlvbnMpO1xuICAgICAgcmVxLmxpc3ROYW1lID0gcmVxLmxpc3ROYW1lIHx8IHJlcS5uYW1lO1xuICAgICAgcmVxLnF1ZXJ5ID0gdG9SdW4udG9YTUwoKTtcbiAgICAgIGlmIChvcHRpb25zLnRhZ3MpIHtcbiAgICAgICAgcmVxLnRhZ3MgPSBvcHRpb25zLnRhZ3Muam9pbignOycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLnBvc3QoJ3F1ZXJ5L3RvbGlzdCcsIHJlcSkudGhlbihMSVNUX1BJUEUodGhpcy5zZXJ2aWNlKSkpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuc3VtbWFyaXNlID0gZnVuY3Rpb24ocGF0aCwgbGltaXQsIGNvbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlclN1bW1hcnkocGF0aCwgJycsIGxpbWl0LCBjb250KTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnN1bW1hcml6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3M7XG4gICAgICBhcmdzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgIHJldHVybiB0aGlzLnN1bW1hcmlzZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcGFyc2VTdW1tYXJ5ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGlzTnVtZXJpYywgciwgc3RhdHMsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMTtcbiAgICAgIGlzTnVtZXJpYyA9ICgoX3JlZiA9IGRhdGEucmVzdWx0c1swXSkgIT0gbnVsbCA/IF9yZWYubWF4IDogdm9pZCAwKSAhPSBudWxsO1xuICAgICAgX3JlZjEgPSBkYXRhLnJlc3VsdHM7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHIgPSBfcmVmMVtfaV07XG4gICAgICAgIHIuY291bnQgPSBwYXJzZUludChyLmNvdW50LCAxMCk7XG4gICAgICB9XG4gICAgICBzdGF0cyA9IHtcbiAgICAgICAgdW5pcXVlVmFsdWVzOiBkYXRhLnVuaXF1ZVZhbHVlcyxcbiAgICAgICAgZmlsdGVyZWRDb3VudDogZGF0YS5maWx0ZXJlZENvdW50XG4gICAgICB9O1xuICAgICAgaWYgKGlzTnVtZXJpYykge1xuICAgICAgICBzdGF0cyA9IG1lcmdlKHN0YXRzLCBkYXRhLnJlc3VsdHNbMF0pO1xuICAgICAgfVxuICAgICAgZGF0YS5zdGF0cyA9IHN0YXRzO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5maWx0ZXJTdW1tYXJ5ID0gZnVuY3Rpb24ocGF0aCwgdGVybSwgbGltaXQsIGNvbnQpIHtcbiAgICAgIHZhciByZXEsIHRvUnVuLCBfcmVmO1xuICAgICAgaWYgKGNvbnQgPT0gbnVsbCkge1xuICAgICAgICBjb250ID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24obGltaXQpKSB7XG4gICAgICAgIF9yZWYgPSBbbGltaXQsIG51bGxdLCBjb250ID0gX3JlZlswXSwgbGltaXQgPSBfcmVmWzFdO1xuICAgICAgfVxuICAgICAgcGF0aCA9IHRoaXMuYWRqdXN0UGF0aChwYXRoKTtcbiAgICAgIHRvUnVuID0gdGhpcy5jbG9uZSgpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKHRvUnVuLnZpZXdzLCBwYXRoKSA8IDApIHtcbiAgICAgICAgdG9SdW4udmlld3MucHVzaChwYXRoKTtcbiAgICAgIH1cbiAgICAgIHJlcSA9IHtcbiAgICAgICAgcXVlcnk6IHRvUnVuLnRvWE1MKCksXG4gICAgICAgIHN1bW1hcnlQYXRoOiBwYXRoLFxuICAgICAgICBmb3JtYXQ6ICdqc29ucm93cydcbiAgICAgIH07XG4gICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgcmVxLnNpemUgPSBsaW1pdDtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXJtKSB7XG4gICAgICAgIHJlcS5maWx0ZXJUZXJtID0gdGVybTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aXRoQ0IoY29udCwgdGhpcy5zZXJ2aWNlLnBvc3QoJ3F1ZXJ5L3Jlc3VsdHMnLCByZXEpLnRoZW4ocGFyc2VTdW1tYXJ5KSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKGNsb25lRXZlbnRzKSB7XG4gICAgICB2YXIgY2xvbmVkLCBrLCB2LCBfcmVmO1xuICAgICAgY2xvbmVkID0gbmV3IFF1ZXJ5KHRoaXMsIHRoaXMuc2VydmljZSk7XG4gICAgICBpZiAoY2xvbmVkLl9jYWxsYmFja3MgPT0gbnVsbCkge1xuICAgICAgICBjbG9uZWQuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGNsb25lRXZlbnRzKSB7XG4gICAgICAgIF9yZWYgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgICAgIGZvciAoayBpbiBfcmVmKSB7XG4gICAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChfcmVmLCBrKSkgY29udGludWU7XG4gICAgICAgICAgdiA9IF9yZWZba107XG4gICAgICAgICAgY2xvbmVkLl9jYWxsYmFja3Nba10gPSB2O1xuICAgICAgICB9XG4gICAgICAgIGNsb25lZC5vZmYoJ2NoYW5nZTp2aWV3cycsIHJlbW92ZUlycmVsZXZhbnRTb3J0T3JkZXJzLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2xvbmU7XG4gICAgICBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGlmICh0aGlzLm1heFJvd3MpIHtcbiAgICAgICAgY2xvbmUuc3RhcnQgPSB0aGlzLnN0YXJ0ICsgdGhpcy5tYXhSb3dzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUucHJldmlvdXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjbG9uZTtcbiAgICAgIGNsb25lID0gdGhpcy5jbG9uZSgpO1xuICAgICAgaWYgKHRoaXMubWF4Um93cykge1xuICAgICAgICBjbG9uZS5zdGFydCA9IHRoaXMuc3RhcnQgLSB0aGlzLm1heFJvd3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZS5zdGFydCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5nZXRTb3J0RGlyZWN0aW9uID0gZnVuY3Rpb24oc29ydGVkKSB7XG4gICAgICB2YXIgYSwgc287XG4gICAgICBhID0gdGhpcy5hZGp1c3RQYXRoKHNvcnRlZCk7XG4gICAgICBpZiAoISh0aGlzLmlzSW5RdWVyeShhKSB8fCB0aGlzLmlzUmVsZXZhbnQoYSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiICsgc29ydGVkICsgXCIgaXMgbm90IGluIHRoZSBxdWVyeVwiKTtcbiAgICAgIH1cbiAgICAgIHNvID0gdXRpbHMuZmluZCh0aGlzLnNvcnRPcmRlciwgZnVuY3Rpb24oX2FyZykge1xuICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgcGF0aCA9IF9hcmcucGF0aDtcbiAgICAgICAgcmV0dXJuIGEgPT09IHBhdGg7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzbyAhPSBudWxsID8gc28uZGlyZWN0aW9uIDogdm9pZCAwO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuaXNPdXRlckpvaW5lZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHZhciBkaXIsIGpwLCBfcmVmO1xuICAgICAgcGF0aCA9IHRoaXMuYWRqdXN0UGF0aChwYXRoKTtcbiAgICAgIF9yZWYgPSB0aGlzLmpvaW5zO1xuICAgICAgZm9yIChqcCBpbiBfcmVmKSB7XG4gICAgICAgIGRpciA9IF9yZWZbanBdO1xuICAgICAgICBpZiAoZGlyID09PSAnT1VURVInICYmIHBhdGguaW5kZXhPZihqcCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0T3V0ZXJKb2luID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdmFyIGpvaW5QYXRocywgaztcbiAgICAgIHBhdGggPSB0aGlzLmFkanVzdFBhdGgocGF0aCk7XG4gICAgICBqb2luUGF0aHMgPSAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoayBpbiB0aGlzLmpvaW5zKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1dGlscy5maW5kKGpvaW5QYXRocywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmpvaW5zW3BdID09PSAnT1VURVInICYmIHBhdGguaW5kZXhPZihwKSA9PT0gMDtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLl9wYXJzZV9zb3J0X29yZGVyID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24sIGssIHBhdGgsIHNvLCB2LCBfcmVmO1xuICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnB1dCcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc28gPSB7XG4gICAgICAgICAgcGF0aDogaW5wdXQsXG4gICAgICAgICAgZGlyZWN0aW9uOiAnQVNDJ1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBwYXRoID0gaW5wdXRbMF0sIGRpcmVjdGlvbiA9IGlucHV0WzFdO1xuICAgICAgICBzbyA9IHtcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LnBhdGggPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGsgaW4gaW5wdXQpIHtcbiAgICAgICAgICB2ID0gaW5wdXRba107XG4gICAgICAgICAgX3JlZiA9IFtrLCB2XSwgcGF0aCA9IF9yZWZbMF0sIGRpcmVjdGlvbiA9IF9yZWZbMV07XG4gICAgICAgIH1cbiAgICAgICAgc28gPSB7XG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IGlucHV0LnBhdGgsIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgICAgc28gPSB7XG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc28ucGF0aCA9IHRoaXMuYWRqdXN0UGF0aChzby5wYXRoKTtcbiAgICAgIGlmIChzby5kaXJlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICBzby5kaXJlY3Rpb24gPSAnQVNDJztcbiAgICAgIH1cbiAgICAgIHNvLmRpcmVjdGlvbiA9IHNvLmRpcmVjdGlvbi50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHNvO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuYWRkT3JTZXRTb3J0T3JkZXIgPSBmdW5jdGlvbihzbykge1xuICAgICAgdmFyIGN1cnJlbnREaXJlY3Rpb24sIG9lO1xuICAgICAgc28gPSB0aGlzLl9wYXJzZV9zb3J0X29yZGVyKHNvKTtcbiAgICAgIGN1cnJlbnREaXJlY3Rpb24gPSB0aGlzLmdldFNvcnREaXJlY3Rpb24oc28ucGF0aCk7XG4gICAgICBpZiAoY3VycmVudERpcmVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYWRkU29ydE9yZGVyKHNvKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudERpcmVjdGlvbiAhPT0gc28uZGlyZWN0aW9uKSB7XG4gICAgICAgIG9lID0gdXRpbHMuZmluZCh0aGlzLnNvcnRPcmRlciwgZnVuY3Rpb24oX2FyZykge1xuICAgICAgICAgIHZhciBwYXRoO1xuICAgICAgICAgIHBhdGggPSBfYXJnLnBhdGg7XG4gICAgICAgICAgcmV0dXJuIHBhdGggPT09IHNvLnBhdGg7XG4gICAgICAgIH0pO1xuICAgICAgICBvZS5kaXJlY3Rpb24gPSBzby5kaXJlY3Rpb247XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOnNvcnRvcmRlcicsIHRoaXMuc29ydE9yZGVyKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuYWRkU29ydE9yZGVyID0gZnVuY3Rpb24oc28sIF9hcmcpIHtcbiAgICAgIHZhciBzaWxlbnQ7XG4gICAgICBzaWxlbnQgPSAoX2FyZyAhPSBudWxsID8gX2FyZyA6IHt9KS5zaWxlbnQ7XG4gICAgICB0aGlzLnNvcnRPcmRlci5wdXNoKHRoaXMuX3BhcnNlX3NvcnRfb3JkZXIoc28pKTtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignYWRkOnNvcnRvcmRlcicsIHNvKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6c29ydG9yZGVyJywgdGhpcy5zb3J0T3JkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLm9yZGVyQnkgPSBmdW5jdGlvbihvZXMsIG9wdHMpIHtcbiAgICAgIHZhciBjb3B5LCBkaXJlY3Rpb24sIG9lLCBvbGRTTywgcGF0aCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIG9sZFNPID0gdGhpcy5zb3J0T3JkZXIuc2xpY2UoKTtcbiAgICAgIHRoaXMuc29ydE9yZGVyID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG9lcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBvZSA9IG9lc1tfaV07XG4gICAgICAgIHRoaXMuYWRkU29ydE9yZGVyKHRoaXMuX3BhcnNlX3NvcnRfb3JkZXIob2UpLCB7XG4gICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29weSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gdGhpcy5zb3J0T3JkZXI7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgX3JlZjEgPSBfcmVmW19qXSwgcGF0aCA9IF9yZWYxLnBhdGgsIGRpcmVjdGlvbiA9IF9yZWYxLmRpcmVjdGlvbjtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3NldDpzb3J0b3JkZXInLCBjb3B5KTtcbiAgICAgIGlmICgoc3RyaW5naWZ5U29ydE9yZGVyKG9sZFNPKSkgIT09IHRoaXMuZ2V0U29ydGluZygpKSB7XG4gICAgICAgIGlmIChvcHRzLnNpbGVudCkge1xuICAgICAgICAgIG9wdHMuZXZlbnRzID0gKChfcmVmID0gb3B0cy5ldmVudHMpICE9IG51bGwgPyBfcmVmIDogW10pLmNvbmNhdChbJ2NoYW5nZScsICdjaGFuZ2U6c29ydG9yZGVyJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOnNvcnRvcmRlcicsIGNvcHkpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuYWRkSm9pbnMgPSBmdW5jdGlvbihqb2lucykge1xuICAgICAgdmFyIGosIGssIHYsIF9pLCBfbGVuLCBfcmVzdWx0cywgX3Jlc3VsdHMxO1xuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoam9pbnMpKSB7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gam9pbnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBqID0gam9pbnNbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5hZGRKb2luKGopKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgZm9yIChrIGluIGpvaW5zKSB7XG4gICAgICAgICAgdiA9IGpvaW5zW2tdO1xuICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHRoaXMuYWRkSm9pbih7XG4gICAgICAgICAgICBwYXRoOiBrLFxuICAgICAgICAgICAgc3R5bGU6IHZcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFkZEpvaW4gPSBmdW5jdGlvbihqb2luKSB7XG4gICAgICBpZiAodHlwZW9mIGpvaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGpvaW4gPSB7XG4gICAgICAgICAgcGF0aDogam9pbixcbiAgICAgICAgICBzdHlsZTogJ09VVEVSJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc2V0Sm9pblN0eWxlKGpvaW4ucGF0aCwgam9pbi5zdHlsZSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5zZXRKb2luU3R5bGUgPSBmdW5jdGlvbihwYXRoLCBzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlID09IG51bGwpIHtcbiAgICAgICAgc3R5bGUgPSAnT1VURVInO1xuICAgICAgfVxuICAgICAgcGF0aCA9IHRoaXMuYWRqdXN0UGF0aChwYXRoKTtcbiAgICAgIHN0eWxlID0gc3R5bGUudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChRdWVyeS5KT0lOX1NUWUxFUywgc3R5bGUpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGpvaW4gc3R5bGU6IFwiICsgc3R5bGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuam9pbnNbcGF0aF0gIT09IHN0eWxlKSB7XG4gICAgICAgIHRoaXMuam9pbnNbcGF0aF0gPSBzdHlsZTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6am9pbnMnLCB7XG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICBzdHlsZTogc3R5bGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFkZENvbnN0cmFpbnRzID0gZnVuY3Rpb24oY29uc3RyYWludHMsIGNvbmopIHtcbiAgICAgIHZhciBjLCBjb24sIG9sZExvZ2ljLCBwYXRoLCBfZm4sIF9pLCBfbGVuO1xuICAgICAgaWYgKGNvbmogPT0gbnVsbCkge1xuICAgICAgICBjb25qID0gJ2FuZCc7XG4gICAgICB9XG4gICAgICB0aGlzLl9fc2lsZW50X18gPSB0cnVlO1xuICAgICAgb2xkTG9naWMgPSB0aGlzLmNvbnN0cmFpbnRMb2dpYztcbiAgICAgIGlmICh1dGlscy5pc0FycmF5KGNvbnN0cmFpbnRzKSkge1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGNvbnN0cmFpbnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgYyA9IGNvbnN0cmFpbnRzW19pXTtcbiAgICAgICAgICB0aGlzLmFkZENvbnN0cmFpbnQoYywgY29uaik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9mbiA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoLCBjb24pIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hZGRDb25zdHJhaW50KGludGVycHJldENvbnN0cmFpbnQocGF0aCwgY29uKSwgY29uaik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcyk7XG4gICAgICAgIGZvciAocGF0aCBpbiBjb25zdHJhaW50cykge1xuICAgICAgICAgIGNvbiA9IGNvbnN0cmFpbnRzW3BhdGhdO1xuICAgICAgICAgIF9mbihwYXRoLCBjb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9fc2lsZW50X18gPSBmYWxzZTtcbiAgICAgIHRoaXMudHJpZ2dlcignYWRkOmNvbnN0cmFpbnQnKTtcbiAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOmNvbnN0cmFpbnRzJyk7XG4gICAgICBpZiAob2xkTG9naWMgIT09IHRoaXMuY29uc3RyYWludExvZ2ljKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOmxvZ2ljJywgdGhpcy5jb25zdHJhaW50TG9naWMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5hZGRDb25zdHJhaW50ID0gZnVuY3Rpb24oY29uc3RyYWludCwgY29uaikge1xuICAgICAgdmFyIGksIGxvZ2ljLCBuZWVkc0xvZ2ljQ2xhdXNlLCBuZXdDb25MZW4sIG5ld0xvZ2ljLCBvbGRMb2dpYywgX3JlZjtcbiAgICAgIGlmIChjb25qID09IG51bGwpIHtcbiAgICAgICAgY29uaiA9ICdhbmQnO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmogIT09ICdhbmQnICYmIGNvbmogIT09ICdvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxvZ2ljYWwgY29uanVuY3Rpb246ICcgKyBjb25qKTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KGNvbnN0cmFpbnQpKSB7XG4gICAgICAgIGNvbnN0cmFpbnQgPSBpbnRlcnByZXRDb25BcnJheShjb25zdHJhaW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0cmFpbnQgPSBjb3B5Q29uKGNvbnN0cmFpbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnN0cmFpbnQuc3dpdGNoZWQgPT09ICdPRkYnKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY29uc3RyYWludC5wYXRoID0gdGhpcy5hZGp1c3RQYXRoKGNvbnN0cmFpbnQucGF0aCk7XG4gICAgICBpZiAoY29uc3RyYWludC50eXBlID09IG51bGwpIHtcbiAgICAgICAgY29uc3RyYWludC5vcCA9IGdldF9jYW5vbmljYWxfb3AoY29uc3RyYWludC5vcCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG4gICAgICBuZWVkc0xvZ2ljQ2xhdXNlID0gKGNvbmogPT09ICdvcicpIHx8ICgoKF9yZWYgPSB0aGlzLmNvbnN0cmFpbnRMb2dpYykgIT0gbnVsbCA/IF9yZWYubGVuZ3RoIDogdm9pZCAwKSA+IDApO1xuICAgICAgbmV3Q29uTGVuID0gdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7XG4gICAgICBvbGRMb2dpYyA9IHRoaXMuY29uc3RyYWludExvZ2ljO1xuICAgICAgaWYgKG5lZWRzTG9naWNDbGF1c2UpIHtcbiAgICAgICAgbmV3TG9naWMgPSBuZXdDb25MZW4gPT09IDIgPyBcIlwiICsgQ09ERVNbMF0gKyBcIiBcIiArIGNvbmogKyBcIiBcIiArIENPREVTWzFdIDogKGxvZ2ljID0gdGhpcy5jb25zdHJhaW50TG9naWMsIGxvZ2ljIHx8IChsb2dpYyA9ICgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYxID0gbmV3Q29uTGVuIC0gMjsgMCA8PSBfcmVmMSA/IF9pIDw9IF9yZWYxIDogX2kgPj0gX3JlZjE7IGkgPSAwIDw9IF9yZWYxID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goQ09ERVNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pKCkpLmpvaW4oJyBhbmQgJykpLCBcIihcIiArIGxvZ2ljICsgXCIpIFwiICsgY29uaiArIFwiIFwiICsgQ09ERVNbbmV3Q29uTGVuIC0gMV0pO1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRMb2dpYyA9IG5ld0xvZ2ljO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9fc2lsZW50X18pIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdhZGQ6Y29uc3RyYWludCcsIGNvbnN0cmFpbnQpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpjb25zdHJhaW50cycpO1xuICAgICAgICBpZiAob2xkTG9naWMgIT09IHRoaXMuY29uc3RyYWludExvZ2ljKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6bG9naWMnLCB0aGlzLmNvbnN0cmFpbnRMb2dpYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0U29ydGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNvcnRPcmRlcih0aGlzLnNvcnRPcmRlcik7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5nZXRDb25zdHJhaW50WE1MID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYywgdG9TZXJpYWxpc2U7XG4gICAgICB0b1NlcmlhbGlzZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGMgPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAoKGMudHlwZSA9PSBudWxsKSB8fCB0aGlzLmlzSW5RdWVyeShjLnBhdGgpKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHRvU2VyaWFsaXNlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY29uY2F0TWFwKGNvblN0cikoY29uY2F0TWFwKGlkKShwYXJ0aXRpb24oZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiBjLnR5cGUgIT0gbnVsbDtcbiAgICAgICAgfSkodG9TZXJpYWxpc2UpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5nZXRKb2luWE1MID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCwgcywgc3RycztcbiAgICAgIHN0cnMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMuam9pbnM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAocCBpbiBfcmVmKSB7XG4gICAgICAgICAgcyA9IF9yZWZbcF07XG4gICAgICAgICAgaWYgKHRoaXMuaXNJblF1ZXJ5KHApICYmIHMgPT09ICdPVVRFUicpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goXCI8am9pbiBwYXRoPVxcXCJcIiArIHAgKyBcIlxcXCIgc3R5bGU9XFxcIk9VVEVSXFxcIi8+XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHN0cnMuam9pbignJyk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS50b1hNTCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF0dHJzLCBoZWFkQXR0cnMsIGssIHY7XG4gICAgICBhdHRycyA9IHtcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwubmFtZSxcbiAgICAgICAgdmlldzogdGhpcy52aWV3cy5qb2luKCcgJyksXG4gICAgICAgIHNvcnRPcmRlcjogdGhpcy5nZXRTb3J0aW5nKCksXG4gICAgICAgIGNvbnN0cmFpbnRMb2dpYzogdGhpcy5jb25zdHJhaW50TG9naWNcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgYXR0cnMubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgIH1cbiAgICAgIGhlYWRBdHRycyA9ICgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrIGluIGF0dHJzKSB7XG4gICAgICAgICAgdiA9IGF0dHJzW2tdO1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGsgKyAnPVwiJyArIHYgKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKSkuam9pbignICcpO1xuICAgICAgcmV0dXJuIFwiPHF1ZXJ5IFwiICsgaGVhZEF0dHJzICsgXCIgPlwiICsgKHRoaXMuZ2V0Sm9pblhNTCgpKSArICh0aGlzLmdldENvbnN0cmFpbnRYTUwoKSkgKyBcIjwvcXVlcnk+XCI7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjLCBkaXJlY3Rpb24sIHBhdGgsIHN0eWxlLCB2O1xuICAgICAgcmV0dXJuIG5vVW5kZWZWYWxzKHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB0aXRsZTogdGhpcy50aXRsZSxcbiAgICAgICAgY29tbWVudDogdGhpcy5jb21tZW50LFxuICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgICAgY29uc3RyYWludExvZ2ljOiB0aGlzLmNvbnN0cmFpbnRMb2dpYyxcbiAgICAgICAgZnJvbTogdGhpcy5yb290LFxuICAgICAgICBzZWxlY3Q6IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZWYgPSB0aGlzLnZpZXdzO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICB2ID0gX3JlZltfaV07XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGhlYWRMZXNzKHYpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpLFxuICAgICAgICBvcmRlckJ5OiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZiA9IHRoaXMuc29ydE9yZGVyO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBfcmVmMSA9IF9yZWZbX2ldLCBwYXRoID0gX3JlZjEucGF0aCwgZGlyZWN0aW9uID0gX3JlZjEuZGlyZWN0aW9uO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgIHBhdGg6IGhlYWRMZXNzKHBhdGgpLFxuICAgICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKSxcbiAgICAgICAgam9pbnM6IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZiA9IHRoaXMuam9pbnM7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHBhdGggaW4gX3JlZikge1xuICAgICAgICAgICAgc3R5bGUgPSBfcmVmW3BhdGhdO1xuICAgICAgICAgICAgaWYgKHN0eWxlID09PSAnT1VURVInKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goaGVhZExlc3MocGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcyksXG4gICAgICAgIHdoZXJlOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVmID0gdGhpcy5jb25zdHJhaW50cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgYyA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChjb25Ub0pTT04oYykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcylcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZmV0Y2hDb2RlID0gZnVuY3Rpb24obGFuZywgY2IpIHtcbiAgICAgIHZhciByZXE7XG4gICAgICByZXEgPSB7XG4gICAgICAgIHF1ZXJ5OiB0aGlzLnRvWE1MKCksXG4gICAgICAgIGxhbmc6IGxhbmdcbiAgICAgIH07XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLnNlcnZpY2UucG9zdCgncXVlcnkvY29kZScsIHJlcSkudGhlbih0aGlzLnNlcnZpY2UuVkVSSUZJRVIpLnRoZW4oZ2V0KCdjb2RlJykpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKG5hbWUsIGNiKSB7XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLnNlcnZpY2UsIDE2LCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciByZXEsIF9yZWY7XG4gICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24obmFtZSkpIHtcbiAgICAgICAgICAgIF9yZWYgPSBbbnVsbCwgbmFtZV0sIG5hbWUgPSBfcmVmWzBdLCBjYiA9IF9yZWZbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLnNldE5hbWUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdQVVQnLFxuICAgICAgICAgICAgcGF0aDogJ3VzZXIvcXVlcmllcycsXG4gICAgICAgICAgICBkYXRhOiBfdGhpcy50b1hNTCgpLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgX3RoaXMuc2VydmljZS5hdXRob3Jpc2UocmVxKSkudGhlbihmdW5jdGlvbihhdXRoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXJ2aWNlLmRvUmVxKGF1dGhlZCk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcC5xdWVyaWVzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbihuYW1lLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcy5zZXJ2aWNlLCAxNiwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZ2V0TmFtZSwgcmVxLCB1cGRhdGVOYW1lLCBfcmVmO1xuICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgICAgICBfcmVmID0gW251bGwsIG5hbWVdLCBuYW1lID0gX3JlZlswXSwgY2IgPSBfcmVmWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXROYW1lKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVOYW1lID0gZnVuY3Rpb24oZXJyLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAoZXJyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldE5hbWUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBnZXROYW1lID0gdXRpbHMuY29tcG9zZShnZXQoX3RoaXMubmFtZSksIGdldCgncXVlcmllcycpKTtcbiAgICAgICAgICByZXEgPSB7XG4gICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICBwYXRoOiAndXNlci9xdWVyaWVzJyxcbiAgICAgICAgICAgIGRhdGE6IF90aGlzLnRvWE1MKCksXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3htbCcsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCB1cGRhdGVOYW1lLCBfdGhpcy5zZXJ2aWNlLmF1dGhvcmlzZShyZXEpKS50aGVuKGZ1bmN0aW9uKGF1dGhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlcnZpY2UuZG9SZXEoYXV0aGVkKTtcbiAgICAgICAgICB9KS50aGVuKGdldE5hbWUpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuc2F2ZUFzVGVtcGxhdGUgPSBmdW5jdGlvbihuYW1lLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcy5zZXJ2aWNlLCAxNiwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcmVxLCBfcmVmO1xuICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgICAgICBfcmVmID0gW251bGwsIG5hbWVdLCBuYW1lID0gX3JlZlswXSwgY2IgPSBfcmVmWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXROYW1lKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIV90aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlcyBtdXN0IGhhdmUgYSBuYW1lXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXEgPSB7XG4gICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICBwYXRoOiAndGVtcGxhdGVzJyxcbiAgICAgICAgICAgIGRhdGE6IFwiPHRlbXBsYXRlIFwiICsgKGNvbkF0dHJzKF90aGlzLCBbJ25hbWUnLCAndGl0bGUnLCAnY29tbWVudCddKSkgKyBcIj5cIiArIChfdGhpcy50b1hNTCgpKSArIFwiPC90ZW1wbGF0ZT5cIixcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24veG1sJyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLnNlcnZpY2UuYXV0aG9yaXNlKHJlcSkudGhlbihmdW5jdGlvbihhdXRoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXJ2aWNlLmRvUmVxKGF1dGhlZCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0Q29kZVVSSSA9IGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgIHZhciByZXEsIF9yZWY7XG4gICAgICByZXEgPSB7XG4gICAgICAgIHF1ZXJ5OiB0aGlzLnRvWE1MKCksXG4gICAgICAgIGxhbmc6IGxhbmcsXG4gICAgICAgIGZvcm1hdDogJ3RleHQnXG4gICAgICB9O1xuICAgICAgaWYgKCgoX3JlZiA9IHRoaXMuc2VydmljZSkgIT0gbnVsbCA/IF9yZWYudG9rZW4gOiB2b2lkIDApICE9IG51bGwpIHtcbiAgICAgICAgcmVxLnRva2VuID0gdGhpcy5zZXJ2aWNlLnRva2VuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLnNlcnZpY2Uucm9vdCArIFwicXVlcnkvY29kZT9cIiArICh0b1F1ZXJ5U3RyaW5nKHJlcSkpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0RXhwb3J0VVJJID0gZnVuY3Rpb24oZm9ybWF0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVxLCBfcmVmO1xuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgIGZvcm1hdCA9ICd0YWInO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoUXVlcnkuQklPX0ZPUk1BVFMsIGZvcm1hdCkgPj0gMCkge1xuICAgICAgICByZXR1cm4gdGhpc1tcImdldFwiICsgKGZvcm1hdC50b1VwcGVyQ2FzZSgpKSArIFwiVVJJXCJdKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmVxID0gbWVyZ2Uob3B0aW9ucywge1xuICAgICAgICBxdWVyeTogdGhpcy50b1hNTCgpLFxuICAgICAgICBmb3JtYXQ6IGZvcm1hdFxuICAgICAgfSk7XG4gICAgICBpZiAoKChfcmVmID0gdGhpcy5zZXJ2aWNlKSAhPSBudWxsID8gX3JlZi50b2tlbiA6IHZvaWQgMCkgIT0gbnVsbCkge1xuICAgICAgICByZXEudG9rZW4gPSB0aGlzLnNlcnZpY2UudG9rZW47XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcIiArIHRoaXMuc2VydmljZS5yb290ICsgXCJxdWVyeS9yZXN1bHRzP1wiICsgKHRvUXVlcnlTdHJpbmcocmVxKSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5uZWVkc0F1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdXRpbHMuYW55KHRoaXMuY29uc3RyYWludHMsIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgIHJldHVybiAoX3JlZiA9IGMub3ApID09PSAnTk9UIElOJyB8fCBfcmVmID09PSAnSU4nO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5mZXRjaFFJRCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLnNlcnZpY2UucG9zdCgncXVlcmllcycsIHtcbiAgICAgICAgcXVlcnk6IHRoaXMudG9YTUwoKVxuICAgICAgfSkudGhlbihnZXQoJ2lkJykpKTtcbiAgICB9O1xuXG4gICAgYWRkUEkgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gcC5hcHBlbmQoJ3ByaW1hcnlJZGVudGlmaWVyJykudG9TdHJpbmcoKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLl9fYmlvX3JlcSA9IGZ1bmN0aW9uKHR5cGVzLCBuKSB7XG4gICAgICB2YXIgaXNTdWl0YWJsZSwgdG9SdW47XG4gICAgICB0b1J1biA9IHRoaXMubWFrZUxpc3RRdWVyeSgpO1xuICAgICAgaXNTdWl0YWJsZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmFueSh0eXBlcywgZnVuY3Rpb24odCkge1xuICAgICAgICAgIHJldHVybiBwLmlzYSh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdG9SdW4udmlld3MgPSB1dGlscy50YWtlKG4pKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMuZ2V0Vmlld05vZGVzKCk7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIG4gPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAoaXNTdWl0YWJsZShuKSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRQSShuKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcXVlcnk6IHRvUnVuLnRvWE1MKCksXG4gICAgICAgIGZvcm1hdDogJ3RleHQnXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuX2Zhc3RhX3JlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19iaW9fcmVxKFtcIlNlcXVlbmNlRmVhdHVyZVwiLCAnUHJvdGVpbiddLCAxKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLl9nZmYzX3JlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19iaW9fcmVxKFsnU2VxdWVuY2VGZWF0dXJlJ10pO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuX2JlZF9yZXEgPSBRdWVyeS5wcm90b3R5cGUuX2dmZjNfcmVxO1xuXG4gICAgcmV0dXJuIFF1ZXJ5O1xuXG4gIH0pKCk7XG5cbiAgdW5pb24gPSBmb2xkKGZ1bmN0aW9uKHhzLCB5cykge1xuICAgIHJldHVybiB4cy5jb25jYXQoeXMpO1xuICB9KTtcblxuICBRdWVyeS5wcm90b3R5cGUudG9TdHJpbmcgPSBRdWVyeS5wcm90b3R5cGUudG9YTUw7XG5cbiAgUXVlcnkuQVRUUklCVVRFX09QUyA9IHVuaW9uKFtRdWVyeS5BVFRSSUJVVEVfVkFMVUVfT1BTLCBRdWVyeS5NVUxUSVZBTFVFX09QUywgUXVlcnkuTlVMTF9PUFNdKTtcblxuICBRdWVyeS5SRUZFUkVOQ0VfT1BTID0gdW5pb24oW1F1ZXJ5LlRFUk5BUllfT1BTLCBRdWVyeS5MT09QX09QUywgUXVlcnkuTElTVF9PUFNdKTtcblxuICBiaW9VcmlBcmdzID0gZnVuY3Rpb24ocmVxTWV0aCwgZikge1xuICAgIHJldHVybiBmdW5jdGlvbihvcHRzLCBjYikge1xuICAgICAgdmFyIGVuc3VyZUF0dHIsIG9iaiwgcmVxLCB2LCBfcmVmO1xuICAgICAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IGZ1bmN0aW9uKCkge307XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihvcHRzKSkge1xuICAgICAgICBfcmVmID0gW3t9LCBvcHRzXSwgb3B0cyA9IF9yZWZbMF0sIGNiID0gX3JlZlsxXTtcbiAgICAgIH1cbiAgICAgIGVuc3VyZUF0dHIgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgICBwYXRoID0gX3RoaXMuZ2V0UGF0aEluZm8ocCk7XG4gICAgICAgICAgaWYgKHBhdGguaXNBdHRyaWJ1dGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoLmFwcGVuZCgnaWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIGlmICgob3B0cyAhPSBudWxsID8gb3B0cy52aWV3IDogdm9pZCAwKSAhPSBudWxsKSB7XG4gICAgICAgIG9wdHMudmlldyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVmMSA9IG9wdHMudmlldztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIHYgPSBfcmVmMVtfaV07XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuZ2V0UGF0aEluZm8odikudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9wdHNbXCJleHBvcnRcIl0gIT0gbnVsbCA/IHRoaXMuc2VsZWN0UHJlc2VydmluZ0ltcGxpZWRDb25zdHJhaW50cyhvcHRzW1wiZXhwb3J0XCJdLm1hcChlbnN1cmVBdHRyKSkgOiB0aGlzO1xuICAgICAgcmVxID0gbWVyZ2Uob2JqW3JlcU1ldGhdKCksIG9wdHMpO1xuICAgICAgcmV0dXJuIGYuY2FsbChvYmosIHJlcSwgY2IpO1xuICAgIH07XG4gIH07XG5cbiAgX3JlZiA9IFF1ZXJ5LkJJT19GT1JNQVRTO1xuICBfZm4gPSBmdW5jdGlvbihmKSB7XG4gICAgdmFyIGdldE1ldGgsIHJlcU1ldGgsIHVyaU1ldGg7XG4gICAgcmVxTWV0aCA9IFwiX1wiICsgZiArIFwiX3JlcVwiO1xuICAgIGdldE1ldGggPSBcImdldFwiICsgKGYudG9VcHBlckNhc2UoKSk7XG4gICAgdXJpTWV0aCA9IGdldE1ldGggKyBcIlVSSVwiO1xuICAgIFF1ZXJ5LnByb3RvdHlwZVtnZXRNZXRoXSA9IGJpb1VyaUFyZ3MocmVxTWV0aCwgZnVuY3Rpb24ocmVxLCBjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLnBvc3QoJ3F1ZXJ5L3Jlc3VsdHMvJyArIGYsIHJlcSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBRdWVyeS5wcm90b3R5cGVbdXJpTWV0aF0gPSBiaW9VcmlBcmdzKHJlcU1ldGgsIGZ1bmN0aW9uKHJlcSwgY2IpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2UudG9rZW4gIT0gbnVsbCkge1xuICAgICAgICByZXEudG9rZW4gPSB0aGlzLnNlcnZpY2UudG9rZW47XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcIiArIHRoaXMuc2VydmljZS5yb290ICsgXCJxdWVyeS9yZXN1bHRzL1wiICsgZiArIFwiP1wiICsgKHRvUXVlcnlTdHJpbmcocmVxKSk7XG4gICAgfSk7XG4gIH07XG4gIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIGYgPSBfcmVmW19pXTtcbiAgICBfZm4oZik7XG4gIH1cblxuICBfZ2V0X2RhdGFfZmV0Y2hlciA9IGZ1bmN0aW9uKHNlcnZlcl9mbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjYnMsIHBhZ2UsIHgsIF9yZWYxO1xuICAgICAgcGFnZSA9IGFyZ3VtZW50c1swXSwgY2JzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2Vbc2VydmVyX2ZuXSkge1xuICAgICAgICBpZiAocGFnZSA9PSBudWxsKSB7XG4gICAgICAgICAgcGFnZSA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFnZSkpIHtcbiAgICAgICAgICBwYWdlID0ge307XG4gICAgICAgICAgY2JzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3Jlc3VsdHM7XG4gICAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gYXJndW1lbnRzLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICB4ID0gYXJndW1lbnRzW19qXTtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHBhZ2UgPSBub1VuZGVmVmFscyhtZXJnZSh7XG4gICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICAgICAgc2l6ZTogdGhpcy5tYXhSb3dzXG4gICAgICAgIH0sIHBhZ2UpKTtcbiAgICAgICAgcmV0dXJuIChfcmVmMSA9IHRoaXMuc2VydmljZSlbc2VydmVyX2ZuXS5hcHBseShfcmVmMSwgW3RoaXMsIHBhZ2VdLmNvbmNhdChfX3NsaWNlLmNhbGwoY2JzKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VydmljZSBkb2VzIG5vdCBwcm92aWRlICdcIiArIHNlcnZlcl9mbiArIFwiJy5cIik7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBmb3IgKF9qID0gMCwgX2xlbjEgPSBSRVNVTFRTX01FVEhPRFMubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgbXRoID0gUkVTVUxUU19NRVRIT0RTW19qXTtcbiAgICBRdWVyeS5wcm90b3R5cGVbbXRoXSA9IF9nZXRfZGF0YV9mZXRjaGVyKG10aCk7XG4gIH1cblxuICBFdmVudHMubWl4aW4oUXVlcnkucHJvdG90eXBlKTtcblxuICBRdWVyeS5wcm90b3R5cGUuZW1pdCA9IFF1ZXJ5LnByb3RvdHlwZS50cmlnZ2VyO1xuXG4gIFF1ZXJ5LnByb3RvdHlwZS5iaW5kID0gUXVlcnkucHJvdG90eXBlLm9uO1xuXG4gIGludGVybWluZS5RdWVyeSA9IFF1ZXJ5O1xuXG59KS5jYWxsKHRoaXMpO1xuXG59LHtcIi4vdXRpbFwiOjE1LFwiLi94bWxcIjoxNyxcImJhY2tib25lLWV2ZW50cy1zdGFuZGFsb25lXCI6MjF9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBBTFdBWVNfQVVUSCwgQ0xBU1NLRVlTLCBDTEFTU0tFWV9QQVRILCBERUZBVUxUX0VSUk9SX0hBTkRMRVIsIERFRkFVTFRfUFJPVE9DT0wsIEVOUklDSE1FTlRfUEFUSCwgSEFTX1BST1RPQ09MLCBIQVNfU1VGRklYLCBJRFJlc29sdXRpb25Kb2IsIElEX1JFU09MVVRJT05fUEFUSCwgTElTVFNfUEFUSCwgTElTVF9PUEVSQVRJT05fUEFUSFMsIExJU1RfUElQRSwgTGlzdCwgTU9ERUxTLCBNT0RFTF9QQVRILCBNb2RlbCwgTkVFRFNfQVVUSCwgTk9fQVVUSCwgUEFUSF9WQUxVRVNfUEFUSCwgUFJFRl9QQVRILCBQcm9taXNlLCBRVUVSWV9SRVNVTFRTX1BBVEgsIFFVSUNLU0VBUkNIX1BBVEgsIFF1ZXJ5LCBSRUxFQVNFUywgUkVMRUFTRV9QQVRILCBSRVFVSVJFU19WRVJTSU9OLCBTVUJUUkFDVF9QQVRILCBTVUZGSVgsIFNVTU1BUllGSUVMRFNfUEFUSCwgU1VNTUFSWV9GSUVMRFMsIFNlcnZpY2UsIFRBQkxFX1JPV19QQVRILCBURU1QTEFURVNfUEFUSCwgVE9fTkFNRVMsIFVTRVJfVE9LRU5TLCBVc2VyLCBWRVJTSU9OUywgVkVSU0lPTl9QQVRILCBXSE9BTUlfUEFUSCwgV0lER0VUUywgV0lER0VUU19QQVRILCBXSVRIX09CSl9QQVRILCBkZWpvaW4sIGVycm9yLCBnZXQsIGdldExpc3RGaW5kZXIsIGh0dHAsIGludm9rZSwgbWFwLCBtZXJnZSwgcCwgc2V0LCBzdWNjZXNzLCB0b19xdWVyeV9zdHJpbmcsIHV0aWxzLCB2ZXJzaW9uLCB3aXRoQ0IsIF9nZXRfb3JfZmV0Y2gsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYsIF9yZWYxLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19zbGljZSA9IFtdLnNsaWNlO1xuXG4gIFByb21pc2UgPSBfZGVyZXFfKCcuL3Byb21pc2UnKTtcblxuICBNb2RlbCA9IF9kZXJlcV8oJy4vbW9kZWwnKS5Nb2RlbDtcblxuICBRdWVyeSA9IF9kZXJlcV8oJy4vcXVlcnknKS5RdWVyeTtcblxuICBMaXN0ID0gX2RlcmVxXygnLi9saXN0cycpLkxpc3Q7XG5cbiAgVXNlciA9IF9kZXJlcV8oJy4vdXNlcicpLlVzZXI7XG5cbiAgSURSZXNvbHV0aW9uSm9iID0gX2RlcmVxXygnLi9pZC1yZXNvbHV0aW9uLWpvYicpLklEUmVzb2x1dGlvbkpvYjtcblxuICB2ZXJzaW9uID0gX2RlcmVxXygnLi92ZXJzaW9uJyk7XG5cbiAgdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWwnKTtcblxuICBodHRwID0gX2RlcmVxXygnLi9odHRwJyk7XG5cbiAgdG9fcXVlcnlfc3RyaW5nID0gdXRpbHMucXVlcnlzdHJpbmc7XG5cbiAgd2l0aENCID0gdXRpbHMud2l0aENCLCBtYXAgPSB1dGlscy5tYXAsIG1lcmdlID0gdXRpbHMubWVyZ2UsIGdldCA9IHV0aWxzLmdldCwgc2V0ID0gdXRpbHMuc2V0LCBpbnZva2UgPSB1dGlscy5pbnZva2UsIHN1Y2Nlc3MgPSB1dGlscy5zdWNjZXNzLCBlcnJvciA9IHV0aWxzLmVycm9yLCBSRVFVSVJFU19WRVJTSU9OID0gdXRpbHMuUkVRVUlSRVNfVkVSU0lPTiwgZGVqb2luID0gdXRpbHMuZGVqb2luO1xuXG4gIFZFUlNJT05TID0ge307XG5cbiAgQ0xBU1NLRVlTID0ge307XG5cbiAgUkVMRUFTRVMgPSB7fTtcblxuICBNT0RFTFMgPSB7fTtcblxuICBTVU1NQVJZX0ZJRUxEUyA9IHt9O1xuXG4gIFdJREdFVFMgPSB7fTtcblxuICBERUZBVUxUX1BST1RPQ09MID0gXCJodHRwOi8vXCI7XG5cbiAgVkVSU0lPTl9QQVRIID0gXCJ2ZXJzaW9uXCI7XG5cbiAgVEVNUExBVEVTX1BBVEggPSBcInRlbXBsYXRlc1wiO1xuXG4gIFJFTEVBU0VfUEFUSCA9IFwidmVyc2lvbi9yZWxlYXNlXCI7XG5cbiAgQ0xBU1NLRVlfUEFUSCA9IFwiY2xhc3NrZXlzXCI7XG5cbiAgTElTVFNfUEFUSCA9IFwibGlzdHNcIjtcblxuICBNT0RFTF9QQVRIID0gXCJtb2RlbFwiO1xuXG4gIFNVTU1BUllGSUVMRFNfUEFUSCA9IFwic3VtbWFyeWZpZWxkc1wiO1xuXG4gIFFVRVJZX1JFU1VMVFNfUEFUSCA9IFwicXVlcnkvcmVzdWx0c1wiO1xuXG4gIFFVSUNLU0VBUkNIX1BBVEggPSBcInNlYXJjaFwiO1xuXG4gIFdJREdFVFNfUEFUSCA9IFwid2lkZ2V0c1wiO1xuXG4gIEVOUklDSE1FTlRfUEFUSCA9IFwibGlzdC9lbnJpY2htZW50XCI7XG5cbiAgV0lUSF9PQkpfUEFUSCA9IFwibGlzdHN3aXRob2JqZWN0XCI7XG5cbiAgTElTVF9PUEVSQVRJT05fUEFUSFMgPSB7XG4gICAgdW5pb246IFwibGlzdHMvdW5pb25cIixcbiAgICBpbnRlcnNlY3Rpb246IFwibGlzdHMvaW50ZXJzZWN0XCIsXG4gICAgZGlmZmVyZW5jZTogXCJsaXN0cy9kaWZmXCJcbiAgfTtcblxuICBTVUJUUkFDVF9QQVRIID0gJ2xpc3RzL3N1YnRyYWN0JztcblxuICBXSE9BTUlfUEFUSCA9IFwidXNlci93aG9hbWlcIjtcblxuICBUQUJMRV9ST1dfUEFUSCA9IFFVRVJZX1JFU1VMVFNfUEFUSCArICcvdGFibGVyb3dzJztcblxuICBQUkVGX1BBVEggPSAndXNlci9wcmVmZXJlbmNlcyc7XG5cbiAgUEFUSF9WQUxVRVNfUEFUSCA9ICdwYXRoL3ZhbHVlcyc7XG5cbiAgVVNFUl9UT0tFTlMgPSAndXNlci90b2tlbnMnO1xuXG4gIElEX1JFU09MVVRJT05fUEFUSCA9ICdpZHMnO1xuXG4gIE5PX0FVVEggPSB7fTtcblxuICBfcmVmID0gW1ZFUlNJT05fUEFUSCwgUkVMRUFTRV9QQVRILCBDTEFTU0tFWV9QQVRILCBXSURHRVRTX1BBVEgsIE1PREVMX1BBVEgsIFNVTU1BUllGSUVMRFNfUEFUSCwgUVVJQ0tTRUFSQ0hfUEFUSCwgUEFUSF9WQUxVRVNfUEFUSF07XG4gIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIHAgPSBfcmVmW19pXTtcbiAgICBOT19BVVRIW3BdID0gdHJ1ZTtcbiAgfVxuXG4gIEFMV0FZU19BVVRIID0ge307XG5cbiAgX3JlZjEgPSBbV0hPQU1JX1BBVEgsIFBSRUZfUEFUSCwgTElTVF9PUEVSQVRJT05fUEFUSFMsIFNVQlRSQUNUX1BBVEgsIFdJVEhfT0JKX1BBVEgsIEVOUklDSE1FTlRfUEFUSCwgVEVNUExBVEVTX1BBVEgsIFVTRVJfVE9LRU5TXTtcbiAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgcCA9IF9yZWYxW19qXTtcbiAgICBBTFdBWVNfQVVUSFtwXSA9IHRydWU7XG4gIH1cblxuICBORUVEU19BVVRIID0gZnVuY3Rpb24ocGF0aCwgcSkge1xuICAgIGlmIChOT19BVVRIW3BhdGhdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChBTFdBWVNfQVVUSFtwYXRoXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghKHEgIT0gbnVsbCA/IHEubmVlZHNBdXRoZW50aWNhdGlvbiA6IHZvaWQgMCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcS5uZWVkc0F1dGhlbnRpY2F0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIEhBU19QUk9UT0NPTCA9IC9eaHR0cHM/OlxcL1xcLy9pO1xuXG4gIEhBU19TVUZGSVggPSAvc2VydmljZVxcLz8kL2k7XG5cbiAgU1VGRklYID0gXCIvc2VydmljZS9cIjtcblxuICBERUZBVUxUX0VSUk9SX0hBTkRMRVIgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGYsIF9yZWYyO1xuICAgIGYgPSAoX3JlZjIgPSBjb25zb2xlLmVycm9yKSAhPSBudWxsID8gX3JlZjIgOiBjb25zb2xlLmxvZztcbiAgICByZXR1cm4gZihlKTtcbiAgfTtcblxuICBfZ2V0X29yX2ZldGNoID0gZnVuY3Rpb24ocHJvcE5hbWUsIHN0b3JlLCBwYXRoLCBrZXksIGNiKSB7XG4gICAgdmFyIG9wdHMsIHByb21pc2UsIHJvb3QsIHVzZUNhY2hlLCB2YWx1ZTtcbiAgICByb290ID0gdGhpcy5yb290LCB1c2VDYWNoZSA9IHRoaXMudXNlQ2FjaGU7XG4gICAgcHJvbWlzZSA9IHRoaXNbcHJvcE5hbWVdICE9IG51bGwgPyB0aGlzW3Byb3BOYW1lXSA6IHRoaXNbcHJvcE5hbWVdID0gdXNlQ2FjaGUgJiYgKHZhbHVlID0gc3RvcmVbcm9vdF0pID8gc3VjY2Vzcyh2YWx1ZSkgOiAob3B0cyA9IHtcbiAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZm9ybWF0OiAnanNvbidcbiAgICAgIH1cbiAgICB9LCB0aGlzLmRvUmVxKG1lcmdlKG9wdHMsIHtcbiAgICAgIHVybDogdGhpcy5yb290ICsgcGF0aFxuICAgIH0pKS50aGVuKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBzdG9yZVtyb290XSA9IHhba2V5XTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIHdpdGhDQihjYiwgcHJvbWlzZSk7XG4gIH07XG5cbiAgZ2V0TGlzdEZpbmRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obGlzdHMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGxpc3Q7XG4gICAgICAgIGlmIChsaXN0ID0gdXRpbHMuZmluZChsaXN0cywgZnVuY3Rpb24obCkge1xuICAgICAgICAgIHJldHVybiBsLm5hbWUgPT09IG5hbWU7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUobGlzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChcIkxpc3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBub3QgZm91bmQgYW1vbmc6IFwiICsgKGxpc3RzLm1hcChnZXQoJ25hbWUnKSkpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICBMSVNUX1BJUEUgPSBmdW5jdGlvbihzZXJ2aWNlLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgPT0gbnVsbCkge1xuICAgICAgcHJvcCA9ICdsaXN0TmFtZSc7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5jb21wb3NlKHNlcnZpY2UuZmV0Y2hMaXN0LCBnZXQocHJvcCkpO1xuICB9O1xuXG4gIFRPX05BTUVTID0gZnVuY3Rpb24oeHMpIHtcbiAgICB2YXIgeCwgX2ssIF9sZW4yLCBfcmVmMiwgX3JlZjMsIF9yZXN1bHRzO1xuICAgIGlmICh4cyA9PSBudWxsKSB7XG4gICAgICB4cyA9IFtdO1xuICAgIH1cbiAgICBfcmVmMiA9ICh1dGlscy5pc0FycmF5KHhzKSA/IHhzIDogW3hzXSk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9rID0gMCwgX2xlbjIgPSBfcmVmMi5sZW5ndGg7IF9rIDwgX2xlbjI7IF9rKyspIHtcbiAgICAgIHggPSBfcmVmMltfa107XG4gICAgICBfcmVzdWx0cy5wdXNoKChfcmVmMyA9IHgubmFtZSkgIT0gbnVsbCA/IF9yZWYzIDogeCk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBTZXJ2aWNlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBGSVZFX01JTiwgY2hlY2tOYW1lUGFyYW0sIGdldE5ld1VzZXJUb2tlbiwgbG9hZFEsIHBhdGhWYWx1ZXNSZXEsIHRvTWFwQnlOYW1lO1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZG9SZXEgPSBodHRwLmRvUmVxO1xuXG4gICAgZnVuY3Rpb24gU2VydmljZShfYXJnKSB7XG4gICAgICB2YXIgbm9DYWNoZTtcbiAgICAgIHRoaXMucm9vdCA9IF9hcmcucm9vdCwgdGhpcy50b2tlbiA9IF9hcmcudG9rZW4sIHRoaXMuZXJyb3JIYW5kbGVyID0gX2FyZy5lcnJvckhhbmRsZXIsIHRoaXMuREVCVUcgPSBfYXJnLkRFQlVHLCB0aGlzLmhlbHAgPSBfYXJnLmhlbHAsIG5vQ2FjaGUgPSBfYXJnLm5vQ2FjaGU7XG4gICAgICB0aGlzLmNvbm5lY3RBcyA9IF9fYmluZCh0aGlzLmNvbm5lY3RBcywgdGhpcyk7XG4gICAgICB0aGlzLmNyZWF0ZUxpc3QgPSBfX2JpbmQodGhpcy5jcmVhdGVMaXN0LCB0aGlzKTtcbiAgICAgIHRoaXMucmVzb2x2ZUlkcyA9IF9fYmluZCh0aGlzLnJlc29sdmVJZHMsIHRoaXMpO1xuICAgICAgdGhpcy50ZW1wbGF0ZVF1ZXJ5ID0gX19iaW5kKHRoaXMudGVtcGxhdGVRdWVyeSwgdGhpcyk7XG4gICAgICB0aGlzLnNhdmVkUXVlcnkgPSBfX2JpbmQodGhpcy5zYXZlZFF1ZXJ5LCB0aGlzKTtcbiAgICAgIHRoaXMucXVlcnkgPSBfX2JpbmQodGhpcy5xdWVyeSwgdGhpcyk7XG4gICAgICB0aGlzLmZldGNoUmVsZWFzZSA9IF9fYmluZCh0aGlzLmZldGNoUmVsZWFzZSwgdGhpcyk7XG4gICAgICB0aGlzLmZldGNoQ2xhc3NLZXlzID0gX19iaW5kKHRoaXMuZmV0Y2hDbGFzc0tleXMsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaFZlcnNpb24gPSBfX2JpbmQodGhpcy5mZXRjaFZlcnNpb24sIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaFN1bW1hcnlGaWVsZHMgPSBfX2JpbmQodGhpcy5mZXRjaFN1bW1hcnlGaWVsZHMsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaE1vZGVsID0gX19iaW5kKHRoaXMuZmV0Y2hNb2RlbCwgdGhpcyk7XG4gICAgICB0aGlzLmZldGNoV2lkZ2V0TWFwID0gX19iaW5kKHRoaXMuZmV0Y2hXaWRnZXRNYXAsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaFdpZGdldHMgPSBfX2JpbmQodGhpcy5mZXRjaFdpZGdldHMsIHRoaXMpO1xuICAgICAgdGhpcy5jb21wbGVtZW50ID0gX19iaW5kKHRoaXMuY29tcGxlbWVudCwgdGhpcyk7XG4gICAgICB0aGlzLmZldGNoTGlzdHNDb250YWluaW5nID0gX19iaW5kKHRoaXMuZmV0Y2hMaXN0c0NvbnRhaW5pbmcsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaExpc3QgPSBfX2JpbmQodGhpcy5mZXRjaExpc3QsIHRoaXMpO1xuICAgICAgdGhpcy5maW5kTGlzdHMgPSBfX2JpbmQodGhpcy5maW5kTGlzdHMsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaExpc3RzID0gX19iaW5kKHRoaXMuZmV0Y2hMaXN0cywgdGhpcyk7XG4gICAgICB0aGlzLmZldGNoVGVtcGxhdGVzID0gX19iaW5kKHRoaXMuZmV0Y2hUZW1wbGF0ZXMsIHRoaXMpO1xuICAgICAgdGhpcy50YWJsZVJvd3MgPSBfX2JpbmQodGhpcy50YWJsZVJvd3MsIHRoaXMpO1xuICAgICAgdGhpcy52YWx1ZXMgPSBfX2JpbmQodGhpcy52YWx1ZXMsIHRoaXMpO1xuICAgICAgdGhpcy5yb3dzID0gX19iaW5kKHRoaXMucm93cywgdGhpcyk7XG4gICAgICB0aGlzLnJlY29yZHMgPSBfX2JpbmQodGhpcy5yZWNvcmRzLCB0aGlzKTtcbiAgICAgIHRoaXMudGFibGUgPSBfX2JpbmQodGhpcy50YWJsZSwgdGhpcyk7XG4gICAgICB0aGlzLnBhdGhWYWx1ZXMgPSBfX2JpbmQodGhpcy5wYXRoVmFsdWVzLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hVc2VyID0gX19iaW5kKHRoaXMuZmV0Y2hVc2VyLCB0aGlzKTtcbiAgICAgIHRoaXMud2hvYW1pID0gX19iaW5kKHRoaXMud2hvYW1pLCB0aGlzKTtcbiAgICAgIHRoaXMuZmluZEJ5SWQgPSBfX2JpbmQodGhpcy5maW5kQnlJZCwgdGhpcyk7XG4gICAgICB0aGlzLmNvdW50ID0gX19iaW5kKHRoaXMuY291bnQsIHRoaXMpO1xuICAgICAgdGhpcy5lbnJpY2htZW50ID0gX19iaW5kKHRoaXMuZW5yaWNobWVudCwgdGhpcyk7XG4gICAgICBpZiAodGhpcy5yb290ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2VydmljZSByb290IHByb3ZpZGVkLiBUaGlzIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFIQVNfUFJPVE9DT0wudGVzdCh0aGlzLnJvb3QpKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IERFRkFVTFRfUFJPVE9DT0wgKyB0aGlzLnJvb3Q7XG4gICAgICB9XG4gICAgICBpZiAoIUhBU19TVUZGSVgudGVzdCh0aGlzLnJvb3QpKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdCArIFNVRkZJWDtcbiAgICAgIH1cbiAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdC5yZXBsYWNlKC9pY2UkLywgXCJpY2UvXCIpO1xuICAgICAgaWYgKHRoaXMuZXJyb3JIYW5kbGVyID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBERUZBVUxUX0VSUk9SX0hBTkRMRVI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oZWxwID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5oZWxwID0gJ25vLmhlbHAuYXZhaWxhYmxlQGRldi5udWxsJztcbiAgICAgIH1cbiAgICAgIHRoaXMudXNlQ2FjaGUgPSAhbm9DYWNoZTtcbiAgICAgIHRoaXMuZ2V0Rm9ybWF0ID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpbnRlbmRlZCkge1xuICAgICAgICAgIGlmIChpbnRlbmRlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnRlbmRlZCA9ICdqc29uJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGludGVuZGVkO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgfVxuXG4gICAgU2VydmljZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KCdQT1NUJywgcGF0aCwgZGF0YSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KCdHRVQnLCBwYXRoLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUubWFrZVJlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIHBhdGgsIGRhdGEsIGNiLCBpbmRpdikge1xuICAgICAgdmFyIGRhdGFUeXBlLCBlcnJCYWNrLCBvcHRzLCB0aW1lb3V0LCBfcmVmMiwgX3JlZjMsIF9yZWY0O1xuICAgICAgaWYgKG1ldGhvZCA9PSBudWxsKSB7XG4gICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICBwYXRoID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgaWYgKGluZGl2ID09IG51bGwpIHtcbiAgICAgICAgaW5kaXYgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KGNiKSkge1xuICAgICAgICBfcmVmMiA9IGNiLCBjYiA9IF9yZWYyWzBdLCBlcnJCYWNrID0gX3JlZjJbMV07XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhID0gdXRpbHMucGFpcnNUb09iaihkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJCYWNrID09IG51bGwpIHtcbiAgICAgICAgZXJyQmFjayA9IHRoaXMuZXJyb3JIYW5kbGVyO1xuICAgICAgfVxuICAgICAgZGF0YSA9IHV0aWxzLmNvcHkoZGF0YSk7XG4gICAgICBkYXRhVHlwZSA9IHRoaXMuZ2V0Rm9ybWF0KGRhdGEuZm9ybWF0KTtcbiAgICAgIGlmICghaHR0cC5zdXBwb3J0cyhtZXRob2QpKSB7XG4gICAgICAgIF9yZWYzID0gW21ldGhvZCwgaHR0cC5nZXRNZXRob2QobWV0aG9kKV0sIGRhdGEubWV0aG9kID0gX3JlZjNbMF0sIG1ldGhvZCA9IF9yZWYzWzFdO1xuICAgICAgfVxuICAgICAgb3B0cyA9IHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZGF0YVR5cGU6IGRhdGFUeXBlLFxuICAgICAgICBzdWNjZXNzOiBjYixcbiAgICAgICAgZXJyb3I6IGVyckJhY2ssXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHR5cGU6IG1ldGhvZFxuICAgICAgfTtcbiAgICAgIGlmIChkYXRhLmF1dGggIT0gbnVsbCkge1xuICAgICAgICBvcHRzLmF1dGggPSBkYXRhLmF1dGg7XG4gICAgICAgIGRlbGV0ZSBvcHRzLmRhdGEuYXV0aDtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgICBvcHRzLmhlYWRlcnMgPSB1dGlscy5jb3B5KGRhdGEuaGVhZGVycyk7XG4gICAgICAgIGRlbGV0ZSBvcHRzLmRhdGEuaGVhZGVycztcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lb3V0ID0gKF9yZWY0ID0gZGF0YS50aW1lb3V0KSAhPSBudWxsID8gX3JlZjQgOiB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgb3B0cy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgZGVsZXRlIGRhdGEudGltZW91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmF1dGhvcmlzZShvcHRzKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXV0aGVkKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmRvUmVxKGF1dGhlZCwgaW5kaXYpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5hdXRob3Jpc2UgPSBmdW5jdGlvbihyZXEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoVmVyc2lvbigpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gICAgICAgICAgdmFyIG9wdHMsIHBhdGhBZGRpdGlvbnMsIF9yZWYyO1xuICAgICAgICAgIG9wdHMgPSB1dGlscy5jb3B5KHJlcSk7XG4gICAgICAgICAgaWYgKG9wdHMuaGVhZGVycyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0cy51cmwgPSBfdGhpcy5yb290ICsgb3B0cy5wYXRoO1xuICAgICAgICAgIHBhdGhBZGRpdGlvbnMgPSBbXTtcbiAgICAgICAgICBpZiAodmVyc2lvbiA8IDE0KSB7XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBvcHRzLmRhdGEpIHtcbiAgICAgICAgICAgICAgcGF0aEFkZGl0aW9ucy5wdXNoKFsnZm9ybWF0Jywgb3B0cy5kYXRhVHlwZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3B0cy5kYXRhLmZvcm1hdCA9IG9wdHMuZGF0YVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoX3RoaXMudG9rZW4gIT0gbnVsbCkgJiYgTkVFRFNfQVVUSChyZXEucGF0aCwgKF9yZWYyID0gb3B0cy5kYXRhKSAhPSBudWxsID8gX3JlZjIucXVlcnkgOiB2b2lkIDApKSB7XG4gICAgICAgICAgICBpZiAodmVyc2lvbiA+PSAxNCkge1xuICAgICAgICAgICAgICBvcHRzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IFwiVG9rZW4gXCIgKyBfdGhpcy50b2tlbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBvcHRzLmRhdGEpIHtcbiAgICAgICAgICAgICAgcGF0aEFkZGl0aW9ucy5wdXNoKFsndG9rZW4nLCBfdGhpcy50b2tlbl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3B0cy5kYXRhLnRva2VuID0gX3RoaXMudG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXRoQWRkaXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgb3B0cy51cmwgKz0gJz8nICsgdG9fcXVlcnlfc3RyaW5nKHBhdGhBZGRpdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZW5yaWNobWVudCA9IGZ1bmN0aW9uKG9wdHMsIGNiKSB7XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLCA4LCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciByZXE7XG4gICAgICAgICAgcmVxID0gbWVyZ2Uoe1xuICAgICAgICAgICAgbWF4cDogMC4wNSxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246ICdIb2xtLUJvbmZlcnJvbmknXG4gICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgX3RoaXMuZ2V0KEVOUklDSE1FTlRfUEFUSCwgcmVxKS50aGVuKGdldCgncmVzdWx0cycpKSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNiKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgOSwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaywgcmVxLCB2LCBfcmVmMjtcbiAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICAgICAgX3JlZjIgPSBbb3B0aW9ucywge31dLCBjYiA9IF9yZWYyWzBdLCBvcHRpb25zID0gX3JlZjJbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlcSA9IHtcbiAgICAgICAgICAgICAgcTogb3B0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxID0ge1xuICAgICAgICAgICAgICBxOiBvcHRpb25zLnFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGsgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKG9wdGlvbnMsIGspKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgdiA9IG9wdGlvbnNba107XG4gICAgICAgICAgICAgIGlmIChrICE9PSAncScpIHtcbiAgICAgICAgICAgICAgICByZXFbXCJmYWNldF9cIiArIGtdID0gdjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5wb3N0KFFVSUNLU0VBUkNIX1BBVEgsIHJlcSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5tYWtlUGF0aCA9IGZ1bmN0aW9uKHBhdGgsIHN1YmNsYXNzZXMsIGNiKSB7XG4gICAgICBpZiAoc3ViY2xhc3NlcyA9PSBudWxsKSB7XG4gICAgICAgIHN1YmNsYXNzZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5mZXRjaE1vZGVsKCkudGhlbihmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBtLm1ha2VQYXRoKHBhdGgsIHN1YmNsYXNzZXMpO1xuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKHEsIGNiKSB7XG4gICAgICB2YXIgcHJvbWlzZSwgcmVxO1xuICAgICAgaWYgKGNiID09IG51bGwpIHtcbiAgICAgICAgY2IgPSAoZnVuY3Rpb24oKSB7fSk7XG4gICAgICB9XG4gICAgICBwcm9taXNlID0gIXEgPyBlcnJvcihcIk5vdCBlbm91Z2ggYXJndW1lbnRzXCIpIDogcS50b1BhdGhTdHJpbmcgIT0gbnVsbCA/IChwID0gcS5pc0NsYXNzKCkgPyBxLmFwcGVuZCgnaWQnKSA6IHEsIHRoaXMucGF0aFZhbHVlcyhwLCAnY291bnQnKSkgOiBxLnRvWE1MICE9IG51bGwgPyAocmVxID0ge1xuICAgICAgICBxdWVyeTogcSxcbiAgICAgICAgZm9ybWF0OiAnanNvbmNvdW50J1xuICAgICAgfSwgdGhpcy5wb3N0KFFVRVJZX1JFU1VMVFNfUEFUSCwgcmVxKS50aGVuKGdldCgnY291bnQnKSkpIDogdHlwZW9mIHEgPT09ICdzdHJpbmcnID8gdGhpcy5mZXRjaE1vZGVsKCkudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICB2YXIgZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvdW50KG0ubWFrZVBhdGgocSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5xdWVyeSh7XG4gICAgICAgICAgICAgIHNlbGVjdDogW3FdXG4gICAgICAgICAgICB9KS50aGVuKF90aGlzLmNvdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSkgOiB0aGlzLnF1ZXJ5KHEpLnRoZW4odGhpcy5jb3VudCk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCBwcm9taXNlKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbih0eXBlLCBpZCwgZmllbGRzLCBjYikge1xuICAgICAgdmFyIHByb21pc2UsIF9yZWYyO1xuICAgICAgaWYgKGZpZWxkcyA9PSBudWxsKSB7XG4gICAgICAgIGZpZWxkcyA9IFsnKionXTtcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oZmllbGRzKSkge1xuICAgICAgICBfcmVmMiA9IFtbJyoqJ10sIGZpZWxkc10sIGZpZWxkcyA9IF9yZWYyWzBdLCBjYiA9IF9yZWYyWzFdO1xuICAgICAgfVxuICAgICAgcHJvbWlzZSA9IHRoaXMucXVlcnkoe1xuICAgICAgICBmcm9tOiB0eXBlLFxuICAgICAgICBzZWxlY3Q6IGZpZWxkcyxcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBpZDogaWRcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihkZWpvaW4pLnRoZW4oaW52b2tlKCdyZWNvcmRzJykpLnRoZW4oZ2V0KDApKTtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHByb21pc2UpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbih0eXBlLCB0ZXJtLCBjb250ZXh0LCBjYikge1xuICAgICAgdmFyIHByb21pc2UsIF9yZWYyO1xuICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oY29udGV4dCkpIHtcbiAgICAgICAgX3JlZjIgPSBbbnVsbCwgY29udGV4dF0sIGNvbnRleHQgPSBfcmVmMlswXSwgY2IgPSBfcmVmMlsxXTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UgPSB0aGlzLnF1ZXJ5KHtcbiAgICAgICAgZnJvbTogdHlwZSxcbiAgICAgICAgc2VsZWN0OiBbJyoqJ10sXG4gICAgICAgIHdoZXJlOiBbW3R5cGUsICdMT09LVVAnLCB0ZXJtLCBjb250ZXh0XV1cbiAgICAgIH0pLnRoZW4oZGVqb2luKS50aGVuKGludm9rZSgncmVjb3JkcycpKTtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHByb21pc2UpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24odHlwZSwgdGVybSwgY29udGV4dCwgY2IpIHtcbiAgICAgIHZhciBfcmVmMjtcbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGNvbnRleHQpKSB7XG4gICAgICAgIF9yZWYyID0gW251bGwsIGNvbnRleHRdLCBjb250ZXh0ID0gX3JlZjJbMF0sIGNiID0gX3JlZjJbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLmxvb2t1cCh0eXBlLCB0ZXJtLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uKGZvdW5kKSB7XG4gICAgICAgIGlmICgoZm91bmQgPT0gbnVsbCkgfHwgZm91bmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFwiTm90aGluZyBmb3VuZFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFwiTXVsdGlwbGUgaXRlbXMgZm91bmQ6IFwiICsgKGZvdW5kLnNsaWNlKDAsIDMpKSArIFwiLi4uXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdWNjZXNzKGZvdW5kWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS53aG9hbWkgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgOSwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5nZXQoV0hPQU1JX1BBVEgpLnRoZW4oZ2V0KCd1c2VyJykpLnRoZW4oZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVc2VyKF90aGlzLCB4KTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmZldGNoVXNlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3M7XG4gICAgICBhcmdzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgIHJldHVybiB0aGlzLndob2FtaS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcGF0aFZhbHVlc1JlcSA9IGZ1bmN0aW9uKGZvcm1hdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICAgIHBhdGg6IFN0cmluZyhwYXRoKSxcbiAgICAgICAgdHlwZUNvbnN0cmFpbnRzOiBKU09OLnN0cmluZ2lmeShwYXRoLnN1YmNsYXNzZXMpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5wYXRoVmFsdWVzID0gZnVuY3Rpb24ocGF0aCwgdHlwZUNvbnN0cmFpbnRzLCBjYikge1xuICAgICAgaWYgKHR5cGVDb25zdHJhaW50cyA9PSBudWxsKSB7XG4gICAgICAgIHR5cGVDb25zdHJhaW50cyA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgNiwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZSwgZm9ybWF0LCBwcm9taXNlLCB3YW50ZWQsIF9yZWYyO1xuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZUNvbnN0cmFpbnRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgd2FudGVkID0gdHlwZUNvbnN0cmFpbnRzO1xuICAgICAgICAgICAgdHlwZUNvbnN0cmFpbnRzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHR5cGVDb25zdHJhaW50cykpIHtcbiAgICAgICAgICAgIF9yZWYyID0gW2NiLCB0eXBlQ29uc3RyYWludHNdLCB0eXBlQ29uc3RyYWludHMgPSBfcmVmMlswXSwgY2IgPSBfcmVmMlsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdhbnRlZCAhPT0gJ2NvdW50Jykge1xuICAgICAgICAgICAgd2FudGVkID0gJ3Jlc3VsdHMnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3JtYXQgPSB3YW50ZWQgPT09ICdjb3VudCcgPyAnanNvbmNvdW50JyA6ICdqc29uJztcbiAgICAgICAgICBwcm9taXNlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9yZWYzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hNb2RlbCgpLnRoZW4oaW52b2tlKCdtYWtlUGF0aCcsIHBhdGgsIChfcmVmMyA9IHBhdGguc3ViY2xhc3NlcykgIT0gbnVsbCA/IF9yZWYzIDogdHlwZUNvbnN0cmFpbnRzKSkudGhlbihmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhWYWx1ZXNSZXEoZm9ybWF0LCBwYXRoKTtcbiAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVxKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucG9zdChQQVRIX1ZBTFVFU19QQVRILCByZXEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pKHRoaXMpKS50aGVuKGdldCh3YW50ZWQpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2FsbChfdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgcHJvbWlzZSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmRvUGFnZWRSZXF1ZXN0ID0gZnVuY3Rpb24ocSwgcGF0aCwgcGFnZSwgZm9ybWF0LCBjYikge1xuICAgICAgdmFyIHJlcSwgX3JlZjI7XG4gICAgICBpZiAocGFnZSA9PSBudWxsKSB7XG4gICAgICAgIHBhZ2UgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgaWYgKHEudG9YTUwgIT0gbnVsbCkge1xuICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihwYWdlKSkge1xuICAgICAgICAgIF9yZWYyID0gW3BhZ2UsIHt9XSwgY2IgPSBfcmVmMlswXSwgcGFnZSA9IF9yZWYyWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJlcSA9IG1lcmdlKHBhZ2UsIHtcbiAgICAgICAgICBxdWVyeTogcSxcbiAgICAgICAgICBmb3JtYXQ6IGZvcm1hdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5wb3N0KHBhdGgsIHJlcSkudGhlbihnZXQoJ3Jlc3VsdHMnKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnkocSkudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5kb1BhZ2VkUmVxdWVzdChxdWVyeSwgcGF0aCwgcGFnZSwgZm9ybWF0LCBjYik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uKHEsIHBhZ2UsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb1BhZ2VkUmVxdWVzdChxLCBRVUVSWV9SRVNVTFRTX1BBVEgsIHBhZ2UsICdqc29udGFibGUnLCBjYik7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnJlY29yZHMgPSBmdW5jdGlvbihxLCBwYWdlLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuZG9QYWdlZFJlcXVlc3QocSwgUVVFUllfUkVTVUxUU19QQVRILCBwYWdlLCAnanNvbm9iamVjdHMnLCBjYik7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnJvd3MgPSBmdW5jdGlvbihxLCBwYWdlLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuZG9QYWdlZFJlcXVlc3QocSwgUVVFUllfUkVTVUxUU19QQVRILCBwYWdlLCAnanNvbicsIGNiKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24ocSwgb3B0cywgY2IpIHtcbiAgICAgIHZhciByZXNwLCBfcmVmMjtcbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKG9wdHMpKSB7XG4gICAgICAgIF9yZWYyID0gW29wdHMsIGNiXSwgY2IgPSBfcmVmMlswXSwgb3B0cyA9IF9yZWYyWzFdO1xuICAgICAgfVxuICAgICAgcmVzcCA9IHEgPT0gbnVsbCA/IGVycm9yKFwiTm8gcXVlcnkgdGVybSBzdXBwbGllZFwiKSA6IChxLmRlc2NyaXB0b3JzICE9IG51bGwpIHx8IHR5cGVvZiBxID09PSAnc3RyaW5nJyA/IHRoaXMucGF0aFZhbHVlcyhxLCBvcHRzKS50aGVuKG1hcChnZXQoJ3ZhbHVlJykpKSA6IHEudG9YTUwgIT0gbnVsbCA/IHEudmlld3MubGVuZ3RoICE9PSAxID8gZXJyb3IoXCJFeHBlY3RlZCBvbmUgY29sdW1uLCBnb3QgXCIgKyBxLnZpZXdzLmxlbmd0aCkgOiB0aGlzLnJvd3MocSwgb3B0cykudGhlbihtYXAoZ2V0KDApKSkgOiB0aGlzLnF1ZXJ5KHEpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy52YWx1ZXMocXVlcnksIG9wdHMpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgcmVzcCk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnRhYmxlUm93cyA9IGZ1bmN0aW9uKHEsIHBhZ2UsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb1BhZ2VkUmVxdWVzdChxLCBUQUJMRV9ST1dfUEFUSCwgcGFnZSwgJ2pzb24nLCBjYik7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmZldGNoVGVtcGxhdGVzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuZ2V0KFRFTVBMQVRFU19QQVRIKS50aGVuKGdldCgndGVtcGxhdGVzJykpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hMaXN0cyA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kTGlzdHMoJycsIGNiKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmluZExpc3RzID0gZnVuY3Rpb24obmFtZSwgY2IpIHtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgbmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKGNiID09IG51bGwpIHtcbiAgICAgICAgY2IgPSAoZnVuY3Rpb24oKSB7fSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaFZlcnNpb24oKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgIHZhciBmbjtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBuYW1lICYmIHYgPCAxMyA/IGVycm9yKFwiRmluZGluZyBsaXN0cyBieSBuYW1lIG9uIHRoZSBzZXJ2ZXIgcmVxdWlyZXMgdmVyc2lvbiAxMy4gVGhpcyBpcyBvbmx5IFwiICsgdikgOiAoZm4gPSBmdW5jdGlvbihscykge1xuICAgICAgICAgICAgdmFyIGRhdGEsIF9rLCBfbGVuMiwgX3Jlc3VsdHM7XG4gICAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChfayA9IDAsIF9sZW4yID0gbHMubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBsc1tfa107XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gobmV3IExpc3QoZGF0YSwgX3RoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9LCBfdGhpcy5nZXQoTElTVFNfUEFUSCwge1xuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgIH0pLnRoZW4oZ2V0KCdsaXN0cycpKS50aGVuKGZuKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaExpc3QgPSBmdW5jdGlvbihuYW1lLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hWZXJzaW9uKCkudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCB2IDwgMTMgPyBfdGhpcy5maW5kTGlzdHMoKS50aGVuKGdldExpc3RGaW5kZXIobmFtZSkpIDogX3RoaXMuZmluZExpc3RzKG5hbWUpLnRoZW4oZ2V0KDApKSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmZldGNoTGlzdHNDb250YWluaW5nID0gZnVuY3Rpb24ob3B0cywgY2IpIHtcbiAgICAgIHZhciBmbjtcbiAgICAgIGZuID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgICAgIHZhciB4LCBfaywgX2xlbjIsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfayA9IDAsIF9sZW4yID0geHMubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICAgICAgICB4ID0geHNbX2tdO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChuZXcgTGlzdCh4LCBfdGhpcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuZ2V0KFdJVEhfT0JKX1BBVEgsIG9wdHMpLnRoZW4oZ2V0KCdsaXN0cycpKS50aGVuKGZuKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmNvbWJpbmVMaXN0cyA9IGZ1bmN0aW9uKG9wZXJhdGlvbiwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHZhciBkZXNjcmlwdGlvbiwgbGlzdHMsIG5hbWUsIHJlcSwgdGFncywgX3JlZjI7XG4gICAgICBfcmVmMiA9IG1lcmdlKHtcbiAgICAgICAgbGlzdHM6IFtdLFxuICAgICAgICB0YWdzOiBbXVxuICAgICAgfSwgb3B0aW9ucyksIG5hbWUgPSBfcmVmMi5uYW1lLCBsaXN0cyA9IF9yZWYyLmxpc3RzLCB0YWdzID0gX3JlZjIudGFncywgZGVzY3JpcHRpb24gPSBfcmVmMi5kZXNjcmlwdGlvbjtcbiAgICAgIHJlcSA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uXG4gICAgICB9O1xuICAgICAgaWYgKHJlcS5kZXNjcmlwdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJlcS5kZXNjcmlwdGlvbiA9IFwiXCIgKyBvcGVyYXRpb24gKyBcIiBvZiBcIiArIChsaXN0cy5qb2luKCcsICcpKTtcbiAgICAgIH1cbiAgICAgIHJlcS50YWdzID0gdGFncy5qb2luKCc7Jyk7XG4gICAgICByZXEubGlzdHMgPSBsaXN0cy5qb2luKCc7Jyk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLmdldChMSVNUX09QRVJBVElPTl9QQVRIU1tvcGVyYXRpb25dLCByZXEpLnRoZW4oTElTVF9QSVBFKHRoaXMpKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21iaW5lTGlzdHMuYXBwbHkodGhpcywgWyd1bmlvbiddLmNvbmNhdChfX3NsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5pbnRlcnNlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbWJpbmVMaXN0cy5hcHBseSh0aGlzLCBbJ2ludGVyc2VjdGlvbiddLmNvbmNhdChfX3NsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21iaW5lTGlzdHMuYXBwbHkodGhpcywgWydkaWZmZXJlbmNlJ10uY29uY2F0KF9fc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmNvbXBsZW1lbnQgPSBmdW5jdGlvbihvcHRpb25zLCBjYikge1xuICAgICAgdmFyIGRlZmF1bHREZXNjLCBkZXNjcmlwdGlvbiwgZXhjbHVkZSwgZnJvbSwgbGlzdHMsIG5hbWUsIHJlZmVyZW5jZXMsIHJlcSwgdGFncztcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGNiID09IG51bGwpIHtcbiAgICAgICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgfVxuICAgICAgZnJvbSA9IG9wdGlvbnMuZnJvbSwgZXhjbHVkZSA9IG9wdGlvbnMuZXhjbHVkZSwgbmFtZSA9IG9wdGlvbnMubmFtZSwgZGVzY3JpcHRpb24gPSBvcHRpb25zLmRlc2NyaXB0aW9uLCB0YWdzID0gb3B0aW9ucy50YWdzO1xuICAgICAgZGVmYXVsdERlc2MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiUmVsYXRpdmUgY29tcGxlbWVudCBvZiBcIiArIChsaXN0cy5qb2luKCcgYW5kICcpKSArIFwiIGluIFwiICsgKHJlZmVyZW5jZXMuam9pbignIGFuZCAnKSk7XG4gICAgICB9O1xuICAgICAgcmVmZXJlbmNlcyA9IFRPX05BTUVTKGZyb20pO1xuICAgICAgbGlzdHMgPSBUT19OQU1FUyhleGNsdWRlKTtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IGRlZmF1bHREZXNjKCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgICAgICBkZXNjcmlwdGlvbiA9IGRlZmF1bHREZXNjKCk7XG4gICAgICB9XG4gICAgICBpZiAodGFncyA9PSBudWxsKSB7XG4gICAgICAgIHRhZ3MgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJlcSA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICB0YWdzOiB0YWdzLFxuICAgICAgICBsaXN0czogbGlzdHMsXG4gICAgICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXNcbiAgICAgIH07XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLnBvc3QoU1VCVFJBQ1RfUEFUSCwgcmVxKS50aGVuKExJU1RfUElQRSh0aGlzKSkpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaFdpZGdldHMgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgOCwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX2dldF9vcl9mZXRjaC5jYWxsKF90aGlzLCAnd2lkZ2V0cycsIFdJREdFVFMsIFdJREdFVFNfUEFUSCwgJ3dpZGdldHMnLCBjYik7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIHRvTWFwQnlOYW1lID0gdXRpbHMub21hcChmdW5jdGlvbih3KSB7XG4gICAgICByZXR1cm4gW3cubmFtZSwgd107XG4gICAgfSk7XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaFdpZGdldE1hcCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLCA4LCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIChfdGhpcy5fX3dtYXBfXyAhPSBudWxsID8gX3RoaXMuX193bWFwX18gOiBfdGhpcy5fX3dtYXBfXyA9IF90aGlzLmZldGNoV2lkZ2V0cygpLnRoZW4odG9NYXBCeU5hbWUpKSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmZldGNoTW9kZWwgPSBmdW5jdGlvbihjYikge1xuICAgICAgdmFyIHJldDtcbiAgICAgIHJldCA9IF9nZXRfb3JfZmV0Y2guY2FsbCh0aGlzLCAnbW9kZWwnLCBNT0RFTFMsIE1PREVMX1BBVEgsICdtb2RlbCcpLnRoZW4oTW9kZWwubG9hZCkudGhlbihzZXQoe1xuICAgICAgICBzZXJ2aWNlOiB0aGlzXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCByZXQpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaFN1bW1hcnlGaWVsZHMgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIF9nZXRfb3JfZmV0Y2guY2FsbCh0aGlzLCAnc3VtbWFyeUZpZWxkcycsIFNVTU1BUllfRklFTERTLCBTVU1NQVJZRklFTERTX1BBVEgsICdjbGFzc2VzJywgY2IpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaFZlcnNpb24gPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIF9nZXRfb3JfZmV0Y2guY2FsbCh0aGlzLCAndmVyc2lvbicsIFZFUlNJT05TLCBWRVJTSU9OX1BBVEgsICd2ZXJzaW9uJywgY2IpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaENsYXNzS2V5cyA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gX2dldF9vcl9mZXRjaC5jYWxsKHRoaXMsICdjbGFzc2tleXMnLCBDTEFTU0tFWVMsIENMQVNTS0VZX1BBVEgsICdjbGFzc2VzJywgY2IpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaFJlbGVhc2UgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIF9nZXRfb3JfZmV0Y2guY2FsbCh0aGlzLCAncmVsZWFzZScsIFJFTEVBU0VTLCBSRUxFQVNFX1BBVEgsICd2ZXJzaW9uJywgY2IpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNiKSB7XG4gICAgICB2YXIgYnVpbGRRdWVyeTtcbiAgICAgIGJ1aWxkUXVlcnkgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKF9hcmcpIHtcbiAgICAgICAgICB2YXIgbW9kZWwsIHN1bW1hcnlGaWVsZHM7XG4gICAgICAgICAgbW9kZWwgPSBfYXJnWzBdLCBzdW1tYXJ5RmllbGRzID0gX2FyZ1sxXTtcbiAgICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KG9wdGlvbnMsIF90aGlzLCB7XG4gICAgICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICAgICBzdW1tYXJ5RmllbGRzOiBzdW1tYXJ5RmllbGRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHV0aWxzLnBhcmFsbGVsKHRoaXMuZmV0Y2hNb2RlbCgpLCB0aGlzLmZldGNoU3VtbWFyeUZpZWxkcygpKS50aGVuKGJ1aWxkUXVlcnkpKTtcbiAgICB9O1xuXG4gICAgbG9hZFEgPSBmdW5jdGlvbihzZXJ2aWNlLCBuYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocSkge1xuICAgICAgICBpZiAoIXEpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXCJObyBxdWVyeSBmb3VuZCBjYWxsZWQgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VydmljZS5xdWVyeShxKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNoZWNrTmFtZVBhcmFtID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgbmFtZSkge1xuICAgICAgICAgIHJldHVybiBzdWNjZXNzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFwiTmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXJyb3IoXCJOYW1lIG5vdCBwcm92aWRlZFwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuc2F2ZWRRdWVyeSA9IGZ1bmN0aW9uKG5hbWUsIGNiKSB7XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLCAxNiwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tOYW1lUGFyYW0obmFtZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLmdldCgndXNlci9xdWVyaWVzJywge1xuICAgICAgICAgICAgICBmaWx0ZXI6IG5hbWVcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICByZXR1cm4gci5xdWVyaWVzW25hbWVdO1xuICAgICAgICAgICAgfSkudGhlbihsb2FkUShfdGhpcywgbmFtZSkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUudGVtcGxhdGVRdWVyeSA9IGZ1bmN0aW9uKG5hbWUsIGNiKSB7XG4gICAgICByZXR1cm4gY2hlY2tOYW1lUGFyYW0obmFtZSkudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLmZldGNoVGVtcGxhdGVzKCkudGhlbihnZXQobmFtZSkpLnRoZW4oc2V0KCd0eXBlJywgJ1RFTVBMQVRFJykpLnRoZW4obG9hZFEoX3RoaXMsIG5hbWUpKSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLm1hbmFnZVVzZXJQcmVmZXJlbmNlcyA9IGZ1bmN0aW9uKG1ldGhvZCwgZGF0YSwgY2IpIHtcbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMsIDExLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLm1ha2VSZXF1ZXN0KG1ldGhvZCwgUFJFRl9QQVRILCBkYXRhKS50aGVuKGdldCgncHJlZmVyZW5jZXMnKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5yZXNvbHZlSWRzID0gZnVuY3Rpb24ob3B0cywgY2IpIHtcbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMsIDEwLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciByZXE7XG4gICAgICAgICAgcmVxID0ge1xuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgdXJsOiBfdGhpcy5yb290ICsgSURfUkVTT0xVVElPTl9QQVRILFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KG9wdHMpLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgX3RoaXMuZG9SZXEocmVxKS50aGVuKGdldCgndWlkJykpLnRoZW4oSURSZXNvbHV0aW9uSm9iLmNyZWF0ZShfdGhpcykpKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUucmVzb2x1dGlvbkpvYiA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gSURSZXNvbHV0aW9uSm9iLmNyZWF0ZSh0aGlzKShpZCk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmNyZWF0ZUxpc3QgPSBmdW5jdGlvbihvcHRzLCBpZHMsIGNiKSB7XG4gICAgICB2YXIgYWRqdXN0LCByZXE7XG4gICAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChpZHMgPT0gbnVsbCkge1xuICAgICAgICBpZHMgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIH1cbiAgICAgIGFkanVzdCA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHJldHVybiBtZXJnZSh4LCB7XG4gICAgICAgICAgICB0b2tlbjogX3RoaXMudG9rZW4sXG4gICAgICAgICAgICB0YWdzOiBvcHRzLnRhZ3MgfHwgW11cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgcmVxID0ge1xuICAgICAgICBkYXRhOiB1dGlscy5pc0FycmF5KGlkcykgPyBpZHMubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyB4ICsgXCJcXFwiXCI7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIikgOiBpZHMsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIHVybDogXCJcIiArIHRoaXMucm9vdCArIFwibGlzdHM/XCIgKyAodG9fcXVlcnlfc3RyaW5nKGFkanVzdChvcHRzKSkpLFxuICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgIGNvbnRlbnRUeXBlOiAndGV4dC9wbGFpbidcbiAgICAgIH07XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLmRvUmVxKHJlcSkudGhlbihMSVNUX1BJUEUodGhpcykpKTtcbiAgICB9O1xuXG4gICAgZ2V0TmV3VXNlclRva2VuID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgcmV0dXJuIHJlc3AudXNlci50ZW1wb3JhcnlUb2tlbjtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuY29ubmVjdEFzID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgIHJldHVybiBTZXJ2aWNlLmNvbm5lY3QobWVyZ2UodGhpcywge1xuICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgIG5vQ2FjaGU6ICF0aGlzLnVzZUNhY2hlXG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24obmFtZSwgcGFzc3dvcmQsIGNiKSB7XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLCA5LCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLnBvc3QoJ3VzZXJzJywge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZFxuICAgICAgICAgIH0pLnRoZW4oZ2V0TmV3VXNlclRva2VuKS50aGVuKF90aGlzLmNvbm5lY3RBcykpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBGSVZFX01JTiA9IDUgKiA2MDtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmdldERlcmVnaXN0cmF0aW9uVG9rZW4gPSBmdW5jdGlvbih2YWxpZGl0eSwgY2IpIHtcbiAgICAgIGlmICh2YWxpZGl0eSA9PSBudWxsKSB7XG4gICAgICAgIHZhbGlkaXR5ID0gRklWRV9NSU47XG4gICAgICB9XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLCAxNiwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZTtcbiAgICAgICAgICBwcm9taXNlID0gX3RoaXMudG9rZW4gIT0gbnVsbCA/IF90aGlzLnBvc3QoJ3VzZXIvZGVyZWdpc3RyYXRpb24nLCB7XG4gICAgICAgICAgICB2YWxpZGl0eTogdmFsaWRpdHlcbiAgICAgICAgICB9KS50aGVuKGdldCgndG9rZW4nKSkgOiBlcnJvcihcIk5vdCByZWdpc3RlcmVkXCIpO1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHByb21pc2UpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5kZXJlZ2lzdGVyID0gZnVuY3Rpb24odG9rZW4sIGNiKSB7XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLCAxNiwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5tYWtlUmVxdWVzdCgnREVMRVRFJywgJ3VzZXInLCB7XG4gICAgICAgICAgICBkZXJlZ2lzdHJhdGlvblRva2VuOiB0b2tlbixcbiAgICAgICAgICAgIGZvcm1hdDogJ3htbCdcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmxvZ2luID0gZnVuY3Rpb24obmFtZSwgcGFzc3dvcmQsIGNiKSB7XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLCA5LCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhdXRoO1xuICAgICAgICAgIGF1dGggPSBcIlwiICsgbmFtZSArIFwiOlwiICsgcGFzc3dvcmQ7XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgX3RoaXMubG9nb3V0KCkudGhlbihmdW5jdGlvbihzZXJ2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VydmljZS5nZXQoJ3VzZXIvdG9rZW4nLCB7XG4gICAgICAgICAgICAgIGF1dGg6IGF1dGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKS50aGVuKGdldCgndG9rZW4nKSkudGhlbihfdGhpcy5jb25uZWN0QXMpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5sb2dvdXQgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgc3VjY2Vzcyh0aGlzLmNvbm5lY3RBcygpKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXJ2aWNlO1xuXG4gIH0pKCk7XG5cbiAgU2VydmljZS5wcm90b3R5cGUucm93QnlSb3cgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncywgZiwgcTtcbiAgICBxID0gYXJndW1lbnRzWzBdLCBhcmdzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICBmID0gaHR0cC5pdGVyUmVxKCdQT1NUJywgUVVFUllfUkVTVUxUU19QQVRILCAnanNvbicpO1xuICAgIGlmIChxLnRvWE1MICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KHEpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5yb3dCeVJvdy5hcHBseShfdGhpcywgW3F1ZXJ5XS5jb25jYXQoX19zbGljZS5jYWxsKGFyZ3MpKSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIFNlcnZpY2UucHJvdG90eXBlLmVhY2hSb3cgPSBTZXJ2aWNlLnByb3RvdHlwZS5yb3dCeVJvdztcblxuICBTZXJ2aWNlLnByb3RvdHlwZS5yZWNvcmRCeVJlY29yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzLCBmLCBxO1xuICAgIHEgPSBhcmd1bWVudHNbMF0sIGFyZ3MgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xuICAgIGYgPSBodHRwLml0ZXJSZXEoJ1BPU1QnLCBRVUVSWV9SRVNVTFRTX1BBVEgsICdqc29ub2JqZWN0cycpO1xuICAgIGlmIChxLnRvWE1MICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KHEpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5yZWNvcmRCeVJlY29yZC5hcHBseShfdGhpcywgW3F1ZXJ5XS5jb25jYXQoX19zbGljZS5jYWxsKGFyZ3MpKSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIFNlcnZpY2UucHJvdG90eXBlLmVhY2hSZWNvcmQgPSBTZXJ2aWNlLnByb3RvdHlwZS5yZWNvcmRCeVJlY29yZDtcblxuICBTZXJ2aWNlLnByb3RvdHlwZS51bmlvbiA9IFNlcnZpY2UucHJvdG90eXBlLm1lcmdlO1xuXG4gIFNlcnZpY2UucHJvdG90eXBlLmRpZmZlcmVuY2UgPSBTZXJ2aWNlLnByb3RvdHlwZS5kaWZmO1xuXG4gIFNlcnZpY2UucHJvdG90eXBlLnN5bW1ldHJpY0RpZmZlcmVuY2UgPSBTZXJ2aWNlLnByb3RvdHlwZS5kaWZmO1xuXG4gIFNlcnZpY2UucHJvdG90eXBlLnJlbGF0aXZlQ29tcGxlbWVudCA9IFNlcnZpY2UucHJvdG90eXBlLmNvbXBsZW1lbnQ7XG5cbiAgU2VydmljZS5wcm90b3R5cGUuc3VidHJhY3QgPSBTZXJ2aWNlLnByb3RvdHlwZS5jb21wbGVtZW50O1xuXG4gIFNlcnZpY2UuZmx1c2hDYWNoZXMgPSBmdW5jdGlvbigpIHtcbiAgICBNT0RFTFMgPSB7fTtcbiAgICBWRVJTSU9OUyA9IHt9O1xuICAgIFJFTEVBU0VTID0ge307XG4gICAgQ0xBU1NLRVlTID0ge307XG4gICAgU1VNTUFSWV9GSUVMRFMgPSB7fTtcbiAgICByZXR1cm4gV0lER0VUUyA9IHt9O1xuICB9O1xuXG4gIFNlcnZpY2UuY29ubmVjdCA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICBpZiAoKG9wdHMgIT0gbnVsbCA/IG9wdHMucm9vdCA6IHZvaWQgMCkgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcHRpb25zIHByb3ZpZGVkOiBcIiArIChKU09OLnN0cmluZ2lmeShvcHRzKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNlcnZpY2Uob3B0cyk7XG4gIH07XG5cbiAgZXhwb3J0cy5TZXJ2aWNlID0gU2VydmljZTtcblxuICBleHBvcnRzLk1vZGVsID0gTW9kZWw7XG5cbiAgZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xuXG4gIGV4cG9ydHMudXRpbHMgPSB1dGlscztcblxuICBleHBvcnRzLlZFUlNJT04gPSB2ZXJzaW9uLlZFUlNJT047XG5cbiAgZXhwb3J0cy5pbWpzID0gdmVyc2lvbjtcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCIuL2h0dHBcIjozLFwiLi9pZC1yZXNvbHV0aW9uLWpvYlwiOjQsXCIuL2xpc3RzXCI6NSxcIi4vbW9kZWxcIjo2LFwiLi9wcm9taXNlXCI6OCxcIi4vcXVlcnlcIjo5LFwiLi91c2VyXCI6MTQsXCIuL3V0aWxcIjoxNSxcIi4vdmVyc2lvblwiOjE2fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgRmFrZURvbVBhcnNlcjtcblxuICBleHBvcnRzLkRPTVBhcnNlciA9IGdsb2JhbC5ET01QYXJzZXIgIT0gbnVsbCA/IGdsb2JhbC5ET01QYXJzZXIgOiBGYWtlRG9tUGFyc2VyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEZha2VEb21QYXJzZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJET01QYXJzZXIgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRmFrZURvbVBhcnNlcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIEhBU19DT05TT0xFLCBIQVNfSlNPTiwgTk9UX0VOVU0sIGhhc0RvbnRFbnVtQnVnLCBoYXNPd25Qcm9wZXJ0eSwgaGVhZCwgbSwgc2NyaXB0LCBfZm4sIF9pLCBfbGVuLCBfcmVmO1xuXG4gIEhBU19DT05TT0xFID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuXG4gIEhBU19KU09OID0gdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnO1xuXG4gIE5PVF9FTlVNID0gWyd0b1N0cmluZycsICd0b0xvY2FsZVN0cmluZycsICd2YWx1ZU9mJywgJ2hhc093blByb3BlcnR5JywgJ2lzUHJvdG90eXBlT2YnLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnY29uc3RydWN0b3InXTtcblxuICBpZiAoIUhBU19KU09OKSB7XG4gICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnNyYyA9ICdodHRwOi8vY2RuLmludGVybWluZS5vcmcvanMvanNvbjMvMy4yLjIvanNvbjMubWluLmpzJztcbiAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyA9PSBudWxsKSB7XG4gICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgIGhhc0RvbnRFbnVtQnVnID0gIXtcbiAgICAgIHRvU3RyaW5nOiBudWxsXG4gICAgfS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcInRvU3RyaW5nXCIpO1xuICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgdmFyIGtleXMsIG5hbWUsIG5vbkVudW0sIF9pLCBfbGVuO1xuICAgICAgaWYgKHR5cGVvZiBvICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvICE9PSBcIlwiIHx8IG8gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3RcIik7XG4gICAgICB9XG4gICAgICBrZXlzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobmFtZSBpbiBvKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwobywgbmFtZSkpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCk7XG4gICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBOT1RfRU5VTS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIG5vbkVudW0gPSBOT1RfRU5VTVtfaV07XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwobywgbm9uRW51bSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChub25FbnVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG4gIH1cblxuICBpZiAoQXJyYXkucHJvdG90eXBlLm1hcCA9PSBudWxsKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHZhciB4LCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0aGlzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHggPSB0aGlzW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChmKHgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maWx0ZXIgPT0gbnVsbCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmKSB7XG4gICAgICB2YXIgeCwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdGhpcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB4ID0gdGhpc1tfaV07XG4gICAgICAgIGlmIChmKHgpKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG4gIH1cblxuICBpZiAoQXJyYXkucHJvdG90eXBlLnJlZHVjZSA9PSBudWxsKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uKGYsIGluaXRWYWx1ZSkge1xuICAgICAgdmFyIHJldCwgeCwgeHMsIF9pLCBfbGVuO1xuICAgICAgeHMgPSB0aGlzLnNsaWNlKCk7XG4gICAgICByZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHhzLnBvcCgpIDogaW5pdFZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB4ID0geHNbX2ldO1xuICAgICAgICByZXQgPSBmKHJldCwgeCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH1cblxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPT0gbnVsbCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZiwgY3R4KSB7XG4gICAgICB2YXIgaSwgeCwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgaWYgKCFmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZ1bmN0aW9uIHByb3ZpZGVkXCIpO1xuICAgICAgfVxuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoaSA9IF9pID0gMCwgX2xlbiA9IHRoaXMubGVuZ3RoOyBfaSA8IF9sZW47IGkgPSArK19pKSB7XG4gICAgICAgIHggPSB0aGlzW2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGYuY2FsbChjdHggIT0gbnVsbCA/IGN0eCA6IHRoaXMsIHgsIGksIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFIQVNfQ09OU09MRSkge1xuICAgIHRoaXMuY29uc29sZSA9IHtcbiAgICAgIGxvZzogKGZ1bmN0aW9uKCkge30pLFxuICAgICAgZXJyb3I6IChmdW5jdGlvbigpIHt9KSxcbiAgICAgIGRlYnVnOiAoZnVuY3Rpb24oKSB7fSlcbiAgICB9O1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuICAgICAgd2luZG93LmNvbnNvbGUgPSB0aGlzLmNvbnNvbGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnNvbGUubG9nID09IG51bGwpIHtcbiAgICBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uKCkge307XG4gIH1cblxuICBpZiAoY29uc29sZS5lcnJvciA9PSBudWxsKSB7XG4gICAgY29uc29sZS5lcnJvciA9IGZ1bmN0aW9uKCkge307XG4gIH1cblxuICBpZiAoY29uc29sZS5kZWJ1ZyA9PSBudWxsKSB7XG4gICAgY29uc29sZS5kZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG4gIH1cblxuICBpZiAoY29uc29sZS5sb2cuYXBwbHkgPT0gbnVsbCkge1xuICAgIGNvbnNvbGUubG9nKFwiWW91ciBjb25zb2xlIG5lZWRzIHBhdGNoaW5nLlwiKTtcbiAgICBfcmVmID0gWydsb2cnLCAnZXJyb3InLCAnZGVidWcnXTtcbiAgICBfZm4gPSBmdW5jdGlvbihtKSB7XG4gICAgICB2YXIgb2xkTTtcbiAgICAgIG9sZE0gPSBjb25zb2xlW21dO1xuICAgICAgcmV0dXJuIGNvbnNvbGVbbV0gPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBvbGRNKGFyZ3MpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgbSA9IF9yZWZbX2ldO1xuICAgICAgX2ZuKG0pO1xuICAgIH1cbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuXG59LHt9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBQcm9taXNlLCBtZXJnZSwgcHJvcGVydGllcyxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIG1lcmdlID0gZnVuY3Rpb24oc3JjLCBkZXN0KSB7XG4gICAgdmFyIGssIHYsIF9yZXN1bHRzO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChrIGluIHNyYykge1xuICAgICAgdiA9IHNyY1trXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goZGVzdFtrXSA9IHYpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgUHJvbWlzZSA9IF9kZXJlcV8oJy4vcHJvbWlzZScpO1xuXG4gIHByb3BlcnRpZXMgPSBbJ2F0dHJpYnV0ZXMnLCAncmVmZXJlbmNlcycsICdjb2xsZWN0aW9ucyddO1xuXG4gIGV4cG9ydHMuVGFibGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVGFibGUob3B0cywgbW9kZWwpIHtcbiAgICAgIHZhciBjLCBwcm9wLCBfLCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICB0aGlzLmdldERpc3BsYXlOYW1lID0gX19iaW5kKHRoaXMuZ2V0RGlzcGxheU5hbWUsIHRoaXMpO1xuICAgICAgdGhpcy5uYW1lID0gb3B0cy5uYW1lLCB0aGlzLnRhZ3MgPSBvcHRzLnRhZ3MsIHRoaXMuZGlzcGxheU5hbWUgPSBvcHRzLmRpc3BsYXlOYW1lLCB0aGlzLmF0dHJpYnV0ZXMgPSBvcHRzLmF0dHJpYnV0ZXMsIHRoaXMucmVmZXJlbmNlcyA9IG9wdHMucmVmZXJlbmNlcywgdGhpcy5jb2xsZWN0aW9ucyA9IG9wdHMuY29sbGVjdGlvbnM7XG4gICAgICB0aGlzLmZpZWxkcyA9IHt9O1xuICAgICAgdGhpcy5fX3BhcmVudHNfXyA9IChfcmVmID0gb3B0c1snZXh0ZW5kcyddKSAhPSBudWxsID8gX3JlZiA6IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3AgPSBwcm9wZXJ0aWVzW19pXTtcbiAgICAgICAgaWYgKHRoaXNbcHJvcF0gPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBtb2RlbCBkYXRhOiBtaXNzaW5nIFwiICsgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2UodGhpc1twcm9wXSwgdGhpcy5maWVsZHMpO1xuICAgICAgfVxuICAgICAgX3JlZjEgPSB0aGlzLmNvbGxlY3Rpb25zO1xuICAgICAgZm9yIChfIGluIF9yZWYxKSB7XG4gICAgICAgIGMgPSBfcmVmMVtfXTtcbiAgICAgICAgYy5pc0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIFRhYmxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG4sIF87XG4gICAgICByZXR1cm4gXCJbVGFibGUgbmFtZT1cIiArIHRoaXMubmFtZSArIFwiLCBmaWVsZHM9W1wiICsgKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gdGhpcy5maWVsZHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobiBpbiBfcmVmKSB7XG4gICAgICAgICAgXyA9IF9yZWZbbl07XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpKSArIFwiXV1cIjtcbiAgICB9O1xuXG4gICAgVGFibGUucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgcmV0dXJuICgoX3JlZiA9IHRoaXMuX19wYXJlbnRzX18pICE9IG51bGwgPyBfcmVmIDogW10pLnNsaWNlKCk7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5nZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaWYgKF90aGlzLm1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKF90aGlzLm1vZGVsLm1ha2VQYXRoKF90aGlzLm5hbWUpLmdldERpc3BsYXlOYW1lKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignbW9kZWwgbm90IHNldCAtIGNhbm5vdCBtYWtlIHBhdGgnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGFibGU7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCIuL3Byb21pc2VcIjo4fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgYW55LCBkb19wcmVmX3JlcSwgZXJyb3IsIGdldCwgaXNGdW5jdGlvbiwgd2l0aENCLCBfcmVmLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cbiAgX3JlZiA9IF9kZXJlcV8oJy4vdXRpbCcpLCB3aXRoQ0IgPSBfcmVmLndpdGhDQiwgZ2V0ID0gX3JlZi5nZXQsIGlzRnVuY3Rpb24gPSBfcmVmLmlzRnVuY3Rpb24sIGFueSA9IF9yZWYuYW55LCBlcnJvciA9IF9yZWYuZXJyb3I7XG5cbiAgZG9fcHJlZl9yZXEgPSBmdW5jdGlvbih1c2VyLCBkYXRhLCBtZXRob2QsIGNiKSB7XG4gICAgcmV0dXJuIHVzZXIuc2VydmljZS5tYW5hZ2VVc2VyUHJlZmVyZW5jZXMobWV0aG9kLCBkYXRhLCBjYikudGhlbihmdW5jdGlvbihwcmVmcykge1xuICAgICAgcmV0dXJuIHVzZXIucHJlZmVyZW5jZXMgPSBwcmVmcztcbiAgICB9KTtcbiAgfTtcblxuICBleHBvcnRzLlVzZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVXNlcihzZXJ2aWNlLCBfYXJnKSB7XG4gICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgdGhpcy51c2VybmFtZSA9IF9hcmcudXNlcm5hbWUsIHRoaXMucHJlZmVyZW5jZXMgPSBfYXJnLnByZWZlcmVuY2VzO1xuICAgICAgdGhpcy5yZWZyZXNoID0gX19iaW5kKHRoaXMucmVmcmVzaCwgdGhpcyk7XG4gICAgICB0aGlzLmNsZWFyUHJlZmVyZW5jZXMgPSBfX2JpbmQodGhpcy5jbGVhclByZWZlcmVuY2VzLCB0aGlzKTtcbiAgICAgIHRoaXMuY2xlYXJQcmVmZXJlbmNlID0gX19iaW5kKHRoaXMuY2xlYXJQcmVmZXJlbmNlLCB0aGlzKTtcbiAgICAgIHRoaXMuc2V0UHJlZmVyZW5jZXMgPSBfX2JpbmQodGhpcy5zZXRQcmVmZXJlbmNlcywgdGhpcyk7XG4gICAgICB0aGlzLnNldFByZWZlcmVuY2UgPSBfX2JpbmQodGhpcy5zZXRQcmVmZXJlbmNlLCB0aGlzKTtcbiAgICAgIHRoaXMuaGFzUHJlZmVyZW5jZXMgPSB0aGlzLnByZWZlcmVuY2VzICE9IG51bGw7XG4gICAgICBpZiAodGhpcy5wcmVmZXJlbmNlcyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXMgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBVc2VyLnByb3RvdHlwZS5zZXRQcmVmZXJlbmNlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgY2IpIHtcbiAgICAgIHZhciBkYXRhLCBfcmVmMTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBfcmVmMSA9IFtudWxsLCB2YWx1ZV0sIHZhbHVlID0gX3JlZjFbMF0sIGNiID0gX3JlZjFbMV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBkYXRhID0ga2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgZXJyb3IoXCJJbmNvcnJlY3QgYXJndW1lbnRzIHRvIHNldFByZWZlcmVuY2VcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc2V0UHJlZmVyZW5jZXMoZGF0YSwgY2IpO1xuICAgIH07XG5cbiAgICBVc2VyLnByb3RvdHlwZS5zZXRQcmVmZXJlbmNlcyA9IGZ1bmN0aW9uKHByZWZzLCBjYikge1xuICAgICAgcmV0dXJuIGRvX3ByZWZfcmVxKHRoaXMsIHByZWZzLCAnUE9TVCcsIGNiKTtcbiAgICB9O1xuXG4gICAgVXNlci5wcm90b3R5cGUuY2xlYXJQcmVmZXJlbmNlID0gZnVuY3Rpb24oa2V5LCBjYikge1xuICAgICAgcmV0dXJuIGRvX3ByZWZfcmVxKHRoaXMsIHtcbiAgICAgICAga2V5OiBrZXlcbiAgICAgIH0sICdERUxFVEUnLCBjYik7XG4gICAgfTtcblxuICAgIFVzZXIucHJvdG90eXBlLmNsZWFyUHJlZmVyZW5jZXMgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIGRvX3ByZWZfcmVxKHRoaXMsIHt9LCAnREVMRVRFJywgY2IpO1xuICAgIH07XG5cbiAgICBVc2VyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBkb19wcmVmX3JlcSh0aGlzLCB7fSwgJ0dFVCcsIGNiKTtcbiAgICB9O1xuXG4gICAgVXNlci5wcm90b3R5cGUuY3JlYXRlVG9rZW4gPSBmdW5jdGlvbih0eXBlLCBtZXNzYWdlLCBjYikge1xuICAgICAgdmFyIF9yZWYxLCBfcmVmMjtcbiAgICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgICAgdHlwZSA9ICdkYXknO1xuICAgICAgfVxuICAgICAgaWYgKChjYiA9PSBudWxsKSAmJiBhbnkoW3R5cGUsIG1lc3NhZ2VdLCBpc0Z1bmN0aW9uKSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0eXBlKSkge1xuICAgICAgICAgIF9yZWYxID0gW251bGwsIG51bGwsIHR5cGVdLCB0eXBlID0gX3JlZjFbMF0sIG1lc3NhZ2UgPSBfcmVmMVsxXSwgY2IgPSBfcmVmMVsyXTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgX3JlZjIgPSBbbnVsbCwgbWVzc2FnZV0sIG1lc3NhZ2UgPSBfcmVmMlswXSwgY2IgPSBfcmVmMlsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLnBvc3QoJ3VzZXIvdG9rZW5zJywge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICB9KS50aGVuKGdldCgndG9rZW4nKSkpO1xuICAgIH07XG5cbiAgICBVc2VyLnByb3RvdHlwZS5mZXRjaEN1cnJlbnRUb2tlbnMgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLmdldCgndXNlci90b2tlbnMnKS50aGVuKGdldCgndG9rZW5zJykpKTtcbiAgICB9O1xuXG4gICAgVXNlci5wcm90b3R5cGUucmV2b2tlQWxsVG9rZW5zID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5tYWtlUmVxdWVzdCgnREVMRVRFJywgJ3VzZXIvdG9rZW5zJykpO1xuICAgIH07XG5cbiAgICBVc2VyLnByb3RvdHlwZS5yZXZva2VUb2tlbiA9IGZ1bmN0aW9uKHRva2VuLCBjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLm1ha2VSZXF1ZXN0KCdERUxFVEUnLCBcInVzZXIvdG9rZW5zL1wiICsgdG9rZW4pKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFVzZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCIuL3V0aWxcIjoxNX1dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIFByb21pc2UsIFJFUVVJUkVTLCBjb21wLCBjdXJyeSwgZW5jb2RlLCBlbnRpdGllcywgZXJyb3IsIGZsYXR0ZW4sIGZvbGQsIGlkLCBpbnZva2UsIGludm9rZVdpdGgsIGlzQXJyYXksIG1lcmdlLCBwYWlyRm9sZCwgcXNGcm9tTGlzdCwgcm9vdCwgc3VjY2VzcywgdGhlbkZvbGQsIF9yZWYsXG4gICAgX19zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9LFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFByb21pc2UgPSBfZGVyZXFfKCcuL3Byb21pc2UnKTtcblxuICByb290ID0gZXhwb3J0cztcblxuICByb290LmRlZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmVycmVkO1xuICAgIGRlZmVycmVkID0ge307XG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICByZXR1cm4gZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfTtcblxuICBlbmNvZGUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoeCkpO1xuICB9O1xuXG4gIHFzRnJvbUxpc3QgPSBmdW5jdGlvbihwYWlycykge1xuICAgIHZhciBwYWlyO1xuICAgIHJldHVybiAoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHBhaXJzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHBhaXIgPSBwYWlyc1tfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2gocGFpci5tYXAoZW5jb2RlKS5qb2luKCc9JykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pKCkpLmpvaW4oJyYnKTtcbiAgfTtcblxuICByb290LnF1ZXJ5c3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGssIHAsIHBhaXJzLCBzdWJMaXN0LCBzdiwgdjtcbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICBwYWlycyA9IG9iai5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlycyA9IFtdO1xuICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICB2ID0gb2JqW2tdO1xuICAgICAgICBpZiAoaXNBcnJheSh2KSkge1xuICAgICAgICAgIHN1Ykxpc3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICBzdiA9IHZbX2ldO1xuICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKFtrLCBzdl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgcGFpcnMgPSBwYWlycy5jb25jYXQoc3ViTGlzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFpcnMucHVzaChbaywgdl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxc0Zyb21MaXN0KChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBwYWlycy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwID0gcGFpcnNbX2ldO1xuICAgICAgICBpZiAocFsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pKCkpO1xuICB9O1xuXG4gIHJvb3QuY3VycnkgPSBjdXJyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzLCBmO1xuICAgIGYgPSBhcmd1bWVudHNbMF0sIGFyZ3MgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN0O1xuICAgICAgcmVzdCA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChyZXN0KSk7XG4gICAgfTtcbiAgfTtcblxuICByb290LmVycm9yID0gZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKF8sIHJlamVjdCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoZSkpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJvb3Quc3VjY2VzcyA9IHN1Y2Nlc3MgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIF8pIHtcbiAgICAgIHJldHVybiByZXNvbHZlKHgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJvb3QucGFyYWxsZWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJvbWlzZXM7XG4gICAgcHJvbWlzZXMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgIGlmIChwcm9taXNlcy5sZW5ndGggPT09IDEgJiYgKCFwcm9taXNlc1swXS50aGVuKSAmJiBwcm9taXNlc1swXS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfVxuICB9O1xuXG4gIHJvb3Qud2l0aENCID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGYsIGZzLCBvbkVyciwgb25TdWNjLCBwLCBfaSwgX2osIF9sZW47XG4gICAgZnMgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBfaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxKSA6IChfaSA9IDAsIFtdKSwgcCA9IGFyZ3VtZW50c1tfaSsrXTtcbiAgICBmb3IgKF9qID0gMCwgX2xlbiA9IGZzLmxlbmd0aDsgX2ogPCBfbGVuOyBfaisrKSB7XG4gICAgICBmID0gZnNbX2pdO1xuICAgICAgaWYgKCEoZiAhPSBudWxsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG9uU3VjYyA9IGN1cnJ5KGYsIG51bGwpO1xuICAgICAgb25FcnIgPSBmO1xuICAgICAgcC50aGVuKG9uU3VjYywgb25FcnIpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICByb290LmZvbGQgPSBmb2xkID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBmdW5jdGlvbihpbml0LCB4cykge1xuICAgICAgdmFyIGssIHJldCwgdjtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHhzID0gKGluaXQgIT0gbnVsbCA/IGluaXQuc2xpY2UoKSA6IHZvaWQgMCkgfHwgaW5pdDtcbiAgICAgICAgaW5pdCA9ICh4cyAhPSBudWxsID8geHMuc2hpZnQoKSA6IHZvaWQgMCkgfHwge307XG4gICAgICB9XG4gICAgICBpZiAoeHMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4cyBpcyBudWxsXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHhzLnJlZHVjZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB4cy5yZWR1Y2UoZiwgaW5pdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBpbml0O1xuICAgICAgICBmb3IgKGsgaW4geHMpIHtcbiAgICAgICAgICB2ID0geHNba107XG4gICAgICAgICAgcmV0ID0gcmV0ICE9IG51bGwgPyBmKHJldCwgaywgdikgOiB7XG4gICAgICAgICAgICBrOiB2XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgcm9vdC50YWtlID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgaWYgKG4gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geHMuc2xpY2UoMCwgKyhuIC0gMSkgKyAxIHx8IDllOSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geHMuc2xpY2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHJvb3QuZmlsdGVyID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgdmFyIHgsIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHhzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHggPSB4c1tfaV07XG4gICAgICAgIGlmIChmKHgpKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG4gIH07XG5cbiAgcm9vdC51bmlxQnkgPSBmdW5jdGlvbihmLCB4cykge1xuICAgIHZhciBrLCBrZXlzLCB2YWx1ZXMsIHgsIF9pLCBfbGVuO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gY3Vycnkocm9vdC51bmlxQnksIGYpO1xuICAgIH1cbiAgICBrZXlzID0gW107XG4gICAgdmFsdWVzID0gW107XG4gICAgaWYgKHhzID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIGZvciAoX2kgPSAwLCBfbGVuID0geHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIHggPSB4c1tfaV07XG4gICAgICBrID0gZih4KTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChrZXlzLCBrKSA8IDApIHtcbiAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICB2YWx1ZXMucHVzaCh4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICByb290LmZpbmQgPSBmdW5jdGlvbih4cywgZikge1xuICAgIHZhciB4LCBfaSwgX2xlbjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZiA9IHhzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHhzKSB7XG4gICAgICAgIHJldHVybiByb290LmZpbmQoeHMsIGYpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgeCA9IHhzW19pXTtcbiAgICAgIGlmIChmKHgpKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBpc0FycmF5ID0gKF9yZWYgPSBBcnJheS5pc0FycmF5KSAhPSBudWxsID8gX3JlZiA6IGZ1bmN0aW9uKHhzKSB7XG4gICAgcmV0dXJuICgoeHMgIT0gbnVsbCA/IHhzLnNwbGljZSA6IHZvaWQgMCkgIT0gbnVsbCkgJiYgKCh4cyAhPSBudWxsID8geHMucHVzaCA6IHZvaWQgMCkgIT0gbnVsbCkgJiYgKCh4cyAhPSBudWxsID8geHMucG9wIDogdm9pZCAwKSAhPSBudWxsKSAmJiAoKHhzICE9IG51bGwgPyB4cy5zbGljZSA6IHZvaWQgMCkgIT0gbnVsbCk7XG4gIH07XG5cbiAgcm9vdC5pc0FycmF5ID0gaXNBcnJheTtcblxuICByb290LmlzRnVuY3Rpb24gPSB0eXBlb2YgLy4vICE9PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJztcbiAgfSA6IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gKGYgIT0gbnVsbCkgJiYgKGYuY2FsbCAhPSBudWxsKSAmJiAoZi5hcHBseSAhPSBudWxsKSAmJiBmLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gIH07XG5cbiAgZW50aXRpZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJmFwb3M7J1xuICB9O1xuXG4gIHJvb3QuZXNjYXBlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGNvZGUsIGksIHJldCwgd2l0aEVudGl0aWVzLCBfaSwgX3JlZjE7XG4gICAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHdpdGhFbnRpdGllcyA9IFN0cmluZyhzdHIpLnJlcGxhY2UoL1smPD5cIiddL2csIGZ1bmN0aW9uKGVudGl0eSkge1xuICAgICAgcmV0dXJuIGVudGl0aWVzW2VudGl0eV07XG4gICAgfSk7XG4gICAgcmV0ID0gW107XG4gICAgZm9yIChpID0gX2kgPSAwLCBfcmVmMSA9IHdpdGhFbnRpdGllcy5sZW5ndGg7IDAgPD0gX3JlZjEgPyBfaSA8PSBfcmVmMSA6IF9pID49IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICBjb2RlID0gd2l0aEVudGl0aWVzLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA+IDI1Nikge1xuICAgICAgICByZXQucHVzaChcIiYjXCIgKyBjb2RlICsgXCI7XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2god2l0aEVudGl0aWVzLmNoYXJBdChpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQuam9pbignJyk7XG4gIH07XG5cbiAgcm9vdC5vbWFwID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBtZXJnZXI7XG4gICAgbWVyZ2VyID0gZm9sZChmdW5jdGlvbihhLCBvbGRrLCBvbGR2KSB7XG4gICAgICB2YXIgbmV3aywgbmV3diwgX3JlZjE7XG4gICAgICBfcmVmMSA9IGYob2xkaywgb2xkdiksIG5ld2sgPSBfcmVmMVswXSwgbmV3diA9IF9yZWYxWzFdO1xuICAgICAgaWYgKGlzQXJyYXkobmV3dikpIHtcbiAgICAgICAgbmV3diA9IG5ld3Yuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIGFbbmV3a10gPSBuZXd2O1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHhzKSB7XG4gICAgICByZXR1cm4gbWVyZ2VyKHt9LCB4cyk7XG4gICAgfTtcbiAgfTtcblxuICByb290LmNvcHkgPSByb290Lm9tYXAoZnVuY3Rpb24oaywgdikge1xuICAgIHJldHVybiBbaywgdl07XG4gIH0pO1xuXG4gIHJvb3QucGFydGl0aW9uID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgdmFyIGRpdmlkZTtcbiAgICAgIGRpdmlkZSA9IGZvbGQoZnVuY3Rpb24oX2FyZywgeCkge1xuICAgICAgICB2YXIgZmFsc2VzLCB0cnVlcztcbiAgICAgICAgdHJ1ZXMgPSBfYXJnWzBdLCBmYWxzZXMgPSBfYXJnWzFdO1xuICAgICAgICBpZiAoZih4KSkge1xuICAgICAgICAgIHJldHVybiBbdHJ1ZXMuY29uY2F0KFt4XSksIGZhbHNlc107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFt0cnVlcywgZmFsc2VzLmNvbmNhdChbeF0pXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGl2aWRlKFtbXSwgW11dLCB4cyk7XG4gICAgfTtcbiAgfTtcblxuICByb290LmlkID0gaWQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG5cbiAgcm9vdC5jb25jYXRNYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHhzKSB7XG4gICAgICB2YXIgZngsIHJldCwgeCwgX2ksIF9sZW47XG4gICAgICByZXQgPSB2b2lkIDA7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHhzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHggPSB4c1tfaV07XG4gICAgICAgIGZ4ID0gZih4KTtcbiAgICAgICAgcmV0ID0gcmV0ID09PSB2b2lkIDAgPyBmeCA6IHR5cGVvZiByZXQgPT09ICdudW1iZXInID8gcmV0ICsgZnggOiByZXQuY29uY2F0ICE9IG51bGwgPyByZXQuY29uY2F0KGZ4KSA6IG1lcmdlKHJldCwgZngpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9O1xuXG4gIHJvb3QubWFwID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBpbnZva2UoJ21hcCcsIGYpO1xuICB9O1xuXG4gIGNvbXAgPSBmb2xkKGZ1bmN0aW9uKGYsIGcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncztcbiAgICAgIGFyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgICAgcmV0dXJuIGYoZy5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgcm9vdC5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZzO1xuICAgIGZzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICByZXR1cm4gY29tcChmcyk7XG4gIH07XG5cbiAgcm9vdC5mbGF0TWFwID0gcm9vdC5jb25jYXRNYXA7XG5cbiAgcm9vdC5kaWZmZXJlbmNlID0gZnVuY3Rpb24oeHMsIHJlbW92ZSkge1xuICAgIHZhciB4LCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHhzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICB4ID0geHNbX2ldO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKHJlbW92ZSwgeCkgPCAwKSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goeCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICByb290LnN0cmluZ0xpc3QgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFt4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9O1xuXG4gIHJvb3QuZmxhdHRlbiA9IGZsYXR0ZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmV0LCB4LCB4cywgeHgsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYxO1xuICAgIHhzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICByZXQgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHhzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICB4ID0geHNbX2ldO1xuICAgICAgaWYgKGlzQXJyYXkoeCkpIHtcbiAgICAgICAgX3JlZjEgPSBmbGF0dGVuLmFwcGx5KG51bGwsIHgpO1xuICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICB4eCA9IF9yZWYxW19qXTtcbiAgICAgICAgICByZXQucHVzaCh4eCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5wdXNoKHgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJvb3Quc3VtID0gcm9vdC5jb25jYXRNYXAoaWQpO1xuXG4gIHJvb3QubWVyZ2UgPSBtZXJnZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrLCBuZXdPYmosIG8sIG9ianMsIHYsIF9pLCBfbGVuO1xuICAgIG9ianMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgIG5ld09iaiA9IHt9O1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gb2Jqcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgbyA9IG9ianNbX2ldO1xuICAgICAgZm9yIChrIGluIG8pIHtcbiAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChvLCBrKSkgY29udGludWU7XG4gICAgICAgIHYgPSBvW2tdO1xuICAgICAgICBuZXdPYmpba10gPSB2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqO1xuICB9O1xuXG4gIHJvb3QuYW55ID0gZnVuY3Rpb24oeHMsIGYpIHtcbiAgICB2YXIgeCwgX2ksIF9sZW47XG4gICAgaWYgKGYgPT0gbnVsbCkge1xuICAgICAgZiA9IGlkO1xuICAgIH1cbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHhzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICB4ID0geHNbX2ldO1xuICAgICAgaWYgKGYoeCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByb290Lmludm9rZSA9IGludm9rZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzLCBuYW1lO1xuICAgIG5hbWUgPSBhcmd1bWVudHNbMF0sIGFyZ3MgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xuICAgIHJldHVybiBpbnZva2VXaXRoKG5hbWUsIGFyZ3MpO1xuICB9O1xuXG4gIHJvb3QuaW52b2tlV2l0aCA9IGludm9rZVdpdGggPSBmdW5jdGlvbihuYW1lLCBhcmdzLCBjdHgpIHtcbiAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICBhcmdzID0gW107XG4gICAgfVxuICAgIGlmIChjdHggPT0gbnVsbCkge1xuICAgICAgY3R4ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG8pIHtcbiAgICAgIGlmIChvID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgbWV0aG9kIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgb2YgbnVsbFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghb1tuYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCB1bmRlZmluZWQgbWV0aG9kIFxcXCJcIiArIG5hbWUgKyBcIiBvZiBcIiArIG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9bbmFtZV0uYXBwbHkoY3R4IHx8IG8sIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgcm9vdC5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9ialtuYW1lXTtcbiAgICB9O1xuICB9O1xuXG4gIHJvb3Quc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgaywgdjtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG9ialtuYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChrIGluIG5hbWUpIHtcbiAgICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKG5hbWUsIGspKSBjb250aW51ZTtcbiAgICAgICAgICB2ID0gbmFtZVtrXTtcbiAgICAgICAgICBvYmpba10gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgUkVRVUlSRVMgPSBmdW5jdGlvbihyZXF1aXJlZCwgZ290KSB7XG4gICAgcmV0dXJuIFwiVGhpcyBzZXJ2aWNlIHJlcXVpcmVzIGEgc2VydmljZSBhdCB2ZXJzaW9uIFwiICsgcmVxdWlyZWQgKyBcIiBvciBhYm92ZS4gVGhpcyBvbmUgaXMgYXQgXCIgKyBnb3Q7XG4gIH07XG5cbiAgcm9vdC5SRVFVSVJFU19WRVJTSU9OID0gZnVuY3Rpb24ocywgbiwgZikge1xuICAgIHJldHVybiBzLmZldGNoVmVyc2lvbigpLnRoZW4oZnVuY3Rpb24odikge1xuICAgICAgaWYgKHYgPj0gbikge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFJFUVVJUkVTKG4sIHYpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByb290LmRlam9pbiA9IGZ1bmN0aW9uKHEpIHtcbiAgICB2YXIgcGFydHMsIHZpZXcsIF9pLCBfbGVuLCBfcmVmMTtcbiAgICBfcmVmMSA9IHEudmlld3M7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgdmlldyA9IF9yZWYxW19pXTtcbiAgICAgIHBhcnRzID0gdmlldy5zcGxpdCgnLicpO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgcS5hZGRKb2luKHBhcnRzLnNsaWNlKDEsIC0xKS5qb2luKCcuJykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcTtcbiAgfTtcblxuICB0aGVuRm9sZCA9IGZvbGQoZnVuY3Rpb24ocCwgZikge1xuICAgIHJldHVybiBwLnRoZW4oZik7XG4gIH0pO1xuXG4gIHJvb3Quc2VxdWVuY2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZm5zO1xuICAgIGZucyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgcmV0dXJuIHRoZW5Gb2xkKHN1Y2Nlc3MoKSwgZm5zKTtcbiAgfTtcblxuICBwYWlyRm9sZCA9IGZvbGQoZnVuY3Rpb24obywgX2FyZykge1xuICAgIHZhciBrLCB2O1xuICAgIGsgPSBfYXJnWzBdLCB2ID0gX2FyZ1sxXTtcbiAgICBpZiAob1trXSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUga2V5OiBcIiArIGspO1xuICAgIH1cbiAgICBvW2tdID0gdjtcbiAgICByZXR1cm4gbztcbiAgfSk7XG5cbiAgcm9vdC5wYWlyc1RvT2JqID0gZnVuY3Rpb24ocGFpcnMpIHtcbiAgICByZXR1cm4gcGFpckZvbGQoe30sIHBhaXJzKTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCIuL3Byb21pc2VcIjo4fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICBleHBvcnRzLlZFUlNJT04gPSAnMy4xMy4wJztcblxufSkuY2FsbCh0aGlzKTtcblxufSx7fV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgRE9NUGFyc2VyLCBzYW5pdGl6ZTtcblxuICBET01QYXJzZXIgPSBfZGVyZXFfKCd4bWxkb20nKS5ET01QYXJzZXI7XG5cbiAgc2FuaXRpemUgPSBmdW5jdGlvbih4bWwpIHtcbiAgICB4bWwgPSB4bWwucmVwbGFjZSgvXlxccyovZywgJycpO1xuICAgIHhtbCA9IHhtbC5yZXBsYWNlKC9cXHMkL2csICcnKTtcbiAgICBpZiAoeG1sLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHhtbDtcbiAgICB9IGVsc2UgaWYgKHhtbFt4bWwubGVuZ3RoIC0gMV0gIT09ICc+Jykge1xuICAgICAgcmV0dXJuIHhtbCArICc+JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHhtbDtcbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKHhtbCkge1xuICAgIHZhciBkb20sIHBhcnNlcjtcbiAgICBpZiAodHlwZW9mIHhtbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nIC0gZ290IFwiICsgeG1sKTtcbiAgICB9XG4gICAgeG1sID0gc2FuaXRpemUoeG1sKTtcbiAgICBpZiAoIXhtbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgY29udGVudCAtIGdvdCBlbXB0eSBzdHJpbmdcIik7XG4gICAgfVxuICAgIGRvbSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCAndGV4dC94bWwnKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICB9KSgpO1xuICAgIGlmICgoIWRvbSkgfHwgKCFkb20uZG9jdW1lbnRFbGVtZW50KSB8fCBkb20uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhcnNlcmVycm9yJykubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFhNTDogXCIgKyB4bWwpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuXG59LHtcInhtbGRvbVwiOjExfV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLEJ1ZmZlcil7XG5cblxudmFyIFBhcnNlciA9IF9kZXJlcV8oJ2pzb25wYXJzZScpXG4gICwgdGhyb3VnaCA9IF9kZXJlcV8oJ3Rocm91Z2gnKVxuXG4vKlxuXG4gIHRoZSB2YWx1ZSBvZiB0aGlzLnN0YWNrIHRoYXQgY3JlYXRpb25peCdzIGpzb25wYXJzZSBoYXMgaXMgd2VpcmQuXG5cbiAgaXQgbWFrZXMgdGhpcyBjb2RlIHVnbHksIGJ1dCBoaXMgcHJvYmxlbSBpcyB3YXkgaGFyZGVyIHRoYXQgbWluZSxcbiAgc28gaSdsbCBmb3JnaXZlIGhpbS5cblxuKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChwYXRoLCBtYXApIHtcblxuICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcigpXG4gIHZhciBzdHJlYW0gPSB0aHJvdWdoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmKCdzdHJpbmcnID09PSB0eXBlb2YgY2h1bmspXG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmspXG4gICAgcGFyc2VyLndyaXRlKGNodW5rKVxuICB9LFxuICBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmKGRhdGEpXG4gICAgICBzdHJlYW0ud3JpdGUoZGF0YSlcbiAgICBzdHJlYW0ucXVldWUobnVsbClcbiAgfSlcblxuICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIHBhdGgpXG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlID09PSAnKicpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBlbHNlIGlmIChlID09PSAnJykgLy8gJy4uJy5zcGxpdCgnLicpIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgIHJldHVybiB7cmVjdXJzZTogdHJ1ZX1cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGVcbiAgICB9KVxuXG5cbiAgdmFyIGNvdW50ID0gMCwgX2tleVxuICBpZighcGF0aCB8fCAhcGF0aC5sZW5ndGgpXG4gICAgcGF0aCA9IG51bGxcblxuICBwYXJzZXIub25WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghdGhpcy5yb290KVxuICAgICAgc3RyZWFtLnJvb3QgPSB2YWx1ZVxuXG4gICAgaWYoISBwYXRoKSByZXR1cm5cblxuICAgIHZhciBpID0gMCAvLyBpdGVyYXRlcyBvbiBwYXRoXG4gICAgdmFyIGogID0gMCAvLyBpdGVyYXRlcyBvbiBzdGFja1xuICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBwYXRoW2ldXG4gICAgICB2YXIgY1xuICAgICAgaisrXG5cbiAgICAgIGlmIChrZXkgJiYgIWtleS5yZWN1cnNlKSB7XG4gICAgICAgIGMgPSAoaiA9PT0gdGhpcy5zdGFjay5sZW5ndGgpID8gdGhpcyA6IHRoaXMuc3RhY2tbal1cbiAgICAgICAgaWYgKCFjKSByZXR1cm5cbiAgICAgICAgaWYgKCEgY2hlY2soa2V5LCBjLmtleSkpIHJldHVyblxuICAgICAgICBpKytcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrK1xuICAgICAgICB2YXIgbmV4dEtleSA9IHBhdGhbaV1cbiAgICAgICAgaWYgKCEgbmV4dEtleSkgcmV0dXJuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgYyA9IChqID09PSB0aGlzLnN0YWNrLmxlbmd0aCkgPyB0aGlzIDogdGhpcy5zdGFja1tqXVxuICAgICAgICAgIGlmICghYykgcmV0dXJuXG4gICAgICAgICAgaWYgKGNoZWNrKG5leHRLZXksIGMua2V5KSkgeyBpKys7IGJyZWFrfVxuICAgICAgICAgIGorK1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqICE9PSB0aGlzLnN0YWNrLmxlbmd0aCkgcmV0dXJuXG5cbiAgICBjb3VudCArK1xuICAgIHZhciBhY3R1YWxQYXRoID0gdGhpcy5zdGFjay5zbGljZSgxKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5rZXkgfSkuY29uY2F0KFt0aGlzLmtleV0pXG4gICAgdmFyIGRhdGEgPSB0aGlzLnZhbHVlW3RoaXMua2V5XVxuICAgIGlmKG51bGwgIT0gZGF0YSlcbiAgICAgIGlmKG51bGwgIT0gKGRhdGEgPSBtYXAgPyBtYXAoZGF0YSwgYWN0dWFsUGF0aCkgOiBkYXRhKSlcbiAgICAgICAgc3RyZWFtLnF1ZXVlKGRhdGEpXG4gICAgZGVsZXRlIHRoaXMudmFsdWVbdGhpcy5rZXldXG4gIH1cbiAgcGFyc2VyLl9vblRva2VuID0gcGFyc2VyLm9uVG9rZW47XG5cbiAgcGFyc2VyLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIHZhbHVlKSB7XG4gICAgcGFyc2VyLl9vblRva2VuKHRva2VuLCB2YWx1ZSk7XG4gICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoc3RyZWFtLnJvb3QpIHtcbiAgICAgICAgaWYoIXBhdGgpXG4gICAgICAgICAgc3RyZWFtLnF1ZXVlKHN0cmVhbS5yb290KVxuICAgICAgICBzdHJlYW0uZW1pdCgncm9vdCcsIHN0cmVhbS5yb290LCBjb3VudClcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICBzdHJlYW0ucm9vdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGFyc2VyLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG5cblxuICByZXR1cm4gc3RyZWFtXG59XG5cbmZ1bmN0aW9uIGNoZWNrICh4LCB5KSB7XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHgpXG4gICAgcmV0dXJuIHkgPT0geFxuICBlbHNlIGlmICh4ICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiB4LmV4ZWMpXG4gICAgcmV0dXJuIHguZXhlYyh5KVxuICBlbHNlIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiB4KVxuICAgIHJldHVybiB4XG4gIGVsc2UgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB4KVxuICAgIHJldHVybiB4KHkpXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvcCwgc2VwLCBjbCwgaW5kZW50KSB7XG4gIGluZGVudCA9IGluZGVudCB8fCAwXG4gIGlmIChvcCA9PT0gZmFsc2Upe1xuICAgIG9wID0gJydcbiAgICBzZXAgPSAnXFxuJ1xuICAgIGNsID0gJydcbiAgfSBlbHNlIGlmIChvcCA9PSBudWxsKSB7XG5cbiAgICBvcCA9ICdbXFxuJ1xuICAgIHNlcCA9ICdcXG4sXFxuJ1xuICAgIGNsID0gJ1xcbl1cXG4nXG5cbiAgfVxuXG4gIC8vZWxzZSwgd2hhdCBldmVyIHlvdSBsaWtlXG5cbiAgdmFyIHN0cmVhbVxuICAgICwgZmlyc3QgPSB0cnVlXG4gICAgLCBhbnlEYXRhID0gZmFsc2VcbiAgc3RyZWFtID0gdGhyb3VnaChmdW5jdGlvbiAoZGF0YSkge1xuICAgIGFueURhdGEgPSB0cnVlXG4gICAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCBpbmRlbnQpXG4gICAgaWYoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZSA7IHN0cmVhbS5xdWV1ZShvcCArIGpzb24pfVxuICAgIGVsc2Ugc3RyZWFtLnF1ZXVlKHNlcCArIGpzb24pXG4gIH0sXG4gIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoIWFueURhdGEpXG4gICAgICBzdHJlYW0ucXVldWUob3ApXG4gICAgc3RyZWFtLnF1ZXVlKGNsKVxuICAgIHN0cmVhbS5xdWV1ZShudWxsKVxuICB9KVxuXG4gIHJldHVybiBzdHJlYW1cbn1cblxuZXhwb3J0cy5zdHJpbmdpZnlPYmplY3QgPSBmdW5jdGlvbiAob3AsIHNlcCwgY2wsIGluZGVudCkge1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgMFxuICBpZiAob3AgPT09IGZhbHNlKXtcbiAgICBvcCA9ICcnXG4gICAgc2VwID0gJ1xcbidcbiAgICBjbCA9ICcnXG4gIH0gZWxzZSBpZiAob3AgPT0gbnVsbCkge1xuXG4gICAgb3AgPSAne1xcbidcbiAgICBzZXAgPSAnXFxuLFxcbidcbiAgICBjbCA9ICdcXG59XFxuJ1xuXG4gIH1cblxuICAvL2Vsc2UsIHdoYXQgZXZlciB5b3UgbGlrZVxuXG4gIHZhciBmaXJzdCA9IHRydWVcbiAgICAsIGFueURhdGEgPSBmYWxzZVxuICBzdHJlYW0gPSB0aHJvdWdoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgYW55RGF0YSA9IHRydWVcbiAgICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGFbMF0pICsgJzonICsgSlNPTi5zdHJpbmdpZnkoZGF0YVsxXSwgbnVsbCwgaW5kZW50KVxuICAgIGlmKGZpcnN0KSB7IGZpcnN0ID0gZmFsc2UgOyB0aGlzLnF1ZXVlKG9wICsganNvbil9XG4gICAgZWxzZSB0aGlzLnF1ZXVlKHNlcCArIGpzb24pXG4gIH0sXG4gIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoIWFueURhdGEpIHRoaXMucXVldWUob3ApXG4gICAgdGhpcy5xdWV1ZShjbClcblxuICAgIHRoaXMucXVldWUobnVsbClcbiAgfSlcblxuICByZXR1cm4gc3RyZWFtXG59XG5cbmlmKCFtb2R1bGUucGFyZW50ICYmIHByb2Nlc3MudGl0bGUgIT09ICdicm93c2VyJykge1xuICBwcm9jZXNzLnN0ZGluXG4gICAgLnBpcGUoZXhwb3J0cy5wYXJzZShwcm9jZXNzLmFyZ3ZbMl0pKVxuICAgIC5waXBlKGV4cG9ydHMuc3RyaW5naWZ5KCdbJywgJyxcXG4nLCAnXVxcbicsIDIpKVxuICAgIC5waXBlKHByb2Nlc3Muc3Rkb3V0KVxufVxuXG59KS5jYWxsKHRoaXMsX2RlcmVxXyhcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSxfZGVyZXFfKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbn0se1wiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCI6NTUsXCJidWZmZXJcIjoyMyxcImpzb25wYXJzZVwiOjE5LFwidGhyb3VnaFwiOjU2fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChCdWZmZXIpe1xuLypnbG9iYWwgQnVmZmVyKi9cbi8vIE5hbWVkIGNvbnN0YW50cyB3aXRoIHVuaXF1ZSBpbnRlZ2VyIHZhbHVlc1xudmFyIEMgPSB7fTtcbi8vIFRva2Vuc1xudmFyIExFRlRfQlJBQ0UgICAgPSBDLkxFRlRfQlJBQ0UgICAgPSAweDE7XG52YXIgUklHSFRfQlJBQ0UgICA9IEMuUklHSFRfQlJBQ0UgICA9IDB4MjtcbnZhciBMRUZUX0JSQUNLRVQgID0gQy5MRUZUX0JSQUNLRVQgID0gMHgzO1xudmFyIFJJR0hUX0JSQUNLRVQgPSBDLlJJR0hUX0JSQUNLRVQgPSAweDQ7XG52YXIgQ09MT04gICAgICAgICA9IEMuQ09MT04gICAgICAgICA9IDB4NTtcbnZhciBDT01NQSAgICAgICAgID0gQy5DT01NQSAgICAgICAgID0gMHg2O1xudmFyIFRSVUUgICAgICAgICAgPSBDLlRSVUUgICAgICAgICAgPSAweDc7XG52YXIgRkFMU0UgICAgICAgICA9IEMuRkFMU0UgICAgICAgICA9IDB4ODtcbnZhciBOVUxMICAgICAgICAgID0gQy5OVUxMICAgICAgICAgID0gMHg5O1xudmFyIFNUUklORyAgICAgICAgPSBDLlNUUklORyAgICAgICAgPSAweGE7XG52YXIgTlVNQkVSICAgICAgICA9IEMuTlVNQkVSICAgICAgICA9IDB4Yjtcbi8vIFRva2VuaXplciBTdGF0ZXNcbnZhciBTVEFSVCAgID0gQy5TVEFSVCAgID0gMHgxMTtcbnZhciBUUlVFMSAgID0gQy5UUlVFMSAgID0gMHgyMTtcbnZhciBUUlVFMiAgID0gQy5UUlVFMiAgID0gMHgyMjtcbnZhciBUUlVFMyAgID0gQy5UUlVFMyAgID0gMHgyMztcbnZhciBGQUxTRTEgID0gQy5GQUxTRTEgID0gMHgzMTtcbnZhciBGQUxTRTIgID0gQy5GQUxTRTIgID0gMHgzMjtcbnZhciBGQUxTRTMgID0gQy5GQUxTRTMgID0gMHgzMztcbnZhciBGQUxTRTQgID0gQy5GQUxTRTQgID0gMHgzNDtcbnZhciBOVUxMMSAgID0gQy5OVUxMMSAgID0gMHg0MTtcbnZhciBOVUxMMiAgID0gQy5OVUxMMyAgID0gMHg0MjtcbnZhciBOVUxMMyAgID0gQy5OVUxMMiAgID0gMHg0MztcbnZhciBOVU1CRVIxID0gQy5OVU1CRVIxID0gMHg1MTtcbnZhciBOVU1CRVIyID0gQy5OVU1CRVIyID0gMHg1MjtcbnZhciBOVU1CRVIzID0gQy5OVU1CRVIzID0gMHg1MztcbnZhciBOVU1CRVI0ID0gQy5OVU1CRVI0ID0gMHg1NDtcbnZhciBOVU1CRVI1ID0gQy5OVU1CRVI1ID0gMHg1NTtcbnZhciBOVU1CRVI2ID0gQy5OVU1CRVI2ID0gMHg1NjtcbnZhciBOVU1CRVI3ID0gQy5OVU1CRVI3ID0gMHg1NztcbnZhciBOVU1CRVI4ID0gQy5OVU1CRVI4ID0gMHg1ODtcbnZhciBTVFJJTkcxID0gQy5TVFJJTkcxID0gMHg2MTtcbnZhciBTVFJJTkcyID0gQy5TVFJJTkcyID0gMHg2MjtcbnZhciBTVFJJTkczID0gQy5TVFJJTkczID0gMHg2MztcbnZhciBTVFJJTkc0ID0gQy5TVFJJTkc0ID0gMHg2NDtcbnZhciBTVFJJTkc1ID0gQy5TVFJJTkc1ID0gMHg2NTtcbnZhciBTVFJJTkc2ID0gQy5TVFJJTkc2ID0gMHg2Njtcbi8vIFBhcnNlciBTdGF0ZXNcbnZhciBWQUxVRSAgID0gQy5WQUxVRSAgID0gMHg3MTtcbnZhciBLRVkgICAgID0gQy5LRVkgICAgID0gMHg3Mjtcbi8vIFBhcnNlciBNb2Rlc1xudmFyIE9CSkVDVCAgPSBDLk9CSkVDVCAgPSAweDgxO1xudmFyIEFSUkFZICAgPSBDLkFSUkFZICAgPSAweDgyO1xuXG4vLyBTbG93IGNvZGUgdG8gc3RyaW5nIGNvbnZlcnRlciAob25seSB1c2VkIHdoZW4gdGhyb3dpbmcgc3ludGF4IGVycm9ycylcbmZ1bmN0aW9uIHRva25hbShjb2RlKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoQyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoQ1trZXldID09PSBjb2RlKSB7IHJldHVybiBrZXk7IH1cbiAgfVxuICByZXR1cm4gY29kZSAmJiAoXCIweFwiICsgY29kZS50b1N0cmluZygxNikpO1xufVxuXG5cbmZ1bmN0aW9uIFBhcnNlcigpIHtcbiAgdGhpcy50U3RhdGUgPSBTVEFSVDtcbiAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcblxuICB0aGlzLnN0cmluZyA9IHVuZGVmaW5lZDsgLy8gc3RyaW5nIGRhdGFcbiAgdGhpcy51bmljb2RlID0gdW5kZWZpbmVkOyAvLyB1bmljb2RlIGVzY2FwZXNcblxuICAvLyBGb3IgbnVtYmVyIHBhcnNpbmdcbiAgdGhpcy5uZWdhdGl2ZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5tYWduYXR1ZGUgPSB1bmRlZmluZWQ7XG4gIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gIHRoaXMuZXhwb25lbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMubmVnYXRpdmVFeHBvbmVudCA9IHVuZGVmaW5lZDtcbiAgXG4gIHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICB0aGlzLm1vZGUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuc3RhY2sgPSBbXTtcbiAgdGhpcy5zdGF0ZSA9IFZBTFVFO1xuICB0aGlzLmJ5dGVzX3JlbWFpbmluZyA9IDA7IC8vIG51bWJlciBvZiBieXRlcyByZW1haW5pbmcgaW4gbXVsdGkgYnl0ZSB1dGY4IGNoYXIgdG8gcmVhZCBhZnRlciBzcGxpdCBib3VuZGFyeVxuICB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlID0gMDsgLy8gYnl0ZXMgaW4gbXVsdGkgYnl0ZSB1dGY4IGNoYXIgdG8gcmVhZFxuICB0aGlzLnRlbXBfYnVmZnMgPSB7IFwiMlwiOiBuZXcgQnVmZmVyKDIpLCBcIjNcIjogbmV3IEJ1ZmZlcigzKSwgXCI0XCI6IG5ldyBCdWZmZXIoNCkgfTsgLy8gZm9yIHJlYnVpbGRpbmcgY2hhcnMgc3BsaXQgYmVmb3JlIGJvdW5kYXJ5IGlzIHJlYWNoZWRcbn1cbnZhciBwcm90byA9IFBhcnNlci5wcm90b3R5cGU7XG5wcm90by5jaGFyRXJyb3IgPSBmdW5jdGlvbiAoYnVmZmVyLCBpKSB7XG4gIHRoaXMub25FcnJvcihuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgSlNPTi5zdHJpbmdpZnkoU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbaV0pKSArIFwiIGF0IHBvc2l0aW9uIFwiICsgaSArIFwiIGluIHN0YXRlIFwiICsgdG9rbmFtKHRoaXMudFN0YXRlKSkpO1xufTtcbnByb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfTtcbnByb3RvLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gXCJzdHJpbmdcIikgYnVmZmVyID0gbmV3IEJ1ZmZlcihidWZmZXIpO1xuICAvL3Byb2Nlc3Muc3Rkb3V0LndyaXRlKFwiSW5wdXQ6IFwiKTtcbiAgLy9jb25zb2xlLmRpcihidWZmZXIudG9TdHJpbmcoKSk7XG4gIHZhciBuO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAodGhpcy50U3RhdGUgPT09IFNUQVJUKXtcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICBpZihuID09PSAweDdiKXsgdGhpcy5vblRva2VuKExFRlRfQlJBQ0UsIFwie1wiKTsgLy8ge1xuICAgICAgfWVsc2UgaWYobiA9PT0gMHg3ZCl7IHRoaXMub25Ub2tlbihSSUdIVF9CUkFDRSwgXCJ9XCIpOyAvLyB9XG4gICAgICB9ZWxzZSBpZihuID09PSAweDViKXsgdGhpcy5vblRva2VuKExFRlRfQlJBQ0tFVCwgXCJbXCIpOyAvLyBbXG4gICAgICB9ZWxzZSBpZihuID09PSAweDVkKXsgdGhpcy5vblRva2VuKFJJR0hUX0JSQUNLRVQsIFwiXVwiKTsgLy8gXVxuICAgICAgfWVsc2UgaWYobiA9PT0gMHgzYSl7IHRoaXMub25Ub2tlbihDT0xPTiwgXCI6XCIpOyAgLy8gOlxuICAgICAgfWVsc2UgaWYobiA9PT0gMHgyYyl7IHRoaXMub25Ub2tlbihDT01NQSwgXCIsXCIpOyAvLyAsXG4gICAgICB9ZWxzZSBpZihuID09PSAweDc0KXsgdGhpcy50U3RhdGUgPSBUUlVFMTsgIC8vIHRcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NjYpeyB0aGlzLnRTdGF0ZSA9IEZBTFNFMTsgIC8vIGZcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NmUpeyB0aGlzLnRTdGF0ZSA9IE5VTEwxOyAvLyBuXG4gICAgICB9ZWxzZSBpZihuID09PSAweDIyKXsgdGhpcy5zdHJpbmcgPSBcIlwiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7IC8vIFwiXG4gICAgICB9ZWxzZSBpZihuID09PSAweDJkKXsgdGhpcy5uZWdhdGl2ZSA9IHRydWU7IHRoaXMudFN0YXRlID0gTlVNQkVSMTsgLy8gLVxuICAgICAgfWVsc2UgaWYobiA9PT0gMHgzMCl7IHRoaXMubWFnbmF0dWRlID0gMDsgdGhpcy50U3RhdGUgPSBOVU1CRVIyOyAvLyAwXG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYgKG4gPiAweDMwICYmIG4gPCAweDQwKSB7IC8vIDEtOVxuICAgICAgICAgIHRoaXMubWFnbmF0dWRlID0gbiAtIDB4MzA7IHRoaXMudFN0YXRlID0gTlVNQkVSMztcbiAgICAgICAgfSBlbHNlIGlmIChuID09PSAweDIwIHx8IG4gPT09IDB4MDkgfHwgbiA9PT0gMHgwYSB8fCBuID09PSAweDBkKSB7XG4gICAgICAgICAgLy8gd2hpdGVzcGFjZVxuICAgICAgICB9IGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBTVFJJTkcxKXsgLy8gQWZ0ZXIgb3BlbiBxdW90ZVxuICAgICAgbiA9IGJ1ZmZlcltpXTsgLy8gZ2V0IGN1cnJlbnQgYnl0ZSBmcm9tIGJ1ZmZlclxuICAgICAgLy8gY2hlY2sgZm9yIGNhcnJ5IG92ZXIgb2YgYSBtdWx0aSBieXRlIGNoYXIgc3BsaXQgYmV0d2VlbiBkYXRhIGNodW5rc1xuICAgICAgLy8gJiBmaWxsIHRlbXAgYnVmZmVyIGl0IHdpdGggc3RhcnQgb2YgdGhpcyBkYXRhIGNodW5rIHVwIHRvIHRoZSBib3VuZGFyeSBsaW1pdCBzZXQgaW4gdGhlIGxhc3QgaXRlcmF0aW9uXG4gICAgICBpZiAodGhpcy5ieXRlc19yZW1haW5pbmcgPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5ieXRlc19yZW1haW5pbmc7IGorKykge1xuICAgICAgICAgIHRoaXMudGVtcF9idWZmc1t0aGlzLmJ5dGVzX2luX3NlcXVlbmNlXVt0aGlzLmJ5dGVzX2luX3NlcXVlbmNlIC0gdGhpcy5ieXRlc19yZW1haW5pbmcgKyBqXSA9IGJ1ZmZlcltqXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmluZyArPSB0aGlzLnRlbXBfYnVmZnNbdGhpcy5ieXRlc19pbl9zZXF1ZW5jZV0udG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSA9IHRoaXMuYnl0ZXNfcmVtYWluaW5nID0gMDtcbiAgICAgICAgaSA9IGkgKyBqIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlc19yZW1haW5pbmcgPT09IDAgJiYgbiA+PSAxMjgpIHsgLy8gZWxzZSBpZiBubyByZW1haW5kZXIgYnl0ZXMgY2FycmllZCBvdmVyLCBwYXJzZSBtdWx0aSBieXRlICg+PTEyOCkgY2hhcnMgb25lIGF0IGEgdGltZVxuICAgICAgICBpZiAoKG4gPj0gMTk0KSAmJiAobiA8PSAyMjMpKSB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlID0gMjtcbiAgICAgICAgaWYgKChuID49IDIyNCkgJiYgKG4gPD0gMjM5KSkgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSA9IDM7XG4gICAgICAgIGlmICgobiA+PSAyNDApICYmIChuIDw9IDI0NCkpIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgPSA0O1xuICAgICAgICBpZiAoKHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgKyBpKSA+IGJ1ZmZlci5sZW5ndGgpIHsgLy8gaWYgYnl0ZXMgbmVlZGVkIHRvIGNvbXBsZXRlIGNoYXIgZmFsbCBvdXRzaWRlIGJ1ZmZlciBsZW5ndGgsIHdlIGhhdmUgYSBib3VuZGFyeSBzcGxpdFxuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDw9IChidWZmZXIubGVuZ3RoIC0gMSAtIGkpOyBrKyspIHtcbiAgICAgICAgICAgIHRoaXMudGVtcF9idWZmc1t0aGlzLmJ5dGVzX2luX3NlcXVlbmNlXVtrXSA9IGJ1ZmZlcltpICsga107IC8vIGZpbGwgdGVtcCBidWZmZXIgb2YgY29ycmVjdCBzaXplIHdpdGggYnl0ZXMgYXZhaWxhYmxlIGluIHRoaXMgY2h1bmtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ieXRlc19yZW1haW5pbmcgPSAoaSArIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UpIC0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICBpID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdHJpbmcgKz0gYnVmZmVyLnNsaWNlKGksIChpICsgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgaSA9IGkgKyB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlIC0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuID09PSAweDIyKSB7IHRoaXMudFN0YXRlID0gU1RBUlQ7IHRoaXMub25Ub2tlbihTVFJJTkcsIHRoaXMuc3RyaW5nKTsgdGhpcy5zdHJpbmcgPSB1bmRlZmluZWQ7IH1cbiAgICAgIGVsc2UgaWYgKG4gPT09IDB4NWMpIHsgdGhpcy50U3RhdGUgPSBTVFJJTkcyOyB9XG4gICAgICBlbHNlIGlmIChuID49IDB4MjApIHsgdGhpcy5zdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShuKTsgfVxuICAgICAgZWxzZSB7IHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFNUUklORzIpeyAvLyBBZnRlciBiYWNrc2xhc2hcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICBpZihuID09PSAweDIyKXsgdGhpcy5zdHJpbmcgKz0gXCJcXFwiXCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTtcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NWMpeyB0aGlzLnN0cmluZyArPSBcIlxcXFxcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyBcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4MmYpeyB0aGlzLnN0cmluZyArPSBcIlxcL1wiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7IFxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg2Mil7IHRoaXMuc3RyaW5nICs9IFwiXFxiXCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICB9ZWxzZSBpZihuID09PSAweDY2KXsgdGhpcy5zdHJpbmcgKz0gXCJcXGZcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyBcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NmUpeyB0aGlzLnN0cmluZyArPSBcIlxcblwiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7IFxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg3Mil7IHRoaXMuc3RyaW5nICs9IFwiXFxyXCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICB9ZWxzZSBpZihuID09PSAweDc0KXsgdGhpcy5zdHJpbmcgKz0gXCJcXHRcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyBcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NzUpeyB0aGlzLnVuaWNvZGUgPSBcIlwiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzM7XG4gICAgICB9ZWxzZXsgXG4gICAgICAgIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IFxuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gU1RSSU5HMyB8fCB0aGlzLnRTdGF0ZSA9PT0gU1RSSU5HNCB8fCB0aGlzLnRTdGF0ZSA9PT0gU1RSSU5HNSB8fCB0aGlzLnRTdGF0ZSA9PT0gU1RSSU5HNil7IC8vIHVuaWNvZGUgaGV4IGNvZGVzXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgLy8gMC05IEEtRiBhLWZcbiAgICAgIGlmICgobiA+PSAweDMwICYmIG4gPCAweDQwKSB8fCAobiA+IDB4NDAgJiYgbiA8PSAweDQ2KSB8fCAobiA+IDB4NjAgJiYgbiA8PSAweDY2KSkge1xuICAgICAgICB0aGlzLnVuaWNvZGUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShuKTtcbiAgICAgICAgaWYgKHRoaXMudFN0YXRlKysgPT09IFNUUklORzYpIHtcbiAgICAgICAgICB0aGlzLnN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHRoaXMudW5pY29kZSwgMTYpKTtcbiAgICAgICAgICB0aGlzLnVuaWNvZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTtcbiAgICAgIH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IE5VTUJFUjEpeyAvLyBhZnRlciBtaW51c1xuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIGlmIChuID09PSAweDMwKSB7IHRoaXMubWFnbmF0dWRlID0gMDsgdGhpcy50U3RhdGUgPSBOVU1CRVIyOyB9XG4gICAgICBlbHNlIGlmIChuID4gMHgzMCAmJiBuIDwgMHg0MCkgeyB0aGlzLm1hZ25hdHVkZSA9IG4gLSAweDMwOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjM7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVIyKXsgLy8gKiBBZnRlciBpbml0aWFsIHplcm9cbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICBpZihuID09PSAweDJlKXsgLy8gLlxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMC4xOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjQ7XG4gICAgICB9ZWxzZSBpZihuID09PSAweDY1IHx8ICBuID09PSAweDQ1KXsgLy8gZS9FXG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSAwOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjY7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy50U3RhdGUgPSBTVEFSVDtcbiAgICAgICAgdGhpcy5vblRva2VuKE5VTUJFUiwgMCk7XG4gICAgICAgIHRoaXMubWFnbmF0dWRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVIzKXsgLy8gKiBBZnRlciBkaWdpdCAoYmVmb3JlIHBlcmlvZClcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICBpZihuID09PSAweDJlKXsgLy8gLlxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMC4xOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjQ7XG4gICAgICB9ZWxzZSBpZihuID09PSAweDY1IHx8IG4gPT09IDB4NDUpeyAvLyBlL0VcbiAgICAgICAgdGhpcy5leHBvbmVudCA9IDA7IHRoaXMudFN0YXRlID0gTlVNQkVSNjtcbiAgICAgIH1lbHNle1xuICAgICAgICBpZiAobiA+PSAweDMwICYmIG4gPCAweDQwKSB7IHRoaXMubWFnbmF0dWRlID0gdGhpcy5tYWduYXR1ZGUgKiAxMCArIG4gLSAweDMwOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMudFN0YXRlID0gU1RBUlQ7IFxuICAgICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLm1hZ25hdHVkZSA9IC10aGlzLm1hZ25hdHVkZTtcbiAgICAgICAgICAgIHRoaXMubmVnYXRpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub25Ub2tlbihOVU1CRVIsIHRoaXMubWFnbmF0dWRlKTsgXG4gICAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVI0KXsgLy8gQWZ0ZXIgcGVyaW9kXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgaWYgKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkgeyAvLyAwLTlcbiAgICAgICAgdGhpcy5tYWduYXR1ZGUgKz0gdGhpcy5wb3NpdGlvbiAqIChuIC0gMHgzMCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gLz0gMTA7XG4gICAgICAgIHRoaXMudFN0YXRlID0gTlVNQkVSNTsgXG4gICAgICB9IGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVI1KXsgLy8gKiBBZnRlciBkaWdpdCAoYWZ0ZXIgcGVyaW9kKVxuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIGlmIChuID49IDB4MzAgJiYgbiA8IDB4NDApIHsgLy8gMC05XG4gICAgICAgIHRoaXMubWFnbmF0dWRlICs9IHRoaXMucG9zaXRpb24gKiAobiAtIDB4MzApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uIC89IDEwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobiA9PT0gMHg2NSB8fCBuID09PSAweDQ1KSB7IHRoaXMuZXhwb25lbnQgPSAwOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjY7IH0gLy8gRS9lXG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy50U3RhdGUgPSBTVEFSVDsgXG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSAtdGhpcy5tYWduYXR1ZGU7XG4gICAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uVG9rZW4oTlVNQkVSLCB0aGlzLm5lZ2F0aXZlID8gLXRoaXMubWFnbmF0dWRlIDogdGhpcy5tYWduYXR1ZGUpOyBcbiAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGktLTsgXG4gICAgICB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVI2KXsgLy8gQWZ0ZXIgRVxuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIGlmIChuID09PSAweDJiIHx8IG4gPT09IDB4MmQpIHsgLy8gKy8tXG4gICAgICAgIGlmIChuID09PSAweDJkKSB7IHRoaXMubmVnYXRpdmVFeHBvbmVudCA9IHRydWU7IH1cbiAgICAgICAgdGhpcy50U3RhdGUgPSBOVU1CRVI3O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobiA+PSAweDMwICYmIG4gPCAweDQwKSB7XG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50ICogMTAgKyAobiAtIDB4MzApO1xuICAgICAgICB0aGlzLnRTdGF0ZSA9IE5VTUJFUjg7XG4gICAgICB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfSAgXG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVI3KXsgLy8gQWZ0ZXIgKy8tXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgaWYgKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkgeyAvLyAwLTlcbiAgICAgICAgdGhpcy5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQgKiAxMCArIChuIC0gMHgzMCk7XG4gICAgICAgIHRoaXMudFN0YXRlID0gTlVNQkVSODtcbiAgICAgIH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9ICBcbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IE5VTUJFUjgpeyAvLyAqIEFmdGVyIGRpZ2l0IChhZnRlciArLy0pXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgaWYgKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkgeyAvLyAwLTlcbiAgICAgICAgdGhpcy5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQgKiAxMCArIChuIC0gMHgzMCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmVFeHBvbmVudCkge1xuICAgICAgICAgIHRoaXMuZXhwb25lbnQgPSAtdGhpcy5leHBvbmVudDtcbiAgICAgICAgICB0aGlzLm5lZ2F0aXZlRXhwb25lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWduYXR1ZGUgKj0gTWF0aC5wb3coMTAsIHRoaXMuZXhwb25lbnQpO1xuICAgICAgICB0aGlzLmV4cG9uZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSkgeyBcbiAgICAgICAgICB0aGlzLm1hZ25hdHVkZSA9IC10aGlzLm1hZ25hdHVkZTtcbiAgICAgICAgICB0aGlzLm5lZ2F0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudFN0YXRlID0gU1RBUlQ7XG4gICAgICAgIHRoaXMub25Ub2tlbihOVU1CRVIsIHRoaXMubWFnbmF0dWRlKTtcbiAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGktLTsgXG4gICAgICB9IFxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gVFJVRTEpeyAvLyByXG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDcyKSB7IHRoaXMudFN0YXRlID0gVFJVRTI7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBUUlVFMil7IC8vIHVcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NzUpIHsgdGhpcy50U3RhdGUgPSBUUlVFMzsgfVxuICAgICAgZWxzZSB7IHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFRSVUUzKXsgLy8gZVxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg2NSkgeyB0aGlzLnRTdGF0ZSA9IFNUQVJUOyB0aGlzLm9uVG9rZW4oVFJVRSwgdHJ1ZSk7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBGQUxTRTEpeyAvLyBhXG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDYxKSB7IHRoaXMudFN0YXRlID0gRkFMU0UyOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gRkFMU0UyKXsgLy8gbFxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg2YykgeyB0aGlzLnRTdGF0ZSA9IEZBTFNFMzsgfVxuICAgICAgZWxzZSB7IHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IEZBTFNFMyl7IC8vIHNcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NzMpIHsgdGhpcy50U3RhdGUgPSBGQUxTRTQ7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBGQUxTRTQpeyAvLyBlXG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDY1KSB7IHRoaXMudFN0YXRlID0gU1RBUlQ7IHRoaXMub25Ub2tlbihGQUxTRSwgZmFsc2UpOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVMTDEpeyAvLyB1XG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDc1KSB7IHRoaXMudFN0YXRlID0gTlVMTDI7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVUxMMil7IC8vIGxcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NmMpIHsgdGhpcy50U3RhdGUgPSBOVUxMMzsgfVxuICAgICAgZWxzZSB7IHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IE5VTEwzKXsgLy8gbFxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg2YykgeyB0aGlzLnRTdGF0ZSA9IFNUQVJUOyB0aGlzLm9uVG9rZW4oTlVMTCwgbnVsbCk7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfVxuICB9XG59O1xucHJvdG8ub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgdmFsdWUpIHtcbiAgLy8gT3ZlcnJpZGUgdGhpcyB0byBnZXQgZXZlbnRzXG59O1xuXG5wcm90by5wYXJzZUVycm9yID0gZnVuY3Rpb24gKHRva2VuLCB2YWx1ZSkge1xuICB0aGlzLm9uRXJyb3IobmV3IEVycm9yKFwiVW5leHBlY3RlZCBcIiArIHRva25hbSh0b2tlbikgKyAodmFsdWUgPyAoXCIoXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyBcIilcIikgOiBcIlwiKSArIFwiIGluIHN0YXRlIFwiICsgdG9rbmFtKHRoaXMuc3RhdGUpKSk7XG59O1xucHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgdGhyb3cgZXJyOyB9O1xucHJvdG8ucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdGFjay5wdXNoKHt2YWx1ZTogdGhpcy52YWx1ZSwga2V5OiB0aGlzLmtleSwgbW9kZTogdGhpcy5tb2RlfSk7XG59O1xucHJvdG8ucG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICB2YXIgcGFyZW50ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgdGhpcy52YWx1ZSA9IHBhcmVudC52YWx1ZTtcbiAgdGhpcy5rZXkgPSBwYXJlbnQua2V5O1xuICB0aGlzLm1vZGUgPSBwYXJlbnQubW9kZTtcbiAgdGhpcy5lbWl0KHZhbHVlKTtcbiAgaWYgKCF0aGlzLm1vZGUpIHsgdGhpcy5zdGF0ZSA9IFZBTFVFOyB9XG59O1xucHJvdG8uZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodGhpcy5tb2RlKSB7IHRoaXMuc3RhdGUgPSBDT01NQTsgfVxuICB0aGlzLm9uVmFsdWUodmFsdWUpO1xufTtcbnByb3RvLm9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgLy8gT3ZlcnJpZGUgbWVcbn07ICBcbnByb3RvLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIHZhbHVlKSB7XG4gIC8vY29uc29sZS5sb2coXCJPblRva2VuOiBzdGF0ZT0lcyB0b2tlbj0lcyAlc1wiLCB0b2tuYW0odGhpcy5zdGF0ZSksIHRva25hbSh0b2tlbiksIHZhbHVlP0pTT04uc3RyaW5naWZ5KHZhbHVlKTpcIlwiKTtcbiAgaWYodGhpcy5zdGF0ZSA9PT0gVkFMVUUpe1xuICAgIGlmKHRva2VuID09PSBTVFJJTkcgfHwgdG9rZW4gPT09IE5VTUJFUiB8fCB0b2tlbiA9PT0gVFJVRSB8fCB0b2tlbiA9PT0gRkFMU0UgfHwgdG9rZW4gPT09IE5VTEwpe1xuICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZVt0aGlzLmtleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCh2YWx1ZSk7ICBcbiAgICB9ZWxzZSBpZih0b2tlbiA9PT0gTEVGVF9CUkFDRSl7XG4gICAgICB0aGlzLnB1c2goKTtcbiAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlW3RoaXMua2V5XSA9IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5rZXkgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnN0YXRlID0gS0VZO1xuICAgICAgdGhpcy5tb2RlID0gT0JKRUNUO1xuICAgIH1lbHNlIGlmKHRva2VuID09PSBMRUZUX0JSQUNLRVQpe1xuICAgICAgdGhpcy5wdXNoKCk7XG4gICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVt0aGlzLmtleV0gPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5ID0gMDtcbiAgICAgIHRoaXMubW9kZSA9IEFSUkFZO1xuICAgICAgdGhpcy5zdGF0ZSA9IFZBTFVFO1xuICAgIH1lbHNlIGlmKHRva2VuID09PSBSSUdIVF9CUkFDRSl7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSBPQkpFQ1QpIHtcbiAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1lbHNlIGlmKHRva2VuID09PSBSSUdIVF9CUkFDS0VUKXtcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IEFSUkFZKSB7XG4gICAgICAgIHRoaXMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpO1xuICAgIH1cbiAgfWVsc2UgaWYodGhpcy5zdGF0ZSA9PT0gS0VZKXtcbiAgICBpZiAodG9rZW4gPT09IFNUUklORykge1xuICAgICAgdGhpcy5rZXkgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBDT0xPTjtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSBSSUdIVF9CUkFDRSkge1xuICAgICAgdGhpcy5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7XG4gICAgfVxuICB9ZWxzZSBpZih0aGlzLnN0YXRlID09PSBDT0xPTil7XG4gICAgaWYgKHRva2VuID09PSBDT0xPTikgeyB0aGlzLnN0YXRlID0gVkFMVUU7IH1cbiAgICBlbHNlIHsgdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7IH1cbiAgfWVsc2UgaWYodGhpcy5zdGF0ZSA9PT0gQ09NTUEpe1xuICAgIGlmICh0b2tlbiA9PT0gQ09NTUEpIHsgXG4gICAgICBpZiAodGhpcy5tb2RlID09PSBBUlJBWSkgeyB0aGlzLmtleSsrOyB0aGlzLnN0YXRlID0gVkFMVUU7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gT0JKRUNUKSB7IHRoaXMuc3RhdGUgPSBLRVk7IH1cblxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09IFJJR0hUX0JSQUNLRVQgJiYgdGhpcy5tb2RlID09PSBBUlJBWSB8fCB0b2tlbiA9PT0gUklHSFRfQlJBQ0UgJiYgdGhpcy5tb2RlID09PSBPQkpFQ1QpIHtcbiAgICAgIHRoaXMucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpO1xuICAgIH1cbiAgfWVsc2V7XG4gICAgdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyO1xuXG59KS5jYWxsKHRoaXMsX2RlcmVxXyhcImJ1ZmZlclwiKS5CdWZmZXIpXG59LHtcImJ1ZmZlclwiOjIzfV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBTdGFuZGFsb25lIGV4dHJhY3Rpb24gb2YgQmFja2JvbmUuRXZlbnRzLCBubyBleHRlcm5hbCBkZXBlbmRlbmN5IHJlcXVpcmVkLlxuICogRGVncmFkZXMgbmljZWx5IHdoZW4gQmFja29uZS91bmRlcnNjb3JlIGFyZSBhbHJlYWR5IGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudFxuICogZ2xvYmFsIGNvbnRleHQuXG4gKlxuICogTm90ZSB0aGF0IGRvY3Mgc3VnZ2VzdCB0byB1c2UgdW5kZXJzY29yZSdzIGBfLmV4dGVuZCgpYCBtZXRob2QgdG8gYWRkIEV2ZW50c1xuICogc3VwcG9ydCB0byBzb21lIGdpdmVuIG9iamVjdC4gQSBgbWl4aW4oKWAgbWV0aG9kIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBFdmVudHNcbiAqIHByb3RvdHlwZSB0byBhdm9pZCB1c2luZyB1bmRlcnNjb3JlIGZvciB0aGF0IHNvbGUgcHVycG9zZTpcbiAqXG4gKiAgICAgdmFyIG15RXZlbnRFbWl0dGVyID0gQmFja2JvbmVFdmVudHMubWl4aW4oe30pO1xuICpcbiAqIE9yIGZvciBhIGZ1bmN0aW9uIGNvbnN0cnVjdG9yOlxuICpcbiAqICAgICBmdW5jdGlvbiBNeUNvbnN0cnVjdG9yKCl7fVxuICogICAgIE15Q29uc3RydWN0b3IucHJvdG90eXBlLmZvbyA9IGZ1bmN0aW9uKCl7fVxuICogICAgIEJhY2tib25lRXZlbnRzLm1peGluKE15Q29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAqXG4gKiAoYykgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuXG4gKiAoYykgMjAxMyBOaWNvbGFzIFBlcnJpYXVsdFxuICovXG4vKiBnbG9iYWwgZXhwb3J0czp0cnVlLCBkZWZpbmUsIG1vZHVsZSAqL1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgcm9vdCA9IHRoaXMsXG4gICAgICBicmVha2VyID0ge30sXG4gICAgICBuYXRpdmVGb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2gsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcbiAgICAgIGlkQ291bnRlciA9IDA7XG5cbiAgLy8gUmV0dXJucyBhIHBhcnRpYWwgaW1wbGVtZW50YXRpb24gbWF0Y2hpbmcgdGhlIG1pbmltYWwgQVBJIHN1YnNldCByZXF1aXJlZFxuICAvLyBieSBCYWNrYm9uZS5FdmVudHNcbiAgZnVuY3Rpb24gbWluaXNjb3JlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIiB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5cygpIGNhbGxlZCBvbiBhIG5vbi1vYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSwga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGtleXNba2V5cy5sZW5ndGhdID0ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgIH0sXG5cbiAgICAgIHVuaXF1ZUlkOiBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICAgICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICAgICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gICAgICB9LFxuXG4gICAgICBoYXM6IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgICAgIH0sXG5cbiAgICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvbmNlOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIHZhciByYW4gPSBmYWxzZSwgbWVtbztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChyYW4pIHJldHVybiBtZW1vO1xuICAgICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBmdW5jID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIF8gPSBtaW5pc2NvcmUoKSwgRXZlbnRzO1xuXG4gIC8vIEJhY2tib25lLkV2ZW50c1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIG1vZHVsZSB0aGF0IGNhbiBiZSBtaXhlZCBpbiB0byAqYW55IG9iamVjdCogaW4gb3JkZXIgdG8gcHJvdmlkZSBpdCB3aXRoXG4gIC8vIGN1c3RvbSBldmVudHMuIFlvdSBtYXkgYmluZCB3aXRoIGBvbmAgb3IgcmVtb3ZlIHdpdGggYG9mZmAgY2FsbGJhY2tcbiAgLy8gZnVuY3Rpb25zIHRvIGFuIGV2ZW50OyBgdHJpZ2dlcmAtaW5nIGFuIGV2ZW50IGZpcmVzIGFsbCBjYWxsYmFja3MgaW5cbiAgLy8gc3VjY2Vzc2lvbi5cbiAgLy9cbiAgLy8gICAgIHZhciBvYmplY3QgPSB7fTtcbiAgLy8gICAgIF8uZXh0ZW5kKG9iamVjdCwgQmFja2JvbmUuRXZlbnRzKTtcbiAgLy8gICAgIG9iamVjdC5vbignZXhwYW5kJywgZnVuY3Rpb24oKXsgYWxlcnQoJ2V4cGFuZGVkJyk7IH0pO1xuICAvLyAgICAgb2JqZWN0LnRyaWdnZXIoJ2V4cGFuZCcpO1xuICAvL1xuICBFdmVudHMgPSB7XG5cbiAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi4gUGFzc2luZyBgXCJhbGxcImAgd2lsbCBiaW5kXG4gICAgLy8gdGhlIGNhbGxiYWNrIHRvIGFsbCBldmVudHMgZmlyZWQuXG4gICAgb246IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICBpZiAoIWV2ZW50c0FwaSh0aGlzLCAnb24nLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSk7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdIHx8ICh0aGlzLl9ldmVudHNbbmFtZV0gPSBbXSk7XG4gICAgICBldmVudHMucHVzaCh7Y2FsbGJhY2s6IGNhbGxiYWNrLCBjb250ZXh0OiBjb250ZXh0LCBjdHg6IGNvbnRleHQgfHwgdGhpc30pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEJpbmQgYW4gZXZlbnQgdG8gb25seSBiZSB0cmlnZ2VyZWQgYSBzaW5nbGUgdGltZS4gQWZ0ZXIgdGhlIGZpcnN0IHRpbWVcbiAgICAvLyB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZCwgaXQgd2lsbCBiZSByZW1vdmVkLlxuICAgIG9uY2U6IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICBpZiAoIWV2ZW50c0FwaSh0aGlzLCAnb25jZScsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pIHx8ICFjYWxsYmFjaykgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgb25jZSA9IF8ub25jZShmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5vZmYobmFtZSwgb25jZSk7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgICAgIG9uY2UuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICByZXR1cm4gdGhpcy5vbihuYW1lLCBvbmNlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIG9uZSBvciBtYW55IGNhbGxiYWNrcy4gSWYgYGNvbnRleHRgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gICAgLy8gY2FsbGJhY2tzIHdpdGggdGhhdCBmdW5jdGlvbi4gSWYgYGNhbGxiYWNrYCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAgIC8vIGNhbGxiYWNrcyBmb3IgdGhlIGV2ZW50LiBJZiBgbmFtZWAgaXMgbnVsbCwgcmVtb3ZlcyBhbGwgYm91bmRcbiAgICAvLyBjYWxsYmFja3MgZm9yIGFsbCBldmVudHMuXG4gICAgb2ZmOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgdmFyIHJldGFpbiwgZXYsIGV2ZW50cywgbmFtZXMsIGksIGwsIGosIGs7XG4gICAgICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhZXZlbnRzQXBpKHRoaXMsICdvZmYnLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSkgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAoIW5hbWUgJiYgIWNhbGxiYWNrICYmICFjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbmFtZXMgPSBuYW1lID8gW25hbWVdIDogXy5rZXlzKHRoaXMuX2V2ZW50cyk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgaWYgKGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50c1tuYW1lXSA9IHJldGFpbiA9IFtdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayB8fCBjb250ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBrID0gZXZlbnRzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICBldiA9IGV2ZW50c1tqXTtcbiAgICAgICAgICAgICAgaWYgKChjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gZXYuY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrLl9jYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgIChjb250ZXh0ICYmIGNvbnRleHQgIT09IGV2LmNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0YWluLnB1c2goZXYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmV0YWluLmxlbmd0aCkgZGVsZXRlIHRoaXMuX2V2ZW50c1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gVHJpZ2dlciBvbmUgb3IgbWFueSBldmVudHMsIGZpcmluZyBhbGwgYm91bmQgY2FsbGJhY2tzLiBDYWxsYmFja3MgYXJlXG4gICAgLy8gcGFzc2VkIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBgdHJpZ2dlcmAgaXMsIGFwYXJ0IGZyb20gdGhlIGV2ZW50IG5hbWVcbiAgICAvLyAodW5sZXNzIHlvdSdyZSBsaXN0ZW5pbmcgb24gYFwiYWxsXCJgLCB3aGljaCB3aWxsIGNhdXNlIHlvdXIgY2FsbGJhY2sgdG9cbiAgICAvLyByZWNlaXZlIHRoZSB0cnVlIG5hbWUgb2YgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBhcmd1bWVudCkuXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICBpZiAoIWV2ZW50c0FwaSh0aGlzLCAndHJpZ2dlcicsIG5hbWUsIGFyZ3MpKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICB2YXIgYWxsRXZlbnRzID0gdGhpcy5fZXZlbnRzLmFsbDtcbiAgICAgIGlmIChldmVudHMpIHRyaWdnZXJFdmVudHMoZXZlbnRzLCBhcmdzKTtcbiAgICAgIGlmIChhbGxFdmVudHMpIHRyaWdnZXJFdmVudHMoYWxsRXZlbnRzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRlbGwgdGhpcyBvYmplY3QgdG8gc3RvcCBsaXN0ZW5pbmcgdG8gZWl0aGVyIHNwZWNpZmljIGV2ZW50cyAuLi4gb3JcbiAgICAvLyB0byBldmVyeSBvYmplY3QgaXQncyBjdXJyZW50bHkgbGlzdGVuaW5nIHRvLlxuICAgIHN0b3BMaXN0ZW5pbmc6IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZGVsZXRlTGlzdGVuZXIgPSAhbmFtZSAmJiAhY2FsbGJhY2s7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XG4gICAgICBpZiAob2JqKSAobGlzdGVuZXJzID0ge30pW29iai5fbGlzdGVuZXJJZF0gPSBvYmo7XG4gICAgICBmb3IgKHZhciBpZCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXJzW2lkXS5vZmYobmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgICBpZiAoZGVsZXRlTGlzdGVuZXIpIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbaWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gIH07XG5cbiAgLy8gUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gc3BsaXQgZXZlbnQgc3RyaW5ncy5cbiAgdmFyIGV2ZW50U3BsaXR0ZXIgPSAvXFxzKy87XG5cbiAgLy8gSW1wbGVtZW50IGZhbmN5IGZlYXR1cmVzIG9mIHRoZSBFdmVudHMgQVBJIHN1Y2ggYXMgbXVsdGlwbGUgZXZlbnRcbiAgLy8gbmFtZXMgYFwiY2hhbmdlIGJsdXJcImAgYW5kIGpRdWVyeS1zdHlsZSBldmVudCBtYXBzIGB7Y2hhbmdlOiBhY3Rpb259YFxuICAvLyBpbiB0ZXJtcyBvZiB0aGUgZXhpc3RpbmcgQVBJLlxuICB2YXIgZXZlbnRzQXBpID0gZnVuY3Rpb24ob2JqLCBhY3Rpb24sIG5hbWUsIHJlc3QpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiB0cnVlO1xuXG4gICAgLy8gSGFuZGxlIGV2ZW50IG1hcHMuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgICAgb2JqW2FjdGlvbl0uYXBwbHkob2JqLCBba2V5LCBuYW1lW2tleV1dLmNvbmNhdChyZXN0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHNwYWNlIHNlcGFyYXRlZCBldmVudCBuYW1lcy5cbiAgICBpZiAoZXZlbnRTcGxpdHRlci50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KGV2ZW50U3BsaXR0ZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgb2JqW2FjdGlvbl0uYXBwbHkob2JqLCBbbmFtZXNbaV1dLmNvbmNhdChyZXN0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3JcbiAgLy8gdHJpZ2dlcmluZyBldmVudHMuIFRyaWVzIHRvIGtlZXAgdGhlIHVzdWFsIGNhc2VzIHNwZWVkeSAobW9zdCBpbnRlcm5hbFxuICAvLyBCYWNrYm9uZSBldmVudHMgaGF2ZSAzIGFyZ3VtZW50cykuXG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24oZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIGV2LCBpID0gLTEsIGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgpOyByZXR1cm47XG4gICAgICBjYXNlIDE6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSk7IHJldHVybjtcbiAgICAgIGNhc2UgMjogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMik7IHJldHVybjtcbiAgICAgIGNhc2UgMzogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMiwgYTMpOyByZXR1cm47XG4gICAgICBkZWZhdWx0OiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5hcHBseShldi5jdHgsIGFyZ3MpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGlzdGVuTWV0aG9kcyA9IHtsaXN0ZW5UbzogJ29uJywgbGlzdGVuVG9PbmNlOiAnb25jZSd9O1xuXG4gIC8vIEludmVyc2lvbi1vZi1jb250cm9sIHZlcnNpb25zIG9mIGBvbmAgYW5kIGBvbmNlYC4gVGVsbCAqdGhpcyogb2JqZWN0IHRvXG4gIC8vIGxpc3RlbiB0byBhbiBldmVudCBpbiBhbm90aGVyIG9iamVjdCAuLi4ga2VlcGluZyB0cmFjayBvZiB3aGF0IGl0J3NcbiAgLy8gbGlzdGVuaW5nIHRvLlxuICBfLmVhY2gobGlzdGVuTWV0aG9kcywgZnVuY3Rpb24oaW1wbGVtZW50YXRpb24sIG1ldGhvZCkge1xuICAgIEV2ZW50c1ttZXRob2RdID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyB8fCAodGhpcy5fbGlzdGVuZXJzID0ge30pO1xuICAgICAgdmFyIGlkID0gb2JqLl9saXN0ZW5lcklkIHx8IChvYmouX2xpc3RlbmVySWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgICAgbGlzdGVuZXJzW2lkXSA9IG9iajtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIGNhbGxiYWNrID0gdGhpcztcbiAgICAgIG9ialtpbXBsZW1lbnRhdGlvbl0obmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWxpYXNlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIEV2ZW50cy5iaW5kICAgPSBFdmVudHMub247XG4gIEV2ZW50cy51bmJpbmQgPSBFdmVudHMub2ZmO1xuXG4gIC8vIE1peGluIHV0aWxpdHlcbiAgRXZlbnRzLm1peGluID0gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICB2YXIgZXhwb3J0cyA9IFsnb24nLCAnb25jZScsICdvZmYnLCAndHJpZ2dlcicsICdzdG9wTGlzdGVuaW5nJywgJ2xpc3RlblRvJyxcbiAgICAgICAgICAgICAgICAgICAnbGlzdGVuVG9PbmNlJywgJ2JpbmQnLCAndW5iaW5kJ107XG4gICAgXy5lYWNoKGV4cG9ydHMsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHByb3RvW25hbWVdID0gdGhpc1tuYW1lXTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gcHJvdG87XG4gIH07XG5cbiAgLy8gRXhwb3J0IEV2ZW50cyBhcyBCYWNrYm9uZUV2ZW50cyBkZXBlbmRpbmcgb24gY3VycmVudCBjb250ZXh0XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRXZlbnRzO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRXZlbnRzO1xuICAgIH1cbiAgICBleHBvcnRzLkJhY2tib25lRXZlbnRzID0gRXZlbnRzO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuQmFja2JvbmVFdmVudHMgPSBFdmVudHM7XG4gIH1cbn0pKHRoaXMpO1xuXG59LHt9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vYmFja2JvbmUtZXZlbnRzLXN0YW5kYWxvbmUnKTtcblxufSx7XCIuL2JhY2tib25lLWV2ZW50cy1zdGFuZGFsb25lXCI6MjB9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qYWtlYXJjaGliYWxkL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIDIuMC4xXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gJCR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJHV0aWxzJCRpc0Z1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJHV0aWxzJCRpc01heWJlVGhlbmFibGUoeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsO1xuICAgIH1cblxuICAgIHZhciAkJHV0aWxzJCRfaXNBcnJheTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSkge1xuICAgICAgJCR1dGlscyQkX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCR1dGlscyQkX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgIH1cblxuICAgIHZhciAkJHV0aWxzJCRpc0FycmF5ID0gJCR1dGlscyQkX2lzQXJyYXk7XG4gICAgdmFyICQkdXRpbHMkJG5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG4gICAgZnVuY3Rpb24gJCR1dGlscyQkRigpIHsgfVxuXG4gICAgdmFyICQkdXRpbHMkJG9fY3JlYXRlID0gKE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY29uZCBhcmd1bWVudCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG8gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICAkJHV0aWxzJCRGLnByb3RvdHlwZSA9IG87XG4gICAgICByZXR1cm4gbmV3ICQkdXRpbHMkJEYoKTtcbiAgICB9KTtcblxuICAgIHZhciAkJGFzYXAkJGxlbiA9IDA7XG5cbiAgICB2YXIgJCRhc2FwJCRkZWZhdWx0ID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gICAgICAkJGFzYXAkJHF1ZXVlWyQkYXNhcCQkbGVuXSA9IGNhbGxiYWNrO1xuICAgICAgJCRhc2FwJCRxdWV1ZVskJGFzYXAkJGxlbiArIDFdID0gYXJnO1xuICAgICAgJCRhc2FwJCRsZW4gKz0gMjtcbiAgICAgIGlmICgkJGFzYXAkJGxlbiA9PT0gMikge1xuICAgICAgICAvLyBJZiBsZW4gaXMgMSwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICAgICAgJCRhc2FwJCRzY2hlZHVsZUZsdXNoKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciAkJGFzYXAkJGJyb3dzZXJHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDoge307XG4gICAgdmFyICQkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSAkJGFzYXAkJGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCAkJGFzYXAkJGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxuICAgIC8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG4gICAgdmFyICQkYXNhcCQkaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyBub2RlXG4gICAgZnVuY3Rpb24gJCRhc2FwJCR1c2VOZXh0VGljaygpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygkJGFzYXAkJGZsdXNoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG9ic2VydmVyID0gbmV3ICQkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoJCRhc2FwJCRmbHVzaCk7XG4gICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IChpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHdlYiB3b3JrZXJcbiAgICBmdW5jdGlvbiAkJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gJCRhc2FwJCRmbHVzaDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkYXNhcCQkdXNlU2V0VGltZW91dCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dCgkJGFzYXAkJGZsdXNoLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyICQkYXNhcCQkcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5cbiAgICBmdW5jdGlvbiAkJGFzYXAkJGZsdXNoKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAkJGFzYXAkJGxlbjsgaSs9Mikge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSAkJGFzYXAkJHF1ZXVlW2ldO1xuICAgICAgICB2YXIgYXJnID0gJCRhc2FwJCRxdWV1ZVtpKzFdO1xuXG4gICAgICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICAgICAgJCRhc2FwJCRxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgJCRhc2FwJCRxdWV1ZVtpKzFdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAkJGFzYXAkJGxlbiA9IDA7XG4gICAgfVxuXG4gICAgdmFyICQkYXNhcCQkc2NoZWR1bGVGbHVzaDtcblxuICAgIC8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAgICQkYXNhcCQkc2NoZWR1bGVGbHVzaCA9ICQkYXNhcCQkdXNlTmV4dFRpY2soKTtcbiAgICB9IGVsc2UgaWYgKCQkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICQkYXNhcCQkc2NoZWR1bGVGbHVzaCA9ICQkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpO1xuICAgIH0gZWxzZSBpZiAoJCRhc2FwJCRpc1dvcmtlcikge1xuICAgICAgJCRhc2FwJCRzY2hlZHVsZUZsdXNoID0gJCRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSAkJGFzYXAkJHVzZVNldFRpbWVvdXQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkbm9vcCgpIHt9XG4gICAgdmFyICQkJGludGVybmFsJCRQRU5ESU5HICAgPSB2b2lkIDA7XG4gICAgdmFyICQkJGludGVybmFsJCRGVUxGSUxMRUQgPSAxO1xuICAgIHZhciAkJCRpbnRlcm5hbCQkUkVKRUNURUQgID0gMjtcbiAgICB2YXIgJCQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SID0gbmV3ICQkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJHNlbGZGdWxsZmlsbG1lbnQoKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkZ2V0VGhlbihwcm9taXNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAkJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuICQkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkdHJ5VGhlbih0aGVuLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICAgICAgICQkYXNhcCQkZGVmYXVsdChmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yID0gJCQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdGhlbmFibGUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICQkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gICAgICBpZiAodGhlbmFibGUuX3N0YXRlID09PSAkJCRpbnRlcm5hbCQkRlVMRklMTEVEKSB7XG4gICAgICAgICQkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gJCQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpIHtcbiAgICAgIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICQkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0aGVuID0gJCQkaW50ZXJuYWwkJGdldFRoZW4obWF5YmVUaGVuYWJsZSk7XG5cbiAgICAgICAgaWYgKHRoZW4gPT09ICQkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUikge1xuICAgICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgJCQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAkJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfSBlbHNlIGlmICgkJHV0aWxzJCRpc0Z1bmN0aW9uKHRoZW4pKSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCAkJCRpbnRlcm5hbCQkc2VsZkZ1bGxmaWxsbWVudCgpKTtcbiAgICAgIH0gZWxzZSBpZiAoJCR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICAgIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgJCQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gJCQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fc3RhdGUgPSAkJCRpbnRlcm5hbCQkRlVMRklMTEVEO1xuXG4gICAgICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkJGFzYXAkJGRlZmF1bHQoJCQkaW50ZXJuYWwkJHB1Ymxpc2gsIHByb21pc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09ICQkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuICAgICAgcHJvbWlzZS5fc3RhdGUgPSAkJCRpbnRlcm5hbCQkUkVKRUNURUQ7XG4gICAgICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgICAgICQkYXNhcCQkZGVmYXVsdCgkJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgICAgIHZhciBsZW5ndGggPSBzdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgICAgIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArICQkJGludGVybmFsJCRGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArICQkJGludGVybmFsJCRSRUpFQ1RFRF0gID0gb25SZWplY3Rpb247XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgICAgICAkJGFzYXAkJGRlZmF1bHQoJCQkaW50ZXJuYWwkJHB1Ymxpc2gsIHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSkge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gICAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgICB2YXIgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCkge1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyICQkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IgPSBuZXcgJCQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgICAgIHJldHVybiAkJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICB2YXIgaGFzQ2FsbGJhY2sgPSAkJHV0aWxzJCRpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgICAgICB2YWx1ZSwgZXJyb3IsIHN1Y2NlZWRlZCwgZmFpbGVkO1xuXG4gICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgdmFsdWUgPSAkJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAkJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCAkJCRpbnRlcm5hbCQkY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSAkJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAvLyBub29wXG4gICAgICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgICAkJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gJCQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICAkJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09ICQkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKXtcbiAgICAgICAgICAkJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGVudW1lcmF0b3IkJG1ha2VTZXR0bGVkUmVzdWx0KHN0YXRlLCBwb3NpdGlvbiwgdmFsdWUpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gJCQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXRlOiAnZnVsZmlsbGVkJyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6ICdyZWplY3RlZCcsXG4gICAgICAgICAgcmVhc29uOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGVudW1lcmF0b3IkJEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0LCBhYm9ydE9uUmVqZWN0LCBsYWJlbCkge1xuICAgICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgICAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKCQkJGludGVybmFsJCRub29wLCBsYWJlbCk7XG4gICAgICB0aGlzLl9hYm9ydE9uUmVqZWN0ID0gYWJvcnRPblJlamVjdDtcblxuICAgICAgaWYgKHRoaXMuX3ZhbGlkYXRlSW5wdXQoaW5wdXQpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0ICAgICA9IGlucHV0O1xuICAgICAgICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgICB0aGlzLl9lbnVtZXJhdGUoKTtcbiAgICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAkJCRpbnRlcm5hbCQkZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHRoaXMucHJvbWlzZSwgdGhpcy5fdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgICQkJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZUlucHV0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiAkJHV0aWxzJCRpc0FycmF5KGlucHV0KTtcbiAgICB9O1xuXG4gICAgJCQkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG4gICAgfTtcblxuICAgICQkJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICB2YXIgJCQkZW51bWVyYXRvciQkZGVmYXVsdCA9ICQkJGVudW1lcmF0b3IkJEVudW1lcmF0b3I7XG5cbiAgICAkJCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoICA9IHRoaXMubGVuZ3RoO1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG4gICAgICB2YXIgaW5wdXQgICA9IHRoaXMuX2lucHV0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgcHJvbWlzZS5fc3RhdGUgPT09ICQkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAkJCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24oZW50cnksIGkpIHtcbiAgICAgIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgICAgIGlmICgkJHV0aWxzJCRpc01heWJlVGhlbmFibGUoZW50cnkpKSB7XG4gICAgICAgIGlmIChlbnRyeS5jb25zdHJ1Y3RvciA9PT0gYyAmJiBlbnRyeS5fc3RhdGUgIT09ICQkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgICAgZW50cnkuX29uZXJyb3IgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChjLnJlc29sdmUoZW50cnkpLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHRoaXMuX21ha2VSZXN1bHQoJCQkaW50ZXJuYWwkJEZVTEZJTExFRCwgaSwgZW50cnkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAkJCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24oc3RhdGUsIGksIHZhbHVlKSB7XG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuICAgICAgaWYgKHByb21pc2UuX3N0YXRlID09PSAkJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgICBpZiAodGhpcy5fYWJvcnRPblJlamVjdCAmJiBzdGF0ZSA9PT0gJCQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdGhpcy5fbWFrZVJlc3VsdChzdGF0ZSwgaSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJCQkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX21ha2VSZXN1bHQgPSBmdW5jdGlvbihzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgJCQkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uKHByb21pc2UsIGkpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgICAgJCQkaW50ZXJuYWwkJHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdCgkJCRpbnRlcm5hbCQkRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KCQkJGludGVybmFsJCRSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgJCRwcm9taXNlJGFsbCQkZGVmYXVsdCA9IGZ1bmN0aW9uIGFsbChlbnRyaWVzLCBsYWJlbCkge1xuICAgICAgcmV0dXJuIG5ldyAkJCRlbnVtZXJhdG9yJCRkZWZhdWx0KHRoaXMsIGVudHJpZXMsIHRydWUgLyogYWJvcnQgb24gcmVqZWN0ICovLCBsYWJlbCkucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgdmFyICQkcHJvbWlzZSRyYWNlJCRkZWZhdWx0ID0gZnVuY3Rpb24gcmFjZShlbnRyaWVzLCBsYWJlbCkge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKCQkJGludGVybmFsJCRub29wLCBsYWJlbCk7XG5cbiAgICAgIGlmICghJCR1dGlscyQkaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRnVsZmlsbG1lbnQodmFsdWUpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJlamVjdGlvbihyZWFzb24pIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgcHJvbWlzZS5fc3RhdGUgPT09ICQkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkJCRpbnRlcm5hbCQkc3Vic2NyaWJlKENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSksIHVuZGVmaW5lZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgdmFyICQkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0ID0gZnVuY3Rpb24gcmVzb2x2ZShvYmplY3QsIGxhYmVsKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKCQkJGludGVybmFsJCRub29wLCBsYWJlbCk7XG4gICAgICAkJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIHZhciAkJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0ID0gZnVuY3Rpb24gcmVqZWN0KHJlYXNvbiwgbGFiZWwpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IoJCQkaW50ZXJuYWwkJG5vb3AsIGxhYmVsKTtcbiAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICB2YXIgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRjb3VudGVyID0gMDtcblxuICAgIGZ1bmN0aW9uICQkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNSZXNvbHZlcigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0ID0gJCRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlO1xuXG4gICAgLyoqXG4gICAgICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gICAgICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICAgICAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2XigJlzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgICAgIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gICAgICBUZXJtaW5vbG9neVxuICAgICAgLS0tLS0tLS0tLS1cblxuICAgICAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgICAgIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgICAgIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgICAgIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAgICAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAgICAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICAgICAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgICAgIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgICAgIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gICAgICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgICAgIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgICAgIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICAgICAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICAgICAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICAgICAgQmFzaWMgVXNhZ2U6XG4gICAgICAtLS0tLS0tLS0tLS1cblxuICAgICAgYGBganNcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gb24gZmFpbHVyZVxuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFkdmFuY2VkIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgICAgIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICAgICAgYGBganNcbiAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gICAgICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICAgICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAY2xhc3MgUHJvbWlzZVxuICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZXJcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEBjb25zdHJ1Y3RvclxuICAgICovXG4gICAgZnVuY3Rpb24gJCRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgICB0aGlzLl9pZCA9ICQkZXM2JHByb21pc2UkcHJvbWlzZSQkY291bnRlcisrO1xuICAgICAgdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gICAgICBpZiAoJCQkaW50ZXJuYWwkJG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgICAgIGlmICghJCR1dGlscyQkaXNGdW5jdGlvbihyZXNvbHZlcikpIHtcbiAgICAgICAgICAkJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiAkJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UpKSB7XG4gICAgICAgICAgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuYWxsID0gJCRwcm9taXNlJGFsbCQkZGVmYXVsdDtcbiAgICAkJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmFjZSA9ICQkcHJvbWlzZSRyYWNlJCRkZWZhdWx0O1xuICAgICQkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZXNvbHZlID0gJCRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQ7XG4gICAgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlamVjdCA9ICQkcHJvbWlzZSRyZWplY3QkJGRlZmF1bHQ7XG5cbiAgICAkJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6ICQkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZSxcblxuICAgIC8qKlxuICAgICAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gICAgICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICAgICAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIENoYWluaW5nXG4gICAgICAtLS0tLS0tLVxuXG4gICAgICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICAgICAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICAgICAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgICAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgICAgIH0pO1xuXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgICB9KTtcbiAgICAgIGBgYFxuICAgICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQXNzaW1pbGF0aW9uXG4gICAgICAtLS0tLS0tLS0tLS1cblxuICAgICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICAgIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gICAgICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFNpbXBsZSBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfVxuICAgICAgYGBgXG5cbiAgICAgIEVycmJhY2sgRXhhbXBsZVxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAvLyBmYWlsdXJlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBQcm9taXNlIEV4YW1wbGU7XG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgICAgIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgdmFyIGF1dGhvciwgYm9va3M7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfVxuICAgICAgYGBgXG5cbiAgICAgIEVycmJhY2sgRXhhbXBsZVxuXG4gICAgICBgYGBqc1xuXG4gICAgICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG5cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcblxuICAgICAgfVxuXG4gICAgICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAvLyBmYWlsdXJlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBQcm9taXNlIEV4YW1wbGU7XG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIGZpbmRBdXRob3IoKS5cbiAgICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgICAgIC8vIGZvdW5kIGJvb2tzXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCB0aGVuXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgdGhlbjogZnVuY3Rpb24ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSAkJCRpbnRlcm5hbCQkRlVMRklMTEVEICYmICFvbkZ1bGZpbGxtZW50IHx8IHN0YXRlID09PSAkJCRpbnRlcm5hbCQkUkVKRUNURUQgJiYgIW9uUmVqZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigkJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJlbnQuX3Jlc3VsdDtcblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbc3RhdGUgLSAxXTtcbiAgICAgICAgICAkJGFzYXAkJGRlZmF1bHQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICQkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCByZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICQkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfSxcblxuICAgIC8qKlxuICAgICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgICAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN5bmNocm9ub3VzXG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQXV0aG9yKCk7XG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfVxuXG4gICAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgY2F0Y2hcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyICQkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHQgPSBmdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgICAgIHZhciBsb2NhbDtcblxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsID0gZ2xvYmFsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgbG9jYWwgPSB3aW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBlczZQcm9taXNlU3VwcG9ydCA9XG4gICAgICAgIFwiUHJvbWlzZVwiIGluIGxvY2FsICYmXG4gICAgICAgIC8vIFNvbWUgb2YgdGhlc2UgbWV0aG9kcyBhcmUgbWlzc2luZyBmcm9tXG4gICAgICAgIC8vIEZpcmVmb3gvQ2hyb21lIGV4cGVyaW1lbnRhbCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgXCJyZXNvbHZlXCIgaW4gbG9jYWwuUHJvbWlzZSAmJlxuICAgICAgICBcInJlamVjdFwiIGluIGxvY2FsLlByb21pc2UgJiZcbiAgICAgICAgXCJhbGxcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgICAgIFwicmFjZVwiIGluIGxvY2FsLlByb21pc2UgJiZcbiAgICAgICAgLy8gT2xkZXIgdmVyc2lvbiBvZiB0aGUgc3BlYyBoYWQgYSByZXNvbHZlciBvYmplY3RcbiAgICAgICAgLy8gYXMgdGhlIGFyZyByYXRoZXIgdGhhbiBhIGZ1bmN0aW9uXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZTtcbiAgICAgICAgICBuZXcgbG9jYWwuUHJvbWlzZShmdW5jdGlvbihyKSB7IHJlc29sdmUgPSByOyB9KTtcbiAgICAgICAgICByZXR1cm4gJCR1dGlscyQkaXNGdW5jdGlvbihyZXNvbHZlKTtcbiAgICAgICAgfSgpKTtcblxuICAgICAgaWYgKCFlczZQcm9taXNlU3VwcG9ydCkge1xuICAgICAgICBsb2NhbC5Qcm9taXNlID0gJCRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlID0ge1xuICAgICAgJ1Byb21pc2UnOiAkJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQsXG4gICAgICAncG9seWZpbGwnOiAkJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0XG4gICAgfTtcblxuICAgIC8qIGdsb2JhbCBkZWZpbmU6dHJ1ZSBtb2R1bGU6dHJ1ZSB3aW5kb3c6IHRydWUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7IH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlWydleHBvcnRzJ10pIHtcbiAgICAgIG1vZHVsZVsnZXhwb3J0cyddID0gZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzWydFUzZQcm9taXNlJ10gPSBlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7XG4gICAgfVxufSkuY2FsbCh0aGlzKTtcbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjU1fV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gX2RlcmVxXygnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gX2RlcmVxXygnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IF9kZXJlcV8oJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG5cbiAgaWYgKHRoaXMubGVuZ3RoID4ga01heExlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoID4+PiAxXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpXG4gICAgICBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgMilcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNvdXJjZS5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpdL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgsIHVuaXRTaXplKSB7XG4gIGlmICh1bml0U2l6ZSkgbGVuZ3RoIC09IGxlbmd0aCAlIHVuaXRTaXplO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxufSx7XCJiYXNlNjQtanNcIjoyNCxcImllZWU3NTRcIjoyNSxcImlzLWFycmF5XCI6MjZ9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuXG59LHt9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcblxufSx7fV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIGlzQXJyYXlcbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogdG9TdHJpbmdcbiAqL1xuXG52YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHZhbGBcbiAqIGlzIGFuIGFycmF5LlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgICAgIGlzQXJyYXkoW10pO1xuICogICAgICAgIC8vID4gdHJ1ZVxuICogICAgICAgIGlzQXJyYXkoYXJndW1lbnRzKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKiAgICAgICAgaXNBcnJheSgnJyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7bWl4ZWR9IHZhbFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXkgfHwgZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gISEgdmFsICYmICdbb2JqZWN0IEFycmF5XScgPT0gc3RyLmNhbGwodmFsKTtcbn07XG5cbn0se31dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxufSx7fV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0se31dLDI5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxufSx7fV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIGh0dHA6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjIuNCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teIC1+XS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9cXHgyRXxcXHUzMDAyfFxcdUZGMEV8XFx1RkY2MS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdGFycmF5W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHRyZXR1cm4gbWFwKHN0cmluZy5zcGxpdChyZWdleFNlcGFyYXRvcnMpLCBmbikuam9pbignLicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIHRvIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHlcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIHRvIFVuaWNvZGUuIE9ubHkgdGhlXG5cdCAqIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS4gaXQgZG9lc24ndFxuXHQgKiBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCB0b1xuXHQgKiBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgUHVueWNvZGUgZG9tYWluIG5hbWUgdG8gY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGRvbWFpbikge1xuXHRcdHJldHVybiBtYXBEb21haW4oZG9tYWluLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSB0byBQdW55Y29kZS4gT25seSB0aGVcblx0ICogbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLiBpdCBkb2Vzbid0XG5cdCAqIG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgdG8gY29udmVydCwgYXMgYSBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZS5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoZG9tYWluKSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihkb21haW4sIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjIuNCcsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbn0se31dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG59LHt9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IF9kZXJlcV8oJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gX2RlcmVxXygnLi9lbmNvZGUnKTtcblxufSx7XCIuL2RlY29kZVwiOjMxLFwiLi9lbmNvZGVcIjozMn1dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXyhcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG5cbn0se1wiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIjozNX1dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSBfZGVyZXFfKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IF9kZXJlcV8oJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG5mb3JFYWNoKG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKVxufSx7XCIuL19zdHJlYW1fcmVhZGFibGVcIjozNyxcIi4vX3N0cmVhbV93cml0YWJsZVwiOjM5LFwiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCI6NTUsXCJjb3JlLXV0aWwtaXNcIjo0MCxcImluaGVyaXRzXCI6Mjh9XSwzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSBfZGVyZXFfKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IF9kZXJlcV8oJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuXG59LHtcIi4vX3N0cmVhbV90cmFuc2Zvcm1cIjozOCxcImNvcmUtdXRpbC1pc1wiOjQwLFwiaW5oZXJpdHNcIjoyOH1dLDM3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gX2RlcmVxXygnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSBfZGVyZXFfKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IF9kZXJlcV8oJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IF9kZXJlcV8oJ3N0cmVhbScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IDE2ICogMTAyNDtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IGZhbHNlO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBJbiBzdHJlYW1zIHRoYXQgbmV2ZXIgaGF2ZSBhbnkgZGF0YSwgYW5kIGRvIHB1c2gobnVsbCkgcmlnaHQgYXdheSxcbiAgLy8gdGhlIGNvbnN1bWVyIGNhbiBtaXNzIHRoZSAnZW5kJyBldmVudCBpZiB0aGV5IGRvIHNvbWUgSS9PIGJlZm9yZVxuICAvLyBjb25zdW1pbmcgdGhlIHN0cmVhbS4gIFNvLCB3ZSBkb24ndCBlbWl0KCdlbmQnKSB1bnRpbCBzb21lIHJlYWRpbmdcbiAgLy8gaGFwcGVucy5cbiAgdGhpcy5jYWxsZWRSZWFkID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSBfZGVyZXFfKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IF9kZXJlcV8oJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiByb3VuZFVwVG9OZXh0UG93ZXJPZjIobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IDMyOyBwIDw8PSAxKSBuIHw9IG4gPj4gcDtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChuID09PSBudWxsIHx8IGlzTmFOKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUuY2FsbGVkUmVhZCA9IHRydWU7XG4gIHZhciBuT3JpZyA9IG47XG4gIHZhciByZXQ7XG5cbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIHJldCA9IG51bGw7XG5cbiAgICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgZGVjb2RlciBkaWQgbm90IHJlY2VpdmUgZW5vdWdoIGRhdGFcbiAgICAvLyB0byBwcm9kdWNlIGEgZnVsbCBjaHVuaywgdGhlbiBpbW1lZGlhdGVseSByZWNlaXZlZCBhblxuICAgIC8vIEVPRiwgc3RhdGUuYnVmZmVyIHdpbGwgY29udGFpbiBbPEJ1ZmZlciA+LCA8QnVmZmVyIDAwIC4uLj5dLlxuICAgIC8vIGhvd011Y2hUb1JlYWQgd2lsbCBzZWUgdGhpcyBhbmQgY29lcmNlIHRoZSBhbW91bnQgdG9cbiAgICAvLyByZWFkIHRvIHplcm8gKGJlY2F1c2UgaXQncyBsb29raW5nIGF0IHRoZSBsZW5ndGggb2YgdGhlXG4gICAgLy8gZmlyc3QgPEJ1ZmZlciA+IGluIHN0YXRlLmJ1ZmZlciksIGFuZCB3ZSdsbCBlbmQgdXAgaGVyZS5cbiAgICAvL1xuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHZpYSBzdGF0ZS5kZWNvZGVyIC0tIG5vIG90aGVyIHZlbnVlXG4gICAgLy8gZXhpc3RzIGZvciBwdXNoaW5nIGEgemVyby1sZW5ndGggY2h1bmsgaW50byBzdGF0ZS5idWZmZXJcbiAgICAvLyBhbmQgdHJpZ2dlcmluZyB0aGlzIGJlaGF2aW9yLiBJbiB0aGlzIGNhc2UsIHdlIHJldHVybiBvdXJcbiAgICAvLyByZW1haW5pbmcgZGF0YSBhbmQgZW5kIHRoZSBzdHJlYW0sIGlmIGFwcHJvcHJpYXRlLlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPiAwICYmIHN0YXRlLmRlY29kZXIpIHtcbiAgICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmxlbmd0aCAtPSByZXQubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCAtIG4gPD0gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBkb1JlYWQgPSB0cnVlO1xuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpXG4gICAgZG9SZWFkID0gZmFsc2U7XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgY2FsbGVkIGl0cyBjYWxsYmFjayBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYFxuICAvLyB3aWxsIGJlIGZhbHNlLCBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlXG4gIC8vIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgaGFwcGVuZWQgdG8gcmVhZCgpIGV4YWN0bHkgdGhlIHJlbWFpbmluZyBhbW91bnQgaW4gdGhlXG4gIC8vIGJ1ZmZlciwgYW5kIHRoZSBFT0YgaGFzIGJlZW4gc2VlbiBhdCB0aGlzIHBvaW50LCB0aGVuIG1ha2Ugc3VyZVxuICAvLyB0aGF0IHdlIGVtaXQgJ2VuZCcgb24gdGhlIHZlcnkgbmV4dCB0aWNrLlxuICBpZiAoc3RhdGUuZW5kZWQgJiYgIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkIGFuZCB3ZSBoYXZlIHNvbWUgZGF0YSBsZWZ0LCB0aGVuIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgZWxzZVxuICAgIGVuZFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5lbWl0dGVkUmVhZGFibGUpXG4gICAgcmV0dXJuO1xuXG4gIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfSk7XG4gIGVsc2VcbiAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBpZiAocmVhZGFibGUgIT09IHNyYykgcmV0dXJuO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIC8vIHRoZSBoYW5kbGVyIHRoYXQgd2FpdHMgZm9yIHJlYWRhYmxlIGV2ZW50cyBhZnRlciBhbGxcbiAgICAvLyB0aGUgZGF0YSBnZXRzIHN1Y2tlZCBvdXQgaW4gZmxvdy5cbiAgICAvLyBUaGlzIHdvdWxkIGJlIGVhc2llciB0byBmb2xsb3cgd2l0aCBhIC5vbmNlKCkgaGFuZGxlclxuICAgIC8vIGluIGZsb3coKSwgYnV0IHRoYXQgaXMgdG9vIHNsb3cuXG4gICAgdGhpcy5vbigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZXN0ID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwKVxuICAgICAgZmxvdyhzcmMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG93KHNyYykge1xuICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBjaHVuaztcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG5cbiAgZnVuY3Rpb24gd3JpdGUoZGVzdCwgaSwgbGlzdCkge1xuICAgIHZhciB3cml0dGVuID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSB3cml0dGVuKSB7XG4gICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBpcGVzQ291bnQgJiYgbnVsbCAhPT0gKGNodW5rID0gc3JjLnJlYWQoKSkpIHtcblxuICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgICAgd3JpdGUoc3RhdGUucGlwZXMsIDAsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIGZvckVhY2goc3RhdGUucGlwZXMsIHdyaXRlKTtcblxuICAgIHNyYy5lbWl0KCdkYXRhJywgY2h1bmspO1xuXG4gICAgLy8gaWYgYW55b25lIG5lZWRzIGEgZHJhaW4sIHRoZW4gd2UgaGF2ZSB0byB3YWl0IGZvciB0aGF0LlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID4gMClcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlmIGV2ZXJ5IGRlc3RpbmF0aW9uIHdhcyB1bnBpcGVkLCBlaXRoZXIgYmVmb3JlIGVudGVyaW5nIHRoaXNcbiAgLy8gZnVuY3Rpb24sIG9yIGluIHRoZSB3aGlsZSBsb29wLCB0aGVuIHN0b3AgZmxvd2luZy5cbiAgLy9cbiAgLy8gTkI6IFRoaXMgaXMgYSBwcmV0dHkgcmFyZSBlZGdlIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSB7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlcmUgd2VyZSBkYXRhIGV2ZW50IGxpc3RlbmVycyBhZGRlZCwgdGhlbiBzd2l0Y2ggdG8gb2xkIG1vZGUuXG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpID4gMClcbiAgICAgIGVtaXREYXRhRXZlbnRzKHNyYyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgbm8gb25lIG5lZWRlZCBhIGRyYWluLCBzbyB3ZSBqdXN0IHJhbiBvdXQgb2YgZGF0YVxuICAvLyBvbiB0aGUgbmV4dCByZWFkYWJsZSBldmVudCwgc3RhcnQgaXQgb3ZlciBhZ2Fpbi5cbiAgc3RhdGUucmFuT3V0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGlwZU9uUmVhZGFibGUoKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmFuT3V0ID0gZmFsc2U7XG4gICAgZmxvdyh0aGlzKTtcbiAgfVxufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpXG4gICAgZW1pdERhdGFFdmVudHModGhpcyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB0aGlzLnJlYWQoMCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuICB0aGlzLnJlYWQoMCk7XG4gIHRoaXMuZW1pdCgncmVzdW1lJyk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZW1pdERhdGFFdmVudHModGhpcywgdHJ1ZSk7XG4gIHRoaXMuZW1pdCgncGF1c2UnKTtcbn07XG5cbmZ1bmN0aW9uIGVtaXREYXRhRXZlbnRzKHN0cmVhbSwgc3RhcnRQYXVzZWQpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9yZWFkYWJsZS1zdHJlYW0vaXNzdWVzLzE2XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dpdGNoIHRvIG9sZCBtb2RlIG5vdy4nKTtcbiAgfVxuXG4gIHZhciBwYXVzZWQgPSBzdGFydFBhdXNlZCB8fCBmYWxzZTtcbiAgdmFyIHJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gY29udmVydCB0byBhbiBvbGQtc3R5bGUgc3RyZWFtLlxuICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuICBzdHJlYW0ucGlwZSA9IFN0cmVhbS5wcm90b3R5cGUucGlwZTtcbiAgc3RyZWFtLm9uID0gc3RyZWFtLmFkZExpc3RlbmVyID0gU3RyZWFtLnByb3RvdHlwZS5vbjtcblxuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgcmVhZGFibGUgPSB0cnVlO1xuXG4gICAgdmFyIGM7XG4gICAgd2hpbGUgKCFwYXVzZWQgJiYgKG51bGwgIT09IChjID0gc3RyZWFtLnJlYWQoKSkpKVxuICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjKTtcblxuICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfTtcblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKHJlYWRhYmxlKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgfTtcblxuICAvLyBub3cgbWFrZSBpdCBzdGFydCwganVzdCBpbiBjYXNlIGl0IGhhZG4ndCBhbHJlYWR5LlxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICAvL2lmIChzdGF0ZS5vYmplY3RNb2RlICYmIHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSlcbiAgICAgIHJldHVybjtcbiAgICBlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHRoaXNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApXG4gICAgcmV0ID0gbnVsbDtcbiAgZWxzZSBpZiAob2JqZWN0TW9kZSlcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgIHJldCA9IGxpc3Quam9pbignJyk7XG4gICAgZWxzZVxuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChsaXN0LCBsZW5ndGgpO1xuICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGp1c3Qgc29tZSBvZiBpdC5cbiAgICBpZiAobiA8IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXG4gICAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IGNhc2UuXG4gICAgICAvLyB3ZSBoYXZlIGVub3VnaCB0byBjb3ZlciBpdCwgYnV0IGl0IHNwYW5zIHBhc3QgdGhlIGZpcnN0IGJ1ZmZlci5cbiAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICByZXQgPSAnJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgICByZXQgKz0gYnVmLnNsaWNlKDAsIGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XG5cbiAgICAgICAgaWYgKGNweSA8IGJ1Zi5sZW5ndGgpXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuXG4gICAgICAgIGMgKz0gY3B5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUuY2FsbGVkUmVhZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxufSkuY2FsbCh0aGlzLF9kZXJlcV8oXCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIikpXG59LHtcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjU1LFwiYnVmZmVyXCI6MjMsXCJjb3JlLXV0aWwtaXNcIjo0MCxcImV2ZW50c1wiOjI3LFwiaW5oZXJpdHNcIjoyOCxcImlzYXJyYXlcIjoyOSxcInN0cmVhbVwiOjQ1LFwic3RyaW5nX2RlY29kZXIvXCI6NDZ9XSwzODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gX2RlcmVxXygnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX2ZsdXNoKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuXG59LHtcIi4vX3N0cmVhbV9kdXBsZXhcIjozNSxcImNvcmUtdXRpbC1pc1wiOjQwLFwiaW5oZXJpdHNcIjoyOH1dLDM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gX2RlcmVxXygnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IF9kZXJlcV8oJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IF9kZXJlcV8oJ3N0cmVhbScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IF9kZXJlcV8oJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIHN0YXRlLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIHN0YXRlLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpXG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KVxuICAgIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcpXG4gICAgc3RhdGUuYnVmZmVyLnB1c2gobmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpKTtcbiAgZWxzZVxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIGlmIChzeW5jKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2VcbiAgICBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBjYigpO1xuICBpZiAoZmluaXNoZWQpXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyW2NdO1xuICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgIGMrKztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgaWYgKGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgZWxzZVxuICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGggPSAwO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2h1bmsgIT09ICd1bmRlZmluZWQnICYmIGNodW5rICE9PSBudWxsKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZClcbiAgICBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5lbmRpbmcgJiZcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgICAhc3RhdGUud3JpdGluZyk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cblxufSkuY2FsbCh0aGlzLF9kZXJlcV8oXCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIikpXG59LHtcIi4vX3N0cmVhbV9kdXBsZXhcIjozNSxcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjU1LFwiYnVmZmVyXCI6MjMsXCJjb3JlLXV0aWwtaXNcIjo0MCxcImluaGVyaXRzXCI6MjgsXCJzdHJlYW1cIjo0NX1dLDQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoQnVmZmVyKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYXJnKTtcbn1cbmV4cG9ydHMuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxufSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJidWZmZXJcIikuQnVmZmVyKVxufSx7XCJidWZmZXJcIjoyM31dLDQxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXyhcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIilcblxufSx7XCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCI6MzZ9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU3RyZWFtID0gX2RlcmVxXygnc3RyZWFtJyk7IC8vIGhhY2sgdG8gZml4IGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBpc3N1ZSB3aGVuIHVzZWQgd2l0aCBicm93c2VyaWZ5XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbTtcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5cbn0se1wiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIjozNSxcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIjozNixcIi4vbGliL19zdHJlYW1fcmVhZGFibGUuanNcIjozNyxcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCI6MzgsXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCI6MzksXCJzdHJlYW1cIjo0NX1dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXyhcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG5cbn0se1wiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIjozOH1dLDQ0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXyhcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcblxufSx7XCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCI6Mzl9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IF9kZXJlcV8oJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcblxufSx7XCJldmVudHNcIjoyNyxcImluaGVyaXRzXCI6MjgsXCJyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzXCI6MzQsXCJyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanNcIjo0MSxcInJlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qc1wiOjQyLFwicmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qc1wiOjQzLFwicmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzXCI6NDR9XSw0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IF9kZXJlcV8oJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cblxufSx7XCJidWZmZXJcIjoyM31dLDQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgcHVueWNvZGUgPSBfZGVyZXFfKCdwdW55Y29kZScpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eW2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSBfZGVyZXFfKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55IGNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgaW4gQVNDSUkuXG4gICAgICB2YXIgZG9tYWluQXJyYXkgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgbmV3T3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gZG9tYWluQXJyYXlbaV07XG4gICAgICAgIG5ld091dC5wdXNoKHMubWF0Y2goL1teQS1aYS16MC05Xy1dLykgP1xuICAgICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKGlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIGlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmIChpc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgfSk7XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fFxuICAgICAgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gIGFyZyA9PSBudWxsO1xufVxuXG59LHtcInB1bnljb2RlXCI6MzAsXCJxdWVyeXN0cmluZ1wiOjMzfV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxufSx7fV0sNDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBfZGVyZXFfKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vc3VwcG9ydC9pc0J1ZmZlclwiOjQ4LFwiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCI6NTUsXCJpbmhlcml0c1wiOjI4fV0sNTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGh0dHAgPSBtb2R1bGUuZXhwb3J0cztcbnZhciBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUmVxdWVzdCA9IF9kZXJlcV8oJy4vbGliL3JlcXVlc3QnKTtcbnZhciB1cmwgPSBfZGVyZXFfKCd1cmwnKVxuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJhbXMgPSB1cmwucGFyc2UocGFyYW1zKVxuICAgIH1cbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgaWYgKCFwYXJhbXMuaG9zdCAmJiAhcGFyYW1zLnBvcnQpIHtcbiAgICAgICAgcGFyYW1zLnBvcnQgPSBwYXJzZUludCh3aW5kb3cubG9jYXRpb24ucG9ydCwgMTApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5ob3N0ICYmIHBhcmFtcy5ob3N0bmFtZSkge1xuICAgICAgICBwYXJhbXMuaG9zdCA9IHBhcmFtcy5ob3N0bmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5wcm90b2NvbCkge1xuICAgICAgICBpZiAocGFyYW1zLnNjaGVtZSkge1xuICAgICAgICAgICAgcGFyYW1zLnByb3RvY29sID0gcGFyYW1zLnNjaGVtZSArICc6JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5wcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmhvc3QpIHtcbiAgICAgICAgcGFyYW1zLmhvc3QgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgfHwgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gICAgfVxuICAgIGlmICgvOi8udGVzdChwYXJhbXMuaG9zdCkpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMucG9ydCkge1xuICAgICAgICAgICAgcGFyYW1zLnBvcnQgPSBwYXJhbXMuaG9zdC5zcGxpdCgnOicpWzFdO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5ob3N0ID0gcGFyYW1zLmhvc3Quc3BsaXQoJzonKVswXTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMucG9ydCkgcGFyYW1zLnBvcnQgPSBwYXJhbXMucHJvdG9jb2wgPT0gJ2h0dHBzOicgPyA0NDMgOiA4MDtcbiAgICBcbiAgICB2YXIgcmVxID0gbmV3IFJlcXVlc3QobmV3IHhockh0dHAsIHBhcmFtcyk7XG4gICAgaWYgKGNiKSByZXEub24oJ3Jlc3BvbnNlJywgY2IpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgcGFyYW1zLm1ldGhvZCA9ICdHRVQnO1xuICAgIHZhciByZXEgPSBodHRwLnJlcXVlc3QocGFyYW1zLCBjYik7XG4gICAgcmVxLmVuZCgpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLkFnZW50ID0gZnVuY3Rpb24gKCkge307XG5odHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNDtcblxudmFyIHhockh0dHAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHdpbmRvdyBvYmplY3QgcHJlc2VudCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgdmFyIGF4cyA9IFtcbiAgICAgICAgICAgICdNc3htbDIuWE1MSFRUUC42LjAnLFxuICAgICAgICAgICAgJ01zeG1sMi5YTUxIVFRQLjMuMCcsXG4gICAgICAgICAgICAnTWljcm9zb2Z0LlhNTEhUVFAnXG4gICAgICAgIF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBheCA9IG5ldyh3aW5kb3cuQWN0aXZlWE9iamVjdCkoYXhzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheF8gPSBheDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBheF87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHdpbmRvdy5BY3RpdmVYT2JqZWN0KShheHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWpheCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FqYXggbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICB9XG59KSgpO1xuXG5odHRwLlNUQVRVU19DT0RFUyA9IHtcbiAgICAxMDAgOiAnQ29udGludWUnLFxuICAgIDEwMSA6ICdTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcbiAgICAxMDIgOiAnUHJvY2Vzc2luZycsICAgICAgICAgICAgICAgICAvLyBSRkMgMjUxOCwgb2Jzb2xldGVkIGJ5IFJGQyA0OTE4XG4gICAgMjAwIDogJ09LJyxcbiAgICAyMDEgOiAnQ3JlYXRlZCcsXG4gICAgMjAyIDogJ0FjY2VwdGVkJyxcbiAgICAyMDMgOiAnTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb24nLFxuICAgIDIwNCA6ICdObyBDb250ZW50JyxcbiAgICAyMDUgOiAnUmVzZXQgQ29udGVudCcsXG4gICAgMjA2IDogJ1BhcnRpYWwgQ29udGVudCcsXG4gICAgMjA3IDogJ011bHRpLVN0YXR1cycsICAgICAgICAgICAgICAgLy8gUkZDIDQ5MThcbiAgICAzMDAgOiAnTXVsdGlwbGUgQ2hvaWNlcycsXG4gICAgMzAxIDogJ01vdmVkIFBlcm1hbmVudGx5JyxcbiAgICAzMDIgOiAnTW92ZWQgVGVtcG9yYXJpbHknLFxuICAgIDMwMyA6ICdTZWUgT3RoZXInLFxuICAgIDMwNCA6ICdOb3QgTW9kaWZpZWQnLFxuICAgIDMwNSA6ICdVc2UgUHJveHknLFxuICAgIDMwNyA6ICdUZW1wb3JhcnkgUmVkaXJlY3QnLFxuICAgIDQwMCA6ICdCYWQgUmVxdWVzdCcsXG4gICAgNDAxIDogJ1VuYXV0aG9yaXplZCcsXG4gICAgNDAyIDogJ1BheW1lbnQgUmVxdWlyZWQnLFxuICAgIDQwMyA6ICdGb3JiaWRkZW4nLFxuICAgIDQwNCA6ICdOb3QgRm91bmQnLFxuICAgIDQwNSA6ICdNZXRob2QgTm90IEFsbG93ZWQnLFxuICAgIDQwNiA6ICdOb3QgQWNjZXB0YWJsZScsXG4gICAgNDA3IDogJ1Byb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJyxcbiAgICA0MDggOiAnUmVxdWVzdCBUaW1lLW91dCcsXG4gICAgNDA5IDogJ0NvbmZsaWN0JyxcbiAgICA0MTAgOiAnR29uZScsXG4gICAgNDExIDogJ0xlbmd0aCBSZXF1aXJlZCcsXG4gICAgNDEyIDogJ1ByZWNvbmRpdGlvbiBGYWlsZWQnLFxuICAgIDQxMyA6ICdSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2UnLFxuICAgIDQxNCA6ICdSZXF1ZXN0LVVSSSBUb28gTGFyZ2UnLFxuICAgIDQxNSA6ICdVbnN1cHBvcnRlZCBNZWRpYSBUeXBlJyxcbiAgICA0MTYgOiAnUmVxdWVzdGVkIFJhbmdlIE5vdCBTYXRpc2ZpYWJsZScsXG4gICAgNDE3IDogJ0V4cGVjdGF0aW9uIEZhaWxlZCcsXG4gICAgNDE4IDogJ0lcXCdtIGEgdGVhcG90JywgICAgICAgICAgICAgIC8vIFJGQyAyMzI0XG4gICAgNDIyIDogJ1VucHJvY2Vzc2FibGUgRW50aXR5JywgICAgICAgLy8gUkZDIDQ5MThcbiAgICA0MjMgOiAnTG9ja2VkJywgICAgICAgICAgICAgICAgICAgICAvLyBSRkMgNDkxOFxuICAgIDQyNCA6ICdGYWlsZWQgRGVwZW5kZW5jeScsICAgICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNDI1IDogJ1Vub3JkZXJlZCBDb2xsZWN0aW9uJywgICAgICAgLy8gUkZDIDQ5MThcbiAgICA0MjYgOiAnVXBncmFkZSBSZXF1aXJlZCcsICAgICAgICAgICAvLyBSRkMgMjgxN1xuICAgIDQyOCA6ICdQcmVjb25kaXRpb24gUmVxdWlyZWQnLCAgICAgIC8vIFJGQyA2NTg1XG4gICAgNDI5IDogJ1RvbyBNYW55IFJlcXVlc3RzJywgICAgICAgICAgLy8gUkZDIDY1ODVcbiAgICA0MzEgOiAnUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZScsLy8gUkZDIDY1ODVcbiAgICA1MDAgOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJyxcbiAgICA1MDEgOiAnTm90IEltcGxlbWVudGVkJyxcbiAgICA1MDIgOiAnQmFkIEdhdGV3YXknLFxuICAgIDUwMyA6ICdTZXJ2aWNlIFVuYXZhaWxhYmxlJyxcbiAgICA1MDQgOiAnR2F0ZXdheSBUaW1lLW91dCcsXG4gICAgNTA1IDogJ0hUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkJyxcbiAgICA1MDYgOiAnVmFyaWFudCBBbHNvIE5lZ290aWF0ZXMnLCAgICAvLyBSRkMgMjI5NVxuICAgIDUwNyA6ICdJbnN1ZmZpY2llbnQgU3RvcmFnZScsICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNTA5IDogJ0JhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZCcsXG4gICAgNTEwIDogJ05vdCBFeHRlbmRlZCcsICAgICAgICAgICAgICAgLy8gUkZDIDI3NzRcbiAgICA1MTEgOiAnTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcgLy8gUkZDIDY1ODVcbn07XG59LHtcIi4vbGliL3JlcXVlc3RcIjo1MSxcImV2ZW50c1wiOjI3LFwidXJsXCI6NDd9XSw1MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU3RyZWFtID0gX2RlcmVxXygnc3RyZWFtJyk7XG52YXIgUmVzcG9uc2UgPSBfZGVyZXFfKCcuL3Jlc3BvbnNlJyk7XG52YXIgQmFzZTY0ID0gX2RlcmVxXygnQmFzZTY0Jyk7XG52YXIgaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpO1xuXG52YXIgUmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhociwgcGFyYW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYueGhyID0geGhyO1xuICAgIHNlbGYuYm9keSA9IFtdO1xuICAgIFxuICAgIHNlbGYudXJpID0gKHBhcmFtcy5wcm90b2NvbCB8fCAnaHR0cDonKSArICcvLydcbiAgICAgICAgKyBwYXJhbXMuaG9zdFxuICAgICAgICArIChwYXJhbXMucG9ydCA/ICc6JyArIHBhcmFtcy5wb3J0IDogJycpXG4gICAgICAgICsgKHBhcmFtcy5wYXRoIHx8ICcvJylcbiAgICA7XG4gICAgXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMud2l0aENyZWRlbnRpYWxzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJhbXMud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkgeyB4aHIud2l0aENyZWRlbnRpYWxzID0gcGFyYW1zLndpdGhDcmVkZW50aWFscyB9XG4gICAgY2F0Y2ggKGUpIHt9XG4gICAgXG4gICAgaWYgKHBhcmFtcy5yZXNwb25zZVR5cGUpIHRyeSB7IHhoci5yZXNwb25zZVR5cGUgPSBwYXJhbXMucmVzcG9uc2VUeXBlIH1cbiAgICBjYXRjaCAoZSkge31cbiAgICBcbiAgICB4aHIub3BlbihcbiAgICAgICAgcGFyYW1zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgICAgc2VsZi51cmksXG4gICAgICAgIHRydWVcbiAgICApO1xuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJykpO1xuICAgIH07XG5cbiAgICBzZWxmLl9oZWFkZXJzID0ge307XG4gICAgXG4gICAgaWYgKHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhwYXJhbXMuaGVhZGVycyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNTYWZlUmVxdWVzdEhlYWRlcihrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtcy5oZWFkZXJzW2tleV07XG4gICAgICAgICAgICBzZWxmLnNldEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAocGFyYW1zLmF1dGgpIHtcbiAgICAgICAgLy9iYXNpYyBhdXRoXG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBCYXNlNjQuYnRvYShwYXJhbXMuYXV0aCkpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSBuZXcgUmVzcG9uc2U7XG4gICAgcmVzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScpO1xuICAgIH0pO1xuICAgIFxuICAgIHJlcy5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuICAgIH0pO1xuXG4gICAgcmVzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG4gICAgXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRml4IGZvciBJRTkgYnVnXG4gICAgICAgIC8vIFNDUklQVDU3NTogQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXG4gICAgICAgIC8vIEl0IGhhcHBlbnMgd2hlbiBhIHJlcXVlc3QgaXMgYWJvcnRlZCwgY2FsbGluZyB0aGUgc3VjY2VzcyBjYWxsYmFjayBhbnl3YXkgd2l0aCByZWFkeVN0YXRlID09PSA0XG4gICAgICAgIGlmICh4aHIuX19hYm9ydGVkKSByZXR1cm47XG4gICAgICAgIHJlcy5oYW5kbGUoeGhyKTtcbiAgICB9O1xufTtcblxuaW5oZXJpdHMoUmVxdWVzdCwgU3RyZWFtKTtcblxuUmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlXG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldXG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldXG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdGhpcy5ib2R5LnB1c2gocyk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHMpIHtcbiAgICB0aGlzLnhoci5fX2Fib3J0ZWQgPSB0cnVlO1xuICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocyAhPT0gdW5kZWZpbmVkKSB0aGlzLmJvZHkucHVzaChzKTtcblxuICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyh0aGlzLl9oZWFkZXJzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2hlYWRlcnNba2V5XTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnhoci5zZW5kKCcnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuYm9keVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy54aHIuc2VuZCh0aGlzLmJvZHkuam9pbignJykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHRoaXMuYm9keVswXSkpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvZHkucHVzaC5hcHBseShib2R5LCB0aGlzLmJvZHlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQoYm9keSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9BcnJheS8udGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5ib2R5WzBdKSkpIHtcbiAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZW4gKz0gdGhpcy5ib2R5W2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keSA9IG5ldyh0aGlzLmJvZHlbMF0uY29uc3RydWN0b3IpKGxlbik7XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuYm9keVtpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGJvZHlbaysrXSA9IGJbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIuc2VuZChib2R5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNYSFIyQ29tcGF0aWJsZSh0aGlzLmJvZHlbMF0pKSB7XG4gICAgICAgIHRoaXMueGhyLnNlbmQodGhpcy5ib2R5WzBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBib2R5ID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ICs9IHRoaXMuYm9keVtpXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQoYm9keSk7XG4gICAgfVxufTtcblxuLy8gVGFrZW4gZnJvbSBodHRwOi8vZHhyLm1vemlsbGEub3JnL21vemlsbGEvbW96aWxsYS1jZW50cmFsL2NvbnRlbnQvYmFzZS9zcmMvbnNYTUxIdHRwUmVxdWVzdC5jcHAuaHRtbFxuUmVxdWVzdC51bnNhZmVIZWFkZXJzID0gW1xuICAgIFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgICBcImFjY2VwdC1lbmNvZGluZ1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzXCIsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiLFxuICAgIFwiY29ubmVjdGlvblwiLFxuICAgIFwiY29udGVudC1sZW5ndGhcIixcbiAgICBcImNvb2tpZVwiLFxuICAgIFwiY29va2llMlwiLFxuICAgIFwiY29udGVudC10cmFuc2Zlci1lbmNvZGluZ1wiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiZXhwZWN0XCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJrZWVwLWFsaXZlXCIsXG4gICAgXCJvcmlnaW5cIixcbiAgICBcInJlZmVyZXJcIixcbiAgICBcInRlXCIsXG4gICAgXCJ0cmFpbGVyXCIsXG4gICAgXCJ0cmFuc2Zlci1lbmNvZGluZ1wiLFxuICAgIFwidXBncmFkZVwiLFxuICAgIFwidXNlci1hZ2VudFwiLFxuICAgIFwidmlhXCJcbl07XG5cblJlcXVlc3QucHJvdG90eXBlLmlzU2FmZVJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyTmFtZSkge1xuICAgIGlmICghaGVhZGVyTmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBpbmRleE9mKFJlcXVlc3QudW5zYWZlSGVhZGVycywgaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTE7XG59O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBrZXlzO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIGluZGV4T2YgPSBmdW5jdGlvbiAoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG52YXIgaXNYSFIyQ29tcGF0aWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBGb3JtRGF0YSkgcmV0dXJuIHRydWU7XG59O1xuXG59LHtcIi4vcmVzcG9uc2VcIjo1MixcIkJhc2U2NFwiOjUzLFwiaW5oZXJpdHNcIjo1NCxcInN0cmVhbVwiOjQ1fV0sNTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFN0cmVhbSA9IF9kZXJlcV8oJ3N0cmVhbScpO1xudmFyIHV0aWwgPSBfZGVyZXFfKCd1dGlsJyk7XG5cbnZhciBSZXNwb25zZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlcykge1xuICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbn07XG5cbnV0aWwuaW5oZXJpdHMoUmVzcG9uc2UsIFN0cmVhbSk7XG5cbnZhciBjYXBhYmxlID0ge1xuICAgIHN0cmVhbWluZyA6IHRydWUsXG4gICAgc3RhdHVzMiA6IHRydWVcbn07XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyAocmVzKSB7XG4gICAgdmFyIGxpbmVzID0gcmVzLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICAgIGlmIChsaW5lID09PSAnJykgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goL14oW146XSspOlxccyooLiopLyk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbVsxXS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSA9IG1bMl07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChoZWFkZXJzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoaGVhZGVyc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2tleV0gPSBbIGhlYWRlcnNba2V5XSwgdmFsdWUgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlcnNbbGluZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0UmVzcG9uc2UgPSBmdW5jdGlvbiAoeGhyKSB7XG4gICAgdmFyIHJlc3BUeXBlID0gU3RyaW5nKHhoci5yZXNwb25zZVR5cGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHJlc3BUeXBlID09PSAnYmxvYicpIHJldHVybiB4aHIucmVzcG9uc2VCbG9iIHx8IHhoci5yZXNwb25zZTtcbiAgICBpZiAocmVzcFR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHJldHVybiB4aHIucmVzcG9uc2U7XG4gICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XG59XG5cblJlc3BvbnNlLnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG59O1xuXG5SZXNwb25zZS5wcm90b3R5cGUuaGFuZGxlID0gZnVuY3Rpb24gKHJlcykge1xuICAgIGlmIChyZXMucmVhZHlTdGF0ZSA9PT0gMiAmJiBjYXBhYmxlLnN0YXR1czIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMocmVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYXBhYmxlLnN0YXR1czIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGNhcGFibGUuc3RhdHVzMikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkeScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhcGFibGUuc3RyZWFtaW5nICYmIHJlcy5yZWFkeVN0YXRlID09PSAzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHJlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHt9XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fZW1pdERhdGEocmVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYXBhYmxlLnN0cmVhbWluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlcy5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkeScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VtaXREYXRhKHJlcyk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgdGhpcy5nZXRSZXNwb25zZShyZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLl9lbWl0RGF0YSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICB2YXIgcmVzcEJvZHkgPSB0aGlzLmdldFJlc3BvbnNlKHJlcyk7XG4gICAgaWYgKHJlc3BCb2R5LnRvU3RyaW5nKCkubWF0Y2goL0FycmF5QnVmZmVyLykpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgbmV3IFVpbnQ4QXJyYXkocmVzcEJvZHksIHRoaXMub2Zmc2V0KSk7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gcmVzcEJvZHkuYnl0ZUxlbmd0aDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVzcEJvZHkubGVuZ3RoID4gdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcmVzcEJvZHkuc2xpY2UodGhpcy5vZmZzZXQpKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSByZXNwQm9keS5sZW5ndGg7XG4gICAgfVxufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxufSx7XCJzdHJlYW1cIjo0NSxcInV0aWxcIjo0OX1dLDUzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbjsoZnVuY3Rpb24gKCkge1xuXG4gIHZhciBvYmplY3QgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzOyAvLyAjODogd2ViIHdvcmtlcnNcbiAgdmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcblxuICBmdW5jdGlvbiBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgSW52YWxpZENoYXJhY3RlckVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcjtcbiAgSW52YWxpZENoYXJhY3RlckVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cbiAgLy8gZW5jb2RlclxuICAvLyBbaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vOTk5MTY2XSBieSBbaHR0cHM6Ly9naXRodWIuY29tL25pZ25hZ11cbiAgb2JqZWN0LmJ0b2EgfHwgKFxuICBvYmplY3QuYnRvYSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGZvciAoXG4gICAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlclxuICAgICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnMsIG91dHB1dCA9ICcnO1xuICAgICAgLy8gaWYgdGhlIG5leHQgaW5wdXQgaW5kZXggZG9lcyBub3QgZXhpc3Q6XG4gICAgICAvLyAgIGNoYW5nZSB0aGUgbWFwcGluZyB0YWJsZSB0byBcIj1cIlxuICAgICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgICAgaW5wdXQuY2hhckF0KGlkeCB8IDApIHx8IChtYXAgPSAnPScsIGlkeCAlIDEpO1xuICAgICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICAgIG91dHB1dCArPSBtYXAuY2hhckF0KDYzICYgYmxvY2sgPj4gOCAtIGlkeCAlIDEgKiA4KVxuICAgICkge1xuICAgICAgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGlkeCArPSAzLzQpO1xuICAgICAgaWYgKGNoYXJDb2RlID4gMHhGRikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENoYXJhY3RlckVycm9yKFwiJ2J0b2EnIGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBlbmNvZGVkIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3V0c2lkZSBvZiB0aGUgTGF0aW4xIHJhbmdlLlwiKTtcbiAgICAgIH1cbiAgICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KTtcblxuICAvLyBkZWNvZGVyXG4gIC8vIFtodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDIwMzk2XSBieSBbaHR0cHM6Ly9naXRodWIuY29tL2F0a11cbiAgb2JqZWN0LmF0b2IgfHwgKFxuICBvYmplY3QuYXRvYiA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvPSskLywgJycpO1xuICAgIGlmIChpbnB1dC5sZW5ndGggJSA0ID09IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IoXCInYXRvYicgZmFpbGVkOiBUaGUgc3RyaW5nIHRvIGJlIGRlY29kZWQgaXMgbm90IGNvcnJlY3RseSBlbmNvZGVkLlwiKTtcbiAgICB9XG4gICAgZm9yIChcbiAgICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyc1xuICAgICAgdmFyIGJjID0gMCwgYnMsIGJ1ZmZlciwgaWR4ID0gMCwgb3V0cHV0ID0gJyc7XG4gICAgICAvLyBnZXQgbmV4dCBjaGFyYWN0ZXJcbiAgICAgIGJ1ZmZlciA9IGlucHV0LmNoYXJBdChpZHgrKyk7XG4gICAgICAvLyBjaGFyYWN0ZXIgZm91bmQgaW4gdGFibGU/IGluaXRpYWxpemUgYml0IHN0b3JhZ2UgYW5kIGFkZCBpdHMgYXNjaWkgdmFsdWU7XG4gICAgICB+YnVmZmVyICYmIChicyA9IGJjICUgNCA/IGJzICogNjQgKyBidWZmZXIgOiBidWZmZXIsXG4gICAgICAgIC8vIGFuZCBpZiBub3QgZmlyc3Qgb2YgZWFjaCA0IGNoYXJhY3RlcnMsXG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIGZpcnN0IDggYml0cyB0byBvbmUgYXNjaWkgY2hhcmFjdGVyXG4gICAgICAgIGJjKysgJSA0KSA/IG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmIGJzID4+ICgtMiAqIGJjICYgNikpIDogMFxuICAgICkge1xuICAgICAgLy8gdHJ5IHRvIGZpbmQgY2hhcmFjdGVyIGluIHRhYmxlICgwLTYzLCBub3QgZm91bmQgPT4gLTEpXG4gICAgICBidWZmZXIgPSBjaGFycy5pbmRleE9mKGJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0pO1xuXG59KCkpO1xuXG59LHt9XSw1NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cz1fZGVyZXFfKDI4KVxufSx7XCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1wiOjI4fV0sNTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxufSx7fV0sNTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbnZhciBTdHJlYW0gPSBfZGVyZXFfKCdzdHJlYW0nKVxuXG4vLyB0aHJvdWdoXG4vL1xuLy8gYSBzdHJlYW0gdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHJlLWVtaXQgdGhlIGlucHV0LlxuLy8gdXNlZnVsIGZvciBhZ2dyZWdhdGluZyBhIHNlcmllcyBvZiBjaGFuZ2luZyBidXQgbm90IGVuZGluZyBzdHJlYW1zIGludG8gb25lIHN0cmVhbSlcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdGhyb3VnaFxudGhyb3VnaC50aHJvdWdoID0gdGhyb3VnaFxuXG4vL2NyZWF0ZSBhIHJlYWRhYmxlIHdyaXRhYmxlIHN0cmVhbS5cblxuZnVuY3Rpb24gdGhyb3VnaCAod3JpdGUsIGVuZCwgb3B0cykge1xuICB3cml0ZSA9IHdyaXRlIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHRoaXMucXVldWUoZGF0YSkgfVxuICBlbmQgPSBlbmQgfHwgZnVuY3Rpb24gKCkgeyB0aGlzLnF1ZXVlKG51bGwpIH1cblxuICB2YXIgZW5kZWQgPSBmYWxzZSwgZGVzdHJveWVkID0gZmFsc2UsIGJ1ZmZlciA9IFtdLCBfZW5kZWQgPSBmYWxzZVxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmVhbSgpXG4gIHN0cmVhbS5yZWFkYWJsZSA9IHN0cmVhbS53cml0YWJsZSA9IHRydWVcbiAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG5cbi8vICBzdHJlYW0uYXV0b1BhdXNlICAgPSAhKG9wdHMgJiYgb3B0cy5hdXRvUGF1c2UgICA9PT0gZmFsc2UpXG4gIHN0cmVhbS5hdXRvRGVzdHJveSA9ICEob3B0cyAmJiBvcHRzLmF1dG9EZXN0cm95ID09PSBmYWxzZSlcblxuICBzdHJlYW0ud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHdyaXRlLmNhbGwodGhpcywgZGF0YSlcbiAgICByZXR1cm4gIXN0cmVhbS5wYXVzZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgIHdoaWxlKGJ1ZmZlci5sZW5ndGggJiYgIXN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHZhciBkYXRhID0gYnVmZmVyLnNoaWZ0KClcbiAgICAgIGlmKG51bGwgPT09IGRhdGEpXG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICAgIGVsc2VcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5xdWV1ZSA9IHN0cmVhbS5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbi8vICAgIGNvbnNvbGUuZXJyb3IoZW5kZWQpXG4gICAgaWYoX2VuZGVkKSByZXR1cm4gc3RyZWFtXG4gICAgaWYoZGF0YSA9PSBudWxsKSBfZW5kZWQgPSB0cnVlXG4gICAgYnVmZmVyLnB1c2goZGF0YSlcbiAgICBkcmFpbigpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG5cbiAgLy90aGlzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyB0aGUgZmlyc3QgJ2VuZCcgbGlzdGVuZXJcbiAgLy9tdXN0IGNhbGwgZGVzdHJveSBuZXh0IHRpY2ssIHRvIG1ha2Ugc3VyZSB3ZSdyZSBhZnRlciBhbnlcbiAgLy9zdHJlYW0gcGlwZWQgZnJvbSBoZXJlLlxuICAvL3RoaXMgaXMgb25seSBhIHByb2JsZW0gaWYgZW5kIGlzIG5vdCBlbWl0dGVkIHN5bmNocm9ub3VzbHkuXG4gIC8vYSBuaWNlciB3YXkgdG8gZG8gdGhpcyBpcyB0byBtYWtlIHN1cmUgdGhpcyBpcyB0aGUgbGFzdCBsaXN0ZW5lciBmb3IgJ2VuZCdcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmKCFzdHJlYW0ud3JpdGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gX2VuZCAoKSB7XG4gICAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2VcbiAgICBlbmQuY2FsbChzdHJlYW0pXG4gICAgaWYoIXN0cmVhbS5yZWFkYWJsZSAmJiBzdHJlYW0uYXV0b0Rlc3Ryb3kpXG4gICAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBzdHJlYW0uZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihlbmRlZCkgcmV0dXJuXG4gICAgZW5kZWQgPSB0cnVlXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgX2VuZCgpIC8vIHdpbGwgZW1pdCBvciBxdWV1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgc3RyZWFtLndyaXRhYmxlID0gc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihzdHJlYW0ucGF1c2VkKSByZXR1cm5cbiAgICBzdHJlYW0ucGF1c2VkID0gdHJ1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkge1xuICAgICAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG4gICAgICBzdHJlYW0uZW1pdCgncmVzdW1lJylcbiAgICB9XG4gICAgZHJhaW4oKVxuICAgIC8vbWF5IGhhdmUgYmVjb21lIHBhdXNlZCBhZ2FpbixcbiAgICAvL2FzIGRyYWluIGVtaXRzICdkYXRhJy5cbiAgICBpZighc3RyZWFtLnBhdXNlZClcbiAgICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG4gIHJldHVybiBzdHJlYW1cbn1cblxuXG59KS5jYWxsKHRoaXMsX2RlcmVxXyhcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSlcbn0se1wiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCI6NTUsXCJzdHJlYW1cIjo0NX1dfSx7fSxbMl0pKDIpXG59KTtcbn0pKHdpbmRvdy5pbnRlcm1pbmUpOyIsInZhciBjeW1pbmUgPSB7XG4gIHRvTm9kZXNBbmRFZGdlcyA6IGZ1bmN0aW9uKHJlY29yZHMsIHBhcmVudE5vZGUpe1xuICAgIHZhciBkID0ge1xuICAgICAgbm9kZXMgOiBbXSxcbiAgICAgIGVkZ2VzIDogW11cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSBpbiByZWNvcmRzKSB7XG4gICAgICB2YXIgdGhpc05vZGUsIHJvdyA9IHJlY29yZHNbaV07XG4gICAgICB0aGlzTm9kZSA9IHRoaXMucmVjb3JkVG9Ob2RlKHJvdyk7XG5cbiAgICAgIGlmKHJvdy5pbnRlcmFjdGlvbnMpIHtcbiAgICAgICAgLy9yZWN1cnNpdmVseSBtYWtlIHRoZSBpbnRlcmFjdGlvbnMgaW50byBub2RlcyxcbiAgICAgICAgLy9iZWNhdXNlIG5vZGUgZW50aXRpZXMgYXJlIG5lc3RlZCBhdCB0d28gbGV2ZWxzLlxuICAgICAgICBkID0gdGhpcy5tZXJnZU9iamVjdHMoZCwgdGhpcy50b05vZGVzQW5kRWRnZXMocm93LmludGVyYWN0aW9ucywgdGhpc05vZGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vaWYgaXQgZG9lc24ndCBoYXZlIGFuIGludGVyYWN0aW9uIGxpc3QsIGl0IHByb2JhYmx5ICppcyogYW4gaW50ZXJhY3Rpb25cbiAgICAgICAgLy9hbmQgdGh1cyBuZWVkcyB0byBiZSBhbiBlZGdlXG4gICAgICAgIGQuZWRnZXMucHVzaCh0aGlzLmludGVyYWN0aW9uVG9FZGdlKHBhcmVudE5vZGUsIHRoaXNOb2RlKSk7XG5cbiAgICAgIH1cbiAgICAgIGQubm9kZXMucHVzaCh0aGlzTm9kZSk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbiAgfSxcbiAgcmVjb3JkVG9Ob2RlIDogZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXQ7XG4gICAgcmV0ID0gb2JqLmdlbmUyID8gb2JqLmdlbmUyIDogb2JqO1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhIDoge1xuICAgICAgICBjbGFzcyA6IHJldC5jbGFzcyxcbiAgICAgICAgbGFiZWwgOiB0aGlzLm5hbWVOb2RlKG9iaiksXG4gICAgICAgIHN5bWJvbCA6IHJldC5zeW1ib2wsXG4gICAgICAgIGlkIDogcmV0Lm9iamVjdElkLnRvU3RyaW5nKCkgLy9jeXRvc2NhcGUgbmVlZHMgc3RyaW5nc1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbmFtZU5vZGUgOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLmdlbmUyICYmIG9iai5nZW5lMi5zeW1ib2wpIHtcbiAgICAgIHJldHVybiBvYmouZ2VuZTIuc3ltYm9sO1xuICAgIH0gZWxzZSBpZiAob2JqLnN5bWJvbCkge1xuICAgICAgcmV0dXJuIG9iai5zeW1ib2w7XG4gICAgfSBlbHNlIGlmIChvYmouZGV0YWlscykge1xuICAgICAgcmV0dXJuIG9iai5kZXRhaWxzWzBdLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIk5BTUUgTUlTU0lOR1wiXG4gICAgfVxuICB9LFxuICBpbnRlcmFjdGlvblRvRWRnZSA6IGZ1bmN0aW9uKG5vZGUsIG5vZGUyKSB7XG4gICAgLy90b2RvOiB3ZSBhbG1vc3QgY2VydGFpbmx5IHdhbnQgdG8gYWRkIG1vcmUgY29tcGxleGl0eSB0byB0aGUgcmV0dXJuIG9iamVjdFxuICAgIHJldHVybiB7XG4gICAgICBkYXRhIDoge1xuICAgICAgICBzb3VyY2UgOiBub2RlLmRhdGEuaWQsXG4gICAgICAgIHRhcmdldCA6IG5vZGUyLmRhdGEuaWRcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICAvKipcbiAgKiBPdmVyd3JpdGVzIG9iajEncyB2YWx1ZXMgd2l0aCBvYmoyJ3MgYW5kIGFkZHMgb2JqMidzIGlmIG5vbiBleGlzdGVudCBpbiBvYmoxXG4gICogQHBhcmFtIG9iajFcbiAgKiBAcGFyYW0gb2JqMlxuICAqIEByZXR1cm5zIG9iajMgYSBuZXcgb2JqZWN0IGJhc2VkIG9uIG9iajEgYW5kIG9iajJcbiAgKi9cblxuICAvL1RPRE86IG1ha2Ugc3VyZSB3ZSBoYW5kbGUgZWRnZSBjYXNlcyBiZXR0ZXIsIGUuZy4gZHVwbGljYXRlIHZhbHVlcy5cbiAgbWVyZ2VPYmplY3RzIDogZnVuY3Rpb24ob2JqMSxvYmoyKXtcbiAgICB2YXIgb2JqMyA9IHt9O1xuICAgIGZvciAodmFyIGF0dHJuYW1lIGluIG9iajEpIHsgb2JqM1thdHRybmFtZV0gPSBvYmoxW2F0dHJuYW1lXTsgfVxuICAgIGZvciAodmFyIGF0dHJuYW1lIGluIG9iajIpIHsgb2JqM1thdHRybmFtZV0gPSBvYmoyW2F0dHJuYW1lXTsgfVxuICAgIHJldHVybiBvYmozO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3ltaW5lO1xuIiwidmFyIGN5bWluZSA9IHJlcXVpcmUoJy4vY3ltaW5lJyksXG5jeXRvc2NhcGUgPSByZXF1aXJlKCcuLy4uL2Jvd2VyX2NvbXBvbmVudHMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlJyksXG5pbWpzID0gcmVxdWlyZSgnLi8uLi9ib3dlcl9jb21wb25lbnRzL2ltanMvanMvaW0uanMnKTtcblxuLy9Ub2RvOiBnZW5lcmlmeSBxdWVyeS5cbnZhciBjeSwgaHVtYW5taW5lID0gbmV3IGltanMuU2VydmljZSh7cm9vdDogJ3d3dy5odW1hbm1pbmUub3JnL2h1bWFubWluZSd9KSxcbnF1ZXJ5ID0ge1xuICBcIm5hbWVcIjogXCJHZW5lX0ludGVyYWN0aW9uc1wiLFxuICBcInRpdGxlXCI6IFwiR2VuZSAtLT4gSW50ZXJhY3Rpb25zXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IGFsbCBpbnRlcmFjdGlvbnMgZm9yIGEgZ2l2ZW4gZ2VuZS5cIixcbiAgXCJjb25zdHJhaW50TG9naWNcIjogXCJBIGFuZCBCXCIsXG4gIFwiZnJvbVwiOiBcIkdlbmVcIixcbiAgXCJzZWxlY3RcIjogW1xuICAgIFwic3ltYm9sXCIsXG4gICAgXCJpbnRlcmFjdGlvbnMuZ2VuZTIuc3ltYm9sXCIsXG4gICAgXCJpbnRlcmFjdGlvbnMuZGV0YWlscy5uYW1lXCIsXG4gICAgXCJpbnRlcmFjdGlvbnMuZGV0YWlscy5yb2xlMVwiLFxuICAgIFwiaW50ZXJhY3Rpb25zLmRldGFpbHMucm9sZTJcIixcbiAgICBcImludGVyYWN0aW9ucy5kZXRhaWxzLnR5cGVcIixcbiAgICBcImludGVyYWN0aW9ucy5kZXRhaWxzLmV4cGVyaW1lbnQuaW50ZXJhY3Rpb25EZXRlY3Rpb25NZXRob2RzLm5hbWVcIixcbiAgICBcImludGVyYWN0aW9ucy5kZXRhaWxzLmV4cGVyaW1lbnQucHVibGljYXRpb24ucHViTWVkSWRcIixcbiAgICBcImludGVyYWN0aW9ucy5kZXRhaWxzLnJlbGF0aW9uc2hpcFR5cGUubmFtZVwiLFxuICAgIFwiaW50ZXJhY3Rpb25zLmRldGFpbHMuZGF0YVNldHMubmFtZVwiXG4gIF0sXG4gIFwib3JkZXJCeVwiOiBbXG4gICAge1xuICAgICAgXCJwYXRoXCI6IFwic3ltYm9sXCIsXG4gICAgICBcImRpcmVjdGlvblwiOiBcIkFTQ1wiXG4gICAgfVxuICBdLFxuICBcIndoZXJlXCI6IFtcbiAgICB7XG4gICAgICBcInBhdGhcIjogXCJHZW5lXCIsXG4gICAgICBcIm9wXCI6IFwiTE9PS1VQXCIsXG4gICAgICBcInZhbHVlXCI6IFwiUFBBUkdcIixcbiAgICAgIFwiZXh0cmFWYWx1ZVwiOiBcIkguIHNhcGllbnNcIixcbiAgICAgIFwiY29kZVwiOiBcIkFcIixcbiAgICAgIFwiZWRpdGFibGVcIjogdHJ1ZSxcbiAgICAgIFwic3dpdGNoZWRcIjogXCJMT0NLRURcIixcbiAgICAgIFwic3dpdGNoYWJsZVwiOiBmYWxzZVxuICAgIH1cbiAgXVxufTtcblxuaHVtYW5taW5lLnJlY29yZHMocXVlcnkpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgaWYgKHJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcblxuICAgICAgdmFyIGdyYXBoID0ge307XG4gICAgICAgIGdyYXBoLmRhdGEgPSBjeW1pbmUudG9Ob2Rlc0FuZEVkZ2VzKHJlc3BvbnNlKSxcbiAgICAgICAgZ3JhcGgudGFyZ2V0RWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjeScpLFxuICAgICAgICBncmFwaC5zdGF0dXNCYXIgPSBncmFwaC50YXJnZXRFbGVtLnF1ZXJ5U2VsZWN0b3IoJy5zdGF0dXMnKTtcblxuICAgICAgY29uc29sZS5kZWJ1ZygncmVzcG9uc2U6JywgcmVzcG9uc2UsICdncmFwaCBkYXRhJywgZ3JhcGguZGF0YSk7XG5cbiAgICAgIGN5ID0gY3l0b3NjYXBlKHtcbiAgICAgICAgY29udGFpbmVyOiBncmFwaC50YXJnZXRFbGVtLFxuICAgICAgICBsYXlvdXQ6IHsgbmFtZTogJ2Nvc2UnfSxcbiAgICAgICAgc3R5bGU6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ25vZGUnLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgJ2NvbnRlbnQnOiAnZGF0YShsYWJlbCknLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgZWxlbWVudHM6IGdyYXBoLmRhdGEsXG4gICAgICAgIHJlYWR5OiBmdW5jdGlvbigpe1xuICAgICAgICAgIHdpbmRvdy5jeSA9IHRoaXM7XG4gICAgICAgICAgZ3JhcGguc3RhdHVzQmFyLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfSBjYXRjaChlKSB7Y29uc29sZS5lcnJvcihlKTt9XG4gIH0gZWxzZSB7XG4gICAgZ3JhcGguc3RhdHVzQmFyLmNsYXNzID0gXCJzdGF0dXMgbm8tcmVzdWx0c1wiO1xuICB9XG59KTtcbiJdfQ==
